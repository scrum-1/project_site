<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>機械設計專題 (虎尾科大MDE) - 2016bg2</title><link href="http://project.mde.tw/blog/" rel="alternate"></link><link href="http://project.mde.tw/blog/feeds/2016bg2.atom.xml" rel="self"></link><id>http://project.mde.tw/blog/</id><updated>2017-06-30T21:00:00+08:00</updated><entry><title>專題模板說明</title><link href="http://project.mde.tw/blog/zhuan-ti-mo-ban-shuo-ming.html" rel="alternate"></link><published>2017-06-30T21:00:00+08:00</published><updated>2017-06-30T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-06-30:/blog/zhuan-ti-mo-ban-shuo-ming.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;置頂中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Leo Editor 專題模板&lt;/p&gt;
&lt;p&gt;倉儲：&lt;a href="https://github.com/KmolYuan/Leo-editor-report-template"&gt;https://github.com/KmolYuan/Leo-editor-report-template&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;協同規則&lt;/li&gt;
&lt;li&gt;設定&lt;/li&gt;
&lt;li&gt;預覽圖&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;&lt;strong&gt;置頂中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Leo Editor 專題模板&lt;/p&gt;
&lt;p&gt;倉儲：&lt;a href="https://github.com/KmolYuan/Leo-editor-report-template"&gt;https://github.com/KmolYuan/Leo-editor-report-template&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;協同規則&lt;/li&gt;
&lt;li&gt;設定&lt;/li&gt;
&lt;li&gt;預覽圖&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Leo Editor 專題模板&lt;/h1&gt;
&lt;p&gt;搭配 Pandoc 將 Markdown 文件轉為 PDF。&lt;/p&gt;
&lt;p&gt;將 template.tex 調整過後，把中英文字型分開，並將英文名稱轉為中文，可以生成接近 Word 格式排版的狀態。&lt;/p&gt;
&lt;p&gt;之後會盡快補完之前的 &lt;a href="http://project.mde.tw/blog/pandoc-markdown-ji-ben-yu-fa-jie-shao.html"&gt;Markdown 語法說明&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;環境準備：Windows 與 Ubuntu 雙平台的 &lt;a href="http://project.mde.tw/blog/pandoc-markdown-zhuan-pdf-ge-shi.html"&gt;Pandoc 安裝說明&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;這個倉儲會持續更新，要獲得更新後的設定，可以下載新版的 template.tex 即可。&lt;/p&gt;
&lt;p&gt;參考模板：&lt;a href="https://github.com/kmollee/nfu-thesis-template/blob/master/template.tex"&gt;https://github.com/kmollee/nfu-thesis-template/blob/master/template.tex&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;協同規則&lt;/h2&gt;
&lt;p&gt;所有 Leo 專案檔皆有所職，以 master 為主，負責控管封面、摘要、模板檔案。&lt;/p&gt;
&lt;p&gt;組員根據 contributor1.leo 的樣式創建負責的 Markdown 文件，命名規則為 paragraph 加上章節順序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最後 Pandoc 合併時會以 &lt;code&gt;master&lt;/code&gt;+&lt;code&gt;paragraph1&lt;/code&gt;+&lt;code&gt;paragraph2&lt;/code&gt; 的順序合併。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Leo 專案中，直接點擊 report-pdf 按鈕即可開始轉檔。&lt;/p&gt;
&lt;h2&gt;設定&lt;/h2&gt;
&lt;p&gt;採用以下設定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;語系：中文（&lt;code&gt;-V lang=chinese&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;自動生成：目錄、表目錄、圖目錄（&lt;code&gt;--toc&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;自動分節（&lt;code&gt;-N&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;程式碼標示：Kate（&lt;code&gt;--highlight-style kate&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;整體設定（&lt;code&gt;-V documentclass=report&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;使用模組：圖片參照 pandoc-fignos（&lt;code&gt;--filter pandoc-fignos&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;自訂模板：template.tex（&lt;code&gt;--template=template.tex&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;中文字型：Windows 標楷體；Ubuntu 教育部標準楷書（&lt;code&gt;-V "CJKmainfont:標楷體"&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;內文字體大小：12 號（&lt;code&gt;-V fontsize=12pt&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;邊界設定：1 英吋（&lt;code&gt;-V geometry:margin=1in&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;英文字型：Times New Roman&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;預覽圖&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0315_01.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0315_02.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0315_03.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0315_04.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0315_05.png"&gt;&lt;/p&gt;</content><category term="Leo Editor"></category><category term="Pandoc"></category></entry><entry><title>40323230日誌 - 106/03/29</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060329.html" rel="alternate"></link><published>2017-03-29T21:00:00+08:00</published><updated>2017-03-29T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-29:/blog/40323230ri-zhi-1060329.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;輸入介面改善&lt;/li&gt;
&lt;li&gt;Debian package&lt;/li&gt;
&lt;li&gt;Drive shaft 面板功能&lt;/li&gt;
&lt;li&gt;Path track 面板功能 - &lt;strong&gt;計畫&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;輸入介面改善&lt;/li&gt;
&lt;li&gt;Debian package&lt;/li&gt;
&lt;li&gt;Drive shaft 面板功能&lt;/li&gt;
&lt;li&gt;Path track 面板功能 - &lt;strong&gt;計畫&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;輸入介面改善&lt;/h2&gt;
&lt;p&gt;連桿和呆鍊的設定視窗會偵測當前兩點的距離，方便使用者估算。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0329_01.png"&gt;&lt;/p&gt;
&lt;h2&gt;Debian package&lt;/h2&gt;
&lt;p&gt;在 Makefile 中加入 deb 選項可以讓編譯完的 Pyslvs 包裝成 Debian 系統的安裝檔，可以當成類似 Windows 的壓縮檔安裝到 Ubuntu 使用者的家目錄 &lt;code&gt;~/Pyslvs&lt;/code&gt; 中。&lt;/p&gt;
&lt;h2&gt;Drive shaft 面板功能&lt;/h2&gt;
&lt;p&gt;改進了之前的水平滑桿，變成比較易懂的 QDial 旋鈕，旋轉方向與圖面一致，逆時針為正。&lt;/p&gt;
&lt;p&gt;不過 QDial 的預設 0 的位置在正下方，要調整可能比較麻煩，因為讀值會變負的，而且起始和終止位置不一定是 0 和 360 度，所以目前尚未改掉。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0329_02.png"&gt;&lt;/p&gt;
&lt;p&gt;旁邊的播放鈕會自動旋轉 10 圈，可以隨時中斷，也能重新播放。&lt;/p&gt;
&lt;h2&gt;Path track 面板功能&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;速度&lt;/strong&gt;和&lt;strong&gt;加速度&lt;/strong&gt;的功能預計歸類到路徑追蹤的項目中，可以推導該座標的公式，並能藉由輸入值求出當前座標的速度和加速度。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/27</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060327.html" rel="alternate"></link><published>2017-03-27T21:00:00+08:00</published><updated>2017-03-27T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-27:/blog/40323230ri-zhi-1060327.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Release version 0.6&lt;/li&gt;
&lt;li&gt;關於報告&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Release version 0.6&lt;/li&gt;
&lt;li&gt;關於報告&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;Release version 0.6&lt;/h2&gt;
&lt;p&gt;先釋出 0.6.0 版本，較 Bata 版增加防止三角形運算錯誤的機制和一些界面改進。&lt;/p&gt;
&lt;p&gt;還新增生成曲柄滑塊的設計範例，不過計算後不是完整角度的，之後會改良。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0327_01.png"&gt;&lt;/p&gt;
&lt;p&gt;計算速度和加速度的功能預計在下個小版本 v0.6.1 中加入，並修正上述目前 Pyslvs 範例中不適合的尺寸。&lt;/p&gt;
&lt;p&gt;小更新仍在分支 dev0.6 中開發。&lt;/p&gt;
&lt;h2&gt;關於報告&lt;/h2&gt;
&lt;p&gt;之前申請預延生有用 Word 稍微整理暑假的資訊，並列出大綱。&lt;/p&gt;
&lt;p&gt;雖然當時章節沒分明確，但是已有大綱基本雛型，現階段要將介紹資料整理完整，並為每個大綱內容分配專題的所屬項目。&lt;/p&gt;
&lt;p&gt;接著使用 Leo editor 將 Markdown 文件編排完整供審理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;預定倉儲&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/KmolYuan/Special-Report"&gt;https://github.com/KmolYuan/Special-Report&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前定版在 Pyslvs 0.6 的部份，會據下列項目作剖析說明。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;緒論&lt;/p&gt;
&lt;p&gt;說明研究動機目的、現有參考資料的討論，以及整體大綱分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;設計理論&lt;/p&gt;
&lt;p&gt;本專案使用的所有數學公式推導、四連桿相關資訊、演算法的說明。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平面機構解題&lt;/p&gt;
&lt;p&gt;源於 Solvespace 的解題程式庫轉為 Python API（應用程式界面）的過程，並說明 Pyslvs 如何利用之。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;四連桿尺寸合成系統&lt;/p&gt;
&lt;p&gt;介紹合成系統使用的技術。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;電腦輔助設計應用程式框架&lt;/p&gt;
&lt;p&gt;關於 Qt 框架的利用，並闡述使用者界面設計上的考量與版本推進內容。&lt;/p&gt;
&lt;p&gt;此部份也會包含所有模組與系統整合的說明。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;結論與未來展望&lt;/p&gt;
&lt;p&gt;現階段的軟體設計成果以及之後的發展方向。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外&lt;strong&gt;使用者手冊&lt;/strong&gt;和&lt;strong&gt;開發者手冊&lt;/strong&gt;可能要以更有效率的方式統整。可能沒辦法做得和 Python 模組一樣細，開發者手冊會先將大項目和各項區域介紹清楚；使用者手冊則會偏向將概念以「圖示」表達清楚而非有太多截圖。之前寒假寫的可能必須重新改版，用新的論文框架排版。&lt;/p&gt;
&lt;p&gt;上述兩者同樣以 Markdown 文件編寫，放在以下倉儲：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/KmolYuan/Pyslvs-manual"&gt;https://github.com/KmolYuan/Pyslvs-manual&lt;/a&gt;&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/25</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060325.html" rel="alternate"></link><published>2017-03-25T21:00:00+08:00</published><updated>2017-03-25T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-25:/blog/40323230ri-zhi-1060325.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面板工具提示&lt;/li&gt;
&lt;li&gt;演算法結果校正&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面板工具提示&lt;/li&gt;
&lt;li&gt;演算法結果校正&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;面板工具提示&lt;/h2&gt;
&lt;p&gt;為了讓 GUI 特色更易懂，在面板的按鈕上加入工具提示，滑鼠游標指到上方會出現功能說明。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0325_01.png"&gt;&lt;/p&gt;
&lt;p&gt;三角求解器的加入鈕也有對應顯示，不用進對話視窗就能看三角形的設計。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0325_02.png"&gt;&lt;/p&gt;
&lt;h2&gt;演算法結果校正&lt;/h2&gt;
&lt;p&gt;之前的演算法結果是多代入一次 Solvespace 的 kernel 做定位，可是無法辨識是否為反轉四連桿。&lt;/p&gt;
&lt;p&gt;現在有三角求解器可以拆開結果（因為是固定形狀和參數很好分辨），比對頂點的位置後決定是否反轉。&lt;/p&gt;
&lt;p&gt;驗證後合併功能就正常了，不會有路徑在下方卻將呆鍊生成在上方的情況。&lt;/p&gt;
&lt;p&gt;另外發現差分演算法雖然快速，但是誤差滿大，有時候某些角度範圍會讓 Solvespace 的 kernel 求解回傳失敗（不過求解成功的片段路徑會符合要求）。&lt;/p&gt;
&lt;p&gt;其他兩個演算法時間雖然較久，但是不容易發生上述情形。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/22</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060322.html" rel="alternate"></link><published>2017-03-22T21:00:00+08:00</published><updated>2017-03-22T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-22:/blog/40323230ri-zhi-1060322.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度 - 三角求解器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完成合併功能&lt;/li&gt;
&lt;li&gt;演算法合併校正&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度 - 三角求解器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完成合併功能&lt;/li&gt;
&lt;li&gt;演算法合併校正&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度 - 三角求解器&lt;/h1&gt;
&lt;h2&gt;完成合併功能&lt;/h2&gt;
&lt;p&gt;算完結果後會依據參照設定合併成實體。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0322_01.png"&gt;&lt;/p&gt;
&lt;h2&gt;演算法合併校正&lt;/h2&gt;
&lt;p&gt;由於現在有了三角求解器的驗證 kernel，可以設法利用其功能協助演算法結果預先得到點座標。&lt;/p&gt;
&lt;p&gt;這樣可以降低錯誤發生的情況。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/20</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060320.html" rel="alternate"></link><published>2017-03-20T21:00:00+08:00</published><updated>2017-03-20T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-20:/blog/40323230ri-zhi-1060320.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度 - 三角求解器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;關於範例結合報告&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度 - 三角求解器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;關於範例結合報告&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度 - 三角求解器&lt;/h1&gt;
&lt;h2&gt;關於範例結合報告&lt;/h2&gt;
&lt;p&gt;預計加入的新範例「Theo Jansen's multi linkage（泰奧．楊森的多連桿組）」，為仿生獸的腳轉到 55° 時的座標位置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0320_01.png"&gt;&lt;/p&gt;
&lt;p&gt;合併功能只做到加入點，之後還有連桿、呆鍊、滑塊的選項，載入範例後能生成多連桿。&lt;/p&gt;
&lt;p&gt;而新的 csv 格式已經包含設計數據，之後會重新整理程式外附的範例檔（包含一組新的曲柄滑塊），解析並加入報告中。&lt;/p&gt;
&lt;p&gt;看了一下滑塊 PLPP 的部份，似乎沒有較流暢的公式推導，而 SimPy 推出來是用矩陣解的，求解器暫時套用 SimPy 的公式，報告中會另外整理。&lt;/p&gt;
&lt;p&gt;報告最近會開始分類章節，以「電腦輔助設計應用程式」為主，「平面四連桿尺寸合成」和 Solvespace 相關部份為輔，扼要介紹理論部份的內容。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/18</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060318.html" rel="alternate"></link><published>2017-03-18T21:00:00+08:00</published><updated>2017-03-18T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-18:/blog/40323230ri-zhi-1060318.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三角求解器面板&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三角求解器面板&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;三角求解器面板&lt;/h2&gt;
&lt;p&gt;接上 GUI，可以用對話視窗輸入數值求解，切換求解法時會有對應的預覽圖。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0318_01.png"&gt;&lt;/p&gt;
&lt;p&gt;按下求解鈕後會更新解答，當解答求出後可以生成實體進畫布，不過這部分功能還沒做。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0318_02.png"&gt;&lt;/p&gt;
&lt;p&gt;支援 PLAP、PLLP、PLPP 三種方式求解。&lt;/p&gt;
&lt;p&gt;另外已修正餘弦定理公式產生分母為 0 的狀況，分母會被設定為 0.01，得出解會有少許誤差。&lt;/p&gt;
&lt;p&gt;最後，這種設計數據會納入檔案格式中，新的範例會給一個有設計數據的空白工作簿，啟動面板後求解，&lt;strong&gt;目標是可以生成範例中仿生獸的腳。&lt;/strong&gt;&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/16</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060316.html" rel="alternate"></link><published>2017-03-16T21:00:00+08:00</published><updated>2017-03-16T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-16:/blog/40323230ri-zhi-1060316.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卡車尾門範例&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;卡車尾門範例&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;卡車尾門範例&lt;/h2&gt;
&lt;p&gt;新增伸縮桿的簡單範例，機構源自 &lt;a href="https://www.google.com/patents/US7547055"&gt;https://www.google.com/patents/US7547055&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;改變 Point0 到 Point2 的距離可以收合尾門。&lt;/p&gt;
&lt;p&gt;兩段式的升降裝置找不太到清楚的機構圖，可能要操控 2 個以上的伸縮桿才能達成。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0316_01.png"&gt;&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>Pandoc - Markdown 基本語法介紹</title><link href="http://project.mde.tw/blog/pandoc-markdown-ji-ben-yu-fa-jie-shao.html" rel="alternate"></link><published>2017-03-16T21:00:00+08:00</published><updated>2017-03-16T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-16:/blog/pandoc-markdown-ji-ben-yu-fa-jie-shao.html</id><summary type="html">&lt;p&gt;一些 Pandoc 常用的 Markdown 語法及注意事項&lt;/p&gt;
</summary><content type="html">&lt;p&gt;一些 Pandoc 常用的 Markdown 語法及注意事項&lt;/p&gt;


&lt;h1&gt;一些 Pandoc 常用的 Markdown 語法及注意事項&lt;/h1&gt;
&lt;p&gt;參考資料：&lt;a href="https://pandoc.org/README.pdf"&gt;https://pandoc.org/README.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基礎須知：Markdown 相對於其他文書格式，並非「易撰寫」，而是「易閱讀」，因此在語法上有很多種表達方式，擇一即可。&lt;/p&gt;
&lt;p&gt;在需要特殊排版要求時才會加入 html 語法，而 html 語法中的任何 Markdown 記號都會視為通常字元。&lt;/p&gt;
&lt;p&gt;這裡介紹的為 Pandoc 支援的語法，Pelican 轉換網誌時可能無法支援。&lt;/p&gt;
&lt;p&gt;為編輯方便，這篇文章使用 Leo Editor 的 &lt;code&gt;@others&lt;/code&gt; 和 &lt;code&gt;@clean&lt;/code&gt; 語法編輯文件。&lt;/p&gt;
&lt;h2&gt;目錄&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#書目與換頁"&gt;書目與換頁&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#換行記號"&gt;換行記號&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#標題"&gt;標題&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#分隔線"&gt;分隔線&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#粗體與斜體"&gt;粗體與斜體&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#清單"&gt;清單&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#連結與圖片"&gt;連結&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#表格"&gt;表格&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#數學符號"&gt;數學符號&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#程式碼"&gt;程式碼&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#參考文獻"&gt;參考文獻&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#注意事項"&gt;注意事項&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a name="書目與換頁"&gt;&lt;/a&gt;Pandoc 書目與換頁&lt;/h2&gt;
&lt;h3&gt;書目&lt;/h3&gt;
&lt;p&gt;使用百分比符號隔著 1 到 4 格空白，插入置中封面文字。&lt;/p&gt;
&lt;pre&gt;
% 封面標題
% 作者
% 28, January, 2017

---

內文不能再使用
&lt;/pre&gt;

&lt;h3&gt;換頁&lt;/h3&gt;
&lt;p&gt;換頁記號使用後不用再換行。&lt;/p&gt;
&lt;pre&gt;
\newpage
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="換行記號"&gt;&lt;/a&gt;換行記號&lt;/h2&gt;
&lt;p&gt;使用&lt;strong&gt;空行&lt;/strong&gt;的方式來作換行，如下：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;第一段文字

第二段文字
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;「看起來像」空行也會被視作空行，如該行只有空白或 tab 字元。&lt;/p&gt;
&lt;p&gt;若是沒有換行，兩段緊貼的文字仍會視為同一段。&lt;/p&gt;
&lt;p&gt;若要插入一段空行，可以用反斜線 &lt;code&gt;\&lt;/code&gt; 符號加上一個以上的空白字元。&lt;/p&gt;
&lt;h2&gt;&lt;a name="標題"&gt;&lt;/a&gt;標題&lt;/h2&gt;
&lt;p&gt;每個標題中都內建錨點，相當於 html 的 h1, h2, h3。&lt;/p&gt;
&lt;p&gt;分成 Setext 和 Atx 兩種形式，而這兩種形式是可以混用的。&lt;/p&gt;
&lt;p&gt;在 Pandoc 中，每個標題都會轉為 PDF 的目錄書籤。&lt;/p&gt;
&lt;h3&gt;Setext 形式&lt;/h3&gt;
&lt;p&gt;使用 3 個或以上的「等於」與「減號」代表 h1 和 h2。&lt;/p&gt;
&lt;pre&gt;
This is an H1
===

This is an H2
-------------
&lt;/pre&gt;

&lt;h3&gt;Atx 形式&lt;/h3&gt;
&lt;p&gt;井字號的數量決定層級。&lt;/p&gt;
&lt;pre&gt;
# This is an H1

## This is an H2

###### This is an H6
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="分隔線"&gt;&lt;/a&gt;分隔線&lt;/h2&gt;
&lt;p&gt;使用 3 個或以上的「星號」、「減號」、「下底線」來畫出水平分隔線。&lt;/p&gt;
&lt;p&gt;水平線的符號必須被空白圍繞，若是緊貼其他文字則會失效。&lt;/p&gt;
&lt;pre&gt;
---

*    *    *    *

_____
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="粗體與斜體"&gt;&lt;/a&gt;粗體與斜體&lt;/h2&gt;
&lt;p&gt;在內文中標記粗體與斜體，兩者可以混用，但是開頭與結尾必須一致。&lt;/p&gt;
&lt;p&gt;論文中比較少用兩者，可以在寫網誌時畫重點。&lt;/p&gt;
&lt;p&gt;使用「星號」或「下底線」代表斜體。&lt;/p&gt;
&lt;pre&gt;
*斜體文字*

_斜體文字_
&lt;/pre&gt;

&lt;p&gt;使用雙「星號」或「下底線」代表粗體。&lt;/p&gt;
&lt;pre&gt;
**粗體文字**

__粗體文字__
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="清單"&gt;&lt;/a&gt;清單&lt;/h2&gt;
&lt;p&gt;清單分為無序和有序，都可以使用降階不間段放入內容。&lt;/p&gt;
&lt;p&gt;使用「星號」、「減號」、「加號」隔著 1 到 4 格空白來代表無序清單。&lt;/p&gt;
&lt;pre&gt;
* 其中一項

    + 還有一項

    + 還有一項

        - 還有一項

* 其中一項

* 其中一項
&lt;/pre&gt;

&lt;p&gt;使用「普通數字」與「英文句號」隔著 1 到 4 格空白放入內容，產生有序清單。可以完全不照順序排版，在最終會自動轉換成順序排列。&lt;/p&gt;
&lt;pre&gt;
1. 永遠的第一項

1. 永遠的第二項

6. 永遠的第三項
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="連結與圖片"&gt;&lt;/a&gt;連結與圖片&lt;/h2&gt;
&lt;p&gt;基本的連結樣式：&lt;/p&gt;
&lt;pre&gt;
有一個[連結文字](http://www.google.com)在這裡。
&lt;/pre&gt;

&lt;p&gt;轉移的連結樣式。優點是可以統一放在同一處，並且能重複引用。&lt;/p&gt;
&lt;p&gt;要注意冒號後必須有 1 到 4 個空白。&lt;/p&gt;
&lt;pre&gt;
有一個[連結文字][]在這裡。

[連結文字]: http://www.google.com
&lt;/pre&gt;

&lt;p&gt;圖片使用方式跟連結一樣，只須在前端加上驚嘆號。&lt;/p&gt;
&lt;p&gt;圖片從自身檔案開始尋找，或是使用網路連結（轉檔時連網即可）。&lt;/p&gt;
&lt;pre&gt;
![圖片名稱][]

[圖片名稱]: image/a.jpg
&lt;/pre&gt;

&lt;p&gt;Pandoc 會處理單行的圖片（同行不可有字元），為其置中、編入圖片編號（以章節出現排序），並且在下方置入圖片標籤。&lt;/p&gt;
&lt;p&gt;安裝擴充套件 pandoc-fignos 後，使用下面的方式引用：&lt;/p&gt;
&lt;pre&gt;
![圖片名稱][]

請參考圖 {@fig:圖片代稱} 中的內容。

[圖片名稱]: image/a.jpg {#fig:圖片代稱}
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="表格"&gt;&lt;/a&gt;表格&lt;/h2&gt;
&lt;p&gt;Markdown 的表格分為 4 種樣式，並有不同表達法。&lt;/p&gt;
&lt;p&gt;正式表格多用管表格表示：&lt;/p&gt;
&lt;pre&gt;
Table: 表格名稱 {#tbl:表格代號}

| Tables   |      Are      |  Cool |
|----------|:-------------:|------:|
| col 1 is |  left-aligned | $1600 |
| col 2 is |    centered   |   $12 |
| col 3 is | right-aligned |    $1 |

參照表 {@tbl:表格代號}
&lt;/pre&gt;

&lt;p&gt;使用網頁服務生成：&lt;a href="http://www.tablesgenerator.com/markdown_tables"&gt;http://www.tablesgenerator.com/markdown_tables&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a name="數學符號"&gt;&lt;/a&gt;數學符號&lt;/h2&gt;
&lt;p&gt;Pandoc 支援插入 Latex 的數學公式，可以藉由網頁服務轉換。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.hostmath.com/"&gt;http://www.hostmath.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用時兩端包上錢幣符號，如下：&lt;/p&gt;
&lt;pre&gt;
$$\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$
&lt;/pre&gt;

&lt;p&gt;會生成：&lt;/p&gt;
&lt;p&gt;$$\frac{-b\pm\sqrt{b^2-4ac}}{2a}$$&lt;/p&gt;
&lt;h2&gt;&lt;a name="程式碼"&gt;&lt;/a&gt;程式碼&lt;/h2&gt;
&lt;p&gt;Markdown 用簡單的縮排插入程式碼，如：&lt;/p&gt;
&lt;pre&gt;
這是一段 Python 程式：

    if __name__='__main__':
        print("Hello world!")

印出 Hello world! 字樣。
&lt;/pre&gt;

&lt;p&gt;或是使用重音符（Grave accent）包起單一程式碼：&lt;/p&gt;
&lt;pre&gt;
一段程式：

`print("Hello world!")`
&lt;/pre&gt;

&lt;p&gt;若一大串程式碼，可以用三個以上的重音符包起，也能用語言名稱加註：&lt;/p&gt;
&lt;pre&gt;
Bash 指令：

```bash
sudo apt install python3-pip
sudo pip3 install markdown
```&lt;/pre&gt;

&lt;h2&gt;&lt;a name="參考文獻"&gt;&lt;/a&gt;參考文獻&lt;/h2&gt;
&lt;p&gt;將參考資料的資訊放入 bibtex 檔案中，並給予一個識別名稱（如 myart），結構如下：&lt;/p&gt;
&lt;pre&gt;
@article{myart,
  author  = {作者名字}, 
  title   = {標題},
  journal = {刊物名稱},
  year    = 1993,
  number  = 2,
  pages   = {201-213},
  month   = 7,
  note    = {選擇性註解}, 
  volume  = 4
}
&lt;/pre&gt;

&lt;p&gt;接著可以在內文中使用：&lt;/p&gt;
&lt;pre&gt;
參考於書籍[@myart]。
&lt;/pre&gt;

&lt;p&gt;Pabdoc 會自動編碼，套用不同的 csl 檔案可以改變條列外觀。&lt;/p&gt;
&lt;h2&gt;&lt;a name="注意事項"&gt;&lt;/a&gt;注意事項&lt;/h2&gt;
&lt;p&gt;不像其他語言，在 Leo Editor 中使用 &lt;code&gt;@others&lt;/code&gt; 與 &lt;code&gt;@clean&lt;/code&gt; 編輯 Markdown 論文或技術手冊時，&lt;strong&gt;子節點必須多留一個換行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;否則 Leo Editor 在儲存時會把下一個子節點的第一行對齊到前個節點的最後一行，導致&lt;strong&gt;沒有換行標記&lt;/strong&gt;，會誤認這兩行的內容為同一行而沒做換行處理。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更多內容請參見：&lt;a href="http://markdown.tw/"&gt;http://markdown.tw/&lt;/a&gt;&lt;/p&gt;</content><category term="pandoc"></category><category term="Leo Editor"></category></entry><entry><title>Pandoc - Markdown 轉 PDF 格式</title><link href="http://project.mde.tw/blog/pandoc-markdown-zhuan-pdf-ge-shi.html" rel="alternate"></link><published>2017-03-16T21:00:00+08:00</published><updated>2017-03-16T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-16:/blog/pandoc-markdown-zhuan-pdf-ge-shi.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 安裝方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows 安裝方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;圖片與表格的參照擴充套件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用範例&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pyslvs 手冊倉儲：&lt;a href="https://github.com/KmolYuan/Pyslvs-manual"&gt;https://github.com/KmolYuan/Pyslvs-manual&lt;/a&gt;&lt;/p&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 安裝方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows 安裝方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;圖片與表格的參照擴充套件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用範例&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pyslvs 手冊倉儲：&lt;a href="https://github.com/KmolYuan/Pyslvs-manual"&gt;https://github.com/KmolYuan/Pyslvs-manual&lt;/a&gt;&lt;/p&gt;


&lt;h1&gt;Ubuntu 安裝方式&lt;/h1&gt;
&lt;p&gt;首先安裝 Pandoc、texLive、texLive-xetex、etoolbox。&lt;/p&gt;
&lt;p&gt;到 Pandoc 的 Github 倉儲下載 debian 安裝檔，用 software center 安裝。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/jgm/pandoc/releases/"&gt;https://github.com/jgm/pandoc/releases/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接著用 apt 安裝 texLive。&lt;/p&gt;
&lt;pre&gt;
$sudo apt install texlive texlive-xetex texlive-lang-chinese etoolbox
&lt;/pre&gt;

&lt;p&gt;若是有檔案缺損，直接轉檔，可能會缺少所需的轉換範本，出現類似下面的警告：  &lt;/p&gt;
&lt;pre&gt;
! LaTeX Error: File `etoolbox.sty' not found.

Type X to quit or RETURN to proceed,
or enter new name. (Default extension: sty)

Enter file name:
! Emergency stop.
read *

l.8 \RequirePackage

pandoc: Error producing PDF
&lt;/pre&gt;

&lt;h1&gt;Windows 安裝方式&lt;/h1&gt;
&lt;p&gt;Windows 只需安裝 Pandoc 與 MikTex。&lt;/p&gt;
&lt;p&gt;到 Pandoc 的 Github 倉儲下載 msi 安裝檔。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/jgm/pandoc/releases/"&gt;https://github.com/jgm/pandoc/releases/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然後根據 XeLaTex 的說明安裝 MikTex，並執行 MikTex Update 更新 xetex 的檔案。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.texts.io/support/0002/"&gt;http://www.texts.io/support/0002/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows 可以使用 MikTex Package Manager 來安裝套件，在過濾器中打上套件搜尋安裝即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0121_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;以下是 Windows 必須安裝的套件名稱：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;etoolbox&lt;/li&gt;
&lt;li&gt;cjk（中文、日文、韓文語法支援，包含漢字數字）&lt;/li&gt;
&lt;li&gt;xecjk（基本的 CJK 支援）&lt;/li&gt;
&lt;li&gt;makecmds（Latex 的自定義函式，提供自訂與複寫參數）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;圖片與表格的參照擴充套件&lt;/h1&gt;
&lt;p&gt;文章中常有「引用圖 1.1」之類的編號說明。&lt;/p&gt;
&lt;p&gt;不過 Pandoc 沒有內建這個功能，所以必須安裝 pandoc-fignos 和 pandoc-tablenos。&lt;/p&gt;
&lt;p&gt;pandoc-fignos 是 Python 套件，使用 pip 安裝。&lt;/p&gt;
&lt;pre&gt;
$sudo pip3 install pandoc-fignos
$sudo pip3 install pandoc-tablenos
&lt;/pre&gt;

&lt;p&gt;之後在 pandoc 參數中增加 &lt;code&gt;--filter pandoc-fignos&lt;/code&gt; 和 &lt;code&gt;--filter pandoc-tablenos&lt;/code&gt; 來啟用這個語法。&lt;/p&gt;
&lt;h1&gt;使用範例&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://pandoc.org/demos.html"&gt;http://pandoc.org/demos.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;參照 pandoc 的 demo，下載 MANUAL.txt 這個 Markdown 檔案來測試。&lt;/p&gt;
&lt;p&gt;使用以下指令：&lt;/p&gt;
&lt;pre&gt;
$pandoc MANUAL.txt --latex-engine=xelatex -o MANUAL.pdf
&lt;/pre&gt;

&lt;p&gt;轉換後不會有任何提示，會直接輸出檔案。&lt;/p&gt;
&lt;p&gt;平常使用 pandoc 指令，可以如同 Python 直譯器直接輸入 Markdown 語法，輸入後按下 &lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;D&lt;/kbd&gt; 來轉換並顯示 html 語法（Windows 是 &lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;C&lt;/kbd&gt;）。&lt;/p&gt;
&lt;p&gt;若是結合 &lt;code&gt;--latex-engine=xelatex&lt;/code&gt; 或是 &lt;code&gt;-o&lt;/code&gt; 參數，更可以直接輸出成 pdf 檔案。&lt;/p&gt;
&lt;p&gt;而輸出的 pdf 檔案會自動分頁、排版、標記頁碼。demo 網頁上還有其他範例，可以轉換成不同格式的文件。&lt;/p&gt;
&lt;p&gt;手冊方面全局使用 Leo editor 管理，並整合轉檔的工作，圖片則使用另一個倉儲儲存，不過這些 Markdown 樣板的語法跟網誌的語法不太相同，可能要稍微測試並習慣其用法。&lt;/p&gt;
&lt;p&gt;另外還可以加入 &lt;code&gt;--toc&lt;/code&gt; 參數自動生成目錄，為 table of contents 的縮寫。&lt;/p&gt;
&lt;p&gt;生成的目錄如下的形式，並會自動加上連結。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0121_02.png"&gt;&lt;/p&gt;</content><category term="pandoc"></category></entry><entry><title>40323230日誌 - 106/03/12</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060312.html" rel="alternate"></link><published>2017-03-12T21:00:00+08:00</published><updated>2017-03-12T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-12:/blog/40323230ri-zhi-1060312.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三角求解器模組&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三角求解器模組&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;三角求解器模組&lt;/h2&gt;
&lt;p&gt;寫了一個小模組求解，還未連接使用者界面。&lt;/p&gt;
&lt;p&gt;主要功能是傳入一個 list（包含大量題目）並解題。不過 class 裡的函式可以單獨使用。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from math import *

##Directions:
##[{'p1':Point1, 'p2':Point2, 'len1':Line1, ('len2':Line2, 'angle':angle)}, ...]

class solver():
    def __init__(self, Directions=list()):
        #Cosine Theorem
        self.CosineTheoremAngle = lambda a, b, c: acos((b**2+c**2-a**2)/(2*b*c))
        self.CosineTheoremSide = lambda alpha, b, c: b**2+c**2-2*b*c*cos(alpha)
        self.Directions = Directions

    def set(self, Directions): self.Directions = Directions

    def answer(self):
        answer = self.Iterator() if self.Parser() else None
        self.Directions.clear()
        return answer

    def Parser(self):
        for e in self.Directions:
            pos = self.Directions.index(e)
            if e.get('p1', False) is False: return False
            if e.get('p2', False) is False: return False
            if e.get('len1', False) is False: return False
            if e.get('len2', False) is False and e.get('angle', False) is False: return False
            if e.get('len2', False) is False: self.Directions[pos]['Type'] = 'PLAP'
            elif e.get('angle', False) is False: self.Directions[pos]['Type'] = 'PLLP'
        return True

    def Iterator(self):
        results = list()
        for e in self.Directions:
            p1 = results[e['p1']] if type(e['p1'])==int else e['p1']
            p2 = results[e['p2']] if type(e['p2'])==int else e['p2']
            #Direction of the point
            other = e.get('other', False)
            ##True: angle1-angle2
            ##False: angle1+angle2
            if e['Type']=='PLAP': results.append(self.PLAP(p1, e['len1'], e['angle'], p2, other))
            elif e['Type']=='PLLP': results.append(self.PLLP(p1, e['len1'], e['len2'], p2, other))
        return results

    def PLAP(self, p1, line1, angle, p2, other=False):
        x1 = p1[0]
        y1 = p1[1]
        len1 = float(line1)
        angle2 = radians(float(angle))
        angle1 = self.m(p1, p2)
        if other:
            cx = x1+len1*cos(angle1-angle2)
            cy = y1+len1*sin(angle1-angle2)
        else:
            cx = x1+len1*cos(angle1+angle2)
            cy = y1+len1*sin(angle1+angle2)
        return cx, cy

    def PLLP(self, p1, line1, line2, p2, other=False):
        x1 = p1[0]
        y1 = p1[1]
        x2 = p2[0]
        y2 = p2[1]
        len1 = float(line1)
        len2 = float(line2)
        d = sqrt((x1-x2)**2+(y2-y1)**2)
        angle1 = self.m(p1, p2)
        angle2 = self.CosineTheoremAngle(len2, d, len1)
        if other:
            cx = x1+len1*cos(angle1-angle2)
            cy = y1+len1*sin(angle1-angle2)
        else:
            cx = x1+len1*cos(angle1+angle2)
            cy = y1+len1*sin(angle1+angle2)
        return cx, cy

    def m(self, p1, p2):
        x1 = p1[0]
        y1 = p1[1]
        x2 = p2[0]
        y2 = p2[1]
        x = x2-x1
        y = y2-y1
        d = sqrt(x**2+y**2)
        return self.CosineTheoremAngle(y, x, d)*(-1 if y&lt;0 else 1)*(-1 if x&lt;0 else 1)

if __name__=='__main__':
    #Test
    s = solver([
        {'p1':(-60, 0), 'p2':(0, 0), 'len1':30, 'angle':50}, #C
        {'p1':0, 'p2':(0, 0), 'len1':50, 'len2':60}, #D
        {'p1':0, 'p2':1, 'len1':50, 'len2':50}, #E
        ])
    print("C={}\nD={}\nE={}".format(*s.answer()))

    ##cx= -40.716371709403816 cy= 22.98133329356934
    ##dx= -6.698073034033397 dy= 59.62495968661744
    ##ex= -55.44153371488418 ey= 70.76385733649067
&lt;/pre&gt;

&lt;p&gt;解題方向指定 p1、p2、len1、angle 或 len2，Parser 會檢查填入項的完整性；Iterator 會自動判斷輸入內容選擇解題。&lt;/p&gt;
&lt;p&gt;而 p1 與 p2 的座標是使用 list 或 tuple 型態給兩個座標軸（取 [0]、[1]），或是引用上一個解（之後會增加順序檢查機制）。其他數據皆為 float 型態。&lt;/p&gt;
&lt;p&gt;角度方面使用 degree，不過 Python 的 math 模組是用 radian，途中會進行轉換。&lt;/p&gt;
&lt;p&gt;原理都是先求 AB 與水平夾的角度（angle1），最後將 CAB 夾角（angle2）加上 angle1 求 AC 與水平夾的角度，最後求出 C 點座標。&lt;/p&gt;
&lt;p&gt;之中為了方便，將餘弦定理做成 lambda 使用。&lt;/p&gt;
&lt;p&gt;程式可能還有一些漏洞，接上 Gui 之前會再檢查一遍。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/11</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060311.html" rel="alternate"></link><published>2017-03-11T21:00:00+08:00</published><updated>2017-03-11T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-11:/blog/40323230ri-zhi-1060311.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;捲動區塊&lt;/li&gt;
&lt;li&gt;PLAP 和 PLLP 的求解 - &lt;strong&gt;計畫&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;QGraphicsView 畫布 - &lt;strong&gt;計畫&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;捲動區塊&lt;/li&gt;
&lt;li&gt;PLAP 和 PLLP 的求解 - &lt;strong&gt;計畫&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;QGraphicsView 畫布 - &lt;strong&gt;計畫&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;捲動區塊&lt;/h2&gt;
&lt;p&gt;面板區由於低解析度的螢幕會塞不進空間，改用捲動方式呈現。&lt;/p&gt;
&lt;p&gt;面板的按鈕也重新歸類命名。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0311_01.png"&gt;&lt;/p&gt;
&lt;p&gt;反合成四連桿系統由視窗改成面板，運算時會凍結自己的 Tab，主畫面的其他功能能夠照常運作。&lt;/p&gt;
&lt;h2&gt;PLAP 和 PLLP 的求解 - &lt;strong&gt;計畫&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;打算開一個新面板（歸類在四連桿尺寸合成系統中），讓使用者能&lt;strong&gt;混用&lt;/strong&gt;兩種方式堆疊三角形求解，並有連續迭代求解的功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;獨立 Kernel 連接 Gui 操縱。&lt;/li&gt;
&lt;li&gt;參數可以使用現成實體位置或長度。&lt;/li&gt;
&lt;li&gt;理論上支援無限迭代。&lt;/li&gt;
&lt;li&gt;運算結果後，使用者可以選擇&lt;strong&gt;生成實體合併進畫布&lt;/strong&gt;、&lt;strong&gt;全部清除&lt;/strong&gt;或是&lt;strong&gt;修改參數&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這個 project 應該是 0.6 版的主要更新項目，會盡量快點完成。&lt;/p&gt;
&lt;h2&gt;QGraphicsView 畫布 - &lt;strong&gt;計畫&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;更有效率、採用局部更新的畫布。&lt;/p&gt;
&lt;p&gt;不過 Qt 當初設計上比較偏向多媒體，所以許多功能偏向動畫方面。&lt;/p&gt;
&lt;p&gt;看完 Python CAD（Qt4）的 QGraphicsView 部份，操縱上不太像 Free CAD 靈活（模仿其他大型商業軟體）。&lt;/p&gt;
&lt;p&gt;目前想先弄好滑鼠中鍵拖移瀏覽的部份（目前還有諸多問題），可能得搞懂 QTransform 的設定。&lt;/p&gt;
&lt;p&gt;新的畫布使用 -t 參數啟動，舊的畫布仍能正常運作。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>Python Parser for command-line options</title><link href="http://project.mde.tw/blog/python-parser-for-command-line-options.html" rel="alternate"></link><published>2017-03-08T21:00:00+08:00</published><updated>2017-03-08T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-08:/blog/python-parser-for-command-line-options.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Python 的命令列參數管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;argparse 模組&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部署說明資訊&lt;/li&gt;
&lt;li&gt;參數類型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Python 的命令列參數管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;argparse 模組&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部署說明資訊&lt;/li&gt;
&lt;li&gt;參數類型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Python 的命令列參數管理&lt;/h1&gt;
&lt;p&gt;當使用 sys 模組下的 argv，可以觀看當前的參數內容。&lt;/p&gt;
&lt;p&gt;參數在 sys.argv 下是成 string 型態儲存，但是 list 成次序排列，且只會儲存當前輸入項目，因此在調用上十分不方便。&lt;/p&gt;
&lt;p&gt;Python 的 argparse 模組是一個不錯的選擇（3.2 版加入），可以用簡單的設定設置參數名稱和類型，並自動生成類 Unix OS 的 help 選項供調用。&lt;/p&gt;
&lt;h1&gt;argparse 模組&lt;/h1&gt;
&lt;p&gt;簡單列出常用的選項。&lt;/p&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://docs.python.org/3/library/argparse.html"&gt;https://docs.python.org/3/library/argparse.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/5262702/argparse-module-how-to-add-option-without-any-argument"&gt;http://stackoverflow.com/questions/5262702/argparse-module-how-to-add-option-without-any-argument&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python 函式庫語法範例字典：&lt;a href="http://www.books.com.tw/products/0010726838"&gt;http://www.books.com.tw/products/0010726838&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;部署說明資訊&lt;/h2&gt;
&lt;p&gt;在腳本中設定：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import argparse

parser = argparse.ArgumentParser(
    prog='prog.py', #程式名稱，預設 sys.argv[0]
    usage='%(prog)s [options]', #自訂使用方法外觀，預設由參數產生
    description='程式說明', #頂端程式說明，預設 None
    epilog='程式說明2', #底端程式說明，預設 None
    prefix_chars='-', #參數起始字串，預設 '-'
    add_help=False, #是否開啟 Help 選項，預設 True
    )
parser.add_argument('integers', metavar='N', type=int, nargs='+',
                    help='an integer for the accumulator') #第一個參數
parser.add_argument('--sum', dest='accumulate', action='store_const',
                    const=sum, default=max,
                    help='sum the integers (default: find the max)') #第二個參數
args = parser.parse_args() #解析
&lt;/pre&gt;

&lt;p&gt;如果有啟用 add_help 選項，模組產出的 Help 說明如下：&lt;/p&gt;
&lt;pre&gt;
$ python3 prog.py -h
usage: prog.py [options]

程式說明

positional arguments:
 N           an integer for the accumulator

optional arguments:
 -h, --help  show this help message and exit
 --sum       sum the integers (default: find the max)

 程式說明2
&lt;/pre&gt;

&lt;h2&gt;參數類型&lt;/h2&gt;
&lt;p&gt;add_argument() 方法中可使用的選項。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;name or flags&lt;/p&gt;
&lt;p&gt;名稱或標籤，看之前設置的 prefix_chars 決定，名稱只能為一個，標籤表示法可以有多個。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;action&lt;/p&gt;
&lt;p&gt;傳入參數的動作，預設為 &lt;code&gt;'store'&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;'store'&lt;/code&gt;：儲存，啟用此標籤時會存入後方跟著的項目，按照 type 選項儲存輸入值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'store_const'&lt;/code&gt;：儲存為常數，啟用此標籤時會存入一個定值，這時必須設定 const 選項。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'store_true'&lt;/code&gt; 和 &lt;code&gt;'store_false'&lt;/code&gt;：儲存為 True 或 False，啟用此標籤時會存入 True 或 False。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'append'&lt;/code&gt;：產生一個 list，啟用此標籤時會將後方跟著的項目，按照 type 選項儲存到 list 中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'append_const'&lt;/code&gt;：產生一個 list，啟用此標籤時會將 const 選項的類型存入 list 中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'count'&lt;/code&gt;：紀錄這個標籤出現的次數，如 &lt;code&gt;-v&lt;/code&gt; 選項輸入成 &lt;code&gt;-vvv&lt;/code&gt; 時會回傳 3。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'help'&lt;/code&gt;：預設已經加入，此時若是自行設置會導致衝突。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'version'&lt;/code&gt;：顯示版本而不啟動程式，這時必須設定 version 選項。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;argparse.Action&lt;/code&gt; 類型：繼承後，透過修改 &lt;strong&gt;call&lt;/strong&gt; 和 &lt;strong&gt;init&lt;/strong&gt; 方法來達成額外的條件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nargs&lt;/p&gt;
&lt;p&gt;決定多個參數傳入時的處理方式，預設由 action 選項決定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;'N'&lt;/code&gt;：迭代，使用一個 list 包裝此標籤後的參數。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'?'&lt;/code&gt;：單一，一次只能傳入一個參數，後方的項目會被視為其他標籤。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'*'&lt;/code&gt;：不限，使用一個 list 包裝此標籤後的參數，多餘的參數會自動歸類到此標籤下。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;'+'&lt;/code&gt;：至少一個，類似 &lt;code&gt;'*'&lt;/code&gt;，但是在此標籤沒有任何參數時會跳出錯誤訊息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;argparse.REMAINDER&lt;/code&gt; 物件：存為 list，使用一個 list 包裝此標籤和其參數。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;const&lt;/p&gt;
&lt;p&gt;根據 action 和 nargs 選項決定的定值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;default&lt;/p&gt;
&lt;p&gt;未輸入時的預設值，不受 type 選項的轉換。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;argparse.SUPPRESS&lt;/code&gt; 物件：若此選項沒有任何參數，不會建立這個選項。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;type&lt;/p&gt;
&lt;p&gt;轉換輸入值的類型，支援任何可呼叫(callable)的類型，預設為 string。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;open&lt;/code&gt;：這個類型可以開啟純文字格式的檔案。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;argparse.FileType('w')&lt;/code&gt;：argparse 也提供讀寫檔案的選項，作用同上。&lt;/li&gt;
&lt;li&gt;choices 選項會在 type 選項轉換完畢後才比對。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;choices&lt;/p&gt;
&lt;p&gt;比對輸入值的項目是否符合，可接受 list 與 generator，若否則跳出錯誤。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;required&lt;/p&gt;
&lt;p&gt;是否為必要標籤，預設為 False。若要啟用，將其設為 True 即可，Help 項目中會歸類成必要標籤。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;help&lt;/p&gt;
&lt;p&gt;當顯示 Help 項目時的說明文字，預設為空字串。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;'%(arg)s'&lt;/code&gt;：說明文字中可以引用其他選項，如 &lt;code&gt;%(default)s&lt;/code&gt;、&lt;code&gt;%(type)s&lt;/code&gt; 等，若要使用 &lt;code&gt;%&lt;/code&gt; 符號，可以用 &lt;code&gt;%%&lt;/code&gt; 表示。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;argparse.SUPPRESS&lt;/code&gt; 物件：這個標籤不會顯示在 Help 項目中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="Python3"></category></entry><entry><title>40323230日誌 - 106/03/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060305.html" rel="alternate"></link><published>2017-03-05T21:00:00+08:00</published><updated>2017-03-05T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-05:/blog/40323230ri-zhi-1060305.html</id><summary type="html">&lt;p&gt;Leo editor 報告樣板&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Leo editor 報告樣板&lt;/p&gt;


&lt;h1&gt;Leo editor 報告樣板&lt;/h1&gt;
&lt;p&gt;統整了一下之前在 Pyslvs 手冊的紀錄，將 Pandoc 和 Reveal.js 的整合放在 Github 倉儲。&lt;/p&gt;
&lt;p&gt;倉儲位址：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/KmolYuan/Leo-editor-report-template"&gt;https://github.com/KmolYuan/Leo-editor-report-template&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PDF 按鈕在儲存 Markdown 後使用，會存成一份內含英文目錄的 PDF 在 pdf 資料夾中。&lt;/li&gt;
&lt;li&gt;Reveal.js 按鈕會將文章處理後存到 html 的節點去，所以轉換完後要再存一次檔，才會寫入 html 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相關設定皆可到個別 Cloned node 中修改。&lt;/p&gt;
&lt;p&gt;之後研究看看 pelican 或 Sphinx 輸出成說明網頁。&lt;/p&gt;
&lt;p&gt;接下來會參照學長的論文格式寫關於「電腦輔助設計（CAD）應用程式框架」、「平面機構解題」、「四連桿尺寸合成系統」的 paper。&lt;/p&gt;</content><category term="pandoc"></category></entry><entry><title>40323230日誌 - 106/03/04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060304.html" rel="alternate"></link><published>2017-03-04T21:00:00+08:00</published><updated>2017-03-04T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-04:/blog/40323230ri-zhi-1060304.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Release version 0.5&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Release version 0.5&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;Release version 0.5&lt;/h2&gt;
&lt;p&gt;釋出 Pyslvs version 0.5 穩定版。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0304_01.png"&gt;&lt;/p&gt;
&lt;p&gt;新功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用者介面改善。&lt;/li&gt;
&lt;li&gt;滑塊、伸縮桿表格功能。&lt;/li&gt;
&lt;li&gt;參數表格功能，能夠在節點、連桿、呆鍊表格中使用參數。&lt;/li&gt;
&lt;li&gt;大部分的表格都有復原與重做功能。&lt;/li&gt;
&lt;li&gt;輸出草圖或模型為 DXF 和 Solvespace 格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Github 上附有 Windows 平台 64 位元的自解壓縮包供下載（83.1 MB）。&lt;/p&gt;
&lt;p&gt;接下來 dev 的分支會先保留，供之後紀錄。&lt;/p&gt;
&lt;p&gt;Version 0.5 作為第一個穩定版（之前的版本沒除太多錯），撰寫報告會以這個版本為主。&lt;/p&gt;
&lt;p&gt;之後會將 Markdown 用 Pandoc 與 Leo Editor 轉檔的模板整理後放在公開倉儲。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/03/01</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060301.html" rel="alternate"></link><published>2017-03-01T21:00:00+08:00</published><updated>2017-03-01T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-03-01:/blog/40323230ri-zhi-1060301.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DXF 輸出 - 2D 模型&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DXF 輸出 - 2D 模型&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;DXF 輸出 - 2D 模型&lt;/h2&gt;
&lt;p&gt;新增這個功能匯出 2D 圖檔，可作為雷射切割使用。&lt;/p&gt;
&lt;p&gt;可用參數基本和 slvs 格式差不多，亦可自訂每個元件的間隙。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0301_01.png"&gt;&lt;/p&gt;
&lt;p&gt;這樣大量的 2D 圖形需要轉出時就很方便了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0301_02.png"&gt;&lt;/p&gt;
&lt;p&gt;有稍微花時間研究這個 DXF write 模組，似乎也能支援畫出 3D 的模型，可能是一個匯入 V-rep 的途徑？&lt;/p&gt;
&lt;p&gt;這週末整理好功能後會釋出 Version 0.5，包含在寒假進行的大量更動，比 Version 0.4 更穩定。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/28</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060228.html" rel="alternate"></link><published>2017-02-28T21:00:00+08:00</published><updated>2017-02-28T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-28:/blog/40323230ri-zhi-1060228.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介面改進&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介面改進&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;介面改進&lt;/h2&gt;
&lt;p&gt;增加轉出格式的預覽圖。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0228_01.png"&gt;&lt;/p&gt;
&lt;p&gt;另外縮減了程式碼和修改 import PyQt5 模組的方式。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/27</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060227.html" rel="alternate"></link><published>2017-02-27T21:00:00+08:00</published><updated>2017-02-27T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-27:/blog/40323230ri-zhi-1060227.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slvs 格式 - 組立&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slvs 格式 - 組立&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;p&gt;由於發現 Ubuntu 上的 Solvespace 是 whitequark 倉儲編的非穩定版，嘗試之後似乎有一些 3D 約束會閃退的狀況，之後再重裝 2016 年底的穩定版看看。&lt;/p&gt;
&lt;p&gt;所以先在 Windows 的舊版 Solvespace 上組合。&lt;/p&gt;
&lt;h2&gt;slvs 格式 - 組立&lt;/h2&gt;
&lt;p&gt;在 Windows 版的 Pyslvs 轉檔。&lt;/p&gt;
&lt;p&gt;之前以為 Linux 檔案結構的 &lt;code&gt;/&lt;/code&gt; 和 Windows 的反斜線會衝突，但是實際測試後發現 Python 的 os 模組和 Qt 的 QFileInfo 會按平台轉換，所以輸出沒問題。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0227_01.png"&gt;&lt;/p&gt;
&lt;p&gt;輸出後得到組合架構圖和連桿、呆鍊的 slvs 檔。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0227_02.png"&gt;&lt;/p&gt;
&lt;p&gt;首先將這些檔案一一點開重新存檔。&lt;/p&gt;
&lt;p&gt;舊版的 Solvespace 有跳出提示說這是新版格式的訊息，不過不影響解題。&lt;/p&gt;
&lt;p&gt;接著開啟組合架構圖，選擇 New Group &amp;gt; Import \ Assemble，匯入其他 slvs 檔。&lt;/p&gt;
&lt;p&gt;這時就可以利用 Constrain point to point、Parallel、Constrain point to plane 約束將匯入文件的草圖和底層的草圖相接。而將側邊點約束到草圖平面上可以防止零件滾動。&lt;/p&gt;
&lt;p&gt;一般來說，一個零件只要上述 3 個約束就能完全固定了。&lt;/p&gt;
&lt;p&gt;組立完成後，就能拉動驅動軸的連桿帶動全體了。&lt;/p&gt;
&lt;p&gt;下圖是組合完後的比對。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0227_03.png"&gt;&lt;/p&gt;
&lt;p&gt;由於上面那張圖是第一次測試品，之後又組一隻腳的範例。&lt;/p&gt;
&lt;p&gt;這次有開中間軸選項（直徑為 2 單位）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0227_04.png"&gt;&lt;/p&gt;
&lt;p&gt;整個流程慢慢組的話不到 10 分鐘可以完成。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/26</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060226.html" rel="alternate"></link><published>2017-02-26T21:00:00+08:00</published><updated>2017-02-26T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-26:/blog/40323230ri-zhi-1060226.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slvs 格式 - 命名規則&lt;/li&gt;
&lt;li&gt;參數式設計&lt;/li&gt;
&lt;li&gt;新增一些範例&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slvs 格式 - 命名規則&lt;/li&gt;
&lt;li&gt;參數式設計&lt;/li&gt;
&lt;li&gt;新增一些範例&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;slvs 格式 - 命名規則&lt;/h2&gt;
&lt;p&gt;將命名的選項調整完善，如下圖把尺寸資訊編入檔名裡。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0226_01.png"&gt;&lt;/p&gt;
&lt;p&gt;再加上幾個測試應該就能使用全部的自訂選項了。&lt;/p&gt;
&lt;p&gt;另外還把組合圖第一層的草圖函式獨立出來，另外有選項可以單獨生成 2D slvs 檔案。&lt;/p&gt;
&lt;h2&gt;參數式設計&lt;/h2&gt;
&lt;p&gt;之前荒廢有點久的參數功能，因為表格統整等等項目還沒做好，所以都沒維護相關區域。&lt;/p&gt;
&lt;p&gt;後來寫好 QUndoCommand 後，統整好表格增刪功能，幾個函式的適應力更為活用，稍微增加判斷式就能接手 Parameter 的增删功能。&lt;/p&gt;
&lt;p&gt;所以現在 Parameter 表格也支援復原重做功能了。&lt;/p&gt;
&lt;p&gt;新增一個 n0 參數。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0226_02.png"&gt;&lt;/p&gt;
&lt;p&gt;新增一個點，座標打上 (n0, 0.0)。&lt;/p&gt;
&lt;p&gt;如下圖，點座標會自己對應到 (70.0, 0.0) 的位置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0226_03.png"&gt;&lt;/p&gt;
&lt;p&gt;原理是更新數據（將表格內容轉為 list 與 dict 儲存）時，會偵測 n 開頭的字元，並自動對應到 Parameter 的字典裡找尋。表格上的樣子是紀錄對應到哪個參數。&lt;/p&gt;
&lt;p&gt;若是使用該參數，並在之後刪除它，程式會在刪除前將該參數的代號換回它代表的數據。&lt;/p&gt;
&lt;p&gt;以上的流程都能任意復原重做，Parameter 的功能支援在節點、連桿、呆鍊的尺寸中使用。&lt;/p&gt;
&lt;p&gt;另外可能還有一些問題待處理，會再檢查一下。&lt;/p&gt;
&lt;h2&gt;新增一些範例&lt;/h2&gt;
&lt;p&gt;新增了一個滑塊的範例。&lt;/p&gt;
&lt;p&gt;另外還把葛式四連桿的路徑重 load 過，參考 PMKS 的範例。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/25</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060225.html" rel="alternate"></link><published>2017-02-25T21:00:00+08:00</published><updated>2017-02-25T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-25:/blog/40323230ri-zhi-1060225.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slvs 格式&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slvs 格式&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;slvs 格式&lt;/h2&gt;
&lt;p&gt;更新組合圖的輸出。&lt;/p&gt;
&lt;p&gt;使用一隻仿生獸的腳來當範例。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0225_01.png"&gt;&lt;/p&gt;
&lt;p&gt;輸出選項新增了「建立資料夾」的選項，不用再預先新增資料夾了。預設是工作簿的名稱。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0225_04.png"&gt;&lt;/p&gt;
&lt;p&gt;接著會分別輸出零件檔（目前只有連桿和呆練）。若有勾選，會產生組合圖的檔案。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0225_02.png"&gt;&lt;/p&gt;
&lt;p&gt;在 Solvespace 開啟的組合檔，第一個線架構圖層已經生成了，可以使用滑鼠拉動，但是若是包含滑塊或伸縮桿，並不會有這兩者的約束。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0225_03.png"&gt;&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/22</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060222.html" rel="alternate"></link><published>2017-02-22T21:00:00+08:00</published><updated>2017-02-22T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-22:/blog/40323230ri-zhi-1060222.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slvs 格式調整&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;slvs 格式調整&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;p&gt;在 16.04 上編譯了新版的 Solvespace，除了一些如 &lt;code&gt;zlib1-dev&lt;/code&gt; 和 &lt;code&gt;libpng-dev&lt;/code&gt; 之類的舊套件無法安裝外，編譯過程順利。安裝在 /usr/share/ 中。&lt;/p&gt;
&lt;h2&gt;slvs 格式調整&lt;/h2&gt;
&lt;p&gt;之前只有試驗性地做出連桿的檔案，所以補上了呆鍊的部份。&lt;/p&gt;
&lt;p&gt;呆鍊有兩種樣式，分為整塊的 Sheet 板與 Form 支梁。&lt;/p&gt;
&lt;p&gt;下圖為支梁樣式在 Solvespace 中的樣子。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0222_01.png"&gt;&lt;/p&gt;
&lt;p&gt;Pyslvs 上的尺寸設定，有圓角直徑、厚度、孔徑、軸徑可調整。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0222_02.png"&gt;&lt;/p&gt;
&lt;p&gt;另還會有「產生組合圖」的選項，不過因為技術問題，沒法直接匯進其他零件。&lt;/p&gt;
&lt;p&gt;因此先暫時產生線架構的草圖，額外手動組裝。這部份最近幾天會開始做。&lt;/p&gt;
&lt;p&gt;還有必須注意零件檔是沒有 Surface 數據的，&lt;strong&gt;手動組裝時必須先用 Solvespace 開啟後再存檔一次&lt;/strong&gt;，才會產生數據。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/21</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060221.html" rel="alternate"></link><published>2017-02-21T21:00:00+08:00</published><updated>2017-02-21T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-21:/blog/40323230ri-zhi-1060221.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面板調整&lt;/li&gt;
&lt;li&gt;伸縮桿面板&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面板調整&lt;/li&gt;
&lt;li&gt;伸縮桿面板&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;面板調整&lt;/h2&gt;
&lt;p&gt;所有面板做了以下調整：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由於一次只啟用 1個驅動軸 Shaft0，所以驅動軸面板將只支援控制 Shaft0 而已。&lt;/li&gt;
&lt;li&gt;所有面板改成當修改或刪除任何表格時強制關閉，新增則不受影響。&lt;/li&gt;
&lt;li&gt;使用者拉動滑桿調整展示角度或位置時，每改變一次位置，就會設置一個復原點。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;伸縮桿面板&lt;/h2&gt;
&lt;p&gt;類似活塞的功能（滑塊加上距離約束），通過這個面板可以調整滑動的位置。&lt;/p&gt;
&lt;p&gt;另外還有自訂距離範圍的功能，按下旁邊的 Reset 鈕可以重置上限和當前位置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0221_01.png"&gt;&lt;/p&gt;
&lt;p&gt;顯示方面也做了一些改變，當有啟用「顯示標註」功能時，驅動軸和伸縮桿會顯示當前距離或角度。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/18</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060218.html" rel="alternate"></link><published>2017-02-18T21:00:00+08:00</published><updated>2017-02-18T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-18:/blog/40323230ri-zhi-1060218.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介面小改進&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;介面小改進&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;p&gt;由於今天剛回學校，忙準備一些事，所以做的比較少。&lt;/p&gt;
&lt;h2&gt;介面小改進&lt;/h2&gt;
&lt;p&gt;一些介面上的小更動。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;右鍵選單歸類。&lt;/li&gt;
&lt;li&gt;編輯任何表格後都會關閉面板分頁，以免誤觸失去條件的面板。&lt;/li&gt;
&lt;li&gt;表格在新增後會自動捲到底，捲動方式從&lt;strong&gt;每格(ScrollPerItem)&lt;/strong&gt;改成&lt;strong&gt;每像素(ScrollPerPixel)&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;批次移動和路徑追蹤的表單新增「加入全部」和「移除全部」鈕，樣式為雙箭頭 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;範例選單的狀態列會顯示範例編號。&lt;/li&gt;
&lt;/ul&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/17</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060217.html" rel="alternate"></link><published>2017-02-17T21:00:00+08:00</published><updated>2017-02-17T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-17:/blog/40323230ri-zhi-1060217.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;批次移動&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;批次移動&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;批次移動&lt;/h2&gt;
&lt;p&gt;將所選的節點群平移（原點不可選）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0217_01.png"&gt;&lt;/p&gt;
&lt;p&gt;移動後採用「批次移動」命令包裝，內含這些點的修改指令。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0217_02.png"&gt;&lt;/p&gt;
&lt;p&gt;命令文字提示如下：&lt;/p&gt;
&lt;pre&gt;
Batch move {Point1, Point2, Point3, Point4, Point5}
- Moved (+0.00, -50.00)
&lt;/pre&gt;

&lt;p&gt;有了移動功能後，管理點座標會更為容易。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/16</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060216.html" rel="alternate"></link><published>2017-02-16T21:00:00+08:00</published><updated>2017-02-16T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-16:/blog/40323230ri-zhi-1060216.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;節點關聯查詢&lt;/li&gt;
&lt;li&gt;取代點&lt;/li&gt;
&lt;li&gt;複製點&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;節點關聯查詢&lt;/li&gt;
&lt;li&gt;取代點&lt;/li&gt;
&lt;li&gt;複製點&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;p&gt;從 Leo Editor 借鑒一些功能。&lt;/p&gt;
&lt;h2&gt;節點關聯查詢&lt;/h2&gt;
&lt;p&gt;新增一個面板，會顯示與個別節點相關的連桿、呆鍊等等。&lt;/p&gt;
&lt;p&gt;因為在刪除該節點時會把相關項目移掉免得出錯，所以就增加這個功能方便使用者檢視它們的關係。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0216_01.png"&gt;&lt;/p&gt;
&lt;h2&gt;複製點&lt;/h2&gt;
&lt;p&gt;在滑鼠右鍵選單中增加複製點的功能。&lt;/p&gt;
&lt;p&gt;會新增一個與目標數據一樣的節點，初始顏色是橘色。&lt;/p&gt;
&lt;h2&gt;取代點&lt;/h2&gt;
&lt;p&gt;類似一般 IDE 的搜尋取代，可以把一個節點的所有關聯&lt;strong&gt;完全轉移&lt;/strong&gt;到另一個點上，但是如果發生約束衝突會導致解決失敗。&lt;/p&gt;
&lt;p&gt;這個功能也支援復原。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0216_02.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;準備再新增批次移動的功能供使用者調整選取的節點，可以將這些點平移到指定的增量。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/15</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060215.html" rel="alternate"></link><published>2017-02-15T21:00:00+08:00</published><updated>2017-02-15T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-15:/blog/40323230ri-zhi-1060215.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;復原與重做功能 - 支援項目&lt;/li&gt;
&lt;li&gt;新增「歷史紀錄」分頁&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;復原與重做功能 - 支援項目&lt;/li&gt;
&lt;li&gt;新增「歷史紀錄」分頁&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;復原與重做功能 - 支援項目&lt;/h2&gt;
&lt;p&gt;現在 Pyslvs 支援復原的命令如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全部表格的新增、編輯、刪除功能&lt;/li&gt;
&lt;li&gt;驅動軸的切換功能&lt;/li&gt;
&lt;li&gt;路徑追蹤的更新、清除功能&lt;/li&gt;
&lt;li&gt;路徑解題會以逐項添加實體的方式呈現&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外還有一些較細節的命令在製作中。&lt;/p&gt;
&lt;h2&gt;新增「歷史紀錄」分頁&lt;/h2&gt;
&lt;p&gt;這個分頁中有命令紀錄的表單，包含開啟檔案時讀取的動作。&lt;/p&gt;
&lt;p&gt;使用滑鼠點擊清單上的命令即可回溯，對開發設計很有幫助。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0215_01.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;影片展示&lt;/strong&gt;：&lt;/p&gt;
&lt;iframe width="640" height="360" src="https://www.youtube.com/embed/RJU0OUPQotk" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>Arguments and Keywords in Python Function</title><link href="http://project.mde.tw/blog/arguments-and-keywords-in-python-function.html" rel="alternate"></link><published>2017-02-14T21:00:00+08:00</published><updated>2017-02-14T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-14:/blog/arguments-and-keywords-in-python-function.html</id><summary type="html">&lt;p&gt;Python 函式的引數與關鍵字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函式基本用法&lt;/li&gt;
&lt;li&gt;引數與關鍵字&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Python 函式的引數與關鍵字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函式基本用法&lt;/li&gt;
&lt;li&gt;引數與關鍵字&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Python 函式的引數與關鍵字&lt;/h1&gt;
&lt;h2&gt;函式基本用法&lt;/h2&gt;
&lt;p&gt;一般的 Python 函式如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(x, y, z):
    print(x, y, z)

a = 10
b = 20
c = 30
AFunction(a, b, c)
#10 20 30
&lt;/pre&gt;

&lt;p&gt;函式接收名稱（name），以在函式中利用之。&lt;/p&gt;
&lt;p&gt;另一種指定 name 的用法如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(x=0, y=0, z=0):
    print(x, y, z)

a = 10
b = 20
AFunction(a, z=b)
#10  0  20
&lt;/pre&gt;

&lt;p&gt;規則：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指定預設數值的項目必須置於尾端。&lt;/li&gt;
&lt;li&gt;未指定的項目會依順序代入。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若是接收數目與輸入不同，會 Raise 出 TypeError。&lt;/p&gt;
&lt;h2&gt;引數與關鍵字&lt;/h2&gt;
&lt;p&gt;Python 提供了使用 tuple、list、dict 來輸入函式，樣式和使用上與 C 語言類似，不過並不是代表指標（Pointer）的意思。&lt;/p&gt;
&lt;p&gt;有序排列的 tuple 和 list 使用星號 * 代表，稱為「引數（Arguments, args）」，會依序輸入或接收進函式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;純輸入&lt;/strong&gt;：接收端數量不對等會回傳錯誤。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(x, y, z):
    print(x, y, z)

aList = [10, 20, 30]
AFunction(*aList)
#10  20  30
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;純接收&lt;/strong&gt;：型態為 tuple。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(*aList):
    print(aList)

AFunction(10, 20, 30)
#(10, 20, 30)
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;輸入 + 接收&lt;/strong&gt;：數量必須調整與對應適當。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(a, b, c, *aList):
    print(aList) #前三項不會顯示

AFunction(10, 20, *[30, 40, 50, 60])
#(40, 50, 60)
&lt;/pre&gt;

&lt;p&gt;使用索引的 dict 使用雙星號 ** 代表，稱為「關鍵字（Keywords, kwargs）」，會依名稱填入函式。名稱的部份&lt;strong&gt;規定必須使用 string 表示&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;純輸入&lt;/strong&gt;：接收端名稱不同、未指定預設值的項目沒輸入，皆會回傳錯誤。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(x, y, z):
    print(x)

aList = {'x':10, 'y':20, 'z':30}
AFunction(**aList)
#10
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;純接收&lt;/strong&gt;：型態為 dict。注意&lt;strong&gt;輸入端都需要給名稱&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(**aList):
    print(aList)

AFunction(c=10, a=20, b=30)
#{'a': 20, 'c': 10, 'b': 30}
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;輸入 + 接收&lt;/strong&gt;：名稱必須調整與對應適當。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(missed, **aList):
    print(aList) #不會列出 missed

AFunction(a=10, b=20, **{'c':30, 'missed':40, 'd':50})
#{'a': 10, 'c': 30, 'b': 20, 'd': 50}
&lt;/pre&gt;

&lt;p&gt;引數與關鍵字是可以混合用的，不過兩者必須擺在接收端和輸入端的最後項。&lt;/p&gt;
&lt;p&gt;此時函式會照位置依序對應，再照引數依序對應，有名稱的項目最後才根據關鍵字對應。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def AFunction(x, y, *aList, **bList):
    print(aList)
    print(bList)

AFunction(0, u=10, y=20, *[30, 40], **{'z':50, 'w':60})
#TypeError: AFunction() got multiple values for argument 'y'
&lt;/pre&gt;

&lt;p&gt;以上錯誤就是因為第一個 0 和 [30, 40] 的 list 已經帶入 x 和 y，並且多出一個 40，而之後又追加一個 y 的名稱所致。&lt;/p&gt;
&lt;p&gt;善用這個功能，可以創造多變的輸入函式，應用到迴圈處理（如新增許多不同欄數的表格內容），不用再個別撰寫類似的函式流程。&lt;/p&gt;</content><category term="Python3"></category></entry><entry><title>40323230日誌 - 106/02/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060213.html" rel="alternate"></link><published>2017-02-13T21:00:00+08:00</published><updated>2017-02-13T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-13:/blog/40323230ri-zhi-1060213.html</id><summary type="html">&lt;p&gt;Qt 的復原與重做功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本功能&lt;/li&gt;
&lt;li&gt;QUndoStack 巨集&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;復原與重做功能&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Qt 的復原與重做功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本功能&lt;/li&gt;
&lt;li&gt;QUndoStack 巨集&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;復原與重做功能&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Qt 的復原與重做功能&lt;/h1&gt;
&lt;p&gt;由於之前 Ubuntu 14.04 更新了 LiberOffice，沒想到 LiberOffice 的 Python 3.5 程式庫被 PyInstaller 錯認，導致在 Ubuntu 14.04 無法編譯出執行檔。&lt;/p&gt;
&lt;p&gt;於是最近幾天裝了第三個系統 Ubuntu 16.04 來編譯，並且整理合併了原本雜亂的 Table Widget 管理用函式，為復原與重做功能。&lt;/p&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://doc.qt.io/qt-5/qundostack.html#beginMacro"&gt;http://doc.qt.io/qt-5/qundostack.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基本功能&lt;/h2&gt;
&lt;p&gt;在 Qt 的程式中，使用下列類型管理指令以供復原。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;QUndoGroup&lt;/p&gt;
&lt;p&gt;統整不同區域，如個別視窗、Widget。每個區域用 QUndoStack 紀錄。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QUndoStack&lt;/p&gt;
&lt;p&gt;統整不同的指令紀錄，如新增、刪除、編輯。每個指令用 QUndoCommand 紀錄。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QUndoCommand&lt;/p&gt;
&lt;p&gt;代表想要復原的指令，指令中可以包含其他 QUndoCommand。每個指令都要有下列方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Redo - &lt;code&gt;QUndoCommand.redo()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;重做，可視為正指令，第一次呼叫會執行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Undo - &lt;code&gt;QUndoCommand.undo()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;復原，做出動作達成與 Redo 相反的狀態。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;由於 QUndoCommand 在 QUndoStack 必須順序執行，因此在指定位置上用當前的位置考慮就好。&lt;/strong&gt;如新增「最後一項」，Undo 時刪掉最後一項就好，不用擔心之後的指令造成這個項目不再是最後一項。&lt;/p&gt;
&lt;p&gt;至於編輯和刪除，&lt;strong&gt;要先紀錄刪除前的狀態（儲存到子項目），才能在 Undo 時加回來。&lt;/strong&gt;寫在 &lt;code&gt;self.__init__()&lt;/code&gt; 即可，會比 Redo 早執行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;呼叫 QUndoStack.push(&lt;code&gt;QUndoCommand()&lt;/code&gt;) 方法來執行 QUndoCommand 的 Redo 項目，同時將 QUndoCommand 加入紀錄中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;呼叫 QUndoStack.redo() 和 QUndoStack.undo() 方法來操作 QUndoCommand 的復原與重做。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要用 GUI 的方式查看並控制 QUndoStack，可以使用 QUndoView 這個 Widget。下面是一個只有 QUndoView 的 QDialog 懸浮窗，輸入對應的 stack 後，直接用滑鼠點擊可以馬上回到該階段。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class commandWindow(QDialog):
    def __init__(self, stack, parent=None):
        super(commandWindow, self).__init__(parent)
        undoView = QUndoView(stack)
        undoView.setEmptyLabel("Start.")
        undoView.setAttribute(Qt.WA_QuitOnClose, False)
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(undoView)
        self.setWindowTitle("Command List")
        self.setSizeGripEnabled(False)
        size = QSize(250, 200)
        self.setMinimumSize(size)
        self.setMaximumSize(size)
&lt;/pre&gt;

&lt;h2&gt;QUndoStack 巨集&lt;/h2&gt;
&lt;p&gt;QUndoStack 的巨集功能幫開發者可以錄製多個 QUndoCommand 組成的指令。&lt;/p&gt;
&lt;p&gt;原理就是建立一個空的 QUndoCommand，再將輸入的 QUndoCommand 建到這個指令下，在使用 count() 方法回傳命令數時，這種巨集只算 1 個指令。&lt;/p&gt;
&lt;p&gt;使用 beginMacro() 方法時，該 QUndoStack 所有項目都會凍結，包含 undo() 都會無法使用，直到使用 endMacro()。&lt;/p&gt;
&lt;p&gt;使用方式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
stack.beginMacro("複合指令") #開始錄製
stack.push(AFunction()) #紀錄第一個 QUndoCommand
print("複合指令執行中") #一般程式不會影響
stack.push(BFunction()) #紀錄第二個 QUndoCommand
stack.endMacro() #結束錄製
&lt;/pre&gt;

&lt;p&gt;這樣下 undo() 方法就會一次倒敘 AFunction() 和 BFunction() 回去。&lt;/p&gt;
&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;復原與重做功能&lt;/h2&gt;
&lt;p&gt;參照一些簡單的範例達成了復原功能，並且在 Command line 上的 print 字樣也有所標示。&lt;/p&gt;
&lt;p&gt;不過還沒把一些更新功能轉成 QUndoCommand，所以暫時無法使用懸浮窗控制，全都加入後會預設啟用懸浮窗。&lt;/p&gt;
&lt;p&gt;下圖是載入檔案後編輯連桿的長度。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0213_01.png"&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt; + &lt;kbd&gt;Z&lt;/kbd&gt; 復原。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0213_02.png"&gt;&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/10</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060210.html" rel="alternate"></link><published>2017-02-10T21:00:00+08:00</published><updated>2017-02-10T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-10:/blog/40323230ri-zhi-1060210.html</id><summary type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Slider 功能修正&lt;/li&gt;
&lt;li&gt;容量縮減&lt;/li&gt;
&lt;li&gt;防呆措施&lt;/li&gt;
&lt;li&gt;轉出 3D 模型&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 開發進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Slider 功能修正&lt;/li&gt;
&lt;li&gt;容量縮減&lt;/li&gt;
&lt;li&gt;防呆措施&lt;/li&gt;
&lt;li&gt;轉出 3D 模型&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 開發進度&lt;/h1&gt;
&lt;h2&gt;Slider 功能修正&lt;/h2&gt;
&lt;p&gt;將滑塊功能從 1 連桿上的 1 點改成 2 點間的 1 點定義。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0210_01.png"&gt;&lt;/p&gt;
&lt;p&gt;只是 Solvespace kernel 處理上仍有些不妥，若是如上圖旋轉中心與這 2 點共線，&lt;strong&gt;會讓 Point3 在一定距離內被鎖到旋轉中心上，因為這樣也符合條件。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;容量縮減&lt;/h2&gt;
&lt;p&gt;讓許多對話方塊共用同 ui，如一般的新增／編輯視窗共用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0210_02.png"&gt;&lt;/p&gt;
&lt;p&gt;所有的警告視窗都刪除，替代成防呆措施或 QMessageBox（如：未存檔警告）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0210_03.png"&gt;&lt;/p&gt;
&lt;p&gt;Windows 編譯時複製的 kernel 也改成只複製 py35w 的，不過減量效果較有限，從 386 MB 縮減到 377 MB。&lt;/p&gt;
&lt;h2&gt;防呆措施&lt;/h2&gt;
&lt;p&gt;實體和模擬的警告視窗都移除了，改成符合條件才會允許建立或修改這些約束。&lt;/p&gt;
&lt;p&gt;例如下圖中的新增視窗 start 和 end 選到了相同的節點，OK 鈕就會變成 Disable 狀態。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0210_04.png"&gt;&lt;/p&gt;
&lt;h2&gt;轉出 3D 模型&lt;/h2&gt;
&lt;p&gt;由於目前暫時沒有 Solvespace Surface 功能的程式庫，最近會先嘗試做出 OBJ 的轉檔功能。&lt;/p&gt;
&lt;p&gt;Solvespace 格式 import 只支援自己的 *.slvs 檔比較可惜，必要的話得看一下原始碼的內容作編譯。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/09</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060209.html" rel="alternate"></link><published>2017-02-09T21:00:00+08:00</published><updated>2017-02-09T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-09:/blog/40323230ri-zhi-1060209.html</id><summary type="html">&lt;p&gt;關於 Solvespace 的 3D 格式&lt;/p&gt;
</summary><content type="html">&lt;p&gt;關於 Solvespace 的 3D 格式&lt;/p&gt;


&lt;h1&gt;關於 Solvespace 的 3D 格式&lt;/h1&gt;
&lt;p&gt;這幾天研究了 fourbarlinkage 和 jasen_8link 的檔案。&lt;/p&gt;
&lt;p&gt;使用純「拉伸」群組的檔案結構如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0209_02.png"&gt;&lt;/p&gt;
&lt;p&gt;「組合圖」的檔案結構如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0209_03.png"&gt;&lt;/p&gt;
&lt;p&gt;這兩個 project 的組立都是將零件匯入，並約束到「組合圖」的草圖中。&lt;/p&gt;
&lt;p&gt;若是只改動連桿的長度，該零件 &lt;code&gt;.slvs&lt;/code&gt; 格式的變動如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0209_01.png"&gt;&lt;/p&gt;
&lt;p&gt;雖然其中包含一些 20 位小數造成的誤差，但是主要的內容都是紀錄運算結果。&lt;/p&gt;
&lt;p&gt;也因為如此，就算其中有缺損，Solvespace 仍能依據主要實體重新算好結果，存檔時重新存入檔案中。&lt;/p&gt;
&lt;p&gt;這些運算結果也包含拉伸出的表面，尤其是弧線的分段計算，每個 1/2 圓弧都會分為 4 等分計算，所以一個完整圓會有 8 段 Curve（平面的 4 等分座標都在一直線上），這些數據就是分段點的當前座標。&lt;/p&gt;
&lt;p&gt;不過這些算好的數據並不是給當前檔案看的，而是拿來&lt;strong&gt;匯入&lt;/strong&gt;用的，倘若缺少這些數據，使用它們的「組合圖」就會發生缺損，而且回溯結構時會變紅字。&lt;/p&gt;
&lt;p&gt;而「組合圖」也會將子項目的數據複製一份存起來，給更大的「組合圖」使用。&lt;/p&gt;
&lt;p&gt;然而，「組合圖」要讀取的這些數據不能有錯誤的答案（因為本身沒有該實體），否則該曲線關聯的 Surface 會消失變成破面。&lt;/p&gt;
&lt;p&gt;Python-solvespace 的模組沒有加入 Surface 的相關功能，所以沒辦法求出結果。&lt;/p&gt;
&lt;p&gt;目前的進度為可以透過 GUI 用迴圈導出 &lt;code&gt;*.slvs&lt;/code&gt; 的零件檔案，但是因為上述問題，無法做成組合圖。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0209_04.png"&gt;&lt;/p&gt;
&lt;p&gt;不知是否需要加入 Solvespace Surface 的相關功能還是找其他格式（如 OBJ file）解決。&lt;/p&gt;
&lt;p&gt;已測試可以在 V-rep 中使用 blender 匯出的模型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0209_05.png"&gt;&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/07</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060207.html" rel="alternate"></link><published>2017-02-07T21:00:00+08:00</published><updated>2017-02-07T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-07:/blog/40323230ri-zhi-1060207.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Leo Editor - 簡單的節點控制&lt;/p&gt;
&lt;p&gt;簡述 Leo Editor 的 @button 節點運用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Generators&lt;/li&gt;
&lt;li&gt;Position Getters&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 手冊應用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 目標 - 模型銜接 V-rep&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Leo Editor - 簡單的節點控制&lt;/p&gt;
&lt;p&gt;簡述 Leo Editor 的 @button 節點運用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Generators&lt;/li&gt;
&lt;li&gt;Position Getters&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 手冊應用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 目標 - 模型銜接 V-rep&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Leo Editor - 簡單的節點控制&lt;/h1&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://leoeditor.com/cheatsheet.html#scripting"&gt;http://leoeditor.com/cheatsheet.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：一些方法（method）可以利用 Leo 的自動完成功能（&lt;kbd&gt;Alt&lt;/kbd&gt; + &lt;kbd&gt;1&lt;/kbd&gt;）尋找。&lt;/p&gt;
&lt;h2&gt;Generators&lt;/h2&gt;
&lt;p&gt;一些常用的 generator。&lt;/p&gt;
&lt;p&gt;Python 的 generator 使用方式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
pList = [e.copy() for e in c.all_positions()]
&lt;/pre&gt;

&lt;p&gt;&lt;a href="http://project.mde.tw/blog/40323230ri-zhi-1060204.html"&gt;上一篇文章&lt;/a&gt; 提到了不要直接使用 generator 來下指令，否則會出現 &lt;code&gt;&amp;lt;pos 139770197424392 [0] None&amp;gt;&lt;/code&gt; 回傳值為 None 的情形。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在一般情形下，@button 中的 &lt;code&gt;p&lt;/code&gt; 為「當前節點」而非「該 @button 節點」的 position，應當特別注意。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;c.all_positions()
    依序回傳大綱所有節點的 position，包含的子項目會跟在父節點之後。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;c.all_unique_positions()
    依序回傳大綱所有節點的 position，包含的子項目會跟在父節點之後，但是分身節點只會回傳一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.children()
    依序回傳該 position 子節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.parents()
    依序（由底開始）回傳該 position 父節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.self_and_parents()
    依序（由底開始）回傳該 position 父節點的 position，第一次會回傳自身。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.self_and_siblings()
    依序回傳該 position 同層級節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.following_siblings()
    依序回傳該 position 下方同層級節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.subtree()
    依序回傳該 position 子孫節點的 position，包含的子孫項目會跟在父節點之後。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.self_and_subtree()
    依序回傳該 position 子孫節點的 position，包含的子孫項目會跟在父節點之後，第一次會回傳自身。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Position Getters&lt;/h2&gt;
&lt;p&gt;一些常用的 Getter。&lt;/p&gt;
&lt;p&gt;這些方法回傳 position 的週邊資訊，上面提過的 Generator 將不再說明 。&lt;/p&gt;
&lt;p&gt;Python 的方法可以使用多層（只要確定非空值）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
B = p.next().firstChild().b
&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;p.back()
    回傳該 position 上方一個節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.next()
    回傳該 position 下方一個節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.firstChild()
    回傳該 position 第一個子節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.lastChild()
    回傳該 position 最後一個子節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.parent()
    回傳該 position 第一個父節點的 position。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;p.level()
    回傳該 position 的層級整數（int）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至於 position 的新增、移動、刪除方法使用後會如同修改 vnode，發生大綱樹不會即時更新的情形（無法選擇更新後節點、不會提醒儲存以及存檔後不會編輯檔案節點），必須重新存檔才能更新大綱樹。也因為如此不符合 @button 的功能需求，因此就不介紹了。&lt;/p&gt;
&lt;h1&gt;Pyslvs 手冊應用&lt;/h1&gt;
&lt;p&gt;縮減了原先的語法，使用 Leo 提供的 generator，變得更易懂。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
pList = [e.copy() for e in c.all_positions()] #節點參照
hList = [e.h for e in c.all_positions()] #索引
MD = pList[hList.index("@clean {}.md".format(filename))] #找到 Markdown file
pos = hList.index("{} Target node".format(filename)) #目標
B = [e.b for e in MD.self_and_subtree()]
B = ''.join(B).replace("%", "##").replace("\n@language md", '').replace("\n@others", '').replace("*@fig:", '').split("\n\n\\newpage")
head = """&lt;section&gt;
&lt;section data-markdown data-separator="^\\n&lt;!--===--&gt;\\n"&gt;
&lt;script type="text/template"&gt;"""
tail = """
&lt;/script&gt;
&lt;/section&gt;
&lt;/section&gt;
"""
B = [head+e+tail for e in B]
pList[pos].b = removeParentheses("@language html\n"+'\n'.join(B))
g.es("{} HTML 簡報轉換完畢".format(filename))
&lt;/pre&gt;

&lt;h1&gt;Pyslvs 目標 - 模型銜接 V-rep&lt;/h1&gt;
&lt;p&gt;為了達成 Pyslvs 的「2D 線條」轉成 V-rep 能用的「3D 支架」（或是連桿之類的），要在接下來的版本做出這個功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0207_01.png"&gt;&lt;/p&gt;
&lt;p&gt;由於 STL 是三角形接合的立體物件，要憑空畫出 3D 支架的組合圖，想知道這方面的資料。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060204.html" rel="alternate"></link><published>2017-02-04T21:00:00+08:00</published><updated>2017-02-04T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-04:/blog/40323230ri-zhi-1060204.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Leo Editor - 簡單的節點控制&lt;/p&gt;
&lt;p&gt;簡述 Leo Editor 的 @button 節點運用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;預先定義名稱：c、g、p&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vnode&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Position&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generator&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 @button 複製節點正文&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 手冊應用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Leo Editor - 簡單的節點控制&lt;/p&gt;
&lt;p&gt;簡述 Leo Editor 的 @button 節點運用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;預先定義名稱：c、g、p&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vnode&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Position&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generator&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 @button 複製節點正文&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 手冊應用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Leo Editor - 簡單的節點控制&lt;/h1&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://leoeditor.com/tutorial-scripting.html#predefined-symbols-c-g-and-p"&gt;http://leoeditor.com/tutorial-scripting.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://leoeditor.com/tutorial-scripting.html#predefined-symbols-c-g-and-p"&gt;http://leoeditor.com/scripting.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;預先定義名稱：c、g 和 p&lt;/h2&gt;
&lt;p&gt;在可執行腳本中預先定義的符號 c、g 和 p。&lt;/p&gt;
&lt;p&gt;c 為包含腳本大綱的 &lt;strong&gt;commander&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Commander 為指令類別的實體（instance），在 &lt;code&gt;leoCommands.py&lt;/code&gt; 文件中定義。&lt;/li&gt;
&lt;li&gt;Commander 提供了所有大綱資料與 Leo 原始碼的權限。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;g 為 Leo 的 leo.core.leoGlobals 模組。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;這個模組包含許多實用的函式，如 &lt;code&gt;g.es&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;p 是當前選擇節點的 &lt;strong&gt;position&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;position 為位置類別的實體，在 &lt;code&gt;leoNodes.py&lt;/code&gt; 文件中定義。&lt;/li&gt;
&lt;li&gt;位置類型提供安全、方便的方式來存取與修改大綱節點。&lt;/li&gt;
&lt;li&gt;對於任何位置的 &lt;code&gt;p&lt;/code&gt;，&lt;code&gt;p.v&lt;/code&gt; 是一個 &lt;strong&gt;vnode&lt;/strong&gt; 物件。&lt;/li&gt;
&lt;li&gt;vnode 包含所有在 Leo 大綱的永久資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Vnode&lt;/h2&gt;
&lt;p&gt;vnode 為 vnode 類別的實體，在 &lt;code&gt;leoNodes.py&lt;/code&gt; 文件中定義。每個 vnode 代表關聯著一個大綱節點的&lt;em&gt;所有&lt;/em&gt;資訊，包含著&lt;em&gt;專用&lt;/em&gt;數據帶有它的大鋼結構。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;v.b 是（大綱）節點的正文（body text）。&lt;/li&gt;
&lt;li&gt;v.h 是節點的標題（headline）。&lt;/li&gt;
&lt;li&gt;v.u 是節點的&lt;strong&gt;使用者資訊&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;所有分身節點共用同一個 vnode。&lt;/strong&gt;反之，每個 vnode 表示出所有分身相應的節點。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0204_01.png"&gt;&lt;/p&gt;
&lt;p&gt;由於&lt;em&gt;單一個&lt;/em&gt; vnode 可以代表&lt;em&gt;多個&lt;/em&gt;大綱節點，直接使用 vnode 會變得較尷尬。這就是為何出現 position：&lt;strong&gt;position 簡化對 vnode 的存取。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Position&lt;/h2&gt;
&lt;p&gt;一個 position 代表一個具體的大綱節點在大綱一個精確的位置上，position 為位置類別的實體，在 &lt;code&gt;leoNodes.py&lt;/code&gt; 文件中定義。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在位置 &lt;code&gt;p&lt;/code&gt; 上的 vnode 就是 &lt;code&gt;p.v&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;由於所有分身共用一樣的 vnode，多個 position 可能會擁有一樣的 &lt;code&gt;p.v&lt;/code&gt; 內容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p.b&lt;/code&gt;、&lt;code&gt;p.h&lt;/code&gt;、&lt;code&gt;p.u&lt;/code&gt; 代表著 &lt;code&gt;p.v.b&lt;/code&gt;、&lt;code&gt;p.v.h&lt;/code&gt;、&lt;code&gt;p.v.u&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;對於任何一個 Commander &lt;code&gt;c&lt;/code&gt;，&lt;code&gt;c.p&lt;/code&gt; 為當前選擇的節點。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;position 常因為大綱結構改變而變成無效。&lt;/strong&gt;腳本應當只在確保大綱結構不會發生任何改變時儲存位置以供稍後使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;c.positionExists(p)&lt;/code&gt; 會在 &lt;code&gt;c.p&lt;/code&gt; 仍為有效值時回傳 True。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0204_02.png"&gt;&lt;/p&gt;
&lt;h2&gt;Generator&lt;/h2&gt;
&lt;p&gt;Leo 的 Generator 即為 Python generator，這些 generator 追蹤（逐漸地）Leo 大綱的一個個節點：&lt;strong&gt;Leo generators yield 出一個位置序列。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;命令（commander）和位置類別定義了數個 generator，&lt;code&gt;c.all_positions()&lt;/code&gt; 隨著大綱順序追蹤大綱。下面的程式 print 出正確縮排的標題清單。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
for p in c.all_positions():
    print(' '*p.level()+p.h)
&lt;/pre&gt;

&lt;p&gt;Leo generator &lt;strong&gt;yield&lt;/strong&gt;（回傳一個環節）出 position。它們&lt;em&gt;不會&lt;/em&gt;回傳一個實際的 list；這為大型的大綱節省了不少空間。事實上，這個位置序列其實是一個&lt;strong&gt;單一&lt;/strong&gt;、&lt;strong&gt;不斷變化位置&lt;/strong&gt;的序列。這是一個非常重要的空間優化。&lt;/p&gt;
&lt;p&gt;當一個 generator 已經回傳完成，這個單一位置變成了一個&lt;strong&gt;空的 position&lt;/strong&gt;。&lt;code&gt;p.v&lt;/code&gt; 會在空的 position 為 None。這裡有正確及錯誤的方式測試空的 position。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if not p:       # Right
if not p.v:     # Right
if p is None:   # Wrong!
&lt;/pre&gt;

&lt;p&gt;為了避免上述情形，應當使用 &lt;code&gt;copy()&lt;/code&gt; 方法複製 vnode 與 position 類型的物件，再予以修改。&lt;/p&gt;
&lt;h2&gt;使用 @button 複製節點正文&lt;/h2&gt;
&lt;p&gt;自己做了一個按鈕程式來應用 Leo editor 的腳本功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目標&lt;/strong&gt;：將 I 節點下的 Hellow World! 文章改名複製到 J 節點下。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0204_03.png"&gt;&lt;/p&gt;
&lt;p&gt;由於還不太熟悉 Leo 的 generator，先用比較生疏的方式指定目標。&lt;/p&gt;
&lt;p&gt;複製節點文章程式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
pList = [e.copy() for e in c.all_positions()]
nList = [e.h for e in c.all_nodes()]
bList = [e.b for e in c.all_nodes()]
Istart = nList.index("I")+1
Iend = nList.index("i-c")+1
Jstart = nList.index("J")+1
Jend = nList.index("j-c")+1
B = bList[Istart:Iend]
P = pList[Jstart:Jend]
B = [e.replace('i', 'j') for e in B]
for e in range(len(P)): P[e].b = B[e]
g.es('Copied!')
&lt;/pre&gt;

&lt;p&gt;清空節點文章程式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
pList = [e.copy() for e in c.all_positions()]
nList = [e.h for e in c.all_nodes()]
Jstart = nList.index("J")+1
Jend = nList.index("j-c")+1
P = pList[Jstart:Jend]
for e in range(len(P)): P[e].b = ''
g.es('Cleaned!')
&lt;/pre&gt;

&lt;p&gt;列出 position 和 vnode 程式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
pList = [str(e.copy()) for e in c.all_positions()]
nList = [str(e.copy()) for e in c.all_nodes()]
g.es('\n'.join(pList))
g.es('\n'.join(nList))
&lt;/pre&gt;

&lt;h1&gt;Pyslvs 手冊應用&lt;/h1&gt;
&lt;p&gt;使用 Leo editor 的腳本功能達成轉換 Pandoc 特殊語法。&lt;/p&gt;
&lt;p&gt;目前功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;及時裁切處理 Markdown 文件，輸出 Reveal.js 的 Markdown + html 語法到指定節點（Target node）。&lt;/li&gt;
&lt;li&gt;切開 &lt;code&gt;\newpage&lt;/code&gt; 記號成水平投影片。&lt;/li&gt;
&lt;li&gt;圖片參照記號移除，但是內文的還未解決。&lt;/li&gt;
&lt;li&gt;其他皆按照 data-markdown 的功能排版。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程式還有些雜亂，之後會整修一下。&lt;/p&gt;
&lt;p&gt;轉換程式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
pList = [e.copy() for e in c.all_positions()]
nList = [e.h for e in c.all_nodes()]
bList = [e.b for e in c.all_nodes()]
Istart = nList.index("@clean {}.md".format(filename))
Iend = nList.index("@clean reveal.js/{}.html".format(filename))
pos = nList.index("{} Target node".format(filename))
B = bList[Istart:Iend]
P = pList[pos]
B[0] = B[0].replace("%", "##")+"\n\\newpage"
B = ''.join(B).replace("\n@language md", '').replace("\n@others", '').split("\n\n\\newpage")
head = """&lt;section&gt;
&lt;section data-markdown data-separator="^\\n&lt;!--===--&gt;\\n"&gt;
&lt;script type="text/template"&gt;"""
tail = """
&lt;/script&gt;
&lt;/section&gt;
&lt;/section&gt;
"""
B = [head+e+tail for e in B]
P.b = removeParentheses("@language html\n"+'\n'.join(B))
g.es("{} HTML 簡報轉換完畢".format(filename))
&lt;/pre&gt;

&lt;p&gt;移除圖片參照專用函式 &lt;code&gt;removeParentheses()&lt;/code&gt;：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def removeParentheses(content):
    while content.find("{")!=-1:
        start = content.find("{")
        end = content.find("}")+1
        result = content[start:end]
        content = content.replace(result, '')
    return content
&lt;/pre&gt;

&lt;p&gt;轉換過程不會用到外部程式，三份 html 文件都是共用同一份 js 檔案。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/03</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060203.html" rel="alternate"></link><published>2017-02-03T21:00:00+08:00</published><updated>2017-02-03T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-03:/blog/40323230ri-zhi-1060203.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Leo Editor - Pyslvs 手冊 - Reveal.js&lt;/p&gt;
&lt;p&gt;兩種方式轉成 Reveal.js 樣板：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Leo Editor Cloned Node&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pandoc - Template&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pelican 的 Pandoc Plugin&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Leo Editor - Pyslvs 手冊 - Reveal.js&lt;/p&gt;
&lt;p&gt;兩種方式轉成 Reveal.js 樣板：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Leo Editor Cloned Node&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pandoc - Template&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pelican 的 Pandoc Plugin&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Leo Editor - Pyslvs 手冊 - Reveal.js&lt;/h1&gt;
&lt;p&gt;為了達成使用相同內容達成一樣的效果，所以找了兩種方法，目前各有優缺，暫時都保留。&lt;/p&gt;
&lt;h2&gt;Leo Editor Cloned Node&lt;/h2&gt;
&lt;p&gt;使用 Leo Editor 的分身節點套用相同的內容，並用 data-markdown 讀取；原始碼中會包含為轉換的 Markdown 語法。&lt;/p&gt;
&lt;p&gt;不過這種方式無法分章節（水平投影片），因此每個章節都需要分身，否則會讀取到 LaTex 的換頁標記。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0203_01.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;優點&lt;/strong&gt;是可以自由裁切投影片長度（使用自訂記號），而且完全不會影響 Pandoc 的讀取。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0203_02.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺點&lt;/strong&gt;是不能使用使用圖片參照，可能還要另外想辦法或是捨棄這種用法。&lt;/p&gt;
&lt;p&gt;還有一個較小的&lt;strong&gt;缺點&lt;/strong&gt;是使用記號裁切後，分開的超連結內容會被脫離，必須在裁切前補上註釋，而 Pandoc 可能也會警告重複轉換的內容。&lt;/p&gt;
&lt;h2&gt;Pandoc - Template&lt;/h2&gt;
&lt;p&gt;在 Github 上找到有人寫的 Template 檔，讓 Pandoc 直接轉好 index.html，而且認得圖片參照與特殊用法。&lt;/p&gt;
&lt;p&gt;倉儲位址：&lt;a href="https://gist.github.com/aaronwolen/5017084"&gt;https://gist.github.com/aaronwolen/5017084&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用的指令：&lt;/p&gt;
&lt;pre&gt;
$pandoc -t html5 --template=template-revealjs.html \
  --standalone --section-divs \
  --variable transition="linear" \
  example.md -o example.html
&lt;/pre&gt;

&lt;p&gt;主要使用 &lt;code&gt;--section-divs&lt;/code&gt; 配上 &lt;code&gt;-t html5&lt;/code&gt; 並套用 Reveal.js 的套件轉出。&lt;/p&gt;
&lt;p&gt;轉出來的樣式如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0203_03.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺點&lt;/strong&gt;明顯就是「小節」會依附在「章」中，每一頁都會有「章」的開頭文字擋住。&lt;/p&gt;
&lt;h1&gt;Pelican 的 Pandoc Plugin&lt;/h1&gt;
&lt;p&gt;Pelican 部分有找到相關的擴充套件 pandoc_reader。&lt;/p&gt;
&lt;p&gt;倉儲位址：&lt;a href="https://github.com/liob/pandoc_reader"&gt;https://github.com/liob/pandoc_reader&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;還沒測試過效果，不過會使用到 command line 的 Pandoc，應該能套用原本的 Markdown 文件。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/02/02</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060202.html" rel="alternate"></link><published>2017-02-02T21:00:00+08:00</published><updated>2017-02-02T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-02-02:/blog/40323230ri-zhi-1060202.html</id><summary type="html">&lt;p&gt;Leo Editor - Pyslvs 手冊&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Pandoc - PDF&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reveal.js - HTML 簡報&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Leo Editor - Pyslvs 手冊&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Pandoc - PDF&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reveal.js - HTML 簡報&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Leo Editor - Pyslvs 手冊&lt;/h1&gt;
&lt;p&gt;目前以 Leo Editor 編輯 Markdown 檔案，為了讓章節更分明，用 node 的方式統整內容。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0202_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;匯出的 PDF 輸出在 &lt;code&gt;/PDF&lt;/code&gt; 資料夾內，而 Reveal.js 則是放在 &lt;code&gt;/reveal.js&lt;/code&gt; 資料夾內。&lt;/p&gt;
&lt;p&gt;至於 Pelican 的部份還沒研究樣板的關係，暫時未加入。&lt;/p&gt;
&lt;h2&gt;Pandoc - PDF&lt;/h2&gt;
&lt;p&gt;這部份使用 Pandoc 的命令匯出，在語法上會用到擴展的功能，Pelican 和 Reveal.js 可能不會支援。&lt;/p&gt;
&lt;p&gt;在 Leo Editor 中設計了 3 個按鈕轉檔，Python code 判斷平台與字型，Windows 採用&lt;strong&gt;標楷體&lt;/strong&gt;；Ubuntu 後來由&lt;strong&gt;文泉驛微米黑&lt;/strong&gt;改成&lt;strong&gt;教育部標準楷書&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0202_04.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Python code 使用 Clone node 的方式，使三本手冊套用一樣的設定輸出。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import os, platform
if platform.system().lower()=="linux": font = "教育部標準楷書"
elif platform.system().lower()=="windows": font = "DFKai-SB"
else: font = "Arial"
fontsize = "12"
margin = "1in"
settingFlag = "--latex-engine=xelatex --toc --filter pandoc-fignos --template=template.tex -V \"mainfont:{0}\" -V fontsize={1}pt -V geometry:margin={2}".format(font, fontsize, margin)
os.system("pandoc {0}.md -o PDF/{0}.pdf {1}".format(filename, settingFlag))
g.es("{} PDF 轉換完畢".format(filename))
&lt;/pre&gt;

&lt;p&gt;只有名稱 filename 使用不同字串而已。&lt;/p&gt;
&lt;h2&gt;Reveal.js - HTML 簡報&lt;/h2&gt;
&lt;p&gt;Reveal.js 若是要使用 Markdown 語法，必須先將 markdown plugin 加回來。&lt;/p&gt;
&lt;p&gt;啟動時使用：&lt;/p&gt;
&lt;pre class="brush: java"&gt;
Reveal.initialize({
    dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/notes/notes.js', async: true },
        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
    ]
});
&lt;/pre&gt;

&lt;p&gt;並且從 &lt;a href="https://github.com/hakimel/reveal.js"&gt;官方倉儲&lt;/a&gt; 載回 &lt;code&gt;lib&lt;/code&gt; 資料夾。&lt;/p&gt;
&lt;p&gt;編寫 index.html 時使用下面的語法：&lt;/p&gt;
&lt;pre class="brush: html"&gt;
&lt;section data-markdown&gt;
    &lt;script type="text/template"&gt;
        Markdown 文字
    &lt;/script&gt;
&lt;/section&gt;
&lt;/pre&gt;

&lt;p&gt;並利用 Clone node 與原文件同步。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0202_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;使用後的樣式如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0202_03.jpg"&gt;&lt;/p&gt;
&lt;p&gt;另外還有需要換頁的問題，官方提供的語法可以自動分行、輸入現成 md 檔等等。&lt;/p&gt;
&lt;pre class="brush: html"&gt;
&lt;section data-markdown="example.md"  
     data-separator="^\n\n\n"  
     data-separator-vertical="^\n\n"  
     data-separator-notes="^Note:"  
     data-charset="iso-8859-15"&gt;
&lt;/section&gt;
&lt;/pre&gt;

&lt;p&gt;不過遇到 Pandoc 語法（如圖片參照）就沒辦法使用了。而針對換頁，可能還需要斟酌嵌入方式，或是在原文件中加入特殊 html 註解換頁。&lt;/p&gt;
&lt;p&gt;至於 Pelican 的 Markdown 應該也和 Reveal.js 一樣，只是不需要分頁。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>Qt5 - Ubuntu switch Fcitx input method</title><link href="http://project.mde.tw/blog/qt5-ubuntu-switch-fcitx-input-method.html" rel="alternate"></link><published>2017-01-24T21:00:00+08:00</published><updated>2017-01-24T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-24:/blog/qt5-ubuntu-switch-fcitx-input-method.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;解決 Ubuntu 平台無法在 Qt5 切換 Fcitx 輸入法的問題&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;解決 Ubuntu 平台無法在 Qt5 切換 Fcitx 輸入法的問題&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;解決 Ubuntu 平台無法在 Qt5 切換 Fcitx 輸入法的問題&lt;/h1&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/cposture/p/5397694.html"&gt;http://www.cnblogs.com/cposture/p/5397694.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用 Python 3 啟動 Leo editor、QtCreator，甚至是自己的 PyQt 專案時，會發生無法在視窗內使用英文以外的輸入法。&lt;/p&gt;
&lt;p&gt;在 Qt4 時，這個功能可以直接在 Qt Setting 中選擇。Qt5 則是依賴「fcitx-qt5」這個套件，使用 apt 檢查時，會顯示已經安裝並為最新版。&lt;/p&gt;
&lt;p&gt;但是安裝 Qt 時的 fcitx-qt5 套件沒有對應到作業系統的 Fcitx 版本時，就要手動 make 了。&lt;/p&gt;
&lt;p&gt;在編譯 fcitx-qt5 前，先確認已經安裝最新的 CMake。&lt;/p&gt;
&lt;p&gt;示範的 Qt 安裝位置為 &lt;code&gt;/opt/Qt/&lt;/code&gt;，版本為 5.6，請根據自身版本做調整。&lt;/p&gt;
&lt;p&gt;這些流程在 14.04 和 16.04 中是大同小異的，並沒有太大分別。&lt;/p&gt;
&lt;h1&gt;編譯 fcitx-qt5&lt;/h1&gt;
&lt;p&gt;從官方倉儲下載 fcitx-qt5，進入該資料夾中：&lt;/p&gt;
&lt;pre&gt;
$git clone https://github.com/fcitx/fcitx-qt5
$cd fcitx-qt5
&lt;/pre&gt;

&lt;p&gt;接著準備編譯 fcitx-qt5。&lt;/p&gt;
&lt;pre&gt;
$cmake .
$make
$sudo make install
&lt;/pre&gt;

&lt;p&gt;在使用 CMake 時會發生如下問題。&lt;/p&gt;
&lt;h2&gt;extra-cmake-modules&lt;/h2&gt;
&lt;p&gt;錯誤訊息：&lt;/p&gt;
&lt;pre&gt;
CMake Error at CMakeLists.txt:8 (find_package):
Could not find a package configuration file provided by "ECM" (requested
  version 1.4.0) with any of the following names:
ECMConfig.cmake
ecm-config.cmake
  Add the installation prefix of "ECM" to CMAKE_PREFIX_PATH or set "ECM_DIR"
  to a directory containing one of the above files.  If "ECM" provides a
  separate development package or SDK, be sure it has been installed.
-- Configuring incomplete, errors occurred!
&lt;/pre&gt;

&lt;p&gt;到下面網址下載 CMake 額外模組：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://launchpad.net/ubuntu/+source/extra-cmake-modules/1.4.0-0ubuntu1"&gt;https://launchpad.net/ubuntu/+source/extra-cmake-modules/1.4.0-0ubuntu1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解壓縮進入，編譯並安裝模組。編譯前必須指定 CMAKE_PREFIX_PATH 位置到 Qt GCC 的 CMake 上。&lt;/p&gt;
&lt;pre&gt;
$export CMAKE_PREFIX_PATH="/opt/Qt/5.6/gcc_64/lib/cmake/"
$cmake .
$make
$sudo make install
&lt;/pre&gt;

&lt;h2&gt;xkbcommon&lt;/h2&gt;
&lt;p&gt;錯誤訊息：&lt;/p&gt;
&lt;pre&gt;
-- Found PkgConfig: /usr/bin/pkg-config (found version "0.26") 
-- Could NOT find XKBCommon_XKBCommon (missing:  XKBCommon_XKBCommon_LIBRARY XKBCommon_XKBCommon_INCLUDE_DIR) 
CMake Error at /usr/share/cmake-2.8/Modules/FindPackageHandleStandardArgs.cmake:108 (message):
  Could NOT find XKBCommon (missing: XKBCommon_LIBRARIES XKBCommon) (Required is at least version "0.5.0")
&lt;/pre&gt;

&lt;p&gt;到 &lt;a href="http://xkbcommon.org/"&gt;http://xkbcommon.org/&lt;/a&gt; 下載最新的穩定版本。&lt;/p&gt;
&lt;p&gt;解壓縮後進入資料夾，安裝時需要用到 bison 套件。&lt;/p&gt;
&lt;pre&gt;
$sudo apt-get install bison
$./configure --prefix=/usr --libdir=/usr/lib/x86_64-linux-gnu --disable-x11
$make
$sudo make install
&lt;/pre&gt;

&lt;h1&gt;安裝 fcitx-qt5&lt;/h1&gt;
&lt;p&gt;若順利執行 CMake 並成功編譯，會在 &lt;code&gt;platforminputcontext&lt;/code&gt; 出現 fcitx-qt5 的程式庫，名為 &lt;code&gt;libfcitxplatforminputcontextplugin.so&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接著刪除 Qt 內的 fcitx-qt5 套件：&lt;/p&gt;
&lt;pre&gt;
$sudo rm -f /opt/Qt/5.6/gcc_64/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so
$sudo rm -f /opt/Qt/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so
&lt;/pre&gt;

&lt;p&gt;然後進入 &lt;code&gt;platforminputcontext&lt;/code&gt; 資料夾，先讓該程式庫「可執行化」後再複製。&lt;/p&gt;
&lt;pre&gt;
$sudo chmod +x libfcitxplatforminputcontextplugin.so
$sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt/5.6/gcc_64/plugins/platforminputcontexts/
$sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/
&lt;/pre&gt;

&lt;p&gt;然後設定 Qt5 的預設輸入法為 Fcitx。&lt;/p&gt;
&lt;p&gt;直接執行下面這兩個命令，若是登出或重新開機失效，則要到 .bashrc 文件中加入。&lt;/p&gt;
&lt;pre&gt;
$export XMODIFIERS=@im=fcitx
$export QT_IM_MODULE=fcitx
&lt;/pre&gt;

&lt;p&gt;重新啟動 Qt 相關的程式，便能使用 Fcitx 切換其他輸入法了。&lt;/p&gt;</content><category term="PyQt5"></category><category term="Leo Editor"></category></entry><entry><title>Pelican - Windows Python Error</title><link href="http://project.mde.tw/blog/pelican-windows-python-error.html" rel="alternate"></link><published>2017-01-22T21:00:00+08:00</published><updated>2017-01-22T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-22:/blog/pelican-windows-python-error.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;解決 ValueError: embedded null byte 錯誤&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;ul&gt;
&lt;li&gt;解決 ValueError: embedded null byte 錯誤&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;解決 ValueError: embedded null byte 錯誤&lt;/h1&gt;
&lt;p&gt;一直以來，某些使用 Python 3.5（無論 Anaconda 與否）的 Windows 電腦會無法使用 Pelican 轉換網誌。&lt;/p&gt;
&lt;p&gt;於是加入 &lt;code&gt;--debug&lt;/code&gt; 指令檢查。&lt;/p&gt;
&lt;pre&gt;
    ...

    File "c:\users\...\pelican\utils.py", line 101, in strftime
        return super(SafeDatetime, self).strftime(fmt)
ValueError: embedded null byte
&lt;/pre&gt;

&lt;p&gt;重新搜尋了這個問題，找到了一篇新的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://xingjian.me/how-to-fix-value-error-embedded-null-byte-error.html"&gt;http://xingjian.me/how-to-fix-value-error-embedded-null-byte-error.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;於是到 cmd 的 Python 直譯器打入下列指令檢查：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import locale, time
locale.setlocale(locale.LC_ALL, 'ko')
time.strftime('%a')
&lt;/pre&gt;

&lt;p&gt;Python Rise 了相同的錯誤如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0122_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;解決方式就是重新設定 local 的設定。&lt;/p&gt;
&lt;p&gt;到 Anaconda 的資料夾中找到 pelican，編輯其 utils.py 檔案（如：&lt;code&gt;Anaconda3\Lib\site-packages\pelican&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;搜尋 &lt;code&gt;def strftime(date, date_format)&lt;/code&gt; 這個函式。&lt;/p&gt;
&lt;p&gt;在函式這片註解後加入 &lt;code&gt;locale.setlocale(locale.LC_ALL, 'en')&lt;/code&gt; 指令，如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def strftime(date, date_format):
    '''
    Replacement for built-in strftime

    ...

    This works by 'grabbing' possible format strings (those starting with %),
    formatting them with the date, (if necessary) decoding the output and
    replacing formatted output back.
    '''
    locale.setlocale(locale.LC_ALL, 'en')
&lt;/pre&gt;

&lt;p&gt;之後存檔關閉即可。&lt;/p&gt;
&lt;p&gt;接著就能使用 Pelican 的功能了。&lt;/p&gt;</content><category term="Pelican"></category><category term="Leo Editor"></category></entry><entry><title>40323230日誌 - 106/01/20</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060120.html" rel="alternate"></link><published>2017-01-20T21:00:00+08:00</published><updated>2017-01-20T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-20:/blog/40323230ri-zhi-1060120.html</id><summary type="html">&lt;p&gt;Pyslvs version 0.4 Relese&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Pyslvs version 0.4 Relese&lt;/p&gt;


&lt;h1&gt;Pyslvs version 0.4 Relese&lt;/h1&gt;
&lt;p&gt;最終在轉動軸的設定中加入修正選項，並優化 csv 的儲存格式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0120_01.png"&gt;&lt;/p&gt;
&lt;p&gt;v0.4 版的功能如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;包含完整編譯流程的 Makefile。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加入演算法，讓使用者可以依據路徑需求生成四連桿的結果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之後會開始完成技術文件和在 v0.5 版中補完之前的目標。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/19</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060119.html" rel="alternate"></link><published>2017-01-19T21:00:00+08:00</published><updated>2017-01-19T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-19:/blog/40323230ri-zhi-1060119.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平行軸 Bug&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平行軸 Bug&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;平行軸 Bug&lt;/h2&gt;
&lt;p&gt;Version 0.4 準備收工，最近陸陸續續修正了一些界面的合理性問題，並且測試了一下目前的範本運作情形。&lt;/p&gt;
&lt;p&gt;除了之前提到演算法可能出現結果錯誤之外，在葛式四連桿的範例中找到一直沒解決的問題。&lt;/p&gt;
&lt;p&gt;「平行四邊形」的連桿範例為機架、三根連桿長皆相等的模型，如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0119_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;在理想狀況下，兩個從動節點的路徑應為兩個半徑相等的正圓。&lt;/p&gt;
&lt;p&gt;不過 Solvespace 的 kernel 卻會造成下面的情況（單純用滑鼠繞行）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0119_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;花了一些時間，寫了一小串校正函式，但是會造成其他範例出現不應該出現的反轉。&lt;/p&gt;
&lt;p&gt;下圖是 Pyslvs 出現相同的狀況：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0119_03.jpg"&gt;&lt;/p&gt;
&lt;p&gt;預計在 Shaft 加入最後一個功能，「平行機件」的選項，可以讓對稱的範例順利執行。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/16</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060116.html" rel="alternate"></link><published>2017-01-16T21:00:00+08:00</published><updated>2017-01-16T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-16:/blog/40323230ri-zhi-1060116.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;拖放檔案開啟功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反轉 Y 軸初始位置功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;拖放檔案開啟功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反轉 Y 軸初始位置功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;拖放檔案開啟功能&lt;/h2&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://doc.qt.io/qt-5/dnd.html"&gt;http://doc.qt.io/qt-5/dnd.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以透過 Qt 的拉入事件「dragEnterEvent」和拖放事件「dropEvent」達成。&lt;/p&gt;
&lt;p&gt;這次只有讓外部資訊拖入，若要讓內部資訊脫出需要其他設置，不過這個功能或許會應用到其他部份，所以先作筆記。&lt;/p&gt;
&lt;p&gt;當 QWidget 設定允許拖放動作 &lt;code&gt;setAcceptDrops(true)&lt;/code&gt; 後，就能使用滑鼠攜帶資訊，滑鼠游標會變成拖放樣式而非禁止符號。&lt;/p&gt;
&lt;p&gt;透過拉入事件「dragEnterEvent」可以允許「哪些資訊」可以被拖入，如字串、圖片、網址和檔案位址。&lt;/p&gt;
&lt;p&gt;拖放事件「dropEvent」可以設定拖入後要執行的動作。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def dragEnterEvent(self, event):
    mimeData = event.mimeData()
    if mimeData.hasUrls():
        for url in mimeData.urls():
            FilePath = url.toLocalFile()
            if QFileInfo(FilePath).suffix()=="csv": event.acceptProposedAction()

def dropEvent(self, event):
    FilePath = event.mimeData().urls()[-1].toLocalFile()
    self.checkChange(FilePath, [], "Loaded drag-in file:\n"+FilePath)
    event.acceptProposedAction()
&lt;/pre&gt;

&lt;p&gt;上面的 dragEnterEvent 先判斷 QEvent 的攜帶資訊 mimeData 是否為副檔名「csv」的 URL，接著才會通過檢查（&lt;code&gt;acceptProposedAction()&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;後面的 dropEvent 則是取出想要的檔案位址並開啟，若是一次選取多個檔案則只開啟最後一個。&lt;/p&gt;
&lt;h2&gt;反轉 Y 軸初始位置功能&lt;/h2&gt;
&lt;p&gt;在選定的連桿上按下滑鼠右鍵可以根據固定軸反轉 Y 軸座標的初始位置，若是沒有固定軸，就反轉終點的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0116_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;以下是反轉之後重繪的路徑圖。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0116_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;透過這個功能能夠手動修正初始位置，不過若是能夠自動檢查並修正會比較好。&lt;/p&gt;
&lt;p&gt;過幾天應該能開始寫開發手冊。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/15</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060115.html" rel="alternate"></link><published>2017-01-15T21:00:00+08:00</published><updated>2017-01-15T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-15:/blog/40323230ri-zhi-1060115.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路徑演算法功能&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路徑演算法功能&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;路徑演算法功能&lt;/h2&gt;
&lt;p&gt;Pyslvs 生成曲柄搖桿的步驟：&lt;/p&gt;
&lt;iframe width="640" height="360" src="https://www.youtube.com/embed/wjdBAlF9u4Y" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;演算法算出的結果有兩種形式：&lt;/p&gt;
&lt;p&gt;一個呆鍊的方向朝上，主動軸（短軸）在左方，為學長論文中的模型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0115_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;另一個呆鍊的端點朝下，主動軸在右方，剛好跟上述的情況相反。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0115_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;雖在轉換式中做了些修正，但是有時仍然會發生 Solvespace kernel 解決失敗的情況。&lt;/p&gt;
&lt;p&gt;大約原因應該是初始位置帶來的困擾。由於是讀取 C++ 程式庫的問題，若是學 C 語言即時運算會造成 QPainter 畫布閃爍問題（不過還不知道 QGraphicsView 的效果），之後想在發布 Version 0.4 前做一個理想化初始位置的功能。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/14</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060114.html" rel="alternate"></link><published>2017-01-14T21:00:00+08:00</published><updated>2017-01-14T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-14:/blog/40323230ri-zhi-1060114.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程式 - 求解轉換函式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;界面 - 演算法結果說明文字&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;程式 - 求解轉換函式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;界面 - 演算法結果說明文字&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;程式 - 求解轉換函式&lt;/h2&gt;
&lt;p&gt;利用演算法得出的解需要經過 Solvespace kernel 的轉換才能得到點座標，不過之前的函式沒經過考慮，會重複許多流程，因此將函式合併，當提供相應值時會回傳需要的解。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
pathTrackProcess = not angle==None
staticProcess = not table_point==None
generateConversionProcess = not generateResult==None
...
if pathTrackProcess:
    try: return x, y
    except: return 0, 0
elif staticProcess:
    try: return resultList, sys.dof, script
    except: return list(), -1, str()
elif generateConversionProcess:
    try: return resultList
    except: return list()
&lt;/pre&gt;

&lt;p&gt;另外編出 Python Script 的部份縮減很多，只會提供表格的點座標和約束讓使用者利用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0114_01.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;界面 - 演算法結果說明文字&lt;/h2&gt;
&lt;p&gt;由於做出預覽會造成 QPaint 畫布需要處理很多項目，所以未來使用 QGraphicsView 畫布時再補回去。&lt;/p&gt;
&lt;p&gt;當 Path Solving 面板算出結果後會將資料存入待審清單中，滑鼠移上去時可以看到使用演算法、AD點座標、運算時間等等數據。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0114_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;剩下上述的轉換函式、點擊 Merge 鈕加入表單的功能。&lt;/p&gt;
&lt;p&gt;完成並驗證演算法流程後，即會發布 Version 0.4。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060105.html" rel="alternate"></link><published>2017-01-05T21:00:00+08:00</published><updated>2017-01-05T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-05:/blog/40323230ri-zhi-1060105.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;界面調整 - 面板&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;編譯 - Makefile&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;界面調整 - 面板&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;編譯 - Makefile&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;界面調整 - 面板&lt;/h2&gt;
&lt;p&gt;當初構想的清單原本也是置頂的視窗，但是後來發現在 Windows 中開啟會導致清單視窗 crash，所以將一些額外的面板合併到點座標的分頁去。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0105_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;不過這些面板插入分頁後排版不太人性化，之後還會再修正。&lt;/p&gt;
&lt;h2&gt;編譯 - Makefile&lt;/h2&gt;
&lt;p&gt;最後還是統一兩個版本都使用 Makefile 來編譯，方便 Windows 可攜的版本下指令，只要使用下列語句即可分辨平台：&lt;/p&gt;
&lt;pre&gt;
ifeq ($(OS),Windows_NT)
#執行 Windows 編譯
else
#執行 Linux 編譯
endif
&lt;/pre&gt;

&lt;p&gt;另外在 Readme 上也有做修正。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060104.html" rel="alternate"></link><published>2017-01-04T21:00:00+08:00</published><updated>2017-01-04T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-04:/blog/40323230ri-zhi-1060104.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度 - 演算法 - Windows 版編譯：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;演算法函式庫除錯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;編譯方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度 - 演算法 - Windows 版編譯：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;演算法函式庫除錯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;編譯方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度 - 演算法 - Windows 版編譯&lt;/h1&gt;
&lt;h2&gt;演算法函式庫除錯&lt;/h2&gt;
&lt;p&gt;之前嘗試過在 Widows 平台編譯學長的 Cython 函式庫，但是使用 MinGW 和 VS 都出錯，於是上網了解一下關鍵原因。&lt;/p&gt;
&lt;p&gt;在官方說明中提到，目前尚未支援 Windows 的 64 位元 GNU，而使用 MinGW32 的話，會造成 64 位元的 Python 無法輸入或讀取任何資訊（進位制不同）。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/cython/cython/wiki/CythonExtensionsOnWindows#less-useful-information"&gt;https://github.com/cython/cython/wiki/CythonExtensionsOnWindows#less-useful-information&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因此在 Windows 平台中只能使用微軟提供的 SDK 協助編譯了。&lt;/p&gt;
&lt;p&gt;使用 Visual Studio Community 客戶端安裝 Windows SDK 即可，若是 Python 認不得 2012 以上的版本，必須編輯 Anaconda 的 Lib\distutils\ 資料夾中的 &lt;code&gt;cygwinccompiler.py&lt;/code&gt;，在大約 85 行的位置插入以下程式碼：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
elif msc_ver == '1700':
    # Visual Studio 2012 / Visual C++ 11.0
    return ['msvcr110']
elif msc_ver == '1800':
    # Visual Studio 2013 / Visual C++ 12.0
    return ['msvcr120']
elif msc_ver == '1900':
    # Visual Studio 2015 / Visual C++ 14.0
    return ['vcruntime140']
&lt;/pre&gt;

&lt;p&gt;Cython 在編譯時才會找到 SDK 的工具。&lt;/p&gt;
&lt;p&gt;編譯後，執行 test.py 時出現了類似 &lt;code&gt;IndexError: index 250 is out of bounds for axis 0...&lt;/code&gt; 的訊息，顯示某個 List 超出可讀取範圍。&lt;/p&gt;
&lt;p&gt;在不斷測試與檢查之後發現是 Cython 從 C 語言 import 的 random 函數有問題。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from libc.stdlib cimport rand, RAND_MAX, srand

cdef double randV():
    return rand()*1.0 / RAND_MAX
&lt;/pre&gt;

&lt;p&gt;這個是產生亂數用的 function，在 Windows 下，回傳值某些時候會大於 1，這就導致長度 250 的 list 出現 &lt;code&gt;[250]&lt;/code&gt; 的選項。&lt;/p&gt;
&lt;p&gt;為了避免這個狀況發生，改寫上面的函式成下面的樣子：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
cdef double randV():
    randomNum = rand()*1.0 / RAND_MAX
    if randomNum&gt;=1: randomNum -= 0.1
    return randomNum
&lt;/pre&gt;

&lt;p&gt;這裡使用迭代運算而非重新指定值，速度會比較快一點。&lt;/p&gt;
&lt;p&gt;需要修改的檔案為 &lt;code&gt;rga.pyx&lt;/code&gt; 和 &lt;code&gt;de.pyx&lt;/code&gt;，其他函式庫都沒問題。&lt;/p&gt;
&lt;p&gt;但是因為 Windows 平台多加了判斷式，還有其他因素，運算時間慢上 1 倍（中間的螢火蟲演算法完全相同）。以下是相同題目的運算結果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0104_01.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0104_02.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;編譯方法&lt;/h2&gt;
&lt;p&gt;由於加入了 Cython 的程式庫，原本的編譯方式又沒辦法使用了，會出現「pythoncom」匯入的錯誤。&lt;/p&gt;
&lt;p&gt;用兩種方式重新編譯後，發現在 PyInstaller 的資料夾（dist）中執行它的主程式，會顯示找不到 py35w 的核心。&lt;/p&gt;
&lt;p&gt;於是就將 cxFreeze 的 core 資料夾複製到 PyInstaller 的資料夾中，再啟動主程式就可以使用了，也不會出現任何錯誤。&lt;/p&gt;
&lt;p&gt;此方法已經套用到 winBuild.bat 中。&lt;/p&gt;
&lt;p&gt;目前暫時將 PyInstaller 的 -w 參數拿掉，方便在 Windows 平台查看 console 資訊。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/02</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060102.html" rel="alternate"></link><published>2017-01-02T21:00:00+08:00</published><updated>2017-01-02T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-02:/blog/40323230ri-zhi-1060102.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度 - 演算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;介面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度 - 演算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;介面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度 - 演算法&lt;/h1&gt;
&lt;h2&gt;介面&lt;/h2&gt;
&lt;p&gt;稍微改寫介面：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0102_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;加入可以控制部份限制值的功能，並做好回傳結果的 dictionary 分類。&lt;/p&gt;
&lt;p&gt;考慮之後，最後還是拿回進度條，做成流動的樣式（最大最小值設為 0 即可）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0102_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;除了現在的視窗外，之後還會加入第二個較小的清單窗格供使用者挑選，切換清單選擇項目時即可預覽，點選「合併」按鈕即可合併至畫布。&lt;/p&gt;
&lt;h2&gt;程式&lt;/h2&gt;
&lt;p&gt;測試不同組座標放入，發現超過當初預設的數目時，kernel 會報錯。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
p = len(path)
upperVal = Limits[0]+[360.0]*p
lowerVal = Limits[1]+[0.0]*p
Parm_num = p+9
&lt;/pre&gt;

&lt;p&gt;這裡 p 代表座標的數量，upperVal 和 lowerVal 是限制值的組合（共 9 項）加上後面點座標的轉動可能性。&lt;/p&gt;
&lt;p&gt;Parm_num 會帶入三種演算法的 nParm、D 位置，必須等於 upperVal 和 lowerVal 的長度。&lt;/p&gt;
&lt;p&gt;比較好奇的是最後回傳的 fitnessParameter 長度會剛好等於 Parm_num，而且前 9 項是 Ax、Ay、Dx、Dy、L0、L1、L2、L3、L4 的答案，後面都是超過範圍的 float 數值，不知道代表含意。&lt;/p&gt;
&lt;p&gt;預覽的部份比較複雜，因為當前的 Solvespace 解題 function 是針對左邊的表單寫的，若是拿來運算 3 個未知點的圖形，必須改寫帶入參數。&lt;/p&gt;
&lt;p&gt;單機演算法解題的部份預計寒假初完成，釋出 Version 0.4.0，寒假進行中會加入平行運算，並同時完成其他項目。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 106/01/01</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1060101.html" rel="alternate"></link><published>2017-01-01T21:00:00+08:00</published><updated>2017-01-01T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2017-01-01:/blog/40323230ri-zhi-1060101.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度 - 演算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程式&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度 - 演算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程式&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度 - 演算法&lt;/h1&gt;
&lt;h2&gt;程式&lt;/h2&gt;
&lt;p&gt;將編譯好的 so 函式庫放到 kernel 資料夾的 pyslvs_generate 資料夾中，一樣是分開版本。&lt;/p&gt;
&lt;p&gt;跟 Path track 與普通解題函式一起放在 calculation.py 中。&lt;/p&gt;
&lt;p&gt;載入選擇：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if platform.system().lower()=="linux":
    if py_nm=="3.4":
        from ..kernel.pyslvs_generate.py34 import tinycadlib
        from ..kernel.pyslvs_generate.py34.planarlinkage import build_planar
        from ..kernel.pyslvs_generate.py34.rga import Genetic
        from ..kernel.pyslvs_generate.py34.firefly import Firefly
        from ..kernel.pyslvs_generate.py34.de import DiffertialEvolution
    if py_nm=="3.5":
        from ..kernel.pyslvs_generate.py35 import tinycadlib
        from ..kernel.pyslvs_generate.py35.planarlinkage import build_planar
        from ..kernel.pyslvs_generate.py35.rga import Genetic
        from ..kernel.pyslvs_generate.py35.firefly import Firefly
        from ..kernel.pyslvs_generate.py35.de import DiffertialEvolution
&lt;/pre&gt;

&lt;p&gt;這裡必須額外載入 tinycadlib 函式庫。&lt;/p&gt;
&lt;p&gt;在同層目錄下，planarlinkage 函式庫可以搜尋到 tinycadlib 函式庫，但是當用外部位置載入時，被包起來的 so 檔會找不到原本存在的名稱，所以額外載入 tinycadlib 供其使用。&lt;/p&gt;
&lt;p&gt;當使用 Path solving panel 後可以回傳數據，但是無法回傳進度，要有這個功能可能得改寫演算法。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0101_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;選擇演算方法的部份是切換式的，一次只能儲存一組解。如果空間允許，可能建一個清單儲存結果。&lt;/p&gt;
&lt;p&gt;至於 Windows 方面則完全封鎖功能，編譯時會跳過整個 Path solving 的相關函式。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/29</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051229.html" rel="alternate"></link><published>2016-12-29T21:00:00+08:00</published><updated>2016-12-29T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-29:/blog/40323230ri-zhi-1051229.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度 - 演算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;編譯&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度 - 演算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;編譯&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度 - 演算法&lt;/h1&gt;
&lt;h2&gt;編譯&lt;/h2&gt;
&lt;p&gt;倉儲：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/40323230/pyslvs_generate-1" title="github.com"&gt;https://github.com/40323230/pyslvs_generate-1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;將演算法的原始碼統整，並為其 Makefile 添加 clean 指令。&lt;/p&gt;
&lt;p&gt;接著就 test.py 範例檔研究了一下，將原本回傳的字串全部改成 float 型態的 list，並且調整了一些顯示方式。&lt;/p&gt;
&lt;p&gt;將結果轉換為浮點數：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
a = [k for k in map(lambda x: [float(i) for i in x.split(',')[1::]],[e for e in time_and_fitness.split(';')[0:-1]])]
b = [float(e) for e in fitnessParameter.split(',')]
print(a)
print(b)
&lt;/pre&gt;

&lt;p&gt;X 和 Y 座標的部份之後再做處理，可以確保的是能夠從整個字串中取回數值，回傳至 Pyslvs 時再做篩選。&lt;/p&gt;
&lt;p&gt;目前在 14.04 和 16.04 的 Python 3.4 和 3.5 測試都運作良好，Windows 還沒試過。&lt;/p&gt;
&lt;p&gt;Linux 編譯流程：&lt;/p&gt;
&lt;p&gt;進入 &lt;code&gt;Tinycad_package&lt;/code&gt; 目錄下。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$sudo&lt;/span&gt; pip3 install Cython
&lt;span class="nv"&gt;$make&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;在該目錄下會編譯出可用的動態連結庫，將其移出就能讓 Python 程式碼使用。&lt;/p&gt;
&lt;p&gt;接著就要讓 Pyslvs 使用演算法解題。&lt;/p&gt;
&lt;p&gt;目前測試解題速度平均 25 秒左右，舊電腦 35 秒左右。&lt;/p&gt;
&lt;p&gt;會試圖研究 Windows 版的編譯方式，最後會像 Python Solvespace 的 kernel 一樣偵測平台和 Python 版本作切換。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/26</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051226.html" rel="alternate"></link><published>2016-12-26T21:00:00+08:00</published><updated>2016-12-26T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-26:/blog/40323230ri-zhi-1051226.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基因演算法 - 反解機構流程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;復原重做功能計畫構思&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Solvespace 格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 圖示&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基因演算法 - 反解機構流程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;復原重做功能計畫構思&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Solvespace 格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 圖示&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;基因演算法 - 反解機構流程&lt;/h2&gt;
&lt;p&gt;做好第二個需要運算用的 panel，不過還沒套入基因演算法的 function 和 kernel，所以目前是存一個必經點的 list 給 QThread 在背景運算（或有其他可變項目），算完後預計用淺色的機構圖形展示結果，使用者可以決定是否需要合併到畫布上，亦或清除後重新計算一個結果。&lt;/p&gt;
&lt;p&gt;Path Solving 這個面板是置頂的，會紀錄一個需要經過點的 list，關閉視窗後還在，除非重新啟動主程式；會考慮是否將「設計中」項目一起存進檔案中。&lt;/p&gt;
&lt;p&gt;當面板開啟後，畫布的右鍵選單就能加入路徑點（不過還沒做出路徑點的顯示），或是自定座標。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1226_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;按下 Generate button 就會開始計算，回傳機構數據，並預覽在畫布上。&lt;/p&gt;
&lt;p&gt;合併的功能還需要想一下，畢竟 Solvespace 還需要初始座標，如果定的不好又會產生問題，所以必須稍微想一下。&lt;/p&gt;
&lt;h1&gt;Solvespace 格式&lt;/h1&gt;
&lt;p&gt;之前一直放置的原因就是因為 Qt 表格的字串沒有轉換格式，現在因為有分門別類的 list 儲存實體和約束，所以會比較好設計。&lt;/p&gt;
&lt;p&gt;最近有空會試試看重寫一下 Solvespace 的格式，讓 Pyslvs 可以完美支援輸出回 Solvespace 做參照。&lt;/p&gt;
&lt;h1&gt;復原重做功能計畫構思&lt;/h1&gt;
&lt;p&gt;使用 Qt 的 undo 功能的話就得做多種「命令」格式，如果加入「命令」的時機太過底層，就會被非預期的命令呼叫到，例如讀檔和手動加入點座標是使用同一個 function。&lt;/p&gt;
&lt;p&gt;所以盡量使用比較簡潔的命令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表格處理方面：增、刪、編輯、上下移、修改 point style。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面板方面：路徑追蹤功能、驅動軸改的 demo angle、未來的 Path Solving。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外有機會的話考慮做視窗的 undo list。&lt;/p&gt;
&lt;h1&gt;Pyslvs 圖示&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1226_02.png"&gt;&lt;/p&gt;
&lt;p&gt;稍微設計了 Pyslvs 的圖示，對應 Python 的顏色風格。&lt;/p&gt;
&lt;p&gt;Windows 方面有 256 x 256 大小的 ico 檔案可以使用。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/22</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051222.html" rel="alternate"></link><published>2016-12-22T21:00:00+08:00</published><updated>2016-12-22T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-22:/blog/40323230ri-zhi-1051222.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;移除需求提示視窗&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;雙平台編譯流程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;移除需求提示視窗&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;雙平台編譯流程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;移除需求提示視窗&lt;/h2&gt;
&lt;p&gt;將大量當前不可用的命令 Disable，取代之前跳出的「不符合要求」提示視窗。&lt;/p&gt;
&lt;p&gt;例如建立一個三角呆鍊需要 3 個連接點，如果點的表單沒有 3 個以上的點，會以紅字顯示需要的項目。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1222_01.png"&gt;&lt;/p&gt;
&lt;p&gt;而編輯、刪除、上下移、轉換等等功能，雖然沒有說明，但是也必須符合條件時才會顯示或啟用。&lt;/p&gt;
&lt;p&gt;至於路徑規劃、驅動軸等等面板，也都有相應的需求才能使用按鈕。&lt;/p&gt;
&lt;p&gt;這個顯示的偵測是每次修改表格時，比以往按下產生一個新的對話視窗省資源。&lt;/p&gt;
&lt;h2&gt;雙平台編譯流程&lt;/h2&gt;
&lt;p&gt;Version 0.4 在 Github 的 Readme 中，寫上了 Linux 和 Windows 平台編譯出 Pyslvs 可執行檔的說明。&lt;/p&gt;
&lt;p&gt;Linux 可以用 PyInstaller 或 cxFreeze 的 CLI（cxFreeze 不支援 Windows）直接編譯（擇一即可）。&lt;/p&gt;
&lt;p&gt;而 Windows 方面寫了一個批次檔（名為 &lt;code&gt;winBuild.bat&lt;/code&gt;），可以編好兩個工具生成的檔案後合併，並已經指定好程式的圖示檔；有安裝必須工具的情況下能直接點兩下執行，在可攜環境必須用 command line 執行。&lt;/p&gt;
&lt;p&gt;不過 Windows 版執行檔無法觀看文字回應（不會有 print），不過可以用參數命令正常開啟檔案、使用 Fusion 介面。&lt;/p&gt;
&lt;p&gt;有試過工具安裝本機的情況下編譯 Windows 版本，但是仍不能只用單一工具，可能是 PyInstaller 和 cxFreeze 互有優缺吧。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/21</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051221.html" rel="alternate"></link><published>2016-12-21T21:00:00+08:00</published><updated>2016-12-21T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-21:/blog/40323230ri-zhi-1051221.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs v0.4 預計目標&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 緊急修正&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs v0.4 預計目標&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 緊急修正&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs v0.4 預計目標&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;於分支 dev0.4 中開發&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;釋出 version 0.3 後，整個軟體大致的雛型已經出現了，不過在範例和轉檔部分仍然需要改進。&lt;/p&gt;
&lt;p&gt;而另外需要進行的重大改進，包含以下目標：&lt;/p&gt;
&lt;h2&gt;可互動物件的畫布&lt;/h2&gt;
&lt;p&gt;這部分可能需要為「需要顯示」的項目歸類，包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;點（特殊標示：固定軸／滑塊）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;連桿（特殊標示：驅動軸／滑塊軌道）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;呆鍊&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路徑點（特殊標示：作用中路徑）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這些物件可能要分別做不同的類型，並且要擁有現在 QPainter 的特性（例如更換顏色），需要協同的需求性滿高的。&lt;/p&gt;
&lt;h2&gt;復原重做功能&lt;/h2&gt;
&lt;p&gt;這個部分正在著手製作，在部屬上較麻煩而已。&lt;/p&gt;
&lt;p&gt;分為下列幾個功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表格新增復原（所有表格）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表格刪除復原（所有表格）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表格調整次序復原（驅動軸）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;物件外觀復原（必須配合新的畫布做調整）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Undo 與 Redo 功能是每個有存檔需求的軟體都必須要的項目，未來可能其他 project 可能也會應用到，所以會優先完成，並會把 Qt 的概念和使用方式做一篇整理。&lt;/p&gt;
&lt;h2&gt;基因演算法 - 反解機構&lt;/h2&gt;
&lt;p&gt;Github 倉儲：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/kmollee/django-project-template" title="github.com"&gt;https://github.com/kmollee/django-project-template&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這個部分使用之前學長的基因演算法，和 Solvespace 的 Kernel 一樣掛在軟體中。&lt;/p&gt;
&lt;p&gt;不過目前遇到的問題點是這個 Kernel 是在 Linux 開發的，要給 Windows 平台使用的話就要重新編譯。&lt;/p&gt;
&lt;p&gt;另外演算法的部分還要審查一下，以確定四連桿呆鍊的方向。&lt;/p&gt;
&lt;h1&gt;Pyslvs 緊急修正&lt;/h1&gt;
&lt;p&gt;由於之前將模組放在 &lt;code&gt;__init__.py&lt;/code&gt; 檔的行為在 PyInstaller 和 cxFreeze 會被識別為掛在資料夾下，因此將模組修正到新的 &lt;code&gt;modules.py&lt;/code&gt; 檔下避免誤判。&lt;/p&gt;
&lt;p&gt;更新在分支 master 中。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>Python Copy Module</title><link href="http://project.mde.tw/blog/python-copy-module.html" rel="alternate"></link><published>2016-12-19T21:00:00+08:00</published><updated>2016-12-19T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-19:/blog/python-copy-module.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Python 的記憶體管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Copy Module&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Python 的記憶體管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Copy Module&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Python 的記憶體管理&lt;/h1&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://billy3321.blogspot.tw/2009/01/python.html" title="billy3321.blogspot.tw"&gt;http://billy3321.blogspot.tw/2009/01/python.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.python-course.eu/deep_copy.php" title="www.python-course.eu"&gt;http://www.python-course.eu/deep_copy.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相對於 C 語言而論，Python 的層級較為高階，為了展現可讀性以及易於管理，有自動調整的功能。&lt;/p&gt;
&lt;p&gt;按常理而言，所有的記憶體位址是不能任意更動儲存值類型的。對 Python 而言，不同類型的值進行運算時都會進行轉換，重新分配後才會寫入新的位址中，也造成執行效率沒有 C 語言來的迅速。&lt;/p&gt;
&lt;p&gt;Python 另一個特色是 list 類型，可以存入任何類型的值，並且能自由修改與增刪。&lt;/p&gt;
&lt;p&gt;這是因為 Python 大部分的情況下都是以「記憶體位址」來存取（可以使用 &lt;code&gt;id()&lt;/code&gt; 函式查詢），相當於 C 語言的指標，共用指標的物件就是同一個物件，其中一項值改變時，就會一起更改。&lt;/p&gt;
&lt;p&gt;如以下範例：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def changeLastOne(list1):
    list1[-1] = "c"
    list1.append("d")

b = [1, 2, 3]
changeLastOne(b)
print(b) #[1, 2, "c", "d"]
&lt;/pre&gt;

&lt;p&gt;上述 changeLastOne 的 function 中，「list1」存取了「b」的記憶體位址（相當於下了 &lt;code&gt;list1 = b&lt;/code&gt; 的指令），改變「list1」的值時，「b」的值也會改變。&lt;/p&gt;
&lt;p&gt;這種基本的參照位址不僅限於兩個變數，可以同時參照給很多對象。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
a = 0
b = 0
print(a is b) #True

a = 0
b = 0
a += 1
print(a is b) #False a = 1, b = 0
c = 1
print(a is c) #True
&lt;/pre&gt;

&lt;p&gt;在這個例子中，Python 會將還未拿來處理的記憶體共用位址，節省空間，改變時才會複製出來修改，存入其他位址。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
a = [0, 1, 2, 3, 4]
b = a[:] #使用了分割器，但是不分割
b[1] = 'x'
print(b) #[0, 'x', 2, 3, 4]
print(a) #[0, 1, 2, 3, 4]
&lt;/pre&gt;

&lt;p&gt;上述的例子拿 list a 做了分割動作給 b，不過取出了完整值，導致 Python 認為這是個「處理」動作，於是將新的記憶體位址分配給它。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
a = [0, 1, 2, 3, [0, 1, 2]]
b = a[:] #使用了分割器，但是不分割
b[1] = 'x'
b[4][2] = 'x'
print(b) #[0, 'x', 2, 3, [0, 1, 'x']]
print(a) #[0, 1, 2, 3, [0, 1, 'x']]
&lt;/pre&gt;

&lt;p&gt;然而對於父類型儲存的記憶體位址，Python 也會一併複製，導致兩個父類型，雖然數據不同，卻會共用同一個子類型。&lt;/p&gt;
&lt;h1&gt;Copy Module&lt;/h1&gt;
&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.5/library/copy.html" title="docs.python.org"&gt;https://docs.python.org/3.5/library/copy.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不過這樣就會產生複製資料的問題，如果使用 &lt;code&gt;a = b&lt;/code&gt;，一律都是複製位址，無法做出一個一模一樣的資料分開修改，因此就必須匯入 Python 內建的 copy 模組。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
import copy

a = [0, 1, 2, 3, [0, 1, 2]]
shallowCopy = copy.copy(a)
deepCopy = copy.deepcopy(a)
&lt;/pre&gt;

&lt;p&gt;Copy 模組中包含兩種複製方式，名為「淺層複製」和「深層複製」，可以重新命令 Python 的參照方式。&lt;/p&gt;
&lt;h2&gt;淺層複製&lt;/h2&gt;
&lt;pre class="brush: python"&gt;
shallowCopy[1] = 'x'
shallowCopy[4][2] = 'x'
print(shallowCopy) #[0, 'x', 2, 3, [0, 1, 'x']]
print(a) #[0, 1, 2, 3, [0, 1, 'x']]
&lt;/pre&gt;

&lt;p&gt;相當於一般 Python 的複製方式（如同上述的分割器），底層的物件仍然是共用記憶體位址的。&lt;/p&gt;
&lt;h2&gt;深層複製&lt;/h2&gt;
&lt;pre class="brush: python"&gt;
deepCopy[1] = 'x'
deepCopy[4][2] = 'x'
print(deepCopy) #[0, 'x', 2, 3, [0, 1, 'x']]
print(a) #[0, 1, 2, 3, [0, 1, 2]]
&lt;/pre&gt;

&lt;p&gt;完全的複製資料，會透過紀錄位址盡可能的將目標值搜尋回來，建立在新的記憶區中，複製出來的項目已經和原本的資料完全不一樣了。&lt;/p&gt;
&lt;h2&gt;自訂 class 的比較&lt;/h2&gt;
&lt;pre class="brush: python"&gt;
from copy import copy, deepcopy

class foo():
    def __init__(self, mylist):
        self.list = mylist

listA = [0, 1, 2, 3]
originData = foo(listA)
shallowCopy = copy(originData)
deepCopy = deepcopy(originData)

listA.append("g") #listA = [0, 1, 2, 3, "g"]

print(shallowCopy.list) #[0, 1, 2, 3, "g"]
print(deepCopy.list) #[0, 1, 2, 3]
&lt;/pre&gt;

&lt;p&gt;不過進行「深層複製」會較「淺層複製」耗時間，如果想要取的值沒有子項目的話，使用「淺層複製」就不用去尋找是否有記憶體位址。&lt;/p&gt;
&lt;p&gt;這部份紀錄是為了接下來做 Undo 與 Redo 功能，Qt 的 QUndoCommand 必須存入物件關聯，以及複製出當前的值做參考，所以必須瞭解 Python 的記憶區管理方式。&lt;/p&gt;</content><category term="Python3"></category></entry><entry><title>40323230日誌 - 105/12/14</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051214.html" rel="alternate"></link><published>2016-12-14T21:00:00+08:00</published><updated>2016-12-14T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-14:/blog/40323230ri-zhi-1051214.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路徑追蹤 - 驅動軸&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大二專題網站&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路徑追蹤 - 驅動軸&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大二專題網站&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;路徑追蹤 - 驅動軸&lt;/h2&gt;
&lt;p&gt;路徑追蹤功能已經可以將所有驅動軸旋轉的座標路徑一齊算出。&lt;/p&gt;
&lt;p&gt;之後會再修正畫面的呈現，因為還沒有類似遮罩的功能，無法分辨對應的驅動軸。&lt;/p&gt;
&lt;p&gt;預計將 Shaft0 的路徑彩色顯示（對應機構點的顏色），其他驅動的路徑以灰色顯示；而且外觀會隨著上移和下移驅動軸表格而變。&lt;/p&gt;
&lt;p&gt;至於 QGraphicsView 畫布的測試仍須一段時間，找不太到可互動的畫布範例，PyQt 的範例也更少；而 Python CAD 的物件類型分滿細的，在繼承方面比較難找些。&lt;/p&gt;
&lt;h1&gt;大二專題網站&lt;/h1&gt;
&lt;p&gt;今天讓學弟建了倉儲來存放未來網誌的文章，並稍微講解 Python 程式常用規則，想請教老師下學期專題網站的建立。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051213.html" rel="alternate"></link><published>2016-12-13T21:00:00+08:00</published><updated>2016-12-13T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-13:/blog/40323230ri-zhi-1051213.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;捷徑功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;驅動軸相關&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kernel 其他修正&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;捷徑功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;驅動軸相關&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kernel 其他修正&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;捷徑功能&lt;/h2&gt;
&lt;p&gt;現在所有表格在項目上雙擊滑鼠左鍵，可以編輯該項目內容。&lt;/p&gt;
&lt;p&gt;而在衝突導致解題失敗時，DOF 的欄位會顯示 "Failed" 字樣，標籤也會改成粗體紅字。&lt;/p&gt;
&lt;p&gt;之後會再審視不方便的操作方式以改進。&lt;/p&gt;
&lt;h2&gt;驅動軸相關&lt;/h2&gt;
&lt;p&gt;改善關於驅動軸相關的功能，並且改成只能驅動 DOF 為 1 的機構。&lt;/p&gt;
&lt;p&gt;目前畫面上顯示的解為 Shaft0 的 Demo Angle 的解，而要切換驅動軸，可以右鍵選單中的上移與下移功能，移到 Shaft0 位置的就會套用 Demo Angle 的約束；目前只剩驅動軸和參數表格有上移與下移的選項。&lt;/p&gt;
&lt;p&gt;另外驅動軸面板的切換選單可以暫時套用選定軸的 Demo Angle 約束，關閉面板後會切回 Shaft0 的約束。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1213_01.png"&gt;&lt;/p&gt;
&lt;p&gt;在 Path Track 功能中，用了一組選擇驅動軸的介面，不過還沒連接 function，在預設的選項中只有 Shaft0，調成 All 後將會解出所有驅動軸帶動的路徑。&lt;/p&gt;
&lt;p&gt;設計好驅動軸的功能後，大致上就能解所有 DOF 為 1 的純連桿機構路徑了；而驅動滑塊的功能還待加入。&lt;/p&gt;
&lt;h2&gt;Kernel 其他修正&lt;/h2&gt;
&lt;p&gt;Grashof chain 範例已經全數加入，不過因為 Kernel 問題，某些範例的路徑追蹤點必須重新繪製。&lt;/p&gt;
&lt;p&gt;與驅動軸旋轉點相依的其他點，初始值也必須做修正，不然在轉到 180 度之後，會造成其他點因為旋轉點初始位置修正，造成機構反折的狀況。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/12</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051212.html" rel="alternate"></link><published>2016-12-12T21:00:00+08:00</published><updated>2016-12-12T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-12:/blog/40323230ri-zhi-1051212.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;諸多錯誤修正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;葛氏運動鍊：Kernel 校正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;復原重做功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;諸多錯誤修正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;葛氏運動鍊：Kernel 校正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;復原重做功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;諸多錯誤修正&lt;/h2&gt;
&lt;p&gt;之前留下一些大大小小的 Bug，會造成程式在讀取檔案或是新增資料時因錯誤而關閉。&lt;/p&gt;
&lt;p&gt;花了一些時間測試功能，確定已完成的功能運作流暢。&lt;/p&gt;
&lt;p&gt;另外還修整了一下界面，避免在 Windows 和 Ubuntu 切換之間發生 Layout 空間延展的問題。&lt;/p&gt;
&lt;h2&gt;葛氏運動鍊：Kernel 校正&lt;/h2&gt;
&lt;p&gt;Example 項目中多出了一個 "Grashof chain" 類別，預計加入所有葛氏運動鍊的四連桿範例。&lt;/p&gt;
&lt;p&gt;也因為當時寫的校正座標指令是以原點為中心點，造成其他象限的中心軸轉動時，旋轉點出現怪異的運算結果。&lt;/p&gt;
&lt;p&gt;校正繞行圓心時造成中心與旋轉點的位置差，目前座標位置如果比中心還高，基本運行就會流暢，不過如果初始低於圓心，還要加上其他判斷才能修正。&lt;/p&gt;
&lt;p&gt;提前測試一下學長論文中的近似直線範例：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1212_01.png"&gt;&lt;/p&gt;
&lt;h2&gt;復原重做功能&lt;/h2&gt;
&lt;p&gt;這個部份快要整備好了，但是不知道運作效能如何，也還沒部屬必須紀錄的步驟。&lt;/p&gt;
&lt;p&gt;仿照 Qt 的方式寫了一個相似的類型（因為 Qt 必須部屬在所有指令上，而且還要另外寫反向命令），並在需要時存入重要資訊，一定的步驟內可還原上次的表格內容。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/09</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051209.html" rel="alternate"></link><published>2016-12-09T21:00:00+08:00</published><updated>2016-12-09T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-09:/blog/40323230ri-zhi-1051209.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;背景資料名稱&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改畫布&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;背景資料名稱&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改畫布&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;背景資料名稱&lt;/h2&gt;
&lt;p&gt;之前為了不讓格式混亂，使用一個函式來轉換所有表格的字串成為數據，但是因為只單純用到清單的功能，分不出來項次代表的內容。&lt;/p&gt;
&lt;p&gt;後來成功改成鍵值的方式存取，在辨識上會更容易。&lt;/p&gt;
&lt;p&gt;這部份希望改成修改時同步清單，而非使用時才轉換。&lt;/p&gt;
&lt;h2&gt;修改畫布&lt;/h2&gt;
&lt;p&gt;由於當前的畫布互動功能只侷限於觀看的部份，在編修上還是得頻繁地去側邊的表格調整，所以必須針對這個部份改強。&lt;/p&gt;
&lt;p&gt;參考 Python CAD（GPL 2.0）的方式，使用 QGraphicsView 和 QGraphicsScene 來建立畫布，以方便管理。&lt;/p&gt;
&lt;p&gt;另外 QGraphicsView 和 QGraphicsScene 的顯示功能也比單純的 QPainter 強大，節省了不少功能。&lt;/p&gt;
&lt;p&gt;不過這種方式修改的部份滿多的，也要重新建立迴圈來畫圖，所以可能會用上一段時間，先從範例的部份開始練習。&lt;/p&gt;
&lt;p&gt;如果瞭解 QGraphicsView 和 QGraphicsScene 的流程後，也會把教學寫在網誌上。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/08</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051208.html" rel="alternate"></link><published>2016-12-08T21:00:00+08:00</published><updated>2016-12-08T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-08:/blog/40323230ri-zhi-1051208.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Bug 修正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;檔案格式檢查&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;__init__.py&lt;/code&gt; 利用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反解連桿尺寸 &amp;amp; 多個驅動軸&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;技術手冊&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Bug 修正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;檔案格式檢查&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;__init__.py&lt;/code&gt; 利用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反解連桿尺寸 &amp;amp; 多個驅動軸&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;技術手冊&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;Bug 修正&lt;/h2&gt;
&lt;p&gt;檢查了一下之前的 code，將兩個地方修正。&lt;/p&gt;
&lt;p&gt;一個是開新檔案的 function 填錯 table 位置所以刪錯項目；另一個是一段時間前將 function 歸類時，造成填寫路徑清單的視窗 function 名稱寫錯。&lt;/p&gt;
&lt;p&gt;另外將清單處理的 &lt;code&gt;list_process.py&lt;/code&gt; 更名為 &lt;code&gt;listProcess.py&lt;/code&gt;，並從 calculation 資料夾轉到 io 底下。這裡的函式經過歸類後，比較像讀寫功能；而非計算功能。&lt;/p&gt;
&lt;h2&gt;檔案格式檢查&lt;/h2&gt;
&lt;p&gt;做了一個小型的檔案格式檢查函式，讀取 csv 的三個標籤（&lt;code&gt;_info_&lt;/code&gt;、&lt;code&gt;_table_&lt;/code&gt;、&lt;code&gt;_path_&lt;/code&gt;）數量來檢查。&lt;/p&gt;
&lt;p&gt;不過就算如此，其中寫入錯誤訊息，還是會導致程式錯誤而關閉，應該改寫成跳出回報錯誤的視窗拒讀，避免造成如 Solvespace 閃退的困擾。&lt;/p&gt;
&lt;p&gt;而之後可能會移除非必要的項目減少 csv 檔案體積和利於程式檢查。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;__init__.py&lt;/code&gt; 利用&lt;/h2&gt;
&lt;p&gt;為了讓 &lt;code&gt;main.py&lt;/code&gt; 起始的標頭不要都是 import 的項目，將所有的 import 項目放到 core 資料夾的 &lt;code&gt;__init__.py&lt;/code&gt; 中（跟 &lt;code&gt;main.py&lt;/code&gt; 同層級）。&lt;/p&gt;
&lt;p&gt;這樣 &lt;code&gt;main.py&lt;/code&gt; 可以向 &lt;code&gt;__init__.py&lt;/code&gt; 借入資料，節省主程式的空間。&lt;/p&gt;
&lt;h2&gt;反解連桿尺寸 &amp;amp; 多個驅動軸&lt;/h2&gt;
&lt;p&gt;預計加入過去學長使用的演算法，使用者指定路徑後，以四連桿的方式反推，「設計」出近似使用者指定路徑的四連桿。&lt;/p&gt;
&lt;p&gt;這個演算法可能會變成類似解路徑的彈出功能，會在介面上規劃空間給它使用，並將解出的第一組解填入表單讓 Solvespace kernel 運算顯示，使用者亦能在產生滿意解之後，另行編修。&lt;/p&gt;
&lt;p&gt;原本的路徑功能也是想支援多個驅動軸的功能，由於當時不太了解 Python 的功能，並沒有做出。不過當初資料格式是有支援寫入多個驅動軸運行的結果，應該較容易相容。&lt;/p&gt;
&lt;h2&gt;技術手冊&lt;/h2&gt;
&lt;p&gt;由於後輩的加入，開發人員的技術手冊應該要在下學期開始前盡快完成，期末前會再審查一次原始碼，歸類好後 Relese v0.4.0 或更新版本以給技術手冊介紹使用。&lt;/p&gt;
&lt;p&gt;之後範例檔案都會存在 core/io/example.py，用 function 回傳 data 值讓程式讀取，若有改版也會附上檔案格式修改的提醒。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/07</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051207.html" rel="alternate"></link><published>2016-12-07T21:00:00+08:00</published><updated>2016-12-07T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-07:/blog/40323230ri-zhi-1051207.html</id><summary type="html">&lt;p&gt;PyInstaller 編譯問題&lt;/p&gt;
</summary><content type="html">&lt;p&gt;PyInstaller 編譯問題&lt;/p&gt;


&lt;h1&gt;PyInstaller 編譯問題&lt;/h1&gt;
&lt;p&gt;將目前原始碼轉為執行檔的測試。由於之前只有成功編譯小型的 PyQt5 介面，所以嘗試看看在比較大的架構下，所有分支模組中是否會有導入問題。&lt;/p&gt;
&lt;h2&gt;Pyslvs 程式碼整理&lt;/h2&gt;
&lt;p&gt;將程式碼整理了一下，避免發生一些狀況。&lt;/p&gt;
&lt;p&gt;移除了讀取 git 資訊的功能，因為這個資訊會讀取 &lt;code&gt;.git&lt;/code&gt; 資料夾內的內容。&lt;/p&gt;
&lt;p&gt;後來將 PyQt4 的導入去除，實際上也沒有用到 PyQt4 的框架。&lt;/p&gt;
&lt;h2&gt;Solvespace 函式庫問題&lt;/h2&gt;
&lt;p&gt;出現了一個重大的問題，在編譯後會找不到函式庫的名稱。&lt;/p&gt;
&lt;pre&gt;
ImportError: No module named 'core.kernel.py35w._slvs'
...
ImportError: DLL load failed: The specified module could not be found.
&lt;/pre&gt;

&lt;p&gt;參閱 PyInstaller 的技術文件後，瞭解到如果使用的 DLL 類函式庫名稱不在程式碼中的話，必須手動加入 Spec 文件中。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://pyinstaller.readthedocs.io/en/stable/spec-files.html#adding-binary-files" title="pyinstaller.readthedocs.io"&gt;https://pyinstaller.readthedocs.io/en/stable/spec-files.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Spec 文件是 PyInstaller 的執行腳本，若沒有指定的話會自己生產一個預設設定的 Spec 文件。&lt;/p&gt;
&lt;p&gt;Spec 文件的 Analysis 中包含四個項目：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;scripts&lt;/code&gt;：當作主程式啟動的腳本（就是指令中 input 的檔案，只有一個）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;pure&lt;/code&gt;：所需的 Python 模組（通常會直接參照 import 的項目搜尋到，所以不用填）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;binaries&lt;/code&gt;：所需的非 Python 模組。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;datas&lt;/code&gt;：其他所需的非二進制文件（如圖片或是音訊檔）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不過在 &lt;code&gt;binaries&lt;/code&gt; 清單中的示範是填入函式庫中的連結名稱，不知道如果是 DLL 或 SO 的話要如何辨識名稱；直接寫上 &lt;code&gt;_slvs.pyd&lt;/code&gt; 或是 &lt;code&gt;libslvs.so&lt;/code&gt; 的位址也不能解決問題。&lt;/p&gt;
&lt;h2&gt;Ubuntu 編譯成功&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1207_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;在一台 16.04 的實體機中，使用 PyInstaller 直接用預設設定編譯，能成功編譯出 Pyslvs 的 Linux 版可執行檔。&lt;/p&gt;
&lt;p&gt;Linux 平台的 SO 函式庫似乎不用特別指定也能找到 &lt;code&gt;_slvs.so&lt;/code&gt; 和 &lt;code&gt;libslvs.so&lt;/code&gt; 的內容；Windows 的 DLL 就得看當初連結庫的名稱是什麼了。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/12/06</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051206.html" rel="alternate"></link><published>2016-12-06T21:00:00+08:00</published><updated>2016-12-06T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-12-06:/blog/40323230ri-zhi-1051206.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Windows 環境&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Windows 環境&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Windows 版進度&lt;/h1&gt;
&lt;p&gt;因為其他作業需求必須編譯 Windows 版的 Python 執行檔，所以順便弄了一下編譯環境。&lt;/p&gt;
&lt;p&gt;在 Windows 架好了撰寫 Pyslvs 所必須的工具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Anaconda Python 3.5.4（執行檔安裝）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Qt 5.7（官方執行檔安裝）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pip 套件（下載&lt;code&gt;get-pip.py&lt;/code&gt;執行）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新 SIP（conda install 更新）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyQt 5.7（pip 安裝）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QScintilla（pip 安裝）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Eric6（Python 執行 &lt;code&gt;install.py&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyInstaller（pip 安裝）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;現在的 PyInstaller 已經不能跨平台編譯了，只能在相應的平台編出可執行檔，而且有 32 和 64 位元的差異。&lt;/p&gt;
&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;p&gt;將範例檔直接放入程式中而不會不小心覆蓋到原始檔。&lt;/p&gt;
&lt;p&gt;另外還將存檔功能歸類了一下，避免搞亂原本的範例。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1206_01.jpg"&gt;&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/11/27</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051127.html" rel="alternate"></link><published>2016-11-27T21:00:00+08:00</published><updated>2016-11-27T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-11-27:/blog/40323230ri-zhi-1051127.html</id><summary type="html">&lt;p&gt;關於 Pyslvs 格式整合的計畫&lt;/p&gt;
</summary><content type="html">&lt;p&gt;關於 Pyslvs 格式整合的計畫&lt;/p&gt;


&lt;h1&gt;2D 格式&lt;/h1&gt;
&lt;p&gt;目前只能畫出支架的圖形，所以要盡快弄出完整樣式。&lt;/p&gt;
&lt;p&gt;使用 dxfwrite（授權類型：MIT）畫出基本連桿（或滑塊）的圖形，也許可以給幾種款式選擇。&lt;/p&gt;
&lt;p&gt;匯出後（到其他 CAD 軟體上），不同件使用不同圖塊，方便使用者分開更改或直接長出建模。&lt;/p&gt;
&lt;p&gt;這方面參照一下 dxfwrite 寫入的方式，放到 Free CAD 或 Autodesk 產品中能夠編修就沒問題了。&lt;/p&gt;
&lt;h1&gt;3D 格式&lt;/h1&gt;
&lt;p&gt;使用 &lt;a href="https://github.com/apparentlymart/python-stl" title="github.com"&gt;python-stl&lt;/a&gt;（授權類型：MIT）畫出立體的模型，符合結構強度的外觀。&lt;/p&gt;
&lt;p&gt;這部份可以盡量少讓使用者修改，或變成組合圖的形式（需要調整重疊順序）。&lt;/p&gt;
&lt;p&gt;轉成 3D 的功能主要是讓 V-rep 可以馬上導入做模擬，可以做一個「生成關節轉軸」的選項。&lt;/p&gt;
&lt;p&gt;不過對寫入 STL 文件沒什麼經驗，可能要稍微比對其他 3D 模型。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/11/20</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051120.html" rel="alternate"></link><published>2016-11-20T21:00:00+08:00</published><updated>2016-11-20T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-11-20:/blog/40323230ri-zhi-1051120.html</id><summary type="html">&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;佈署單元測試函式（unittest）&lt;/h2&gt;
&lt;p&gt;建構了需要測試的項目，會提取主程式的函式測試回傳值。&lt;/p&gt;
&lt;p&gt;也因為測試需求，把主程式 &lt;code&gt;main.py&lt;/code&gt; 單獨留在 core 資料夾中，其他程式都歸類進資料夾中，方便之後測試函式呼叫。&lt;/p&gt;
&lt;p&gt;不過目前的項目只有 Kernel 解題，之後會增加測試單元。&lt;/p&gt;
&lt;p&gt;執行頂層目錄的 &lt;code&gt;launch_test.py&lt;/code&gt; 來啟動單元測試。&lt;/p&gt;
&lt;h2&gt;清單處理格式轉移&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;處理表格及算點的程式都放到 calculation 資料夾中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原本都是讀取 Qt 的 Table Widget 來取得點座標，但是這樣處理太過混亂（因為回傳值是字串而非數字），也會降低執行效率，所以打算更改。&lt;/p&gt;
&lt;p&gt;原先處理表格的 &lt;code&gt;list_process.py&lt;/code&gt; 劃分出不同表格的 class，它們的函式也重新命名過，更能知道用途。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Points (style)
Lines
Chains
Shafts
Sliders
Rods
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;下一步是在 &lt;strong&gt;init&lt;/strong&gt; 初始化函式中建立空的 list（每筆資料型態都是鍵值），和 Qt 的 Table Widget 同時紀錄資料（格式對應），取資料時不再於 Table Widget 抓資料，而是呼叫所屬 class 的 list，不用轉換格式。&lt;/p&gt;
&lt;p&gt;至於還有一些名稱太冗長的程式碼，可能會用 class 歸類，更容易瞭解用途。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/11/19</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051119.html" rel="alternate"></link><published>2016-11-19T21:00:00+08:00</published><updated>2016-11-19T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-11-19:/blog/40323230ri-zhi-1051119.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;Pyslvs 編譯進度&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;Pyslvs 編譯進度&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;視角拖曳&lt;/h2&gt;
&lt;p&gt;做出與 AutoCAD 相似的檢視方式，單靠按住滑鼠滾輪即可自由移動圖形而不會一直鎖定在畫面上。&lt;/p&gt;
&lt;p&gt;過去按住 Ctrl 鍵的功能仍會保留。由於必須按住鍵盤，不至於會與主要檢視方式衝突。&lt;/p&gt;
&lt;h2&gt;技術手冊&lt;/h2&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;User Manual
Developer Manual
Application Examples
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;技術手冊採用 Markdown 的方式寫成。&lt;/p&gt;
&lt;p&gt;在系統裝上 Pandoc 與 TeX Live 可以轉成其他純文字格式或 PDF。&lt;/p&gt;
&lt;p&gt;接下來會先大約在 Developer Manual 簡介原始碼，細部內容會一邊開發一邊補齊。&lt;/p&gt;
&lt;p&gt;User Manual 的部份則是做所有功能的介紹，不過預計會附上程式的圖片（改版時若是動到界面就比較麻煩），解釋操作各項功能的方式。&lt;/p&gt;
&lt;p&gt;這三個手冊目前是使用中文說明。&lt;/p&gt;
&lt;h2&gt;v0.3.0 核心改動&lt;/h2&gt;
&lt;p&gt;最近參考大量  Java Script 的程式架構後，覺得以鍵值管理變數的方式比較容易分清用途，解說上也較好管理。&lt;/p&gt;
&lt;p&gt;不過相對於 Java Script，Python 的物件得先建立 class，定義上比較繁瑣，所以就使用 Dictionary 來存取變數，雖然使用上比 Java Script 麻煩許多。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1119_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;目前畫布 &lt;code&gt;canvas.py&lt;/code&gt; 中的變數已經分類得差不多了，計算那塊由於關聯太多物件，修改需要花一段時間，亦或使用 Python 原本的 class 建構？&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/11/18</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051118.html" rel="alternate"></link><published>2016-11-18T21:00:00+08:00</published><updated>2016-11-18T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-11-18:/blog/40323230ri-zhi-1051118.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;Pyslvs v0.2.0 Release &amp;amp; informations&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;Pyslvs v0.2.0 Release &amp;amp; informations&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs v0.2.0 Release&lt;/h1&gt;
&lt;h2&gt;包含功能&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;儲存時紀錄路徑（存檔格式改變）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多種輔助與控制面板&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;授權聲明&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;問題&lt;/h2&gt;
&lt;p&gt;暫停進階選項的開發，將階段放在解題異常的問題上。&lt;/p&gt;
&lt;p&gt;目前已知問題是在解題時，運算某些位置會發生錯誤，必須修正此問題。&lt;/p&gt;
&lt;p&gt;而 v0.3.0 的目標就是解決死點問題，而滑塊功能仍會繼續測試。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/10/17</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051017.html" rel="alternate"></link><published>2016-10-17T21:00:00+08:00</published><updated>2016-10-17T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-17:/blog/40323230ri-zhi-1051017.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Kernel 編譯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Kernel 編譯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Kernel 編譯&lt;/h1&gt;
&lt;p&gt;位於 python-solvespace 倉儲的程式庫文件因應 Pyslvs 的自動切換功能，編譯後不會放在 Ubuntu 或是 Windows 資料夾中了，而是採用 Pyslvs 的顯示方式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1017_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;這個改變儲存在 configure.py 文件中，生成後的 Makefile 將會鎖定在一個編譯者的 Python 版本上，使用其他 Python 編譯的話，要重新用 configure.py 生成。&lt;/p&gt;
&lt;p&gt;而這個 configure.py 的功能之後可能會變成 Leo Editor 的按鈕。&lt;/p&gt;
&lt;p&gt;目前為止還沒測試 Windows 的編譯，也許試過之後會嘗試改用 MinGW，讓 Ubuntu 平台的協同者能為 Windows 編譯。&lt;/p&gt;
&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;p&gt;增加參數控制功能，使用 Python 內建的 sys.argv 清單判定。&lt;/p&gt;
&lt;pre&gt;
$python3 launch_pyslvs.py [arg1] [arg2] ...
&lt;/pre&gt;

&lt;p&gt;可能包裝成執行檔後用終端機呼叫才會出現。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1017_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;目前大約做了如下幾個基本的參數。&lt;/p&gt;
&lt;h2&gt;Git 資訊 &lt;code&gt;-g / --git&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;使用後啟動時的標題會讀取目前版次的代碼，不過軟體若是沒帶有 Git 的資訊就會無法顯示。&lt;/p&gt;
&lt;h2&gt;開啟檔案 &lt;code&gt;-o&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在這個參數上直接接上 CSV 檔案的名稱，可以在開啟 Pyslvs 時馬上載入這個檔案。&lt;/p&gt;
&lt;p&gt;不過如果副檔名不是 CSV 的話就不會讀取。&lt;/p&gt;
&lt;h2&gt;基本資訊 &lt;code&gt;-h / --help&lt;/code&gt; &lt;code&gt;-v / --version&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;使用這兩個參數後將不會開啟 Pyslvs 本體，只會顯示其資訊，偵測的優先權最高。&lt;/p&gt;
&lt;p&gt;若是使用 &lt;code&gt;-v / --version&lt;/code&gt;，只會列出 Pyslvs 和 Python 的版本。&lt;/p&gt;
&lt;h2&gt;其他待加入功能&lt;/h2&gt;
&lt;p&gt;預計加入檢查程式庫和整個 GUI 的 Debug 功能，不過還要研究 Python 的 unit test。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/10/16</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051016.html" rel="alternate"></link><published>2016-10-16T21:00:00+08:00</published><updated>2016-10-16T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-16:/blog/40323230ri-zhi-1051016.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Putty 連線&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Putty 連線&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;顯示資訊&lt;/h2&gt;
&lt;p&gt;啟動時顯示的資訊加上 commit 編號和平台類型。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1016_01.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;自動選擇平台版本&lt;/h2&gt;
&lt;p&gt;現在程式庫改移到 kernel 資料夾中，Pyslvs 會讀取平台資訊和 Python 版本來選擇 import 的程式庫。&lt;/p&gt;
&lt;p&gt;名稱為不同版本的 Python 名稱，如 py35。後方加上「w」為 Windows 平台的版本。&lt;/p&gt;
&lt;p&gt;不過若是如此，當 Python Solvespace kernel 更新時，要為所有平台搬運進倉儲。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1016_02.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;設定檔&lt;/h2&gt;
&lt;p&gt;GUI 的設定檔存放在主目錄，名為 &lt;code&gt;Pyslvs_Settings.ini&lt;/code&gt;，還未開始連結設定功能。&lt;/p&gt;
&lt;p&gt;這個檔案並不會被 git 上傳。&lt;/p&gt;
&lt;h2&gt;License&lt;/h2&gt;
&lt;p&gt;加入了 GPL 3 的授權檔案。&lt;/p&gt;
&lt;p&gt;另外，在 main.py 程式碼中加入了簡短宣告條文（參考自 Gimp）。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Putty 連線&lt;/h1&gt;
&lt;p&gt;在研究室用 Putty 實測了虛擬機連線的部份，同為 Linux 平台中就沒出現跨平台的錯誤，所以在跨平台撰寫後，測試時可能就得注意了。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/10/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051013.html" rel="alternate"></link><published>2016-10-13T21:00:00+08:00</published><updated>2016-10-13T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-13:/blog/40323230ri-zhi-1051013.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Asus 開機選項（UEFI）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Qt 升級&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;個人網頁創建&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Asus 開機選項（UEFI）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Qt 升級&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;個人網頁創建&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Asus BIOS&lt;/h1&gt;
&lt;p&gt;一些新版的 BIOS 採用 UEFI 模式讀取開機硬體，會有以光碟開機後產生光碟錯誤的提示（甚至讀不到鍵盤無法選擇）；或是選單黑屏卡死。&lt;/p&gt;
&lt;p&gt;學校的新電腦 BIOS 必須啟用相容模式（預設是自動，要強制啟動）才能讀取安裝光碟或隨身碟。&lt;/p&gt;
&lt;p&gt;啟用後重新開機，按 F8 叫出開機選單，選擇沒有「UEFI」字樣的選項，才能用一般的選項載入。&lt;/p&gt;
&lt;p&gt;之前發現第一台測試機的顯示卡不太好，跑 QPainter 的快速 Render 時會滿 lag 的（拖動滑桿控制轉軸時），所以想用新電腦的配備處理看看。&lt;/p&gt;
&lt;h1&gt;Qt 和 PyQt 升級&lt;/h1&gt;
&lt;p&gt;安裝 Qt 後會多出 Qt Maintanance Tool 的捷徑，使用其可以額外安裝、升級、移除現有的 Qt 程式庫。&lt;/p&gt;
&lt;p&gt;不過若要升級，必須每個新版本慢慢升上去，有點花時間就是。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1013_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1013_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;至於 PyQt 的部份，由於 apt-get 的 &lt;code&gt;python3-pyqt5&lt;/code&gt; 16.04 只支援到 5.5，而且 16.10 也只支援到 5.6，所以看似只能使用 pip3 安裝，不過還沒測試是否會衝突。&lt;/p&gt;
&lt;h1&gt;個人網頁&lt;/h1&gt;
&lt;p&gt;複製了 project site 網站的倉儲建了一個副本，準備改成自己的個人網頁，目前只有存自己的文章。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://40323230.github.io/YuanBlog/blog/"&gt;https://40323230.github.io/YuanBlog/blog/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之後會在 About 加入簡介和心智圖，並整理 Tags。&lt;/p&gt;</content><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/10/11</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051011.html" rel="alternate"></link><published>2016-10-11T21:00:00+08:00</published><updated>2016-10-11T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-11:/blog/40323230ri-zhi-1051011.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Kubuntu 16.04 一些瑣事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python Solvespace Makefile 配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Kubuntu 16.04 一些瑣事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python Solvespace Makefile 配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Kubuntu 16.04&lt;/h1&gt;
&lt;p&gt;安裝 Eric6 成功之後，又安裝了 Leo Editor（使用 &lt;code&gt;git clone&lt;/code&gt; 後直接 launch 的方式），在 Python 3.5 + PyQt 5.5 的情形下沒有遇到無法切換輸入法的問題，所以就可以用這台電腦寫網誌了。&lt;/p&gt;
&lt;p&gt;升級之後有類似 Windows 的不定期更新，不過是非強制的，可以不用理它。&lt;/p&gt;
&lt;p&gt;另外新版的 Plasma 將帳戶和即時通綁在一起，所以通知列一直會有即時通的圖示關不掉，不過不妨礙工作。&lt;/p&gt;
&lt;p&gt;資源使用量：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1011_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;另外比較奇怪的一點是 Eric6 偵測相關工具時發現了 Pyside（不過 Python 3 無法 import；Python 2 可以）；卻找不到 PyQt（但是可以 import），可能是路徑問題。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1011_02.jpg"&gt;&lt;/p&gt;
&lt;h1&gt;Python Solvespace Makefile 配置&lt;/h1&gt;
&lt;p&gt;撰寫了 configure.py 來幫忙生成 Makefile，放在 exposed 資料夾裡。&lt;/p&gt;
&lt;p&gt;不過目前只能支援 Ubuntu（測試成功），Windows 的部份因為有可攜環境的關係，需要知道各種工具的位置，必須另外做調整。&lt;/p&gt;
&lt;p&gt;也因為如此，目前 Windows 的部份是原本 W: 槽的設定，之後會改用 Windows 7 測試新的可攜 Solvespace 編譯環境，還有如果本機直接安裝相關工具的環境。&lt;/p&gt;
&lt;p&gt;能夠自動偵測環境編譯後，在想是否需要重新規劃 Submodule 的父子關係，因為 Pyslvs GUI 無法直接切換對應 Python 版本的 Kernal 來用，只會拿到上個使用者的核心來使用，有很大的機率會出問題。&lt;/p&gt;
&lt;p&gt;因此當其他協同者下載 Pyslvs 後，可能需要重新編譯 Kernal 來用，之後放入專案中（或許 Makefile 可以協助），協同 GUI 時就不用理會核心版本不同了。&lt;/p&gt;
&lt;p&gt;至於之後是否會在 16.04 升級 Qt 或 PyQt，可能得尋找其他方法，目前是不會更改內建的程式庫。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - Kubuntu 16.04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-kubuntu-1604.html" rel="alternate"></link><published>2016-10-07T21:00:00+08:00</published><updated>2016-10-07T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-07:/blog/40323230ri-zhi-kubuntu-1604.html</id><summary type="html">&lt;p&gt;：：Kubuntu 16.04 資訊紀錄：：&lt;/p&gt;
</summary><content type="html">&lt;p&gt;：：Kubuntu 16.04 資訊紀錄：：&lt;/p&gt;


&lt;h1&gt;Kubuntu 16.04&lt;/h1&gt;
&lt;h2&gt;系統資訊&lt;/h2&gt;
&lt;p&gt;Ubuntu: 16.04&lt;/p&gt;
&lt;p&gt;KDE Plasma: 5.5.5&lt;/p&gt;
&lt;p&gt;Qt: 5.5.1&lt;/p&gt;
&lt;p&gt;核心：3.13.0-36-generic (x64)&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1007_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;由於研究室有空閒的兩台電腦效能不佳，只有 4GB 的記憶體，且無法模擬 x64 作業系統的能力，所以就配合使用 16.04 版本的測試。&lt;/p&gt;
&lt;p&gt;用 Kubuntu 升級成實體機測試後，其中一台較沒問題，另一台雙系統的電腦反而效能不彰。&lt;/p&gt;
&lt;p&gt;Kubuntu 是使用 muon 系統更新來升級的（但是 16.04 中名稱變為「軟體更新 Update Manager」），若是更新選項調成 LTS 穩定版，就會偵測到 16.04，接受後就會升級。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1007_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;升級時所有內建軟體（包括終端機 Konsole）都會凍結，設定功能也會停用，整個過程大約 1 小時左右。升級時建議不要開外部程式以免造成中斷。&lt;/p&gt;
&lt;p&gt;而自己的電腦仍在 14.04 開發。&lt;/p&gt;
&lt;h2&gt;升級後問題&lt;/h2&gt;
&lt;p&gt;主要最大的部份是改用 &lt;strong&gt;Python 3.5&lt;/strong&gt; 與內建 &lt;strong&gt;Qt / PyQt 5.5.1&lt;/strong&gt;。因此在升級時 Python 3.4 和它相關的所有套件都會被移除。（Python 2.7 也因為比 16.04 舊的關係，一樣會被移除）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新工具：由於官方套件供應者變成 Xenial，所有套件都已經捨棄舊版（如不再提供 GNU 4），而且內建更多工具（如 CMake、Python-dev）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新驅動：內建非穩定版 Ubuntu 15 的 Kernel，支援以往 14.04 沒支援的驅動，要注意是否有新的驅動選項要勾選（如測試電腦中有主機板驅動的選項，預設是未啟用）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KDE 界面變動：需要稍微習慣和重新設定新的圖形界面，例如滑鼠點兩下的設定放在「滑鼠」中而非檔案總管。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pidgin 移除：通訊程式 Pidgin 不再於新的 KDE 支援了，若不想在更新程式捷徑時出現錯誤，必須在軟體中心移除它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python 3.5 套件：安裝 pip 與 QScintilla、QtSQL、QtSVG 時要使用 apt-get，不然自行下載的版本會無法認得內建的 Qt 5。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝 QMake：內建的 Qt 沒有附上 QMake，使用 apt-get 下載 &lt;code&gt;qt5-qmake&lt;/code&gt; 安裝它。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;安裝 Eric 6 IDE&lt;/h2&gt;
&lt;p&gt;以下為項目的安裝方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Qt5（內建 5.5，目前與 Pyslvs 並沒有相容問題）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SIP（重新安裝）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyQt5（內建）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QScintilla2（用 apt-get 安裝，名稱 &lt;code&gt;python3-pyqt5.qsci&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QtSQL（Eric 6 需求，用 apt-get 安裝，名稱 &lt;code&gt;python3-pyqt5.qtsql&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;QtSVG（Eric 6 需求，用 apt-get 安裝，名稱 &lt;code&gt;python3-pyqt5.qtsvg&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Eric 6（正常安裝）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Python Solvespace 核心&lt;/h2&gt;
&lt;p&gt;遇到 Python dev Kernel 不相容的問題，因為之前是使用 Python 3.4。意味著必須重編一個 Python Solvespace 的核心給使用 Python 3.5 的 16.04。&lt;/p&gt;
&lt;p&gt;不過新工具跟自己電腦的 14.04 一樣，只要一個新的 Makefile 就行了。&lt;/p&gt;
&lt;p&gt;Python Solvespace 或其 GUI 的編譯是否需要加入 CMake 或 QMake？因為以前不熟悉的關係只能手寫 Makefile，如果能因應未來版本的相關 lib，會比較符合升級的概念。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 影音</title><link href="http://project.mde.tw/blog/40323230ri-zhi-ying-yin.html" rel="alternate"></link><published>2016-10-06T21:00:00+08:00</published><updated>2016-10-06T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-06:/blog/40323230ri-zhi-ying-yin.html</id><summary type="html">&lt;p&gt;：：影片作業環境（Ubuntu）：：&lt;/p&gt;
</summary><content type="html">&lt;p&gt;：：影片作業環境（Ubuntu）：：&lt;/p&gt;


&lt;h1&gt;Kazam&lt;/h1&gt;
&lt;p&gt;Ubuntu 平台的錄製軟體，為 KDE 系列的附屬程式，因此安裝 Kubuntu 時就內建了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1006_01.jpg"&gt;&lt;/p&gt;
&lt;h1&gt;FFmpeg&lt;/h1&gt;
&lt;p&gt;從官方網站下載 &lt;code&gt;.tar.bz2&lt;/code&gt; 壓縮檔解開並進入資料夾。&lt;/p&gt;
&lt;pre&gt;
$./configure --disable-yasm #若是不支援某些項目會提醒停用參數
$make
$sudo make install
&lt;/pre&gt;

&lt;p&gt;最後檢查一下是否安裝：&lt;/p&gt;
&lt;pre&gt;
$ffmpeg -h
&lt;/pre&gt;

&lt;h1&gt;SRT 字幕&lt;/h1&gt;
&lt;p&gt;以前自己載過 Youtube 的字幕練習英文，所以不算陌生。&lt;/p&gt;
&lt;p&gt;未來做 introduction video 應該能好好發揮。&lt;/p&gt;</content><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/10/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051005.html" rel="alternate"></link><published>2016-10-05T21:00:00+08:00</published><updated>2016-10-05T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-05:/blog/40323230ri-zhi-1051005.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu MinGW&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 16.04 與 Windows 10&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leo Editor IDE&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu MinGW&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 16.04 與 Windows 10&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leo Editor IDE&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Ubuntu MinGW&lt;/h2&gt;
&lt;p&gt;用 apt-get 安裝 MinGW，以在 Ubuntu 編譯 Windows 的可執行檔 &lt;code&gt;.exe&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
$sudo apt-get install mingw-w64
&lt;/pre&gt;

&lt;p&gt;編譯時使用下列指令（相當於 GNU 工具）：&lt;/p&gt;
&lt;pre&gt;
$x86_64-w64-mingw32-gcc
$x86_64-w64-mingw32-g++
&lt;/pre&gt;

&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1005_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;不過若要使用在 Pyslvs，Qt 方面仍要做相應的調整。&lt;/p&gt;
&lt;h1&gt;Ubuntu 16.04 與 Windows 10&lt;/h1&gt;
&lt;p&gt;目前研究室沒有實體機使用這兩個系統，所以打算使用一台學校的電腦安裝 Virtualbox，模擬兩個系統的環境。&lt;/p&gt;
&lt;p&gt;該電腦由於安裝雙系統，Ubuntu 不使用時 Virtualbox 不會佔用 Windows 7 的記憶體，所以應該能提供較流暢的模擬環境。&lt;/p&gt;
&lt;p&gt;明天早上會裝好 Virtualbox 的設定。&lt;/p&gt;
&lt;h1&gt;Leo Editor IDE&lt;/h1&gt;
&lt;p&gt;目前觀察利用 Python 3 的程式碼編譯 Solvespace 是沒有問題的，不過在 14.04 與 16.04 的 Python 3.4 和 3.5 之間需要切換 Makefile。不然會沒有 include 或 lib 位置。&lt;/p&gt;
&lt;pre&gt;
slvs_wrap.cxx:14:23: fatal error: Python.h: 沒有此一檔案或目錄
&lt;/pre&gt;

&lt;p&gt;而若是編譯給 Windows 使用，也是要改一些設定。&lt;/p&gt;
&lt;p&gt;除了之前無法輸入中文的問題以外，測試執行 Button 的 Script 是沒問題。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/10/04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051004.html" rel="alternate"></link><published>2016-10-04T21:00:00+08:00</published><updated>2016-10-04T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-04:/blog/40323230ri-zhi-1051004.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;Pyslvs 編譯進度&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;Pyslvs 編譯進度&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;DXF 輸出&lt;/h2&gt;
&lt;p&gt;使用 dxfwrite 模組進行建檔，成功轉出 DXF 檔，可以在其他 CAD 軟體使用。&lt;/p&gt;
&lt;p&gt;dxfwrite 可以使用 pip 安裝。&lt;/p&gt;
&lt;p&gt;不過這個模組的讀取功能似乎不太能支援直接取得 DXF 的數據。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/1004_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;dxfwrite documentation:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pythonhosted.org/dxfwrite/" title="pythonhosted.org"&gt;http://pythonhosted.org/dxfwrite/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;設定功能&lt;/h2&gt;
&lt;p&gt;規劃了一些自訂功能，想使用 QSettings 功能製作使用者的偏好選項。&lt;/p&gt;
&lt;p&gt;預計會有面板位置、顏色等等選項可以調整。&lt;/p&gt;
&lt;p&gt;不過還在研究 QSettings，可能屬於次要項目。&lt;/p&gt;
&lt;h2&gt;SLVS 輸出&lt;/h2&gt;
&lt;p&gt;將 &lt;code&gt;.slvs&lt;/code&gt; 輸出功能分離出來做調整，希望以後可以單獨使用。&lt;/p&gt;
&lt;p&gt;類似一般撰寫的功能，輸入點或線後可以寫成 &lt;code&gt;.slvs&lt;/code&gt; 檔。&lt;/p&gt;
&lt;p&gt;不過還有一些問題待調整，仍要測試一些項目。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/10/02</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1051002.html" rel="alternate"></link><published>2016-10-02T21:00:00+08:00</published><updated>2016-10-02T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-10-02:/blog/40323230ri-zhi-1051002.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OCE Kernel&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OCE Kernel&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;p&gt;Log：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;圖片格式選擇&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照機構寬度或高度縮放視角功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表格提示文字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表格右鍵複製數據&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遮罩修正&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;OCE Kernel&lt;/h1&gt;
&lt;p&gt;Open CASCADE Community Edition:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/tpaviot/oce" title="https://github.com"&gt;https://github.com/tpaviot/oce&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;pythonocc:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/tpaviot/pythonocc-core" title="https://github.com"&gt;https://github.com/tpaviot/pythonocc-core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;找到官方 Open CASCADE 的 C++ 核心，還有 Python 的接口 pythonocc。&lt;/p&gt;
&lt;p&gt;另外 pythonocc 有一個附加模組 aocxchange 可以幫忙轉換 3D 檔案格式。&lt;/p&gt;
&lt;p&gt;預想在 Pyslvs 設計草圖後，可以利用模組轉出簡單的 3D 零件樣式（例如連桿），供 3D CAD 軟體編修。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/30</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050930.html" rel="alternate"></link><published>2016-09-30T21:00:00+08:00</published><updated>2016-09-30T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-30:/blog/40323230ri-zhi-1050930.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;Pyslvs 編譯進度&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;Pyslvs 編譯進度&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;p&gt;Log：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;格式加入路徑儲存功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原點初始值改變&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;驅動軸面板輸入精確角度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重置顯示區按鈕&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;滑塊計算功能（未驗證）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;滑塊路徑追蹤功能（未驗證）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/28</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050928.html" rel="alternate"></link><published>2016-09-28T21:00:00+08:00</published><updated>2016-09-28T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-28:/blog/40323230ri-zhi-1050928.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;Pyslvs 編譯進度&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;Pyslvs 編譯進度&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;輔助線面板&lt;/h2&gt;
&lt;p&gt;增加標示極限功能，開啟顯示標註的話，會顯示極限的數值（最大 6 位小數）。&lt;/p&gt;
&lt;p&gt;這個面板在關閉後仍會保留上次的資料（歸類在畫布的參數中），不過切換到其他機構點時就會清掉極限紀錄。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0928_01.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;模擬面板改進&lt;/h2&gt;
&lt;p&gt;這次調整過模擬功能的面板，更明確易懂。&lt;/p&gt;
&lt;p&gt;另外新增開關路徑圖的功能，之前要刪掉才會消失。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0928_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;路徑圖最後會加入存檔中，這部份功能會之後做。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/27</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050927.html" rel="alternate"></link><published>2016-09-27T21:00:00+08:00</published><updated>2016-09-27T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-27:/blog/40323230ri-zhi-1050927.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Release v0.1.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Release v0.1.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Release v0.1.0&lt;/h1&gt;
&lt;p&gt;穩定版本釋出，開發中的功能有標示「Alpha」的字樣，未做出的功能鈕已經 disable。&lt;/p&gt;
&lt;p&gt;目前更動的部份都是 GUI 相關，動態模擬的部份可能會整合進圖形界面。&lt;/p&gt;
&lt;p&gt;之後的編譯進度更新的是第二版號，第三版號是單純修正 bug，第一版號是大功能的整合。&lt;/p&gt;
&lt;h1&gt;Pyslvs 編譯進度&lt;/h1&gt;
&lt;h2&gt;輔助線&lt;/h2&gt;
&lt;p&gt;新增輔助線面板，可以觀察機構點的水平或垂直位置，之後會加入最大最小位置紀錄的功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0927_01.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;主動軸標示&lt;/h2&gt;
&lt;p&gt;圖中會標示主動軸的相對點連線，使用橘色虛線表示，之後自訂功能做好後就能改別的顏色了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0927_02.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天花時間在輔助線的功能上，還沒做滑塊的計算。&lt;/p&gt;
&lt;p&gt;滑塊可能會和主動軸分開面板控制。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>WebGL_three.js</title><link href="http://project.mde.tw/blog/webgl_threejs.html" rel="alternate"></link><published>2016-09-25T22:00:00+08:00</published><updated>2016-09-25T22:00:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-09-25:/blog/webgl_threejs.html</id><summary type="html">&lt;p&gt;研究WebGL的框架three.js ,嘗試建立和Onshape同性質的網頁繪圖系統 
</summary><content type="html">&lt;p&gt;研究WebGL的框架three.js ,嘗試建立和Onshape同性質的網頁繪圖系統 
&lt;/p&gt;
&lt;p&gt;經過討論後 ,我比較想要嘗試網頁方面的繪圖 ,然後上網找到了一些對岸製作的有關於WebGL、three.js的介紹&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.hewebgl.com/article/getarticle/27"&gt;WebGL中文网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;因為之前也沒有很深入的了解 ,所以可能要接觸一些範例來加深印象 ,假如可行 便能加入30號同學的核心進行2D線上繪圖 ,這樣資源也會更加豐富&lt;/p&gt;</content><category term="WebGL"></category></entry><entry><title>40323230日誌 - 105/09/24</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050924.html" rel="alternate"></link><published>2016-09-24T21:00:00+08:00</published><updated>2016-09-24T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-24:/blog/40323230ri-zhi-1050924.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;安裝 bullet-2.81 程式庫&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;安裝 bullet-2.81 程式庫&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;安裝 bullet 程式庫&lt;/h1&gt;
&lt;p&gt;Bullet 其中一個用途為 Blender 的物理運算。&lt;/p&gt;
&lt;p&gt;由於找到了一些 Python 相關的端口，所以想先安裝來讓 Python 使用。&lt;/p&gt;
&lt;p&gt;＊先確認已安裝 OpenCL。&lt;/p&gt;
&lt;p&gt;從官方網站下載 Bullet Physics Library。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?t=8490" title="bulletphysics.org"&gt;http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?t=8490&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;載點為 bullet-2.81-rev2613.tgz：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://code.google.com/archive/p/bullet/downloads" title="bullet"&gt;https://code.google.com/archive/p/bullet/downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用 CMake 設定系統參數，並安裝：&lt;/p&gt;
&lt;pre&gt;
$cmake . -G "Unix Makefiles" -DBUILD_SHARED_LIBS=ON
$sudo make
$sudo make install
&lt;/pre&gt;

&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0924_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;預設會安裝於 &lt;code&gt;/usr/loca/lib/&lt;/code&gt; 中。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/21</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050921.html" rel="alternate"></link><published>2016-09-21T21:00:00+08:00</published><updated>2016-09-21T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-21:/blog/40323230ri-zhi-1050921.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.slvs&lt;/code&gt; 格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;速度計算&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.slvs&lt;/code&gt; 格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;速度計算&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;&lt;code&gt;.slvs&lt;/code&gt; 格式&lt;/h1&gt;
&lt;p&gt;簡述進度：&lt;/p&gt;
&lt;p&gt;輸出功能做了之後就測試 Pyslvs 產生的檔案是否能給 Solvespace 讀取，但是發現其實 16 進位編號是有順序的，如果跳號或對錯位就會導致閃退。&lt;/p&gt;
&lt;p&gt;測試之後，目前基本的點輸入一切正常，但是當有連接線時就會產生錯誤，可能是數值對錯位，轉檔紀錄時應該必須和現在的算點功能分離。&lt;/p&gt;
&lt;p&gt;目前轉出點成功：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0921_01.jpg"&gt;&lt;/p&gt;
&lt;h1&gt;速度計算功能&lt;/h1&gt;
&lt;p&gt;想做一個有關速度計算的功能，從轉的角度轉換距離，用自訂 RPM 速度轉換當前線速度。&lt;/p&gt;
&lt;p&gt;可能會結合路徑追蹤使用。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/19</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050919.html" rel="alternate"></link><published>2016-09-19T21:00:00+08:00</published><updated>2016-09-19T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-19:/blog/40323230ri-zhi-1050919.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.slvs&lt;/code&gt; 格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3D Printer 模擬&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.slvs&lt;/code&gt; 格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3D Printer 模擬&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;&lt;code&gt;.slvs&lt;/code&gt; 格式&lt;/h1&gt;
&lt;p&gt;其實 &lt;code&gt;.slvs&lt;/code&gt; 格式只是將 Solvespace 的暫存數據記錄下來，若有缺失就會使用預設數據，存檔時會刷新而非只修改部份。&lt;/p&gt;
&lt;p&gt;參考的部份是空白文件的數據（包含預設平面、向量、原點等等），當有增加實體時就會追加內容。&lt;/p&gt;
&lt;p&gt;特別注意的是這些代碼皆為 16 進位，&lt;code&gt;True&lt;/code&gt; 的部份用 1 表示，&lt;code&gt;False&lt;/code&gt; 則用 0 表示。&lt;/p&gt;
&lt;p&gt;總共分為 5 個部份：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;群組：群組，類似圖層的概念。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;參數：之後會用到的幾何數據，會用編號歸納關係，基本上無法共用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;回應：圖形化界面的回應，包含滑鼠能點擊到的所有物件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;實體：點線的構成，包含實體建構時的參考副本，例如 point[0] 到 point[1] 的內容會被歸納到線條的從屬下。&lt;em&gt;未閉合的端點會有重複的紀錄，不過實驗過刪除多餘的紀錄仍可正常開啟。&lt;/em&gt;不同實體有不同屬性可調整。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;約束：用來約束實體，不同約束有不同屬性可調整。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;參照下列格式：&lt;/p&gt;
&lt;pre&gt;
辨識標頭（使用 ISO-8859-15）：
±²³SolveSpaceREVa

參考群組（00000001）：
Group.h.v=00000001
Group.type=5000
Group.name=#references
...
AddGroup

加入群組：
Group.h.v=00000002
Group.type=5001
Group.order=1
Group.name=sketch-in-plane
...
AddGroup

參考參數（00010010~00030023）：
Param.h.v.=00010010
AddParam

加入參數：00030020
Param.h.v.=00040010
Param.val=40.00000000000000000000
AddParam

參考回應（00000001~00000003）：
Request.h.v=00000001
Request.type=100
Request.group.v=00000001
Request.construction=0
AddRequest

加入回應：
Request.h.v=00000004
Request.type=101
Request.workplane.v=80020000
Request.group.v=00000002
Request.construction=0
AddRequest

參考實體（00010000~00030020）：
Entity.h.v=00010000
Entity.type=10000
Entity.construction=0
Entity.point[0].v=00010001
Entity.normal.v=00010020
Entity.actVisible=1
AddEntity

加入實體：
Entity.h.v=00040000
Entity.type=2001
Entity.construction=0
Entity.workplane.v=80020000
Entity.actPoint.x=40.00000000000000000000
Entity.actPoint.y=30.00000000000000000000
Entity.actVisible=1
AddEntity

複製項（80020000~80020002）：
Entity.h.v=80020000
Entity.type=10000
Entity.construction=0
Entity.point[0].v=80020002
Entity.normal.v=80020001
Entity.actVisible=1
AddEntity

加入約束：
Constraint.h.v=00000001
Constraint.type=30
Constraint.group.v=00000002
Constraint.workplane.v=80020000
Constraint.valA=50.00000000000000000000
Constraint.ptA.v=00040000
Constraint.ptB.v=80020002
Constraint.other=0
Constraint.other2=0
Constraint.reference=0
AddConstraint
&lt;/pre&gt;

&lt;p&gt;研究花了一些時間，可能得後天才能加入匯出功能。&lt;/p&gt;
&lt;p&gt;Pyslvs 的群組應該只會有一個，用點之間的線架構就好了。&lt;/p&gt;
&lt;p&gt;應該只有 3D Mode 才有 STL 支援的功能。&lt;/p&gt;
&lt;p&gt;剩下 3D Mode 將 2D 的功能加過去，另外新增線條鉛錘與水平的約束、應該就能結束了。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;3D Printer 模擬&lt;/h1&gt;
&lt;p&gt;關於 3D Printer 模擬的部份，可能必須寫一個新的軟體來應對。&lt;/p&gt;
&lt;p&gt;因為一些定義如果直接套用目前的範本，可能會無法模擬。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0919_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;畫了個模型，之後套範本應該比較快。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/17</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050917.html" rel="alternate"></link><published>2016-09-17T21:00:00+08:00</published><updated>2016-09-17T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-17:/blog/40323230ri-zhi-1050917.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyOpenGL&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyOpenGL&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;3D 模式&lt;/h2&gt;
&lt;p&gt;在另一個分頁新增相同的面板，不過拿掉了呆鍊約束。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/9GEGPzD.png" &gt;&lt;/p&gt;
&lt;p&gt;新的 Widget 名稱都改成 &lt;code&gt;_3d&lt;/code&gt; 字尾以供辨識。&lt;/p&gt;
&lt;p&gt;不過上方的 QMenuBar 必須應對這個改變，估計製作 3D 的 QAction 後，會根據當前頁籤隱藏另一邊的 QAction。&lt;/p&gt;
&lt;h2&gt;記憶體釋放&lt;/h2&gt;
&lt;p&gt;由於初學時的寫法沒優化觀念，Qt 的視窗物件必須用 &lt;code&gt;setAttribute()&lt;/code&gt; 設定屬性，其中的 &lt;code&gt;Qt.WA_DeleteOnClose&lt;/code&gt; 會在關閉後刪除物件，以免開過太多視窗會導致速度降低。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;.slvs&lt;/code&gt; 格式&lt;/h2&gt;
&lt;p&gt;今天還是沒時間研究詳細的用法，但是可以確定 2D 圖面的初步內容（基準面之類的），用 Python 程式碼存成 &lt;code&gt;.slvs&lt;/code&gt; 附檔名的 &lt;code&gt;ISO-8859-15&lt;/code&gt; 編碼文字檔。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
with open(fileName, 'w', encoding="iso-8859-15", newline="") as f:
    f.write(self.Slvs_Script)
print("Successful Save: "+fileName)
&lt;/pre&gt;

&lt;hr&gt;

&lt;h1&gt;PyOpenGL&lt;/h1&gt;
&lt;p&gt;找了一下之前為何無法使用 OpenGL 範例的原因，似乎是因為那些範例無法支援新的 OpenGL 了。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/38645674/issues-with-pyqt5s-opengl-module-and-versioning-calls-for-incorrect-qopenglfu" title="stackoverflow.com"&gt;http://stackoverflow.com/questions/38645674/issues-with-pyqt5s-opengl-module-and-versioning-calls-for-incorrect-qopenglfu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以按照建議，安裝了 PyOpenGL（License: BSD） ，不過它的開發期較長。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pyopengl.sourceforge.net/documentation/installation.html" title="pyopengl.sourceforge.net"&gt;http://pyopengl.sourceforge.net/documentation/installation.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;執行過上面文章的範例，可以成功使用（不過那個範例 code 忘記匯入 sys 和 math）。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/hZf6lu2.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;明天可能會利用時間放圖片。&lt;/p&gt;
&lt;p&gt;Mark Down 圖片的語法（其實和超連結很像）：&lt;/p&gt;
&lt;pre&gt;
![替代文字](近端或遠端連結"滑鼠提示文字")
&lt;/pre&gt;

&lt;p&gt;只是無法調整圖片大小。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/15</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050915.html" rel="alternate"></link><published>2016-09-15T21:00:00+08:00</published><updated>2016-09-15T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-15:/blog/40323230ri-zhi-1050915.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;現時 Ubuntu 版 Solvespace 安裝&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.slvs&lt;/code&gt; 檔案格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 3D 模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;現時 Ubuntu 版 Solvespace 安裝&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.slvs&lt;/code&gt; 檔案格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 3D 模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Solvespace 編譯&lt;/h1&gt;
&lt;p&gt;確保下列事項：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;GNU 5.3 以上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CMake 3.0 以上&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下載後進入資料夾。&lt;/p&gt;
&lt;pre&gt;
$git submodule update --init extlib/libdxfrw
$mkdir build
$cd build
$cmake .. -DENABLE_TESTS=OFF
&lt;/pre&gt;

&lt;p&gt;若出現 &lt;code&gt;GCC 5.0+ is required&lt;/code&gt; 問題，請使用下列指令更改優先權：&lt;/p&gt;
&lt;pre&gt;
$sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 1
$sudo update-alternatives --config gcc
替代項目 gcc（提供 /usr/bin/gcc）有 2 個選擇。

  選項       路徑            優先權  狀態
------------------------------------------------------------
* 0            /usr/bin/gcc-4.8   48        自動模式
  1            /usr/bin/gcc-4.8   48        手動模式
  2            /usr/bin/gcc-5     1         手動模式

按 [enter] 保留目前選項 [*]，或輸入選項編號：2   
update-alternatives: 以 /usr/bin/gcc-5 提供 手動模式 中的 /usr/bin/gcc (gcc)
&lt;/pre&gt;

&lt;p&gt;若出現這個警告：&lt;/p&gt;
&lt;pre&gt;
The CMAKE_CXX_COMPILER:

/usr/bin/c++

is not a full path to an existing compiler tool.
&lt;/pre&gt;

&lt;p&gt;請更改 CMake List 的參數（注意不要指到軟連結，必須是執行檔本體）：&lt;/p&gt;
&lt;pre&gt;
$sudo cmake -D CMAKE_C_COMPILER="/usr/bin/gcc-5" -D CMAKE_CXX_COMPILER="/usr/bin/g++-5" ../CMakeLists.txt
&lt;/pre&gt;

&lt;p&gt;最後 build 檔案出來後，使用下列指令：&lt;/p&gt;
&lt;pre&gt;
$cd ..
$sudo make
&lt;/pre&gt;

&lt;p&gt;編譯完畢後，可以在 &lt;code&gt;src&lt;/code&gt; 資料夾中找到 &lt;code&gt;solvespace&lt;/code&gt; 執行檔，點兩下就能執行了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rgW87Ao.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;code&gt;.slvs&lt;/code&gt; 檔案格式&lt;/h1&gt;
&lt;p&gt;為了瞭解 Solvespace 的運作流程，也以便之後跟它溝通，想知道 &lt;code&gt;.slvs&lt;/code&gt; 的儲存方式。&lt;/p&gt;
&lt;p&gt;觀察檔案格式，用文字編輯軟體開啟之前存的範例。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/7E2onBk.png" &gt;&lt;/p&gt;
&lt;p&gt;Solvespace 是用西歐語系 &lt;code&gt;ISO-8859-15&lt;/code&gt; 編碼儲存圖檔的，以這點來說，Python 要輸出成 &lt;code&gt;.slvs&lt;/code&gt; 應該是輕而易舉。&lt;/p&gt;
&lt;p&gt;之後觀察一下每種圖形的變化式，應該就能理解如何將 Pyslvs 的表格 Output 給 Solvespace 開啟了。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Pyslvs 3D 模式&lt;/h1&gt;
&lt;p&gt;在想 Pyslvs 之後會加入 3D 模式，採用 Qt OpenGL 繪圖（可以控制鏡頭），且和 2D 模式並存，參考這裡的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://doc.qt.io/qt-5/topics-graphics.html#2d-graphics-with-qpainter" title="doc.qt.io"&gt;http://doc.qt.io/qt-5/topics-graphics.html#2d-graphics-with-qpainter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前好像看過 QPainter 和 QOpenglWidgets 重疊渲染錯誤的問題，不過只要分開 Widget，應該是不會造成太大衝突。&lt;/p&gt;
&lt;p&gt;而 2D 和 3D 共存不知道是否會吃太多資源，還有待觀察。&lt;/p&gt;
&lt;p&gt;另外在成功大學的文件裡找到關於 STL 格式的說明：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://vr.me.ncku.edu.tw/courses/cg99/Download/STL.pdf" title="vr.me.ncku.edu.tw"&gt;http://vr.me.ncku.edu.tw/courses/cg99/Download/STL.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;想要大約瞭解一下，畢竟大部分的 3D CAD 軟體應該都支援 STL 檔。&lt;/p&gt;
&lt;p&gt;亦找到一篇 C++ 讀取 STL 並用 OpenGL 顯示的範例 code，值得研究一下。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/xds1224/p/3565280.html" title="www.cnblogs.com"&gt;http://www.cnblogs.com/xds1224/p/3565280.html&lt;/a&gt;&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/14</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050914.html" rel="alternate"></link><published>2016-09-14T21:00:00+08:00</published><updated>2016-09-14T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-14:/blog/40323230ri-zhi-1050914.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Qt OpenGL 教學資料&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PySide 2 安裝問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Qt OpenGL 教學資料&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PySide 2 安裝問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Qt OpenGL&lt;/h1&gt;
&lt;p&gt;Qt 的官方頁面還沒有撰寫說明，只看函式與格式不太能了解其用途。&lt;/p&gt;
&lt;p&gt;所以去找其他 QtOpenGLWidgets 的教學，找到滿多資料的。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/cly116/article/details/47184729" title="blog.csdn.net"&gt;http://blog.csdn.net/cly116/article/details/47184729&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PyQt 的詳細說明比較少，不過找到幾篇範例後，可以對照著看。由於是高階語言，Python 使用 C++ 函式滿容易的，省略不少步驟。&lt;/p&gt;
&lt;h1&gt;PySide 2 安裝問題&lt;/h1&gt;
&lt;p&gt;今天將 Qt 版本改成 5.6，並重新下載官方倉儲安裝。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/PySide/pyside2-setup" title="github.com/PySide"&gt;https://github.com/PySide/pyside2-setup&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用的參數：&lt;/p&gt;
&lt;pre&gt;
$sudo python3 setup.py install --qmake=/usr/bin/qmake --cmake=/usr/bin/cmake
&lt;/pre&gt;

&lt;p&gt;剛開始遇到 Makelist 找不到指定檔案的問題，如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/hougrQE.png" &gt;&lt;/p&gt;
&lt;p&gt;必須安裝以下套件：&lt;/p&gt;
&lt;pre&gt;
$sudo apt-get install libqt5xmlpatterns5-dev
&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/7OnYdB8.png" &gt;&lt;/p&gt;
&lt;p&gt;不過接下來遇到編譯 shiboken 的問題，編到一半就中斷了。&lt;/p&gt;
&lt;p&gt;上網查了下結果，是因為函式未回傳值，可是不知道什麼原因。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/957Qjp3.png" &gt;&lt;/p&gt;
&lt;p&gt;到官方的倉儲找 Issue，不過好像都沒遇到這種情況。&lt;/p&gt;
&lt;p&gt;所以另外從非官方倉儲下載 wheel 來用。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/fredrikaverpil/pyside2-wheels" title="github.com/fredrikaverpil"&gt;https://github.com/fredrikaverpil/pyside2-wheels&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下載了編譯完成的 wheel (Python 3.4) 後，按照下方 Readme 的說明安裝。&lt;/p&gt;
&lt;p&gt;這個套件提供者是將 Qt 版本分開裝的，所以會和 PyQt 使用的資料庫不一樣。&lt;/p&gt;
&lt;p&gt;不過不須擔心這個問題，因為包好的 wheel 會直接讀安裝的 Qt 資料庫，可以不用裝說明裡的套件。&lt;/p&gt;
&lt;p&gt;以下連結有 4 個平台的 PySide 2 載點，只需使用 &lt;code&gt;pip install&lt;/code&gt; 或 &lt;code&gt;pip3 install&lt;/code&gt; 就能裝成功。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://bintray.com/fredrikaverpil/pyside2-wheels/pyside2/2.0.0.dev0#files/" title="bintray.com"&gt;https://bintray.com/fredrikaverpil/pyside2-wheels/pyside2/2.0.0.dev0#files/&lt;/a&gt;&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050913.html" rel="alternate"></link><published>2016-09-13T21:00:00+08:00</published><updated>2016-09-13T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-13:/blog/40323230ri-zhi-1050913.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 版本子倉儲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PySide 2 一些資料&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 版本子倉儲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PySide 2 一些資料&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;子倉儲&lt;/h1&gt;
&lt;p&gt;將資料夾重新命名後，建立新的倉儲，將 Pyslvs 的程式碼放入。&lt;/p&gt;
&lt;p&gt;再用指令將子倉儲嵌入 Python-solvespace 的倉儲：&lt;/p&gt;
&lt;pre&gt;
git submodule add https://github.com/40323230/Pyslvs-PyQt5 Pyslvs-PyQt5
&lt;/pre&gt;

&lt;p&gt;重新 push 一次，這樣就將子倉儲放在主倉儲中了。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;.gitmodules&lt;/code&gt; 檔案中也會紀錄子倉儲的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/lnJGtQs.png" &gt;&lt;/p&gt;
&lt;p&gt;只是在切換分支時要特別小心，以免造成衝突。&lt;/p&gt;
&lt;p&gt;參考的是 Git 官方英文網站的說明，不過這裡有中文版的：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://git-scm.com/book/zh-tw/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E7%B5%84-Submodules" title="git-scm.com"&gt;https://git-scm.com/book/zh-tw/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E7%B5%84-Submodules&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;PySide 2&lt;/h1&gt;
&lt;p&gt;找了 PySide 的相關資料，發現目前支援 Qt5 的是 PySide 2，是去年開始開發的，仍在努力追上 PyQt 的腳步。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://wiki.qt.io/PySide2" title="wiki.qt.io"&gt;https://wiki.qt.io/PySide2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在開發紀錄中提到還在克服 Qt 5.7 中 shiboken 失去 C++ 11 的支援，所以暫不支援 Qt 5.7。&lt;/p&gt;
&lt;p&gt;也因為如此，今天試圖 build 出 PySide 2 的安裝檔時發生 shiboken 的錯誤，應該就是這個問題，明天會將 Qt 改成 5.6，以裝上 PySide 2。&lt;/p&gt;
&lt;p&gt;另外也先預習 PyQt 轉 PySide 時需要注意的事項，不過目前看下來頂多是信號槽的名稱需要去掉 &lt;code&gt;pyqt&lt;/code&gt; 的字頭。&lt;/p&gt;
&lt;p&gt;其他因為是用 Python 3 開發的關係，內建標準的 String 與 List 格式，不須煩憂 QString 或 QList 的問題。&lt;/p&gt;
&lt;p&gt;而還有用 Super 繼承的問題，在 PySide 中也有 Qt Designer，&lt;code&gt;.ui&lt;/code&gt; 轉換 &lt;code&gt;.py&lt;/code&gt; 上使用 PySide 的程式（或是 Eric 可以自己應變）就行了。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/12</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050912.html" rel="alternate"></link><published>2016-09-12T21:00:00+08:00</published><updated>2016-09-12T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-12:/blog/40323230ri-zhi-1050912.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二對連桿腳&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二對連桿腳&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;參數式界面&lt;/h2&gt;
&lt;p&gt;大部分的界面都統整好了，剩下遮罩沒設定。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/yz2lXJN.png" &gt;&lt;/p&gt;
&lt;p&gt;這些參數確定可用，不過角度格式還不支援。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/PKUskgY.png" &gt;&lt;/p&gt;
&lt;h2&gt;滑鼠加入點&lt;/h2&gt;
&lt;p&gt;在畫布上使用滑鼠右鍵選單就可以在該位置加入座標。&lt;/p&gt;
&lt;p&gt;加入後會出現在左側的表格裡，亦可供編輯。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/GYnvhQz.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;連桿組範例&lt;/h1&gt;
&lt;p&gt;用新的繪圖系統加入了第二組連桿腳。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/G4VXlZe.png" &gt;&lt;/p&gt;
&lt;p&gt;模擬了一下動作，效果還不錯。&lt;/p&gt;
&lt;p&gt;之後會改試試 OpenGL 的模組功能，之前執行範例時會出錯，要找辦法解決。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;另外在 imgur.com 的圖片載了一個副本下來，找時間會移到倉儲上。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/11</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050911.html" rel="alternate"></link><published>2016-09-11T21:00:00+08:00</published><updated>2016-09-11T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-11:/blog/40323230ri-zhi-1050911.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度 - 參數式架構核心完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度 - 參數式架構核心完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;簡略 log：&lt;/p&gt;
&lt;p&gt;大改核心，寫了一條函式將表格轉為 list 型態，並自動儲存成相應的類型。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/1hV4XYP.png" &gt;&lt;/p&gt;
&lt;p&gt;整修後的計算式乾淨多了，沒有型態問題，從對應 list 取出來就行。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DBaMWdj.png" &gt;&lt;/p&gt;
&lt;p&gt;這次大改是因應新的參數表加入，圖中的項目配置方便使用者直接選取後打入新數值。&lt;/p&gt;
&lt;p&gt;而 Commit 的部份沒多加限制，點擊兩下就能修改。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/yz2lXJN.png" &gt;&lt;/p&gt;
&lt;p&gt;執行全部功能正常。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/yX0WKvb.png" &gt;&lt;/p&gt;
&lt;p&gt;不過輸入界面部份還沒做轉換，Point 的加入可能會出問題，所以目前是讀範例做測試。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/10</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050910.html" rel="alternate"></link><published>2016-09-10T21:00:00+08:00</published><updated>2016-09-10T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-10:/blog/40323230ri-zhi-1050910.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;參數式架構&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測試影片&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;參數式架構&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測試影片&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;今天將所有的視窗都用圖層或 Widget 固定化，免得編譯後位置出現落差。&lt;/p&gt;
&lt;p&gt;不過也花了許多時間，之後主要是為參數式編輯做架構。&lt;/p&gt;
&lt;p&gt;最後決定使用單行文字框做輸入。&lt;/p&gt;
&lt;p&gt;未來的輸入界面大約像這樣：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/tqvi7j1.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;參數式界面改良&lt;/h1&gt;
&lt;p&gt;在點座標分頁中新增參數表，使用右鍵可以新增或刪除項目，點擊兩下就能編輯數據與註解。&lt;/p&gt;
&lt;p&gt;而下方加入點的欄位中，可以打入新增的代碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/4AWc7cw.png" &gt;&lt;/p&gt;
&lt;p&gt;雖然整體改換還需要段時間，但是重要的功能已經有雛型了。&lt;/p&gt;
&lt;h2&gt;輸入遮罩&lt;/h2&gt;
&lt;p&gt;遮罩設定存於主視窗中，對話方塊生成時會複製內容，給其所有需要的單行文字框。&lt;/p&gt;
&lt;p&gt;有了這個設定，就能避免使用者亂輸入文字了，基本概念如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
X_coordinate = QLineEdit()
X_coordinate.setValidator(QRegExpValidator(QRegExp(mask)))
&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;mask&lt;/code&gt; 是字串，也是篩選的條件。&lt;/p&gt;
&lt;p&gt;基本規則如下：&lt;/p&gt;
&lt;pre&gt;
[ 任何文字 ]{ 必要出現次數 , 在接下來的長度內 }
&lt;/pre&gt;

&lt;p&gt;中括弧中是打允許使用者的字元。&lt;/p&gt;
&lt;p&gt;如 &lt;code&gt;[a]&lt;/code&gt;，使用者必須打入 1 個小寫的 a 才能再繼續之後的規則，可以使用 &lt;code&gt;[0-9]&lt;/code&gt; 表示 0 至 9 的數字，&lt;code&gt;[a-z]&lt;/code&gt; 表示小寫的 26 個英文字母等等。&lt;/p&gt;
&lt;p&gt;大括弧是篩選條件，默認是 &lt;code&gt;{1, 1}&lt;/code&gt;，第一項是必須打的數量，第二項是這個規則最大的數量。&lt;/p&gt;
&lt;p&gt;小括弧是邏輯順序，跟其他程式語言差不多，如 &lt;code&gt;([a] | [b]{3, 5})&lt;/code&gt; 就是在這個位置可以選擇打入 1 個 a，或是 3 個到 5 個 b。&lt;/p&gt;
&lt;p&gt;至於 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 則是標示貼緊字頭與字尾的符號，能夠比較明確，但是要注意是否會導致字頭設下太多規則，而讓使用者打不了半個字。&lt;/p&gt;
&lt;p&gt;基本規則容易搞混的話，可以使用簡語，如 &lt;code&gt;?&lt;/code&gt; 符號代表 &lt;code&gt;{0, 1}&lt;/code&gt;，就是能選擇要不要輸入的意思，可以省略它打入下個規則的字串。&lt;/p&gt;
&lt;p&gt;其他簡語可以參考&lt;a href="http://doc.qt.io/qt-5/qregexp.html" title="doc.qt.io"&gt;官方網站&lt;/a&gt;的說明。&lt;/p&gt;
&lt;p&gt;以下是 Pyslvs的遮罩：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#超過10個參數
param_10 = '[1-'+str(int(self.Parameter_list.rowCount()/10))+']?' if self.Parameter_list.rowCount()&gt;=10 else ''
#有參數
param_use = '(^[n]'+param_10+'[0-'+str(int(self.Parameter_list.rowCount())-1)+']$|' if self.Parameter_list.rowCount()&gt;=1 else ''
#最小值 -9999.9999 最大值 9999.9999 的數字
mask = param_use+'^[-]?([1-9][0-9]{1,2})?[0-9][.][0-9]{1,4}$'
if param_use: mask += ')'
self.Mask = QRegExpValidator(QRegExp(mask))
self.X_coordinate.setValidator(self.Mask)
self.Y_coordinate.setValidator(self.Mask)
&lt;/pre&gt;

&lt;p&gt;如果參數表長度超過 1，只要開頭打入 &lt;code&gt;n&lt;/code&gt; 這個字母，就會啟用參數規則，而且只能打入目前長度設入的參數代號。&lt;/p&gt;
&lt;p&gt;如果沒有設定參數，文字欄內只能填入最大 9999.9999 的數字。&lt;/p&gt;
&lt;p&gt;因為要讀表的長度，上述設定在參數表新增或移除項目時就會更新。&lt;/p&gt;
&lt;p&gt;另一方面，因為變成了文字欄，為了偵測是否為空值，做了一些小篩選：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
x = self.X_coordinate.text() if not self.X_coordinate.text()=="" else self.X_coordinate.placeholderText()
y = self.Y_coordinate.text() if not self.Y_coordinate.text()=="" else self.Y_coordinate.placeholderText()
&lt;/pre&gt;

&lt;p&gt;至於空的欄位上的淡色文字（Place Holder Text）部份地方只是寫好看的，之後可能就直接讀淡色文字來用。例如編輯視窗中只需要改動 X 軸座標，不小心動到 Y 軸座標時直接刪成空欄位，系統可以填回原本的數值。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;測試影片&lt;/h1&gt;
&lt;p&gt;錄製一段粗糙的影片展示目前基本功能。&lt;/p&gt;
&lt;p&gt;之後會找一個比較好的軟體剪接。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;路徑追蹤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式碼和路徑座標展示&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;動態模擬&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;距離量測&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;iframe src="https://player.vimeo.com/video/182206176" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;a href="https://vimeo.com/182206176"&gt;Pyslvs preview&lt;/a&gt; from &lt;a href="https://vimeo.com/user56487696"&gt;Union000&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/09</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050909.html" rel="alternate"></link><published>2016-09-09T21:00:00+08:00</published><updated>2016-09-09T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-09:/blog/40323230ri-zhi-1050909.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;近似直線機構問題&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;活塞 → 動力源而非被動元件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;參數式設計？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測量能力待加強&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;近似直線機構問題&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;活塞 → 動力源而非被動元件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;參數式設計？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測量能力待加強&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;Fusion 主題&lt;/h2&gt;
&lt;p&gt;使用 QApplication 的主題選擇功能指定主題。&lt;/p&gt;
&lt;p&gt;這樣在 Ubuntu 執行時會強制使用該元件外觀，而非之前節圖的鐵灰色。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
QApplication.setStyle("fusion")
app = QApplication(argv)
run  = MainWindow()
run.show()
exit(app.exec())
&lt;/pre&gt;

&lt;p&gt;Qt 的說明文件提及，雖然 Qt 程式庫擁有 5 種主題，但是所有平台共通的是 &lt;code&gt;fusion&lt;/code&gt; 和 &lt;code&gt;windows&lt;/code&gt;（傳統佈景）主題。&lt;/p&gt;
&lt;p&gt;只在有在特定平台才能正常顯示特定主題，如在麥金塔上使用 &lt;code&gt;macintosh&lt;/code&gt;，Windows XP 上使用 &lt;code&gt;windowsxp&lt;/code&gt;，Windows Vista 以上的作業系統使用 &lt;code&gt;windowsvista&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/AuNkVl3.png" &gt;&lt;/p&gt;
&lt;h2&gt;編輯視窗提取舊資料&lt;/h2&gt;
&lt;p&gt;編輯視窗會在下拉選單變更對象時提取該項目資料，以供參考。&lt;/p&gt;
&lt;p&gt;使用右鍵選單時，亦會嘗試讀取選中的欄位，自動選到該項目。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/hHMwFx7.png" &gt;&lt;/p&gt;
&lt;p&gt;刪除功能的右鍵選單也會將選中的欄位對應下拉式選單。&lt;/p&gt;
&lt;h2&gt;移除驅動軸面板的暫停功能&lt;/h2&gt;
&lt;p&gt;由於暫停的功能也不算是非常必須，所以將停止的功能拿掉。&lt;/p&gt;
&lt;p&gt;若要中止動畫，直接將面板關掉就好了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Qj26wE2.png" &gt;&lt;/p&gt;
&lt;h1&gt;直線機構問題&lt;/h1&gt;
&lt;p&gt;今天嘗試了 Peaucellier 直線機構的模擬，但是在輸入軸轉動的時候碰到一些障礙。&lt;/p&gt;
&lt;p&gt;直線機構無法立即得知其極限，而之前做的路徑追蹤功能只支援&lt;strong&gt;知道範圍&lt;/strong&gt;的圓周運動。&lt;/p&gt;
&lt;p&gt;不過按理說頂多會回傳約束錯誤的訊息，但是沒想到連一度都無法搖擺，不知道是機構卡死還是什麼問題。&lt;/p&gt;
&lt;p&gt;所以想正視這個情況，讓直線機構也可以在 Pyslvs 上模擬。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/wRWDQ3x.png" &gt;&lt;/p&gt;
&lt;p&gt;應該做一個能夠解極限的功能。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;活塞動力源&lt;/h1&gt;
&lt;p&gt;由於程式庫的技術問題，可能無法計算可以改變長度的被動元件，所以將活塞功能改成直線驅動的連桿，可以嘗試讓一活動點進行固定直線運動。&lt;/p&gt;
&lt;p&gt;構成是由節點、兩固定點構成的直線上作動，跟滑塊不同的是，這個項目是無極限的主動元件，利用增量進行移動（使用者可設定範圍），遇到約束衝突會強制結束。&lt;/p&gt;
&lt;p&gt;預計這個功能要加入驅動面板中，讓這個面板能管理主動軸與活塞動力。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;參數式設計&lt;/h1&gt;
&lt;p&gt;想讓 Pyslvs 加入新的參數設計表，紀錄所有使用者使用的參數，支援使用者自行註解、在表內進行交叉運算。&lt;/p&gt;
&lt;p&gt;這樣修改更快，達成機械設計的目的，跟上大部分 CAD 軟體一樣的功能。&lt;/p&gt;
&lt;p&gt;表格會跟點座標和連桿約束等等的項目存入 Data Sheet 中。&lt;/p&gt;
&lt;p&gt;不過這樣所有新增和編輯界面就得做調整。&lt;/p&gt;
&lt;h1&gt;測量能力&lt;/h1&gt;
&lt;p&gt;測量面板目前只有計算點之間的距離，無法測量角度之類，有些不方便。&lt;/p&gt;
&lt;p&gt;有大量現成的數學公式求解，拿來用在點座標結果上是再好不過了。&lt;/p&gt;
&lt;p&gt;預計之後測量、驅動面板會增強許多，上面提到的解極限的功能或許也會歸類在面板類。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/08</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050908.html" rel="alternate"></link><published>2016-09-08T21:00:00+08:00</published><updated>2016-09-08T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-08:/blog/40323230ri-zhi-1050908.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs Demo 功能介紹 錄影準備中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs Demo 功能介紹 錄影準備中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;模擬功能按鈕調整&lt;/h2&gt;
&lt;p&gt;路徑追蹤功能區隔出來，其他兩個面板類的歸在下方。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/le7waBe.png" &gt;&lt;/p&gt;
&lt;p&gt;面板同時只能開啟一個，必須關掉前一個才能切換。&lt;/p&gt;
&lt;p&gt;而開啟新檔時會自動關閉已開啟的面板。&lt;/p&gt;
&lt;h2&gt;路徑座標輸出&lt;/h2&gt;
&lt;p&gt;路徑追蹤功能啟動時做一些小改變，會自動開啟顯示標註。&lt;/p&gt;
&lt;p&gt;現在會將運算後的路徑保留，會顯示在畫面上，使用者可以決定其去留，若是沒刪除，再次執行追蹤功能時結果將覆蓋當前數據。&lt;/p&gt;
&lt;p&gt;因應新增兩個按鈕，分別為清除鈕和結果預覽。&lt;/p&gt;
&lt;p&gt;座標表格亦可匯出成 CSV 表格。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XQwvacu.png" &gt;&lt;/p&gt;
&lt;p&gt;而不同點的路徑現在會用不同顏色呈現了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/VFH69Nr.png" &gt;&lt;/p&gt;
&lt;p&gt;點外觀的分頁中可以調整路徑粗細。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/BgkLaSS.png" &gt;&lt;/p&gt;
&lt;h2&gt;量測面板&lt;/h2&gt;
&lt;p&gt;量測面板可以計算機構任意兩點間的距離，並且顯示滑鼠座標位置，以供滑鼠附近點的座標參考，座標單位已經為縮放調整了。&lt;/p&gt;
&lt;p&gt;面板開啟時會自動開啟顯示標註。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/36wGlPe.png" &gt;&lt;/p&gt;
&lt;h2&gt;驅動軸面板&lt;/h2&gt;
&lt;p&gt;這個面板可以選擇任意設定好的主動軸調整角度，並且還有慢速播放的功能，不過暫停後等待延遲的缺陷還在找方法修正。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/lBrMQBA.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;影片簡介&lt;/h1&gt;
&lt;p&gt;當初預想的功能大部分都快完成了，剩下一些輸出和防呆的細節處理。&lt;/p&gt;
&lt;p&gt;之後想錄製一點說明影片，介紹基本功能之類的，算是專題資料的一部分。&lt;/p&gt;
&lt;p&gt;而如果找不到輸出給其他 CAD 軟體的方式的話，網頁版可能得沿用目前 Data Sheet 的儲存方式。&lt;/p&gt;
&lt;p&gt;網頁版在這學期學習 Java Script 之後，配合專題所學得的技能，應該有能力做一個圖形化界面出來。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/07</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050907.html" rel="alternate"></link><published>2016-09-07T21:00:00+08:00</published><updated>2016-09-07T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-07:/blog/40323230ri-zhi-1050907.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;路徑計算解決&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式碼功能簡介&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyQt5 線程 QThread 教學&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyQt5 信號槽教學&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyQt5 進度條教學&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;路徑計算解決&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式碼功能簡介&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyQt5 線程 QThread 教學&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyQt5 信號槽教學&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PyQt5 進度條教學&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;書籤：&lt;/p&gt;
&lt;p&gt;&lt;a href="#QThread"&gt;PyQt 線程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#pyqtSlot"&gt;PyQt 信號槽&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#QProgressBar"&gt;PyQt 進度條&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;路徑計算解決&lt;/h1&gt;
&lt;p&gt;煩惱多日的路徑問題解決了，是靠觀察程式碼產生結果觀察出判斷式有問題。&lt;/p&gt;
&lt;p&gt;在 Qt 表格的回傳值中&lt;strong&gt;不可以這樣用&lt;/strong&gt;，因為永遠不會發生：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if table_point.item(i, 3).checkState()==True:
    ...
&lt;/pre&gt;

&lt;p&gt;必須這樣用：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
if table_point.item(i, 3).checkState():
    ...
&lt;/pre&gt;

&lt;hr&gt;

&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;程式碼 Demo&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/7C2HXYY.png" &gt;&lt;/p&gt;
&lt;p&gt;這個程式碼使用 matplotlib 繪出圖形，最上端可以設定運算的對象。&lt;/p&gt;
&lt;p&gt;按下「Copy」鈕可以複製到剪貼簿，「Help」鈕會連到之前寫的程式庫網頁。&lt;/p&gt;
&lt;p&gt;PyQt 的剪貼簿用法很簡單：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
clipboard = QApplication.clipboard()
clipboard.setText(self.script.toPlainText())
&lt;/pre&gt;

&lt;p&gt;「Save」可以存成 Python 程式碼，執行過確認沒問題。&lt;/p&gt;
&lt;h2&gt;路徑追蹤&lt;/h2&gt;
&lt;p&gt;追加解析度功能，預設 5 度，最大 45 度，最小到 0.5 度。&lt;/p&gt;
&lt;p&gt;表單也經過篩選，不會加入固定點了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/oorux4u.png" &gt;&lt;/p&gt;
&lt;p&gt;按下「Apply」鈕後會開始執行運算，而且進度條會顯示運算進度（進度無誤）。&lt;/p&gt;
&lt;p&gt;中途隨時可以停止執行，只是一旦停止就會關閉小視窗且刪除暫存資料，要重新計算。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/VRNWAbp.png" &gt;&lt;/p&gt;
&lt;p&gt;執行完畢後，就會自動關閉視窗，呈現路徑圖。&lt;/p&gt;
&lt;p&gt;接著就能調整畫布，用內建的存檔功能存成圖片！&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Uvud38L.png" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/MPRQtB5.png" &gt;&lt;/p&gt;
&lt;p&gt;關於路徑追蹤的視窗，其實花了不少功夫研究 Qt 的功能，將 Python 的教學寫在下面。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="QThread"&gt;&lt;/a&gt;PyQt 線程&lt;/h1&gt;
&lt;p&gt;需要執行序的原因是，程式語言通常會將複雜運算的程序優先度提高，相對畫面的處理較簡單，因此會將「複雜運算」處理完後才會更新畫面顯示。&lt;/p&gt;
&lt;p&gt;若是不想讓視窗凍結，使用排程功能就十分重要，提醒使用者正在運算，亦可以避免輸入過多指令時，因為正在處理「複雜運算」，而無法理會使用者的呼叫。&lt;/p&gt;
&lt;p&gt;線程功能並非平行運算，而是拖慢所有進度，在執行序之間來回處理，以因應多方面需求。&lt;/p&gt;
&lt;p&gt;Python3 雖然有內建 &lt;code&gt;threading&lt;/code&gt; 和 &lt;code&gt;_thread&lt;/code&gt; 的模組，但是還滿難使用與管理的，所以利用 Qt 的功能來替代之。&lt;/p&gt;
&lt;p&gt;可以想像成 QThread 是另一個元件，也是使用 class的方式繼承，基本架構如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class WorkerThread(QThread):
    #這裡是信號（括弧中填入傳出參數類型，沒有就不用）
    #必須擺外面
    done = pyqtSignal(list)

    #初始化
    def __init__(self, parent = None):
        QThread.__init__(self, parent)
        self.stoped = False
        self.mutex = QMutex()

    #執行序（可以很多個）
    def run(self):
        ...
        #完成，發出信號（帶一個 list 參數）
        self.done.emit(nPath)

    #中止序
    def stop(self):
        with QMutexLocker(self.mutex): self.stoped = True
&lt;/pre&gt;

&lt;p&gt;QThread 跟外界溝通的方式是靠信號跟從外部定值（這樣可以從 self 直接讀值）。&lt;/p&gt;
&lt;p&gt;Window 或 Widget 可以如下使用：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class Path_Track_show(QDialog, Ui_Dialog):
    def __init__(self, parent=None):
        super(Path_Track_show, self).__init__(parent)
        ...
        #定義線程
        self.work = WorkerThread()
        #連接啟動信號
        self.buttonBox.button(QDialogButtonBox.Apply).clicked.connect(self.start)
        #連接強制結束訊號
        self.buttonBox.button(QDialogButtonBox.Cancel).clicked.connect(self.stop)
        #連接完成信號
        self.work.done.connect(self.finish)

    #啟動
    def start(self):
        #傳入值（或任何前置作業）
        self.work.Run_list = self.Run_list
        ...
        #啟動
        self.work.start()
        #關閉按鈕（有關GUI項目）
        #會同時執行work和之後的項目
        self.buttonBox.button(QDialogButtonBox.Apply).setEnabled(False)
        ...

    #強制結束
    def stop(self): self.work.stop()

    #完成
    #信號槽接收值（帶一個 list 參數）
    @pyqtSlot(list)
    def finish(self, Path):
        self.Path_data = Path
        #接收後關閉
        self.accept()
&lt;/pre&gt;

&lt;hr&gt;

&lt;h1&gt;&lt;a name="pyqtSlot"&gt;&lt;/a&gt;PyQt 信號槽&lt;/h1&gt;
&lt;p&gt;信號是 Qt 元件用來溝通的方式，通常是「函式」使用「信號物件」發送訊息給連結的「信號槽」，而配戴此信號槽的函式就會在接收訊息的時候開始執行。&lt;/p&gt;
&lt;p&gt;特別注意 PyQt4 和 PyQt5 的信號連接方式有所不同。&lt;/p&gt;
&lt;p&gt;在一個 class 配置「信號物件」：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class a(parentA):
    done = pyqtSignal()
&lt;/pre&gt;

&lt;p&gt;這個物件必須擺在 class 中，不過不行在任何函式裡（包括初始化函式 &lt;code&gt;__init__&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;呼叫方式是跟其他同 class 底下的函式同個位階（如 &lt;code&gt;self&lt;/code&gt;.&lt;code&gt;done&lt;/code&gt; 或 &lt;code&gt;a&lt;/code&gt;.&lt;code&gt;done&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;接著在一個函式配置一個信號槽：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class b(parentB):
    @pyqtSlot()
    def b_1(self):
        ...
&lt;/pre&gt;

&lt;p&gt;然後在需要連接的時段連結它們（亦可以在時機內斷開連結），例如 class b 的初始化：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class b(parentB):
    def __init__(self, parent=None):
        ...
        self.Come_from_A = a()
        self.Come_from_A.done.connect(self.b_1)
&lt;/pre&gt;

&lt;p&gt;最後就是發送信號的時機，剛才的信號物件是 class a 內的函式都可調用的：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
class a(parentA):
    def a_1(self):
        ...
        self.done.emit()
&lt;/pre&gt;

&lt;p&gt;這樣 class b 內的 b_1 就會執行了。&lt;/p&gt;
&lt;p&gt;這些括弧內都是可以帶入參數的，由於 Qt 是 C++ 寫成的，&lt;code&gt;@pyqtSlot()&lt;/code&gt; 的括弧中是填參數類型。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="QProgressBar"&gt;&lt;/a&gt;PyQt 進度條&lt;/h1&gt;
&lt;p&gt;知道線程和信號槽的利用後，處理時控制進度條物件就易如反掌了。&lt;/p&gt;
&lt;p&gt;首先在執行前算一下進度條跑滿後的格數（若是迴圈，會在執行一次時加 1，加到滿）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
self.progressBar.setRange(0, limit)
&lt;/pre&gt;

&lt;p&gt;接著在線程的初始化中設置一個整數 &lt;code&gt;progress_Signal&lt;/code&gt;，從零開始。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
self.progress = 0
&lt;/pre&gt;

&lt;p&gt;執行時的迴圈，用另一個函式發送訊息與增加進度值：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def run(self):
    for i in range(_range_):
        self.progress_going()

def progress_going(self):
        self.progress = self.progress+1
        self.progress_Signal.emit(self.progress)
&lt;/pre&gt;

&lt;p&gt;接收端函式（也許是另一個 class）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
@pyqtSlot(int)
def progressbar_change(self, val): self.progressBar.setValue(val)
&lt;/pre&gt;

&lt;p&gt;連接（在初始化就可以了）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
self.work = WorkerThread()
self.work.progress_Signal.connect(self.progressbar_change)
&lt;/pre&gt;

&lt;hr&gt;

&lt;p&gt;最重要的功能做完了，最終也學會了難懂的信號槽（以前都是編譯器幫忙產生的），剩下的功能應該也能順利做完。&lt;/p&gt;
&lt;p&gt;雖然最終沒有在暑假內完成專題的項目，但是也學會許東西，培養出快速統整資料並架構化的能力。&lt;/p&gt;
&lt;p&gt;覺得自己需要多練習語言表達的部份，因為可能統整資料十分明瞭，在口語上卻節奏太快，順著聽者的思路呈現才是最重要的方向。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;P.S Roger 用 wordpress 架了一個存文章的網站：&lt;a href="http://roger-blog.tk/" title="roger-blog.tk"&gt;http://roger-blog.tk/&lt;/a&gt;&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/06</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050906.html" rel="alternate"></link><published>2016-09-06T21:00:00+08:00</published><updated>2016-09-06T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-06:/blog/40323230ri-zhi-1050906.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;表格管理與程式碼&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路徑計算問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;表格管理與程式碼&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路徑計算問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;表格管理&lt;/h2&gt;
&lt;p&gt;新增調整連桿和呆鍊順序的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/c5lH4lb.png" &gt;&lt;/p&gt;
&lt;p&gt;但是 slvs 程式庫處理的結果似乎和約束順序無關。&lt;/p&gt;
&lt;p&gt;不論是調整表格順序，還是調動範例 code 裡的順序，結果都一樣。&lt;/p&gt;
&lt;p&gt;點座標的表格現在多了當前座標欄位，和初始座標區隔開。&lt;/p&gt;
&lt;p&gt;運算時是使用初始座標，當前座標是繪圖用的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/1X4Tfu7.png" &gt;&lt;/p&gt;
&lt;p&gt;這樣按理說產生的點座標和約束條件就和範例一樣了，但是仍然沒解決。&lt;/p&gt;
&lt;h2&gt;程式碼輸出&lt;/h2&gt;
&lt;p&gt;將字串和文字區塊作合併，存成一個 object，但是還未回傳主程式。&lt;/p&gt;
&lt;p&gt;以下是加入點座標的範例。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Script = ""
#初始化
Script += """
sys = System(1000)
p0 = sys.add_param(0.0)
p1 = sys.add_param(0.0)
p2 = sys.add_param(0.0)
Point0 = Point3d(p0, p1, p2)
qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
p3 = sys.add_param(qw)
p4 = sys.add_param(qx)
p5 = sys.add_param(qy)
p6 = sys.add_param(qz)
Normal1 = Normal3d(p3, p4, p5, p6)
Workplane1 = Workplane(Point0, Normal1)

p7 = sys.add_param(0.0)
p8 = sys.add_param(0.0)
Point1 = Point2d(Workplane1, p7, p8)
Constraint.dragged(Workplane1, Point1)
"""
...
#加入點
Script += """p"""+str(i+7)+""" = sys.add_param("""+str(float(table_point.item(i, 1).text()))+""")
p"""+str(i+8)+""" = sys.add_param("""+str(float(table_point.item(i, 2).text()))+""")
Point"""+str(i+1)+""" = Point2d(Workplane1, p"""+str(i+8)+""", p"""+str(i+9)+""")
"""
#如果點固定
Script += """Constraint.dragged(Workplane1, Point"""+str(i+1)+""")
"""
&lt;/pre&gt;

&lt;hr&gt;

&lt;h1&gt;路徑計算&lt;/h1&gt;
&lt;p&gt;今天嘗試過許多方法，但是未能讓路徑運算功能的結果與 Python 3 執行範例的結果一樣。&lt;/p&gt;
&lt;p&gt;逐步將其他功能做起來，也許能幫助檢查為何無法算出正確的結果。&lt;/p&gt;
&lt;p&gt;以下是直接將執行範例的結果畫在圖層上，違和感滿大的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/baYNsJv.png" &gt;&lt;/p&gt;
&lt;p&gt;接著會先著重於程式碼輸出的部份，拿來和範例比對，希望能找出錯誤。&lt;/p&gt;
&lt;p&gt;如果必要的話，也許有些複雜的能會暫時移除。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050905.html" rel="alternate"></link><published>2016-09-05T21:00:00+08:00</published><updated>2016-09-05T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-05:/blog/40323230ri-zhi-1050905.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;小細節修正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式碼顯示功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路徑計算問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;小細節修正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程式碼顯示功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路徑計算問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;繪圖選項&lt;/h2&gt;
&lt;p&gt;新增顯示尺度和反黑背景的選項。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/GR2XV7W.png" &gt;&lt;/p&gt;
&lt;h2&gt;佈署面板&lt;/h2&gt;
&lt;p&gt;由於碰到一些小障礙，所以就先作模擬面板的部份。&lt;/p&gt;
&lt;p&gt;之所以使用嵌入的 Widget，是因為必須一面看著畫布作調整，所以都放在主視窗作業會比較好。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/mzzttQV.png" &gt;&lt;/p&gt;
&lt;p&gt;不過之間的傳輸功能還在研究，和視窗設定的形式不一樣，不能在關閉的瞬間偵測。&lt;/p&gt;
&lt;h2&gt;右鍵選單&lt;/h2&gt;
&lt;p&gt;由於發現會受表格標頭欄厚度的影響，微調了一下右鍵選單的位置，不過這些定值會因為字體大小而改變。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/i1HaiEu.png" &gt;&lt;/p&gt;
&lt;p&gt;拆開滑鼠游標的 X Y 位置作像素調整：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def on_point_context_menu(self, point):
    pos = QPoint(point.x()+43, point.y()+23)
    action = self.popMenu_point.exec_(self.Entiteis_Point.mapToGlobal(pos))
    ...
&lt;/pre&gt;

&lt;p&gt;以及偵測加入項目後出現欄的寬度：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def on_link_context_menu(self, point):
    if self.Entiteis_Link.rowCount()==0: pos = QPoint(point.x()+3, point.y()+23)
    else: pos = QPoint(point.x()+15, point.y()+23)
&lt;/pre&gt;

&lt;h2&gt;存檔提示&lt;/h2&gt;
&lt;p&gt;視窗標題會在修改後，未存檔時多出星號。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vu3IpEj.png" &gt;&lt;/p&gt;
&lt;p&gt;讀檔、開新檔案、存檔後星號會消失。&lt;/p&gt;
&lt;p&gt;在沒有星號的情形下，關閉程式時不會提示是否存檔。&lt;/p&gt;
&lt;h2&gt;圖形顏色對應&lt;/h2&gt;
&lt;p&gt;利用 Python 的 dict 鍵值功能作顏色對應表，基本概念如下：&lt;/p&gt;
&lt;pre&gt;
dict = {key1 : value1, key2 : value2}
dict[key1] 得 value1
dict[key2] 得 value2
&lt;/pre&gt;

&lt;p&gt;可以使用 zip 來將兩個 list 縫合，顏色代碼對應 Qt 的 Name space。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
self.Color = dict(zip(self.re_Color, val_Color))
&lt;/pre&gt;

&lt;p&gt;這樣就可得（無定義則用綠色）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
try: pen.setColor(self.Color[self.table_style.item(i, 1).text()])
except KeyError: pen.setColor(Qt.green)
&lt;/pre&gt;

&lt;p&gt;以下是目前支援的顏色表：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/difDk5c.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Print 程式碼&lt;/h1&gt;
&lt;p&gt;新增一個功能，會在監視窗中 Print 所有迴圈呈現的程式碼。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/IaWfQ3B.png" &gt;&lt;/p&gt;
&lt;p&gt;這個功能目前僅只於 print，之後會做成顯示在視窗中、存成文字的功能。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;路徑計算問題&lt;/h1&gt;
&lt;p&gt;將約束帶入後似乎出現了問題，還在研究如何解決。&lt;/p&gt;
&lt;p&gt;路徑計算功能能夠畫出指定點（可複數）的移動軌跡，設定視窗中使用兩個表單達成這個功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vAZJs5i.png" &gt;&lt;/p&gt;
&lt;p&gt;結果計算後變成 180° 之後的軌跡出現錯亂。&lt;/p&gt;
&lt;p&gt;下圖繪製 Point2 和 Point3 的軌跡，Point3 的圓周運動是一切正常，但是 Point2 在繞回來時運算不知道為何出了嚴重的錯誤，畫在不可能出現的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/VYzwVFZ.png" &gt;&lt;/p&gt;
&lt;p&gt;由於這部份功能的程式滿大的，也是用自己的邏輯手寫的，可能會漏一些沒注意的地方，檢查費了不少功夫。&lt;/p&gt;
&lt;p&gt;原理是用一整個 list object 傳送座標群的，包含選擇的點，從 start angle 到 end angle 的範圍，理論上是三維的。&lt;/p&gt;
&lt;p&gt;不過迴圈迭代時有點小毛病，所以改成 object[0] 是第一個點的 X 軸，object[1] 是 Y 軸，object[2] 是第二個點的 X 軸，以此類推。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#取值用的迴圈
for i in range(0, len(self.Path), 2):
    X_path = self.Path[i]
    Y_path = self.Path[i+1]
&lt;/pre&gt;

&lt;p&gt;可能是 slvs 程式庫的約束處理問題，因為我是先將「呆鍊」組成三角形後才約束「連桿」接起，因而動到主動軸的點，產生了這個問題。&lt;/p&gt;
&lt;p&gt;相反地，「客製化」零件的約束順序採用最保險的方式，所以沒有這個問題。&lt;/p&gt;
&lt;p&gt;歸納幾個解決方式，是製作以下功能（都會加入）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;調整表格順序的功能（決定優先權，比較好知道原因）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;優先偵測主動軸的參照點，優先定義與其相關的連桿約束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前提到的，因為這部份程式碼滿大的，跨了3個檔案，所以可能要一些時間處理。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/03</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050903.html" rel="alternate"></link><published>2016-09-03T21:00:00+08:00</published><updated>2016-09-03T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-03:/blog/40323230ri-zhi-1050903.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;QPaint 繪圖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模擬功能-目標&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;QPaint 繪圖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模擬功能-目標&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;QPaint&lt;/h1&gt;
&lt;p&gt;其實 QPaint 繪圖就跟 slvs 程式庫滿像的，只需要擔心順序（圖層）問題。&lt;/p&gt;
&lt;p&gt;用 QPaint 繪圖的話，想辦法將最新的座標 copy 進去就行了。&lt;/p&gt;
&lt;p&gt;把繪圖的 Widget 和處理 list 的副程式獨立出來，名為 &lt;code&gt;canvas.py&lt;/code&gt; 和 &lt;code&gt;list_process&lt;/code&gt;，沒什麼影響，讓主程式不會太雜亂。&lt;/p&gt;
&lt;p&gt;Class 中宣告一個名為 &lt;code&gt;update_figure&lt;/code&gt; 的函式，主程式要刷新時就會呼叫，並填進主程式的表單，這個函式就會將所有表單填進 &lt;code&gt;self&lt;/code&gt; 的 object 裡，讓 &lt;code&gt;paintEvent&lt;/code&gt; 函式讀取。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def update_figure(self, table_point, table_line,
        table_chain, table_shaft,
        table_slider, table_rod,
        table_style, zoom_rate):
    self.Xval = []
    self.Yval = []
    zoom = float(zoom_rate.replace("%", ""))/100
    self.table_point = table_point
    ...
    self.update()
&lt;/pre&gt;

&lt;p&gt;之所以這樣寫，是因為 &lt;code&gt;paintEvent&lt;/code&gt; 函式和所有 Qt 的 &lt;code&gt;Event&lt;/code&gt; 函式都不能輸入 &lt;code&gt;event&lt;/code&gt; 以外的參數。&lt;/p&gt;
&lt;p&gt;而且 Qt 有規定 QPainter 只能畫在 &lt;code&gt;paintEvent&lt;/code&gt; 函式中，不然會出錯。而這個函式也同時決定重新繪製的時機（視窗縮放，改變大小時）。&lt;/p&gt;
&lt;p&gt;若想手動刷新，對 Widget 物件下 &lt;code&gt;self.update()&lt;/code&gt; 或 &lt;code&gt;self.repaint()&lt;/code&gt;（不建議，閃爍頻率高）就行了。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;event&lt;/code&gt; 參數是專門傳入事件發生相關的數據，如滑鼠座標：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
def mouseMoveEvent(self, event):
    if self.drag:
        self.origin_x = event.x()
        self.origin_y = event.y()
        self.update()
&lt;/pre&gt;

&lt;p&gt;能夠繪圖後，必須校正視圖的大小和位置，由於大小要看這個機構的基本尺寸是多少，所以給使用者自己調整是最好的方法了。&lt;/p&gt;
&lt;p&gt;預設是將座標尺度放大兩倍後定義為畫布的一倍，所以剛才的 &lt;code&gt;update_figure&lt;/code&gt; 中有下列轉換式：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
for i in range(table_point.rowCount()):
    self.Xval += [float(table_point.item(i, 1).text())*zoom*rate_all]
    self.Yval += [float(table_point.item(i, 2).text())*zoom*rate_all*(-1)]
&lt;/pre&gt;

&lt;p&gt;Y 軸座標乘上負號是因為不論 Window 和 Widget，兩者都是從「標題欄」往下延伸的，所以向下是負值。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/tqzbuxp.png" &gt;&lt;/p&gt;
&lt;p&gt;上次更新中加入沒用到的 QSlider 滑桿，這次讓它能夠定義放大的倍率，從 50％ 到 500％，應該都能夠支援幾乎所有尺度的機構了。&lt;/p&gt;
&lt;p&gt;另外調整畫布大小可以用 &lt;kbd&gt;Ctrl&lt;/kbd&gt; + 滑鼠滾輪調整，&lt;kbd&gt;Ctrl&lt;/kbd&gt; + 左鍵按住拖移或雙擊可以定義原點位置。&lt;/p&gt;
&lt;p&gt;這樣設定是讓使用者不會亂拉將圖面移走，也更能知道機構樣貌。&lt;/p&gt;
&lt;p&gt;而這次顏色設定暫時只有 R、G、B 三色，其他色碼的加入還要看下說明文件，原本的顏色都偏亮或太黯淡，所以會整合後加入其他顏色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;＊上次的 mpl 畫布就有加入存成 png 圖片的功能了，想不到現在 QPainter 也能如法炮製。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好像大部分 Widget 都能用這個方式截圖，不過 OpenGL 不知道可不可行。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
fileName, sub = QFileDialog.getSaveFileName(self, 'Save file...', '../', 'PNG file(*.png)')
if fileName:
    fileName = fileName.replace(".png", "")
    fileName += ".png"
    pixmap = self.mplWindow.grab()
    pixmap.save(fileName)
&lt;/pre&gt;

&lt;hr&gt;

&lt;h1&gt;模擬功能&lt;/h1&gt;
&lt;p&gt;主要關鍵都在 Drive Shaft （驅動軸）的清單上，太多驅動軸就會有很多組解，可能要慢慢代入；活塞部份還沒想到怎做。&lt;/p&gt;
&lt;p&gt;期望模擬的部份有如下效果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;畫出機構運動時指定點（可複數）路徑，路徑可以用線條或打點的方式繪出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相關動畫的展示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用者觀看自訂角度（滑鼠在圖面上拖拉最佳）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測量工具（指定點距離）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/02</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050902.html" rel="alternate"></link><published>2016-09-02T21:00:00+08:00</published><updated>2016-09-02T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-02:/blog/40323230ri-zhi-1050902.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;改換 Qt 5.7 與 PyQt 5.7&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些操作重點&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;改換 Qt 5.7 與 PyQt 5.7&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些操作重點&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Qt 5.3 -&amp;gt; 5.7&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Qt 5.8 預計今年11月29日釋出穩定版&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;一些繪圖功能需要較高的 Qt 版本才支援，所以選擇升級了當前的函式庫。&lt;/p&gt;
&lt;p&gt;將需要的 Qt 版本載下來，不須舊版的話可以刪掉。&lt;/p&gt;
&lt;p&gt;要切換 Qt 的版本，必須修改之前的 &lt;code&gt;.bashrc&lt;/code&gt; 的目錄至切換的版本，並重新建立 QMake 的軟連結，這樣就可以了（對 C++ 的使用者來說）。&lt;/p&gt;
&lt;pre&gt;
$sudo rm -f /usr/bin/qmake
$sudo ln -s /opt/Qt/5.7/gcc_64/bin/qmake /usr/bin/qmake
&lt;/pre&gt;

&lt;p&gt;但是對其他語言的使用者來說，必須將接口套件的設定一起切換版本，所以得重新安裝 Python 的 PyQt（亦或 PySide）。&lt;/p&gt;
&lt;p&gt;使用下列指令刪除 PyQt：&lt;/p&gt;
&lt;pre&gt;
$sudo rm -r -f /usr/lib/python3/dist-packages/PyQt5
&lt;/pre&gt;

&lt;p&gt;然後從&lt;a href="https://riverbankcomputing.com/software/pyqt/download5" title="riverbankcomputing.com"&gt;官方載點&lt;/a&gt;下載 Linux 版本。&lt;/p&gt;
&lt;p&gt;照著之前的範例重新安裝 PyQt、QScintilla2、Eric6，並修改 Eric6 的相關設定。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CAdFahb.png" &gt;&lt;/p&gt;
&lt;p&gt;裝完後，若 Eric 安裝時出現版本過低的狀況，就必須完全刪除 PyQt 再重新安裝。&lt;/p&gt;
&lt;p&gt;若是出現缺少一些套件的狀況，請使用 &lt;code&gt;apt-get&lt;/code&gt; 下載安裝，相關名稱如下網站所示。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://packages.ubuntu.com/search?keywords=python3-pyqt5" title="packages.ubuntu.com"&gt;http://packages.ubuntu.com/search?keywords=python3-pyqt5&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;安裝後檢查&lt;/h1&gt;
&lt;p&gt;即使安裝完成，都能啟動或匯入相關套件，因為是重新安裝，還是得檢查一下是否載到舊版的檔案。&lt;/p&gt;
&lt;p&gt;在 Python3 的直譯器中檢查：&lt;/p&gt;
&lt;pre&gt;
&gt;&gt;&gt;from PyQt5.QtCore import qVersion
&gt;&gt;&gt;print("Qt Version: {0}".format(qVersion.strip()))
#顯示 Qt 版本

&gt;&gt;&gt;from PyQt5.QtCore import PYQT_VERSION_STR as pyqtVersion
&gt;&gt;&gt;print("PyQt Version:", pyqtVersion.strip())
#顯示 PyQt 版本
&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/MBTakmh.png" &gt;&lt;/p&gt;
&lt;p&gt;在 Eric6 的 Settings -&amp;gt; Show extermal tools 選項中，載入所有相關的工具版本。&lt;/p&gt;
&lt;p&gt;下圖中的 Qt 工具版本均要一致，選擇的部份是 PyQt，非常重要，因為和 Python 中顯示的版本是一樣的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/KtevLeH.png" &gt;&lt;/p&gt;
&lt;p&gt;另一個就是觀察 Qt 附的相關工具，不過只要載對版本應該都是對的，僅供參考。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rbnu8Gy.png" &gt;&lt;/p&gt;
&lt;p&gt;新版的 Qt 工具也會支援新功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nyrxK7y.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;稍微看過上次範例倉儲的程式碼，QPainter 是可以和 QOpenGL 的元件組合使用的，不過如果直接插入空的圖形化元件，會造成程式視窗內黑屏，應該要另外設定。&lt;/p&gt;
&lt;p&gt;新版的 Qt 支援 OpenGL3D 的嵌入，會找一些範例，作到和之前 bokeh 套件相仿的功能，再把其他運算功能補齊（或許之後會做銜接其他 CAD 軟體的格式），本機解題+繪圖專案就完成了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/LuIz34p.png" &gt;
&lt;img src="http://i.imgur.com/tKoNPIx.png" &gt;&lt;/p&gt;
&lt;p&gt;專題在 Python Solvespace 的部份在想要如何結構化，因為尚未圖形化的編譯部份比較難呈現，如果將現成的程式理論搬上報告又有點太「資訊系」和發散了些。&lt;/p&gt;
&lt;p&gt;預計報告中會包含一部分原版 Solvespace 的解說，還有 SWIG 相關的原始碼呈現。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/09/01</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050901.html" rel="alternate"></link><published>2016-09-01T21:00:00+08:00</published><updated>2016-09-01T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-09-01:/blog/40323230ri-zhi-1050901.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些 QPainter 及 OpenGL 的資料連結&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些 QPainter 及 OpenGL 的資料連結&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;今天花時間在整修細節的部份（包括讀寫檔和繪圖時機），所以只有暫時將 matplotlib 的畫布隱藏到參數 &lt;code&gt;-mpl&lt;/code&gt; 裡。&lt;/p&gt;
&lt;p&gt;想要用 matplotlib 繪圖時要加上上述參數，不然只會使用 QPainter 的 Widget。&lt;/p&gt;
&lt;p&gt;不過這個地方還沒做好，還沒研究 QPainter 上的細節。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/uX1kSGK.png" &gt;&lt;/p&gt;
&lt;p&gt;另外將 crank_rocker 範例存成 Pyslvs 可用的 CSV 表格，可以隨時讀進來 Demo。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ulsX1Jl.png" &gt;&lt;/p&gt;
&lt;p&gt;至於繪圖時機，採用的是 resizeEvent，當偵測到 Widget 大小改變時會觸發。&lt;/p&gt;
&lt;p&gt;原先想使用 paintEvent，但是不知道為何改用在主視窗後就會一直重新整理，很吃資源，所以只好改用相近的 resizeEvent。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;QPainter 及 OpenGL 參考資料&lt;/h1&gt;
&lt;p&gt;官方 Qt 文件： &lt;a href="http://doc.qt.io/qt-5/qpainter.html" title="doc.qt.io"&gt;http://doc.qt.io/qt-5/qpainter.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OpenGL 範例： &lt;a href="https://github.com/baoboa/pyqt5/tree/master/examples/opengl" title="github.com"&gt;https://github.com/baoboa/pyqt5/tree/master/examples/opengl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;還沒深入看過介紹，只看過一些簡單的 QPainter 範例。&lt;/p&gt;
&lt;p&gt;另外 PyQt5 的 QOpenGLWidget 要另外安裝：&lt;/p&gt;
&lt;pre&gt;
$sudo apt-get install python3-pyqt5.qtopengl
$sudo apt-get install libqt5opengl5
&lt;/pre&gt;

&lt;p&gt;不過安裝套件一直有麻煩，已經是最新版可是 import 還是找不到，在想是不是安裝位置問題。&lt;/p&gt;
&lt;p&gt;網際應用程式方面只查到 PHP 與 OpenGL 整合的範例，Qt 的部份貌似只能在本機端執行。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/31</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050831.html" rel="alternate"></link><published>2016-08-31T21:00:00+08:00</published><updated>2016-08-31T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-31:/blog/40323230ri-zhi-1050831.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度 - 繪圖功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度 - 繪圖功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;畫布嵌入&lt;/h1&gt;
&lt;p&gt;成功嵌入畫布，使用另一個繼承自 &lt;code&gt;matplotlib&lt;/code&gt;.&lt;code&gt;backends&lt;/code&gt;.&lt;code&gt;backend_qt5agg&lt;/code&gt;.&lt;code&gt;FigureCanvasQTAgg&lt;/code&gt;（更名為&lt;code&gt;FigureCanvas&lt;/code&gt;）的 class 函式 &lt;code&gt;DynamicMplCanvas&lt;/code&gt;來繪製點座標。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/lRrnk7z.png" &gt;&lt;/p&gt;
&lt;p&gt;這個 class 只包含三個功能，初始化圖形、清除畫布、更新畫布。&lt;/p&gt;
&lt;p&gt;而在主視窗的 &lt;code&gt;__init__&lt;/code&gt; 中初始在預設的 Layout 中嵌入一個 Widget（名稱為「mplWindow」），複製 &lt;code&gt;DynamicMplCanvas()&lt;/code&gt; 的格式來用。&lt;/p&gt;
&lt;p&gt;當初 &lt;code&gt;DynamicMplCanvas()&lt;/code&gt; 是參考自網站範例：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://matplotlib.org/examples/user_interfaces/embedding_in_qt4.html" title="matplotlib.org"&gt;http://matplotlib.org/examples/user_interfaces/embedding_in_qt4.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;後來改寫成可以匯入表格代參數的功能。&lt;/p&gt;
&lt;p&gt;目前畫布只有支援繪製節點、連桿和呆鍊，以下是繪製未約束的呆鍊。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XZfsLGI.png" &gt;&lt;/p&gt;
&lt;p&gt;而另外也修正一些程式庫帶入重疊點的問題，會自動增加偏移量。&lt;/p&gt;
&lt;p&gt;表格在畫布重新繪製時也會作修改，重新繪製的功能目前是&lt;em&gt;手動的&lt;/em&gt;，所以還待改進。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/30</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050830.html" rel="alternate"></link><published>2016-08-30T21:00:00+08:00</published><updated>2016-08-30T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-30:/blog/40323230ri-zhi-1050830.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;寫了算點程式（&lt;code&gt;calculation.py&lt;/code&gt;）的雛型，目前只 &lt;code&gt;print&lt;/code&gt; 出來結果，還沒直接寫進表格。&lt;/p&gt;
&lt;p&gt;而以後模擬的路徑座標功能會寫在同個檔案裡。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/SIZhCiM.png" &gt;&lt;/p&gt;
&lt;p&gt;由於 Python 在記憶體中的物件名稱不能撞名，所以如果是用 launch 腳本來帶動整個程式執行的話，若其中有部件互相 &lt;code&gt;import&lt;/code&gt; ，會造成暫存檔重疊而無法載入，這種方法只適用啟動一端的腳本。&lt;/p&gt;
&lt;p&gt;所以在 class 中寫了一條指令 &lt;code&gt;Reload_Canvas&lt;/code&gt;，讓它將表格物件代入 &lt;code&gt;calculation.py&lt;/code&gt; 的 &lt;code&gt;table_process&lt;/code&gt; 中，回傳點座標的 list 回來。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Reload_Canvas&lt;/code&gt; 打算也會有判斷 Solve 成功或失敗的功能，會跳出警告，亦不會覆寫到原本的表格上。&lt;/p&gt;
&lt;p&gt;程式碼大約的樣子：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Ayh1BHm.png" &gt;&lt;/p&gt;
&lt;p&gt;執行結果（加入 Point2 後回傳第三組點座標）：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/o8iA22K.png" &gt;&lt;/p&gt;
&lt;p&gt;目前加入 Link 的表單，約束距離的功能正常。&lt;/p&gt;
&lt;p&gt;不過碰到無法對重合點作距離約束的情況，可能要提前作座標修正（增加間隙）。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Reload_Canvas 函式應當是在表格增刪或是編輯後執行，不過如果顯示失敗的話相當麻煩，可能之後會做1步復原功能之類的。&lt;/p&gt;
&lt;p&gt;而繪圖功能比較沒那麼繁瑣，會拖比較後面。&lt;/p&gt;
&lt;p&gt;隔天要回虎尾搬遷宿舍，所以能利用時間較少，預計下午後做好 &lt;code&gt;table_process&lt;/code&gt; 整體功能，包括座標修正的判斷。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/29</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050829.html" rel="alternate"></link><published>2016-08-29T21:00:00+08:00</published><updated>2016-08-29T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-29:/blog/40323230ri-zhi-1050829.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SQLite 資料&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SQLite 資料&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;新增一個類似活塞／彈簧的連結器，可以自訂最大和最小拉伸長度。&lt;/p&gt;
&lt;p&gt;造型方面應該只會改線段顏色。&lt;/p&gt;
&lt;p&gt;不過不知道程式方面怎寫，因為程式庫中沒有類似約束，可能要寫在外部，帶入最大值／最小值／範圍內（不須約束）的結果。&lt;/p&gt;
&lt;p&gt;至於彈簧的彈性效果可能作不太出來，所以目前是朝活塞桿設計。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/uZrfXYx.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;SQLite 資料庫&lt;/h1&gt;
&lt;p&gt;上網找了一些有關寫入寫出 Data Base 的範例，主要是 Python 官方的解說。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3.4/library/sqlite3.html" title="docs.python.org"&gt;https://docs.python.org/3.4/library/sqlite3.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.runoob.com/sqlite/sqlite-python.html" title="runoob.com"&gt;http://www.runoob.com/sqlite/sqlite-python.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/UwwvSQ5.png" &gt;&lt;/p&gt;
&lt;p&gt;不過主要還是研究 peewee 套件的功能。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://docs.peewee-orm.com/en/latest/peewee/quickstart.html" title="docs.peewee-orm.com"&gt;http://docs.peewee-orm.com/en/latest/peewee/quickstart.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;peewee 的用法比較直覺化一些，畢竟不用對 C++ 資料庫下指令。&lt;/p&gt;
&lt;p&gt;不過上網找了一下 FreeCAD 的技術文件，沒有提到關於 Data Base 如何匯入 2D 圖形的解說，只有模擬材料表的格式。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.freecadweb.org/wiki/index.php?title=Material" title="freecadweb.org"&gt;http://www.freecadweb.org/wiki/index.php?title=Material&lt;/a&gt;&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/28</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050828.html" rel="alternate"></link><published>2016-08-28T21:00:00+08:00</published><updated>2016-08-28T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-28:/blog/40323230ri-zhi-1050828.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測試程式庫能否支援 Python 的 list 型態&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測試程式庫能否支援 Python 的 list 型態&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;h2&gt;旋轉軸及滑塊清單&lt;/h2&gt;
&lt;p&gt;和點、連桿、呆鍊一樣都有增刪功能，不過還沒支援右鍵選單。&lt;/p&gt;
&lt;p&gt;一些細節也可能還沒做好，需要一些時間修正。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/rWzmiDc.png" &gt;&lt;/p&gt;
&lt;h2&gt;CSV 匯出入功能調整&lt;/h2&gt;
&lt;p&gt;現在可以支援匯出整個工作簿存檔，並能完整載入所有表格。&lt;/p&gt;
&lt;p&gt;意味著可以保留工作階段而不會遺失。&lt;/p&gt;
&lt;p&gt;在每個表格間插入的是 &lt;code&gt;Next_table&lt;/code&gt; 這個欄位來辨識。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/obOpMJz.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;算點程式測試&lt;/h1&gt;
&lt;p&gt;打算使用 Python 的 list 來存 SLVS 程式庫的 &lt;code&gt;Point&lt;/code&gt; 或 &lt;code&gt;Line&lt;/code&gt;，對迴圈的相性比較好。&lt;/p&gt;
&lt;p&gt;所以建立了一個清單物件 &lt;code&gt;draw&lt;/code&gt;，來測試看看能不能存入後提出來給約束函式用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/IoRqjaT.png" &gt;&lt;/p&gt;
&lt;p&gt;結果是可行的。&lt;/p&gt;
&lt;p&gt;上面測試寫法有點累贅，應該直接用 &lt;code&gt;draw += [Point]&lt;/code&gt; 加入清單就可以了。&lt;/p&gt;
&lt;p&gt;這樣支援迴圈讀取就十分不錯了，只是在 &lt;code&gt;import&lt;/code&gt; 的部份還需要另外測試。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/27</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050827.html" rel="alternate"></link><published>2016-08-27T21:00:00+08:00</published><updated>2016-08-27T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-27:/blog/40323230ri-zhi-1050827.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linkage 的參考心得&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linkage 的參考心得&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;運動約束類型&lt;/h1&gt;
&lt;p&gt;打算使用主動旋轉軸和滑塊用在繪製動態圖或是移動路徑上。&lt;/p&gt;
&lt;p&gt;旋轉軸可以在定義的角度範圍中旋轉，滑塊則是一個被約束在直線上的點（至於滑動範圍不知道程式庫是否能辦得到）。&lt;/p&gt;
&lt;p&gt;在模擬選項中可以調整：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;靜態移動 - 所有旋轉軸待在某個角度時，整體機構的外觀狀態。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移動路徑 - 指定一點位置，轉動所有旋轉軸（或自訂），畫出移動路徑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前旋轉軸和滑塊的新增方式都和其他實體一樣。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;字型大小&lt;/h1&gt;
&lt;p&gt;系統會因為字型大小的問題而跑出外框，只能調整多一點的空間給太大的字。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/mE1vIkO.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Linkage&lt;/h1&gt;
&lt;p&gt;參考了技術手冊的介紹和使用說明，Linkage 有一些滿複雜的功能，也支援彈簧計算之類的。&lt;/p&gt;
&lt;p&gt;應該能夠在 Pyslvs 中加入一些值得使用的優點，不過實作性要先評估。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/26</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050826.html" rel="alternate"></link><published>2016-08-26T21:00:00+08:00</published><updated>2016-08-26T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-26:/blog/40323230ri-zhi-1050826.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些後續寫法想法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些後續寫法想法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;圖層統整&lt;/h1&gt;
&lt;p&gt;重新編排了圖層，以在縮放視窗時還能對齊調整大小，不過空間判定上還需要調整參數，才能達到理想的結果。&lt;/p&gt;
&lt;p&gt;另外有研究下 PyQt 嵌入 matpoltlib 繪圖的資料，大約知道該如何嵌入繪出的結果了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/DyQCMsS.png" &gt;&lt;/p&gt;
&lt;h2&gt;右鍵選單&lt;/h2&gt;
&lt;p&gt;嘗試寫了表格的右鍵選單，功能等同於叫出新增、刪除和編輯的對話方塊。&lt;/p&gt;
&lt;p&gt;不過位置無法置中，參數可能還要看一下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Qdu2JpG.png" &gt;&lt;/p&gt;
&lt;h2&gt;從屬項目刪除&lt;/h2&gt;
&lt;p&gt;刪除點時會將包含這個點的連桿或呆鍊一起刪除。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/viCG92Z.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;程式結構&lt;/h1&gt;
&lt;p&gt;之後大約會將 import 程式庫的程式碼放在 &lt;code&gt;main.py&lt;/code&gt; 同層的資料夾下，互相載入。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;main.py&lt;/code&gt; 中會有一個專門的 def 放在主視窗的 class 外，好讓算點的程式可以讀表格的資料。&lt;/p&gt;
&lt;p&gt;以下是原始碼結構，括弧中還待建構。&lt;/p&gt;
&lt;pre&gt;
Pyslvs
    launch_pyslvs.py（啟動檔）
    icons_rc.py（圖示資源）
    +icons（讀取用圖示）
    +core
        main.py（主程式-待加入）
        （算點程式.py）
        slvs.py
        _slvs.so
        libslvs.so
        +draw（繪圖表管理視窗-已完成）
        +info（提示與說明視窗-待加入）
        +warning（警告視窗-待加入）
        +（模擬表管理視窗）
        +（一些給使用者的設定檔）
&lt;/pre&gt;

&lt;hr&gt;

&lt;p&gt;今天由於花了些時間更新 Ubuntu 版的顯示卡驅動，所以拖了一些時間。&lt;/p&gt;
&lt;p&gt;之後會快點將核心的算點功能做好。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/24</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050824.html" rel="alternate"></link><published>2016-08-24T21:00:00+08:00</published><updated>2016-08-24T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-24:/blog/40323230ri-zhi-1050824.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;新增了管理物件（點、連線、呆鍊）的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/ItXXzqt.png" &gt;&lt;/p&gt;
&lt;h2&gt;刪除物件&lt;/h2&gt;
&lt;p&gt;在選單中選取名稱即可刪除。&lt;/p&gt;
&lt;p&gt;不過還沒為刪除點的連帶影響作調整。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/83q2bA7.png" &gt;&lt;/p&gt;
&lt;h2&gt;編輯物件&lt;/h2&gt;
&lt;p&gt;可以重新複寫物件的狀態而不用刪除。&lt;/p&gt;
&lt;p&gt;包括重新調整點的位置和固定狀態。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/IUbVmBj.png" &gt;&lt;/p&gt;
&lt;h2&gt;點外觀&lt;/h2&gt;
&lt;p&gt;紀錄點的外觀，包括用環圈起來，並能讓使用者直接調整其大小和顏色。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/pVwY0sP.png" &gt;&lt;/p&gt;
&lt;h2&gt;CSV匯入功能&lt;/h2&gt;
&lt;p&gt;後來有把匯出功能調整一下，可以用 &lt;code&gt;Fixed&lt;/code&gt; 和 &lt;code&gt;noFixed&lt;/code&gt; 紀錄點的固定狀態了。&lt;/p&gt;
&lt;p&gt;所以在讀值時，可以將每列的物件精準填入點的列表中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/qL1OB6X.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;因為要讓其他 &lt;code&gt;.py&lt;/code&gt; 檔讀值，又要回傳回 &lt;code&gt;main.py&lt;/code&gt; 中，想要可以浮動創造 Point 並新增約束的功能，所以在思考執行的可行性。&lt;/p&gt;
&lt;p&gt;有嘗試過兩個檔案互相 &lt;code&gt;import&lt;/code&gt;，不過出錯的機率很大，上網尋找的建議是 import 兩邊的檔名就好，需要該物件才會特別指定。&lt;/p&gt;
&lt;p&gt;也就是說直接指定 def 或 class 就會出錯，之後會試試看。&lt;/p&gt;
&lt;p&gt;想要找一個比較保險的方式計算，不然只能盡量避開會衝突的地方。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/23</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050823.html" rel="alternate"></link><published>2016-08-23T21:00:00+08:00</published><updated>2016-08-23T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-23:/blog/40323230ri-zhi-1050823.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;Pyslvs 的界面大致上完成，表單的增加功能都寫好了。&lt;/p&gt;
&lt;h2&gt;主界面&lt;/h2&gt;
&lt;p&gt;右側打算作為繪圖區，只要左邊表單有更動就會更新。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6X6JNKO.png" &gt;&lt;/p&gt;
&lt;h2&gt;增加線條選單&lt;/h2&gt;
&lt;p&gt;讀取既有兩點來規定距離，若為重複點或是點的數目不足就會警告。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/RpYilrT.png" &gt;&lt;/p&gt;
&lt;h2&gt;增加呆鍊選單&lt;/h2&gt;
&lt;p&gt;只能新增三角形呆鍊，不過以解連桿的工具而言，三角形呆鍊已經夠實用。&lt;/p&gt;
&lt;p&gt;同樣會在違反規則時警告。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/m9a1JTe.png" &gt;&lt;/p&gt;
&lt;h2&gt;匯出CSV能力&lt;/h2&gt;
&lt;p&gt;成功撰寫將點座標匯出成CSV的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zziWbkn.png" &gt;&lt;/p&gt;
&lt;p&gt;在其他工作表軟體的匯入畫面。&lt;/p&gt;
&lt;p&gt;以後會在動態模擬那裡針對點座標作相同的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Unis1dy.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;大部分的功能由於都沒接觸過，每換一種元件都要上網搜尋它們取值、設值的用法，Qt 的相關介紹又都是以 C++ 撰寫的，為此研究了一下 Python 物件導向的說明。&lt;/p&gt;
&lt;p&gt;由於再過 2 天就要回去家裡了，所以會盡量將需要整合的工作完成，回去後仍會繼續整理資料。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/21</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050821.html" rel="alternate"></link><published>2016-08-21T21:00:00+08:00</published><updated>2016-08-21T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-21:/blog/40323230ri-zhi-1050821.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leo editor 輸入法問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pyslvs 編譯進度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leo editor 輸入法問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Pyslvs 界面&lt;/h1&gt;
&lt;p&gt;目前編譯的圖形化界面使用常見的功能表做命令設定。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6iqBDFs.png" &gt;&lt;/p&gt;
&lt;p&gt;不過只有外表，實際功能還需要連結。&lt;/p&gt;
&lt;p&gt;目前只有控制視窗縮放，結束執行，連結說明網頁的功能。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Leo Editor&lt;/h1&gt;
&lt;p&gt;自從安裝過新版的 Qt 5.3 和 5.7 後 Leo Editor 就怪怪的，無法切換英文以外的輸入法，啟動時 Leo Editor 是使用 5.3 版。&lt;/p&gt;
&lt;p&gt;而使用 Python 2 啟動是使用 Qt 4，所以沒這個問題，但是就無法使用 Pelican。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/20</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050820.html" rel="alternate"></link><published>2016-08-20T21:00:00+08:00</published><updated>2016-08-20T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-20:/blog/40323230ri-zhi-1050820.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝 eric 6 成功&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;圖形介面計畫：Pyslvs&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝 eric 6 成功&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;圖形介面計畫：Pyslvs&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Eric 6&lt;/h1&gt;
&lt;p&gt;透過一些安裝教學的資料，成功將 Eric 6.1.8 安裝於 Ubuntu 上。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/idber/article/details/40076821" title="blog.csdn.net"&gt;http://blog.csdn.net/idber/article/details/40076821&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/t7NXOkq.png" &gt;&lt;/p&gt;
&lt;p&gt;不過由於安裝位置及主程式運作的關係，執行時必須給予 Root 權限。&lt;/p&gt;
&lt;pre&gt;
$sudo  eric6
&lt;/pre&gt;

&lt;p&gt;若是沒給予權限，會造成 Eric 顯示一系列錯誤後關閉。&lt;/p&gt;
&lt;p&gt;而透過 Eric 建立的目錄，會被轉為 Root 的所有權，所以必須改回給其他使用者使用。&lt;/p&gt;
&lt;pre&gt;
$sudo chmod -c 777 目錄名稱
mode of ‘目錄名稱’ changed from 0755 (rwxr-xr-x) to 0777 (rwxrwxrwx)
&lt;/pre&gt;

&lt;p&gt;目前還在摸索 Qt 相關的教學，發現有許多自訂功能，包括圖示界面和呼叫傳輸之類，稍作了解應該就能達成相關效果。&lt;/p&gt;
&lt;p&gt;Eric 的語言問題在於外部程式（Qt 設計師之類的），會偵測系統語言作變更，但是主程式卻不會如此，所以本體改成英文後，附屬的程式仍然是繁體中文。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Xv34qIx.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Pyslvs&lt;/h1&gt;
&lt;p&gt;將圖形化包裝的 Python Solvespace 程式暫定名為 Pyslvs，如果覺得定名不妥就之後再變更。&lt;/p&gt;
&lt;p&gt;當界面有基本雛型之後會上傳至倉儲，之後會陸續更新表單按鈕的功能連結。&lt;/p&gt;
&lt;p&gt;Pyslvs 目前在 Ubuntu 系統上開發，因為 Ubuntu 目前好像沒有一個如 Linkage 之類的模擬程式，使用 LibreCAD 或是 FreeCAD 又會太佔資源，所以想做這個工具給 Ubuntu 系統用。&lt;/p&gt;
&lt;p&gt;剛開始評估的困難點可能是如何呈現 2D 圖形在 Qt 界面上吧。其他如輸出成程式碼之類的應該用普通的 &lt;code&gt;.py&lt;/code&gt; 程式就能辦到了。&lt;/p&gt;</content><category term="Kmol"></category><category term="Pyslvs"></category></entry><entry><title>40323230日誌 - 105/08/19</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050819.html" rel="alternate"></link><published>2016-08-19T21:00:00+08:00</published><updated>2016-08-19T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-19:/blog/40323230ri-zhi-1050819.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;紀錄 GCC 和 CMake 在 Ubuntu 上安裝的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;紀錄 Ubuntu 網誌編譯環境&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;紀錄 GCC 和 CMake 在 Ubuntu 上安裝的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;紀錄 Ubuntu 網誌編譯環境&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;為推廣學員使用 Ubuntu 作業系統，紀錄一些安裝軟體的方式。&lt;/p&gt;
&lt;p&gt;紀錄如何建構 Ubuntu (ezgo) 的作業環境。&lt;/p&gt;
&lt;p&gt;官方版本的 Ubuntu 更新較快，已經到了 &lt;code&gt;16.04&lt;/code&gt;，教育部的 ezgo 使用 Ubuntu 14.04，使用上較多推薦工具，不用再自己尋找，不過也會安裝一些可能不會用到的套件。&lt;/p&gt;
&lt;p&gt;目前使用感想是 ezgo 的 KDE 界面還滿方便的，終端機能提供比 Windows 更多的功能，而且硬體支援度非常良好，即使使用非官方驅動程式，運作甚至會比任何版本的 Windows 更加流暢。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;GNU 工具&lt;/h1&gt;
&lt;p&gt;完整版的 ezgo 預設沒有安裝 g++，使用精簡版的 Ubuntu 亦必須自己安裝這兩套編譯工具。&lt;/p&gt;
&lt;p&gt;使用下列指令安裝 GCC。&lt;/p&gt;
&lt;pre&gt;
$sudo apt-get install gcc
$sudo apt-get install g++
&lt;/pre&gt;

&lt;p&gt;使用下列指令安裝 CMake，不過由於提供者版本的問題，可以稍候安裝。&lt;/p&gt;
&lt;pre&gt;
$sudo apt-get install cmake
&lt;/pre&gt;

&lt;p&gt;在沒使用其他提供者的情況下，gcc 的最新版本只會到 &lt;code&gt;4.9&lt;/code&gt;，所以想安裝 gcc 5.0 以上的版本，必須加入信任來源。&lt;/p&gt;
&lt;p&gt;同樣地，在沒使用其他提供者的情況下，CMake 的最新版本無法到 &lt;code&gt;3.x&lt;/code&gt;，也要另一個信任來源。&lt;/p&gt;
&lt;p&gt;加入信任來源後，使用 &lt;code&gt;apt-get update&lt;/code&gt; 指令或是圖形界面的 Ubuntu 管理中心時，就會將你的提供者也加入搜尋。&lt;/p&gt;
&lt;pre&gt;
$sudo add-apt-repository ppa:ubuntu-toolchain-r/test #gcc 的提供者
$sudo add-apt-repository ppa:george-edison55/cmake-3.x #cmake 的提供者
$sudo apt-get update
$sudo apt-get install gcc-5
$sudo apt-get install g++-5
$sudo apt-get install cmake
&lt;/pre&gt;

&lt;p&gt;這時只能使用 &lt;code&gt;gcc-5&lt;/code&gt; 指令啟動 gcc 5.x，使用一般的 &lt;code&gt;gcc&lt;/code&gt; 指令只會啟動最新的 &lt;code&gt;4.x&lt;/code&gt; 的版本。&lt;/p&gt;
&lt;p&gt;因此必須將指令連結過去。&lt;/p&gt;
&lt;pre&gt;
$alias gcc='gcc-5'
$alias g++='g++-5'
&lt;/pre&gt;

&lt;p&gt;下圖是完成畫面，用 &lt;code&gt;gcc --version&lt;/code&gt; 指令來檢查編譯器的版本（g++ 的版本應該也會相同）。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/8Di87en.png" &gt;&lt;/p&gt;
&lt;p&gt;附註：想移除提供者也很簡單，只要加上 &lt;code&gt;--remove&lt;/code&gt; 參數就行。&lt;/p&gt;
&lt;pre&gt;
$sudo add-apt-repository --remove ppa:提供者來源
&lt;/pre&gt;

&lt;hr&gt;

&lt;h1&gt;Leo Editor&lt;/h1&gt;
&lt;p&gt;注意：Leo Editor 在 Python 3.5 中的 Pelican 會產生錯誤，所以請使用 Python 3.4 以下的 Python3 版本。&lt;/p&gt;
&lt;p&gt;使用下列指令從官方倉儲下載 Leo Editor。&lt;/p&gt;
&lt;pre&gt;
$cd "安裝位置"
$git clone https://github.com/leo-editor/leo-editor.git
&lt;/pre&gt;

&lt;p&gt;直接使用下列指令啟動 Leo Editor。&lt;/p&gt;
&lt;p&gt;啟動後如果關閉這個終端機，將會結束 Leo Editor，請注意是否有存檔。&lt;/p&gt;
&lt;pre&gt;
$cd "安裝位置"/leo-editor
$python3 launchLeo.py
&lt;/pre&gt;

&lt;p&gt;寫網誌的必要週邊模組：&lt;/p&gt;
&lt;pre&gt;
$sudo pip3 install pelican -U
$sudo pip3 install markdown -U
$sudo pip3 install bs4 -U
&lt;/pre&gt;

&lt;p&gt;圖中是 Leo 5.3 的版本。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/7VA7EXg.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;未來若有必要軟體的特殊安裝方式，會更新在此。&lt;/p&gt;</content><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/18</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050818.html" rel="alternate"></link><published>2016-08-18T21:00:00+08:00</published><updated>2016-08-18T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-18:/blog/40323230ri-zhi-1050818.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CentOS 的 Python 3.3 版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;glibc 版本問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CentOS 的 Python 3.3 版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;glibc 版本問題&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;GLIBC&lt;/h1&gt;
&lt;p&gt;編譯好的 CentOS 版程式庫放入 Openshift 後，回傳了錯誤：&lt;/p&gt;
&lt;pre&gt;
libc.so.6: version `GLIBC_2.14' not found
&lt;/pre&gt;

&lt;p&gt;是執行系統的 GLIBC 版本較舊所引起的，最簡單的解決方法是升級執行系統的 GLIBC，但是不知道如何命令 Openshift 的倉儲升級。&lt;/p&gt;
&lt;p&gt;用指令檢查了一下虛擬機上的 GLIBC 版本，是 &lt;code&gt;2.17&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6JSlDKG.png" &gt;&lt;/p&gt;
&lt;p&gt;不過 gcc 應該用了 &lt;code&gt;2.14&lt;/code&gt; 做編譯，而 Openshift 的版本沒到 &lt;code&gt;2.14&lt;/code&gt; 所致。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天在 &lt;code&gt;python.log&lt;/code&gt; 注意到 Openshift 使用的 Python 版本是 3.3.2，所以剛開始懷疑是小版號不合所致，但是並非如此。&lt;/p&gt;
&lt;p&gt;從官方的連結下載了 GLIBC &lt;code&gt;2.14&lt;/code&gt; 版：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ftp.gnu.org/gnu/glibc/" title="ftp.gnu.org"&gt;http://ftp.gnu.org/gnu/glibc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上網找到的方法大約都是要執行端主機下命令，但是不知道如何對 Openshift 做出要求，所以先在編譯用的虛擬機做調整。&lt;/p&gt;
&lt;p&gt;但是不知道如何在同一台電腦上取代或是安裝兩個版本的 GLIBC，而虛擬機的效能還滿不彰的。&lt;/p&gt;</content><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/17</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050817.html" rel="alternate"></link><published>2016-08-17T21:00:00+08:00</published><updated>2016-08-17T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-17:/blog/40323230ri-zhi-1050817.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;距離約束 Bug 解決&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CentOS 的 Python 3.3 版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;距離約束 Bug 解決&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CentOS 的 Python 3.3 版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;slvs_python.hpp&lt;/h1&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/tl8Nkk3.jpg" &gt;&lt;/p&gt;
&lt;p&gt;修改 &lt;code&gt;slvs_python.hpp&lt;/code&gt; 標頭檔，讓 value 的值等於 0 時自動轉換成重合約束。&lt;/p&gt;
&lt;p&gt;不過點與線的重合約束還沒調整，稍後會做更新。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;CentOS 編譯&lt;/h1&gt;
&lt;p&gt;在 CentOS 上重新編譯 Python 3.3，在執行configure時添加了 &lt;code&gt;--enable-shared&lt;/code&gt; 參數，這樣make時會產生可用的共享資料庫 &lt;code&gt;libpython3.3m.so&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2d8tkYE.png" &gt;&lt;/p&gt;
&lt;p&gt;另外還把 Makefile 修正到 Python 3.3 的 &lt;code&gt;include&lt;/code&gt; 和共享資料庫的目錄。&lt;/p&gt;
&lt;p&gt;執行時會找不到 &lt;code&gt;libpython3.3m.so&lt;/code&gt;，可能是 CentOS 的 Python 3.3 是安裝在自訂的位置，所以環境變數沒對到。&lt;/p&gt;
&lt;p&gt;後來想調整，但是虛擬機因為記憶體太少而卡住了，不過 Redhat 的 Python 是原生的，應該是沒問題。&lt;/p&gt;
&lt;p&gt;目前還未搬上 Openshift 測試。&lt;/p&gt;</content><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>SLVS 程式庫函式</title><link href="http://project.mde.tw/blog/slvs-cheng-shi-ku-han-shi.html" rel="alternate"></link><published>2016-08-17T12:00:00+08:00</published><updated>2016-08-17T12:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-17:/blog/slvs-cheng-shi-ku-han-shi.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;slvs&lt;/code&gt;程式庫（&lt;code&gt;_slvs.pyd&lt;/code&gt;或&lt;code&gt;_slvs.so&lt;/code&gt;）轉成Python後的內容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;協助Python程式使用指令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;內容待勘誤&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;08/17 更新-錯誤已解決&lt;/em&gt;&lt;/p&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;slvs&lt;/code&gt;程式庫（&lt;code&gt;_slvs.pyd&lt;/code&gt;或&lt;code&gt;_slvs.so&lt;/code&gt;）轉成Python後的內容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;協助Python程式使用指令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;內容待勘誤&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;08/17 更新-錯誤已解決&lt;/em&gt;&lt;/p&gt;


&lt;h1&gt;&lt;strong&gt;快速尋找&lt;/strong&gt;&lt;/h1&gt;
&lt;h2&gt;&lt;a href="#FOREWORD"&gt;簡介&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="#CDemo"&gt;CDemo&lt;/a&gt;｜&lt;a href="#SLVS"&gt;程式庫簡介&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="#START"&gt;使用基礎&lt;/a&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;a href="#ENTITIES"&gt;實體&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="#Point"&gt;點&lt;/a&gt;｜&lt;a href="#Workplane"&gt;工作平面&lt;/a&gt;｜&lt;a href="#Distance"&gt;距離&lt;/a&gt;｜&lt;a href="#Normal"&gt;向量法線&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#Line"&gt;線段&lt;/a&gt;｜&lt;a href="#Arc"&gt;中心點弧&lt;/a&gt;｜&lt;a href="#Circle"&gt;完整圓&lt;/a&gt;｜&lt;a href="#Cubic"&gt;貝茲曲線&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="#CONSTRAINTS"&gt;約束&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="#C-Distance"&gt;距離&lt;/a&gt;｜&lt;a href="#C-Ratio"&gt;線段比值&lt;/a&gt;｜&lt;a href="#C-Diameter"&gt;直徑&lt;/a&gt;｜&lt;a href="#C-Angle"&gt;角度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#C-On"&gt;重合&lt;/a&gt;｜&lt;a href="#C-Equal"&gt;相等&lt;/a&gt;｜&lt;a href="#C-Dragged"&gt;鎖定位置&lt;/a&gt;｜&lt;a href="#C-Midpoint"&gt;中點&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#C-Symmetric"&gt;對稱&lt;/a&gt;｜&lt;a href="#C-HV"&gt;水平或垂直&lt;/a&gt;｜&lt;a href="#C-Parallel"&gt;平行&lt;/a&gt;｜&lt;a href="#C-Tangent"&gt;相切&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="#ADD"&gt;未支援功能&lt;/a&gt;&lt;/h2&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="FOREWORD"&gt;&lt;/a&gt;Brief Introduction&lt;/h1&gt;
&lt;p&gt;SLVS 程式庫裡面的名稱結構是使用C語言撰寫，雖然 &lt;code&gt;slvs.py&lt;/code&gt; 已經幫忙轉換了裡面的名稱，但是仍有些許函式名稱變化。&lt;/p&gt;
&lt;p&gt;所以紀錄一下在Python中如何使用這些功能，預計讓這篇文章達到易使用和易理解的功能。&lt;/p&gt;
&lt;h2&gt;&lt;a name="CDemo"&gt;&lt;/a&gt;CDemo&lt;/h2&gt;
&lt;p&gt;SolveSpace 是一款開源的 2D / 3D 電腦輔助設計繪圖軟體，從 2008 年釋出第一個版本，相容於 Windows / Mac / Linux 三個平台。&lt;/p&gt;
&lt;p&gt;有著體積小、執行快速、免費，且不用安裝的特性，支援 STEP 或 STL 開啟，或輸出成 DXF 、 PDF 、 SVG 等開放格式，也有自己的文字式格式 &lt;code&gt;*.slvs&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;更新方面，可以在 GitHub 的&lt;a href="https://github.com/solvespace/solvespace" title="github.com"&gt;官方倉儲&lt;/a&gt;或是&lt;a href="https://github.com/whitequark/solvespace" title="github.com"&gt;非官方倉儲&lt;/a&gt;中下載最新的原始碼後，直接利用開發者工具（如 GNU）編譯出主程式。&lt;/p&gt;
&lt;p&gt;Solvespace 在繪圖程式本身外還附帶一個名為 CDemo 的小執行檔，是利用 Solvespace 的原始碼編譯出來的。&lt;/p&gt;
&lt;p&gt;可以利用此外部程式呼叫 Solvespace 的程式庫 &lt;code&gt;libslvs.dll&lt;/code&gt; 進行 2D 或是 3D 的解題運算，而無須啟動 Solvespace 。&lt;/p&gt;
&lt;p&gt;CDemo 的概念是能夠讓外部程式使用 Solvespace 的功能，無論是利用其解開最大行程、干涉位置，都能讓應用程式免去您需要親自使用 CAD 軟體解題的困擾。&lt;/p&gt;
&lt;h2&gt;&lt;a name="SLVS"&gt;&lt;/a&gt;SLVS Library&lt;/h2&gt;
&lt;p&gt;CDemo 為 C 語言編譯而成，使用的 Solvespace 程式庫則是C++編譯的，在運算和使用上固然快速，但活用性較局限。&lt;/p&gt;
&lt;p&gt;Python 語言擁有大量自定義模組、易讀的函式，並且在網際執行方面比C語言多一片天，若將 Solvespace 程式庫轉換使用，將會使這些 Python 程式擁有線上解題的能力，在機械設計方面更是方便許多。&lt;/p&gt;
&lt;p&gt;在 Python 的連結庫中， &lt;code&gt;*.pyd&lt;/code&gt; 和 Windows 中 C 語言的動態載入庫 &lt;code&gt;*.dll&lt;/code&gt; 相仿； &lt;code&gt;*.so&lt;/code&gt; 則是大部分開放式作業系統（如為人熟知的 Ubuntu）使用的。 &lt;code&gt;*.so&lt;/code&gt; 的優點是利於共享資料，執行檔與程式庫分離，更新函式庫更為方便。&lt;/p&gt;
&lt;p&gt;Python-Solvespace 的製作概念是利用 SWIG 軟體製作一個 C++ 至 Python 的端口，使任何一個使用 Anaconda 3 (Python 3.5) 的 Python 程式都能夠使用 Solvespace 的函式庫。&lt;/p&gt;
&lt;p&gt;當 Solvespace 的函式轉換成 Python 介面時，也希望保持這個語言一貫清爽易懂的名稱，因此特別重新分類了這些指令的名稱及用法。&lt;/p&gt;
&lt;p&gt;稱號下方是原始的命令代號，用於程式庫中識別命令的類型。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="START"&gt;&lt;/a&gt;Starting Draw and Solve&lt;/h1&gt;
&lt;p&gt;若要使用SLVS程式庫，必須透過&lt;code&gt;slvs.py&lt;/code&gt;介面來轉換。&lt;/p&gt;
&lt;p&gt;在您的Python程式中使用以下指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#導入slvs.py
from slvs import *

#導入Solid Python
#沒有使用就不需要導入
import solid

#創造你的系統，以及支援單位數量
#預設單位數為50
#若是在迴圈中創造系統，將會重新洗掉記錄
sys = System(20)
...
&lt;/pre&gt;

&lt;p&gt;欲執行解題，Python必須使用下列命令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#執行解題
sys.solve()
#直接命令
Slvs_Solve(sys, g)

#結果回報的值如下
if (sys.result == SLVS_RESULT_OKAY):
    ...
elif (sys.result == SLVS_RESULT_INCONSISTENT):
    print ("solve failed")
    print ("SLVS_RESULT_INCONSISTENT")
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
    print ("solve failed")
    print ("SLVS_RESULT_DIDNT_CONVERGE")
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
    print ("solve failed")
    print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
    print ("%d DOF" % sys.dof)
&lt;/pre&gt;

&lt;p&gt;在執行解題程式後，會出現三種結果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;所有約束都能滿足，會回傳&lt;code&gt;SLVS_RESULT_OKAY&lt;/code&gt;，這時就能檢查您的約束結果，沒有完全約束的項目會被移動至滿足條件的範圍中，不過可能會不符合您的期待。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解題程式證明約束條件互相牴觸，會傳回&lt;code&gt;SLVS_RESULT_INCONSISTENT&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解題程式證明約束條件沒有互相牴觸，但定義了一些重複的約束，會傳回&lt;code&gt;SLVS_RESULT_DIDNT_CONVERGE&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最後能調用以下值來檢查結果。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#實體結果
#格式為高精度浮點數
sys.get_param(0).val
&lt;/pre&gt;

&lt;p&gt;而過於嚴重的錯誤會回傳&lt;code&gt;SLVS_RESULT_TOO_MANY_UNKNOWNS&lt;/code&gt;，必須檢查您的 Python 程式庫或是 SLVS 函式庫是否損壞。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="ENTITIES"&gt;&lt;/a&gt;Types of Entities&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;SLVS_E&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;實體的類型，屬於物件的部分，Entity中還有一些子分類。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;Point&lt;/kbd&gt; 此物件屬於點。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;LineSegment&lt;/kbd&gt; 此物件屬於線段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;Circular&lt;/kbd&gt; 此物件屬於圓弧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;沒有標籤的項目屬於 &lt;kbd&gt;Entity&lt;/kbd&gt; 旗下的物件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根據這些關係，在約束時必須判斷其分類以填入。&lt;/p&gt;
&lt;p&gt;輸入值後方加入&lt;code&gt;, sys&lt;/code&gt;，以傳入系統清單&lt;code&gt;sys&lt;/code&gt;中（也許有&lt;code&gt;sys2&lt;/code&gt;或&lt;code&gt;sys3&lt;/code&gt;等等）；亦可用&lt;code&gt;sys.add_&lt;/code&gt;加入以下支援的實體，而取出的編號取決於註冊的順序。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;add_param( )
add_point2d( )
add_point3d( )
add_entity( )
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;取出時亦同（函數中加上編號就能指定）：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;get_Point2d( )
get_Point3d( )
get_LineSegment2d( )
get_LineSegment3d( )
get_Normal3d( )
get_Distance( )
get_Workplane( )
get_Cubic( )
get_Circle( )
get_ArcOfCircle( )
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2&gt;&lt;a name="Point"&gt;&lt;/a&gt;Point&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_POINT_IN_3D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Point&lt;/kbd&gt; / &lt;kbd&gt;Point3d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Point3d(Param x, Param y, Param z)
&lt;/pre&gt;

&lt;p&gt;代表空間中的點。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_POINT_IN_2D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Point&lt;/kbd&gt; / &lt;kbd&gt;Point2d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Point2d(Workplane workplane, Param u, Param v)
&lt;/pre&gt;

&lt;p&gt;代表工作平面上的點。&lt;/p&gt;
&lt;h2&gt;&lt;a name="Normal"&gt;&lt;/a&gt;Normal&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_NORMAL_IN_3D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Normal3d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Normal3d(Param qw, Param qx, Param qy, Param qz)
&lt;/pre&gt;

&lt;p&gt;代表空間中的一條法線。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_NORMAL_IN_2D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Normal3d&lt;/kbd&gt; / &lt;kbd&gt;Normal2d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Normal3d(Workplane wrkpl)
&lt;/pre&gt;

&lt;p&gt;代表垂直工作平面的一條法線。&lt;/p&gt;
&lt;p&gt;在SolveSpace中，法線是由一個3x3的旋轉矩陣從基本的坐標系到一個新的架構，是由單位四元數定義的。&lt;/p&gt;
&lt;p&gt;可以想像這個四元數代表一個通過原點的平面。&lt;/p&gt;
&lt;p&gt;這個平面跟三個向量相關：基礎向量&lt;code&gt;U&lt;/code&gt;和&lt;code&gt;V&lt;/code&gt;在平面上、而法線&lt;code&gt;N&lt;/code&gt;則垂直它，相當於&lt;code&gt;[ U V N ]'&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此U、N、N都有單位長度，而他們都正交，所以：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;U cross V = N
V cross N = U
N cross U = V
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;轉換函式&lt;code&gt;Slvs_Quaternion&lt;/code&gt;提供了在&lt;code&gt;U&lt;/code&gt;、&lt;code&gt;V&lt;/code&gt;、&lt;code&gt;N&lt;/code&gt;和單位四元數之間轉換。&lt;/p&gt;
&lt;p&gt;單位四元數只有三個自由度，但是要在四個參數中指定。因此一個額外的約束產生了，就是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;w^2 + x^2 + y^2 + z^2 = 1&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Make a Quaternion for a Work Plane &lt;kbd&gt;Tips&lt;/kbd&gt;&lt;/h2&gt;
&lt;p&gt;要定義一個由&lt;code&gt;U[1 0 0]&lt;/code&gt;向量（等同X軸）和&lt;code&gt;V[0 1 0]&lt;/code&gt;向量（等同Y軸）組成的平面，是需要一條3D法線的。&lt;/p&gt;
&lt;p&gt;若是不會計算四元數，可以利用下列函式達成：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#函式轉換四元數
qw, qx, qy, qz = MakeQuaternion(1, 0, 0, 0, 1, 0)

#帶入3D法線的函式中
normal = Normal3d(Param(qw), Param(qx), Param(qy), Param(qz), sys)

#做成工作平面
c = Point3d(Param(0.0), Param(0.0), Param(0.0))
plane = Workplane(c, normal)
&lt;/pre&gt;

&lt;p&gt;這個公式在製作2D平面時非常方便。&lt;/p&gt;
&lt;p&gt;以下是不同平面參考：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;XY平面：[1 0 0], [0 1 0]
MakeQuaternion(1, 0, 0, 0, 1, 0)

YZ平面：[0 1 0], [0 0 1]
MakeQuaternion(0, 1, 0, 0, 0, 1)

XZ平面：[1 0 0], [0 0 1]
MakeQuaternion(1, 0, 0, 0, 0, 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2&gt;&lt;a name="Distance"&gt;&lt;/a&gt;Distance&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_DISTANCE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Distance&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Distance(Workplane wrkpl, Param distance)
&lt;/pre&gt;

&lt;p&gt;代表與工作平面平行的距離。&lt;/p&gt;
&lt;h2&gt;&lt;a name="Workplane"&gt;&lt;/a&gt;Work Plane&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Workplane&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_WORKPLANE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Workplane(Point3d origin, Normal3d normal)
&lt;/pre&gt;

&lt;p&gt;代表通過原點，與法線垂直的工作平面。&lt;/p&gt;
&lt;h2&gt;&lt;a name="Line"&gt;&lt;/a&gt;Line Segment&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_LINE_SEGMENT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;LineSegment&lt;/kbd&gt; / &lt;kbd&gt;LineSegment3d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
LineSegment3d(Point3d a, Point3d b)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;LineSegment&lt;/kbd&gt; / &lt;kbd&gt;LineSegment2d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
LineSegment2d(Workplane wrkpl, Point2d a, Point2d b)
&lt;/pre&gt;

&lt;p&gt;在兩個&lt;code&gt;Point2d/3d&lt;/code&gt;之間繪出直線條。&lt;/p&gt;
&lt;p&gt;代表兩個點之間的連線。&lt;/p&gt;
&lt;h2&gt;&lt;a name="Cubic"&gt;&lt;/a&gt;Cubic&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_CUBIC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Cubic&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Cubic(Point3d pt0, Point3d pt1, Point3d pt2, Point3d pt3)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Cubic(Workplane wrkpl, Point2d pt0, Point2d pt1, Point2d pt2, Point2d pt3)
&lt;/pre&gt;

&lt;p&gt;四個點構成的貝茲曲線，無論是用2D還是3D建構，都會視為3D物件。&lt;/p&gt;
&lt;p&gt;四個點的公式如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;公式（t從0積分到1）
p(t) = P0*(1 - t)^3 + 3*P1*(1 - t)^2*t + 3*P2*(1 - t)*t^2 + P3*t^3&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a name="Circle"&gt;&lt;/a&gt;Circle&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Circular&lt;/kbd&gt; / &lt;kbd&gt;Circle&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_CIRCLE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Circle(Workplane wrkpl, Normal3d normal, Point2d center, Distance radius)
&lt;/pre&gt;

&lt;p&gt;與一條&lt;code&gt;Normal3d&lt;/code&gt;法線垂直，與一個&lt;code&gt;Workplane&lt;/code&gt;平面平行，由&lt;code&gt;Point2d&lt;/code&gt;圓心和&lt;code&gt;Distance&lt;/code&gt;半徑構成的完整圓。&lt;/p&gt;
&lt;p&gt;這個圓無法使用相切約束，除非給定切點，並使圓心距離永遠和切線保持半徑長度。&lt;/p&gt;
&lt;h2&gt;&lt;a name="Arc"&gt;&lt;/a&gt;Arc of Circle&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_ARC_OF_CIRCLE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Circular&lt;/kbd&gt; / &lt;kbd&gt;ArcOfCircle&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
ArcOfCircle(Workplane wrkpl, Normal3d normal, Point2d center, Point2d start, Point2d end)
&lt;/pre&gt;

&lt;p&gt;與一條&lt;code&gt;Normal3d&lt;/code&gt;法線垂直，與一個&lt;code&gt;Workplane&lt;/code&gt;平面平行，由&lt;code&gt;Point2d&lt;/code&gt;圓心和兩個&lt;code&gt;Point2d&lt;/code&gt;點構成的三點弧。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="CONSTRAINTS"&gt;&lt;/a&gt;Types of Constrains&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;SLVS_C&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;約束的類型，大部分的指令都會自動判斷狀況。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 此種約束只能用在3D或投影到平面上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 此種約束只能用在平面上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;Val&lt;/kbd&gt; 此種約束必須設定額外的參考值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;輸入值最後端加入群組編號可以規定群組（預設值&lt;code&gt;Slvs_hGroup group = USE_DEFAULT_GROUP&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;約束的直接命令（必須在空白項目中填入 &lt;code&gt;0&lt;/code&gt;）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Slvs_MakeConstraint(h, group, type, wrkpl, valA, ptA, ptB, entityA, entityB,  entityC,  entityD, other, other2)
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="C-Distance"&gt;&lt;/a&gt;Distance &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_PT_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Point3d p1, Point3d p2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Workplane wrkpl, Point p1, Point p2)
&lt;/pre&gt;

&lt;p&gt;約束兩個&lt;code&gt;Point2d/3d&lt;/code&gt;的距離。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PROJ_PT_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance_proj(double value, Point3d p1, Point3d p2, Workplane wrkpl)
&lt;/pre&gt;

&lt;p&gt;約束兩個&lt;code&gt;Point3d&lt;/code&gt;的投影到&lt;code&gt;Workplane&lt;/code&gt;的距離。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_PLANE_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Workplane wrkpl, Point3d p)
&lt;/pre&gt;

&lt;p&gt;從一個&lt;code&gt;Point3d&lt;/code&gt;到一個&lt;code&gt;Workplane&lt;/code&gt;的距離。&lt;/p&gt;
&lt;p&gt;距離值的正負會規定點在平面之上或之下。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_LINE_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Point3d p, LineSegment3d line)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Workplane wrkpl, Point p, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;從一個&lt;code&gt;Point2d/3d&lt;/code&gt;到一條&lt;code&gt;LineSegment2d/3d&lt;/code&gt;的距離。&lt;/p&gt;
&lt;p&gt;距離值的正負會規定點在線段之上或之下。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-On"&gt;&lt;/a&gt;On&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_POINTS_COINCIDENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Point3d p1, Point3d p2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point p1, Point p2)
&lt;/pre&gt;

&lt;p&gt;兩個&lt;code&gt;Point2d/3d&lt;/code&gt;的座標相等。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_IN_PLANE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point3d p)
&lt;/pre&gt;

&lt;p&gt;一個&lt;code&gt;Point3d&lt;/code&gt;會被固定在一個&lt;code&gt;Workplane&lt;/code&gt;上。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_ON_LINE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Point3d p, LineSegment3d line)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point p, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;一個&lt;code&gt;Point2d/3d&lt;/code&gt;會被固定在一條&lt;code&gt;LineSegment2d/3d&lt;/code&gt;上。&lt;/p&gt;
&lt;p&gt;注意此約束會在2D時移除一個自由度；而在3D空間時變成兩個。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_ON_CIRCLE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point p, Circle circle)
&lt;/pre&gt;

&lt;p&gt;一個&lt;code&gt;Point2d&lt;/code&gt;會被固定在一個&lt;code&gt;Circle&lt;/code&gt;上。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Equal"&gt;&lt;/a&gt;Equal&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_LENGTH_LINES&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal(Workplane wrkpl, LineSegment2d line1, LineSegment2d line line2)
&lt;/pre&gt;

&lt;p&gt;兩條&lt;code&gt;LineSegment2d&lt;/code&gt;的長度等長。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQ_LEN_PT_LINE_D&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal(Workplane wrkpl, Point2d p, LineSegment2d line1, LineSegment2d line line2)
&lt;/pre&gt;

&lt;p&gt;第一條&lt;code&gt;LineSegment2d&lt;/code&gt;長度等於一個&lt;code&gt;Point2d&lt;/code&gt;到第二條&lt;code&gt;LineSegment2d&lt;/code&gt;的距離。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQ_PT_LN_DISTANCES&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal_point_line(Workplane wrkpl, Point2d p1, Point2d p2, LineSegment2d line1, LineSegment2d line2)
&lt;/pre&gt;

&lt;p&gt;第一個&lt;code&gt;Point2d&lt;/code&gt;到第一條&lt;code&gt;LineSegment2d&lt;/code&gt;的距離等於第二個&lt;code&gt;Point2d&lt;/code&gt;到第二條&lt;code&gt;LineSegment2d&lt;/code&gt;的距離。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_ANGLE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal_angle(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2, LineSegment2d line3, LineSegment2d line4)
&lt;/pre&gt;

&lt;p&gt;第一條&lt;code&gt;LineSegment2d&lt;/code&gt;和第二條&lt;code&gt;LineSegment2d&lt;/code&gt;的夾角等於第三條&lt;code&gt;LineSegment2d&lt;/code&gt;和第四條&lt;code&gt;LineSegment2d&lt;/code&gt;的夾角。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_LINE_ARC_LEN&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal(Workplane wrkpl, LineSegment2d line, Circular c)
&lt;/pre&gt;

&lt;p&gt;一條&lt;code&gt;LineSegment2d&lt;/code&gt;線段長度和另一段&lt;code&gt;Circular&lt;/code&gt;長度相等。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_RADIUS&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal_radius(Workplane wrkpl, Circular c1, Circular c2)
&lt;/pre&gt;

&lt;p&gt;兩條&lt;code&gt;Circular&lt;/code&gt;的半徑相等。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SAME_ORIENTATION&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.orientation(Normal3d nrml1, Normal3d nrml2)
&lt;/pre&gt;

&lt;p&gt;兩條&lt;code&gt;Normal3d&lt;/code&gt;法線的方向相等。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Ratio"&gt;&lt;/a&gt;Ratio of Length &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_LENGTH_RATIO&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.ratio(double value, Workplane wrkpl, LineSegment2d line1, LineSegment2d line2)
&lt;/pre&gt;

&lt;p&gt;第一條&lt;code&gt;LineSegment2d&lt;/code&gt;長度對上第二條&lt;code&gt;LineSegment2d&lt;/code&gt;長度的比值。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Symmetric"&gt;&lt;/a&gt;Symmetric&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric(Workplane wrkpl, Point3d p1, Point3d p2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric(Workplane wrkpl, Point2d p1, Point2d p2)
&lt;/pre&gt;

&lt;p&gt;第一個&lt;code&gt;Point2d/3d&lt;/code&gt;會和第二個&lt;code&gt;Point2d/3d&lt;/code&gt;對稱於一個工作平面。&lt;/p&gt;
&lt;p&gt;意味著兩個點到平面的距離都相等，而兩點的連線可以做為平面的法線。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC_HORIZ&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric_H(Workplane wrkpl, Point2d p1, Point2d p2)
&lt;/pre&gt;

&lt;p&gt;兩個&lt;code&gt;Point2d&lt;/code&gt;會鎖定在相同的水平座標。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC_VERT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric_V(Workplane wrkpl, Point2d p1, Point2d p2)
&lt;/pre&gt;

&lt;p&gt;兩個&lt;code&gt;Point2d&lt;/code&gt;會鎖定在相同的垂直座標。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC_LINE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric(Workplane wrkpl, Point2d p1, Point2d p2, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;規定兩個&lt;code&gt;Point2d&lt;/code&gt;，對稱&lt;code&gt;LineSegment2d&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Midpoint"&gt;&lt;/a&gt;Middle point&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_AT_MIDPOINT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.midpoint(Point3d p, LineSegment3d line)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.midpoint(Workplane wrkpl, Point2d p, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;讓一個&lt;code&gt;Point2d/3d&lt;/code&gt;位於一條&lt;code&gt;LineSegment2d&lt;/code&gt;的中點。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-HV"&gt;&lt;/a&gt;Horizontal &amp;amp; Vertical&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_HORIZONTAL&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.horizontal(Workplane wrkpl, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SLVS_C_VERTICAL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.vertical(Workplane wrkpl, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;規定一條&lt;code&gt;LineSegment2d&lt;/code&gt;水平或垂直。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Diameter"&gt;&lt;/a&gt;Diameter &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_DIAMETER&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.diameter(double diameter, Workplane wrkpl, Circular c)
&lt;/pre&gt;

&lt;p&gt;一段&lt;code&gt;Circular&lt;/code&gt;的直徑。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Angle"&gt;&lt;/a&gt;Angle &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_ANGLE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.angle(Workplane wrkpl, double value, LineSegment2d line1, LineSegment2d line2, bool other)
&lt;/pre&gt;

&lt;p&gt;兩條&lt;code&gt;LineSegment2d&lt;/code&gt;的夾角，定義值單位為度。&lt;/p&gt;
&lt;p&gt;公式如下（&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;為兩條線的向量）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(A dot B)/(|A||B|) = cos(valA)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意這裡的值定義比較不明確，無論正負90度都會是相同的結果。&lt;/p&gt;
&lt;p&gt;所以必須使用&lt;code&gt;other&lt;/code&gt;布林值來判斷正負。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PERPENDICULAR&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.perpendicular(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2, bool other)
&lt;/pre&gt;

&lt;p&gt;源自約束&lt;code&gt;SLVS_C_ANGLE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;這個約束是定義角度約束為90度的情況。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Parallel"&gt;&lt;/a&gt;Parallel&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PARALLEL&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.parallel(LineSegment3d line1, LineSegment3d line2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.parallel(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2)
&lt;/pre&gt;

&lt;p&gt;兩條&lt;code&gt;LineSegment2d/3d&lt;/code&gt;互相平行。&lt;/p&gt;
&lt;p&gt;注意此約束會在投影到一個平面上時移除一個自由度；而在3D空間時變成兩個。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Tangent"&gt;&lt;/a&gt;Tangent &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_ARC_LINE_TANGENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.tangent(ArcOfCircle arc, LineSegment2d line, bool other)
&lt;/pre&gt;

&lt;p&gt;一段&lt;code&gt;ArcOfCircle&lt;/code&gt;和一條&lt;code&gt;LineSegment2d&lt;/code&gt;相切。&lt;/p&gt;
&lt;p&gt;若布林值是&lt;code&gt;False&lt;/code&gt;，則圓弧的切點會位於它的起點&lt;code&gt;s&lt;/code&gt;；反之若為&lt;code&gt;True&lt;/code&gt;，則會位於它的終點&lt;code&gt;e&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_CUBIC_LINE_TANGENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.tangent(Cubic c, LineSegment3d l, bool other)
&lt;/pre&gt;

&lt;p&gt;一條&lt;code&gt;Cubic&lt;/code&gt;和一條&lt;code&gt;LineSegment3d&lt;/code&gt;相切。&lt;/p&gt;
&lt;p&gt;若布林值是&lt;code&gt;False&lt;/code&gt;，則貝茲曲線的切點會位於它的起點&lt;code&gt;p0&lt;/code&gt;；反之若為&lt;code&gt;True&lt;/code&gt;，則會位於它的終點&lt;code&gt;p3&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_CURVE_CURVE_TANGENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.tangent(ArcOfCircle c1, ArcOfCircle c2, bool other, bool other2)
Constraint.tangent(Cubic c1, Cubic c2, bool other, bool other2)
Constraint.tangent(ArcOfCircle c1, Cubic c2, bool other, bool other2)
Constraint.tangent(Cubic c1, ArcOfCircle c2, bool other, bool other2)
&lt;/pre&gt;

&lt;p&gt;兩條曲線的相切組合。&lt;/p&gt;
&lt;p&gt;若布林值是&lt;code&gt;False&lt;/code&gt;，則圓弧的切點會位於它的起點&lt;code&gt;s&lt;/code&gt;，貝茲曲線的切點會位於它的起點&lt;code&gt;p0&lt;/code&gt;；反之若為&lt;code&gt;True&lt;/code&gt;，則會位於它的終點&lt;code&gt;e&lt;/code&gt;或&lt;code&gt;p3&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Dragged"&gt;&lt;/a&gt;Dragged&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_WHERE_DRAGGED&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.dragged(Point3d p)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.dragged(Workplane wrkpl, Point2d p)
&lt;/pre&gt;

&lt;p&gt;永久鎖定這個&lt;code&gt;Point2d/3d&lt;/code&gt;的座標在目前計算的座標上，再也不會改變。&lt;/p&gt;
&lt;p&gt;在2D平面上，會移除兩個自由度；在3D空間中，是三個自由度。&lt;/p&gt;
&lt;h2&gt;Set Dragged &lt;kbd&gt;Tips&lt;/kbd&gt;&lt;/h2&gt;
&lt;p&gt;關於鎖定位置，另一個系統的約束如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
sys.set_dragged(Point p)
&lt;/pre&gt;

&lt;p&gt;是命令約束盡量固定這個&lt;code&gt;Point2d/3d&lt;/code&gt;點，取而代之的是移動周遭的項目。&lt;/p&gt;
&lt;p&gt;這個點被固定後移動量會較小。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="ADD"&gt;&lt;/a&gt;Additional Types of Constrains&lt;/h1&gt;
&lt;p&gt;一些額外的約束條件，目前沒有對應實體項目可用。&lt;/p&gt;
&lt;h2&gt;Point and Face&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_C_PT_FACE_DISTANCE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#這個功能尚未建構
&lt;/pre&gt;

&lt;h2&gt;Point on Face&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_C_PT_ON_FACE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; 使用指令：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#這個功能尚未建構
&lt;/pre&gt;</content><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>SLVS Library Functions</title><link href="http://project.mde.tw/blog/slvs-library-functions.html" rel="alternate"></link><published>2016-08-17T12:00:00+08:00</published><updated>2016-08-17T12:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-17:/blog/slvs-library-functions.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;slvs&lt;/code&gt; library（&lt;code&gt;_slvs.pyd&lt;/code&gt;or &lt;code&gt;_slvs.so&lt;/code&gt;）for Python.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Retrieve for Python Programing Design.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;Content to be amended&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;08/17 Updated&lt;/em&gt;&lt;/p&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;slvs&lt;/code&gt; library（&lt;code&gt;_slvs.pyd&lt;/code&gt;or &lt;code&gt;_slvs.so&lt;/code&gt;）for Python.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Retrieve for Python Programing Design.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;Content to be amended&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;08/17 Updated&lt;/em&gt;&lt;/p&gt;


&lt;h1&gt;&lt;strong&gt;Quick Search&lt;/strong&gt;&lt;/h1&gt;
&lt;h2&gt;&lt;a href="#FOREWORD"&gt;Brief introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="#CDemo"&gt;CDemo&lt;/a&gt;｜&lt;a href="#SLVS"&gt;SLVS Library&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="#START"&gt;How to start&lt;/a&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;a href="#ENTITIES"&gt;Entities&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="#Point"&gt;Point&lt;/a&gt;｜&lt;a href="#Workplane"&gt;Work Plane&lt;/a&gt;｜&lt;a href="#Distance"&gt;Distance&lt;/a&gt;｜&lt;a href="#Normal"&gt;Normal&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#Line"&gt;Line Segment&lt;/a&gt;｜&lt;a href="#Arc"&gt;Arc (have a center)&lt;/a&gt;｜&lt;a href="#Circle"&gt;Circle&lt;/a&gt;｜&lt;a href="#Cubic"&gt;Bezier curve&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="#CONSTRAINTS"&gt;Constraints&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="#C-Distance"&gt;Distance&lt;/a&gt;｜&lt;a href="#C-Ratio"&gt;Ratio of Line Segment&lt;/a&gt;｜&lt;a href="#C-Diameter"&gt;Diameter&lt;/a&gt;｜&lt;a href="#C-Angle"&gt;Angle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#C-On"&gt;Coincide&lt;/a&gt;｜&lt;a href="#C-Equal"&gt;Equal&lt;/a&gt;｜&lt;a href="#C-Dragged"&gt;Locked position&lt;/a&gt;｜&lt;a href="#C-Midpoint"&gt;Middle point&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="#C-Symmetric"&gt;Symmetric&lt;/a&gt;｜&lt;a href="#C-HV"&gt;Horizontal &amp;amp; Vertical&lt;/a&gt;｜&lt;a href="#C-Parallel"&gt;Parallel&lt;/a&gt;｜&lt;a href="#C-Tangent"&gt;Tangent&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="#ADD"&gt;Functions that not in use&lt;/a&gt;&lt;/h2&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="FOREWORD"&gt;&lt;/a&gt;Brief Introduction&lt;/h1&gt;
&lt;p&gt;SLVS Library is compose by C language, Although &lt;code&gt;slvs.py&lt;/code&gt; was translate to Python interface, but some function names has change.&lt;/p&gt;
&lt;p&gt;So I record these function, that how to use in Python program.&lt;/p&gt;
&lt;h2&gt;&lt;a name="CDemo"&gt;&lt;/a&gt;CDemo&lt;/h2&gt;
&lt;p&gt;SolveSpace is an open source 2D / 3D computer-aided design and drafting software, from 2008 released the first version, compatible with Windows / Mac / Linux three platforms.&lt;/p&gt;
&lt;p&gt;Has a small size, perform fast, free, and no installation features, STEP or STL support open, or exported into DXF, PDF, SVG and other open formats, also has its own text-based format &lt;code&gt;*.slvs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For updating, you can go to GitHub's &lt;a href="https://github.com/solvespace/solvespace" title="github.com"&gt;official storage&lt;/a&gt; or &lt;a href="https://github.com/whitequark/solvespace" title="github.com"&gt;unofficial storage&lt;/a&gt; to download the latest source code, the direct use of developer tools (such as GNU) compile the main program.&lt;/p&gt;
&lt;p&gt;Solvespace has another small executable file named CDemo, compiled with source code of Solvespace.&lt;/p&gt;
&lt;p&gt;You can use this external program call library of Solvespace &lt;code&gt;libslvs.dll&lt;/code&gt; be 2D or 3D computing problem-solving, and without startup Solvespace.&lt;/p&gt;
&lt;p&gt;The concept of CDemo is be able to use an external program to call functions from Solvespace, whether it is using its maximum travel untied, the interference position. You can use this app without need to use CAD software to personally solving problems by you self.&lt;/p&gt;
&lt;h2&gt;&lt;a name="SLVS"&gt;&lt;/a&gt;SLVS Library&lt;/h2&gt;
&lt;p&gt;CDemo compiled from C language. Solvespace database using the C++ compiler is useful and fast of course, but the utilization of more limited.&lt;/p&gt;
&lt;p&gt;Python language has a lot of custom modules, easy-reading function, and has another scopes in the Internet than the C language, if Solvespace use database conversion, will make these Python programs have online problem-solving ability, mechanical design in particular it is a lot easier.&lt;/p&gt;
&lt;p&gt;In Python link library, &lt;code&gt;*.pyd&lt;/code&gt; is similar to C language dynamic load library &lt;code&gt;*.dll&lt;/code&gt; in Windows; &lt;code&gt;*.so&lt;/code&gt; is the most open operating systems (such as Ubuntu) in use. Advantage of &lt;code&gt;*.so&lt;/code&gt; is beneficial to share information, perform file and database separation, updated library more convenient.&lt;/p&gt;
&lt;p&gt;Concept of the production Python-Solvespace is using SWIG to create a C ++ to Python port to make any use of Anaconda 3 (Python 3.5) of Python programs are able to use the library of Solvespace.&lt;/p&gt;
&lt;p&gt;When Solvespace the function is converted into when Python interface, but also want to keep consistently fresh and understandable names for this language, so I especially reclassified these names and usage instructions.&lt;/p&gt;
&lt;p&gt;Below the title is original name of the command code, the database using to identify the type of command.&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="START"&gt;&lt;/a&gt;Starting Draw and Solve&lt;/h1&gt;
&lt;p&gt;To use SLVS database must be converted through the &lt;code&gt;slvs.py&lt;/code&gt; interface.&lt;/p&gt;
&lt;p&gt;Use the following command in your Python program:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#Import "slvs.py".
from slvs import *

#Import Solid Python.
#If not using Solid Python, don't need to do this.
import solid

#Your system, and it's supporting number of params.
#Default Units 50
#If your system is in a loop, it's params will be re-clear.
sys = System(20)
...
&lt;/pre&gt;

&lt;p&gt;For the implementation of problem-solving, Python program must use the following command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#Implementation of problem-solving.
sys.solve()
#Another command.
Slvs_Solve(sys, g)

#Return result value as follows.
if (sys.result == SLVS_RESULT_OKAY):
    ...
elif (sys.result == SLVS_RESULT_INCONSISTENT):
    print ("solve failed")
    print ("SLVS_RESULT_INCONSISTENT")
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
    print ("solve failed")
    print ("SLVS_RESULT_DIDNT_CONVERGE")
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
    print ("solve failed")
    print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
    print ("%d DOF" % sys.dof)
&lt;/pre&gt;

&lt;p&gt;After the execution of problem-solving program, there will be three results:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;All constraints were satisfied to within our numerical tolerance (i.e., success). The result is equal to &lt;code&gt;SLVS_RESULT_OKAY&lt;/code&gt;, entities that not fully constrained will be moved to meet the conditions of, but may not meet your expectations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The solver can prove that two constraints are inconsistent (for example, if a line with nonzero length is constrained both horizontal and vertical). The result is equal to &lt;code&gt;SLVS_RESULT_INCONSISTENT&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The solver cannot prove that two constraints are inconsistent, but it cannot find a solution. The result is equal to &lt;code&gt;SLVS_RESULT_DIDNT_CONVERGE&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Finally, the following function can call to check the results.&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#Entities result.
#Precision floating-point format.
sys.get_param(0).val
&lt;/pre&gt;

&lt;p&gt;And too serious error will return &lt;code&gt;SLVS_RESULT_TOO_MANY_UNKNOWNS&lt;/code&gt;. You must checkout your Python library or SLVS library is damaged or not.&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="ENTITIES"&gt;&lt;/a&gt;Types of Entities&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;SLVS_E&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Entity type, object parts for problem-solving. Entity has some sub-categories.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;Point&lt;/kbd&gt; This object belongs to Point.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;LineSegment&lt;/kbd&gt; This object belongs to Line Segment.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;Circular&lt;/kbd&gt; This object belongs to Circular.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No label items belonging to sub-categories of &lt;kbd&gt;Entity&lt;/kbd&gt; .&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;According to these relations, in the constraint must determine its classification to fill.&lt;/p&gt;
&lt;p&gt;When function input "&lt;code&gt;, sys&lt;/code&gt;" after value, it can record into &lt;code&gt;sys&lt;/code&gt; (There maybe exist &lt;code&gt;sys2&lt;/code&gt; or &lt;code&gt;sys3&lt;/code&gt;). It can also use &lt;code&gt;sys.add_&lt;/code&gt; to input to current system.&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;add_param( )
add_point2d( )
add_point3d( )
add_entity( )
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;As same as take them out (Add the specified number).&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;get_Point2d( )
get_Point3d( )
get_LineSegment2d( )
get_LineSegment3d( )
get_Normal3d( )
get_Distance( )
get_Workplane( )
get_Cubic( )
get_Circle( )
get_ArcOfCircle( )
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2&gt;&lt;a name="Point"&gt;&lt;/a&gt;Point&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_POINT_IN_3D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Point&lt;/kbd&gt; / &lt;kbd&gt;Point3d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Point3d(Param x, Param y, Param z)
&lt;/pre&gt;

&lt;p&gt;Representative of a point in space.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_POINT_IN_2D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Point&lt;/kbd&gt; / &lt;kbd&gt;Point2d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Point2d(Workplane workplane, Param u, Param v)
&lt;/pre&gt;

&lt;p&gt;Representative a point on a work plane.&lt;/p&gt;
&lt;h2&gt;&lt;a name="Normal"&gt;&lt;/a&gt;Normal&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_NORMAL_IN_3D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Normal3d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Normal3d(Param qw, Param qx, Param qy, Param qz)
&lt;/pre&gt;

&lt;p&gt;Representative of a normal in space.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_NORMAL_IN_2D&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Normal3d&lt;/kbd&gt; / &lt;kbd&gt;Normal2d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Normal3d(Workplane wrkpl)
&lt;/pre&gt;

&lt;p&gt;Representative of a normal line perpendicular to the work plane.&lt;/p&gt;
&lt;p&gt;In SolveSpace, "normals" represent a 3x3 rotation matrix from our base coordinate system to a new frame. Defined by the unit quaternion w, x, y, z.&lt;/p&gt;
&lt;p&gt;It is useful to think of this quaternion as representing a plane through the origin. This plane has three associated vectors: basis vectors U, V that lie within the plane, and normal N that is perpendicular to it. This means that&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    [ U V N ]&amp;#39;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;defines a 3x3 rotation matrix. So U, V, and N all have unit length, and are orthogonal so that&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;U cross V = N
V cross N = U
N cross U = V
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;Convenience functions &lt;code&gt;Slvs_Quaternion&lt;/code&gt; are provided to convert between this representation as vectors U, V, N and the unit quaternion.&lt;/p&gt;
&lt;p&gt;A unit quaternion has only 3 degrees of freedom, but is specified in terms of 4 parameters. An extra constraint is therefore generatedimplicitly, that&lt;/p&gt;
&lt;p&gt;&lt;code&gt;w^2 + x^2 + y^2 + z^2 = 1&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Make a Quaternion for a Work Plane &lt;kbd&gt;Tips&lt;/kbd&gt;&lt;/h2&gt;
&lt;p&gt;To define a plane consisting by the &lt;code&gt;U [1 0 0]&lt;/code&gt; vector (equivalent X-axis) and &lt;code&gt;V [0 1 0]&lt;/code&gt; vector (equivalent Y axis) need for 3D normals.&lt;/p&gt;
&lt;p&gt;If you don't know how to calculated quaternion, can be reached using the following functions:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#Conversion quaternion
qw, qx, qy, qz = MakeQuaternion(1, 0, 0, 0, 1, 0)

#Take into the 3D normal function
normal = Normal3d(Param(qw), Param(qx), Param(qy), Param(qz), sys)

#Make a working plane
c = Point3d(Param(0.0), Param(0.0), Param(0.0))
plane = Workplane(c, normal)
&lt;/pre&gt;

&lt;p&gt;When creating 2D plane, using this formula is very convenient.&lt;/p&gt;
&lt;p&gt;The following are the different planes reference:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;XY plane: [1 0 0], [0 1 0]
MakeQuaternion(1, 0, 0, 0, 1, 0)

YZ plane: [0 1 0], [0 0 1]
MakeQuaternion(0, 1, 0, 0, 0, 1)

XZ plane: [1 0 0], [0 0 1]
MakeQuaternion(1, 0, 0, 0, 0, 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2&gt;&lt;a name="Distance"&gt;&lt;/a&gt;Distance&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_DISTANCE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Distance&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Distance(Workplane wrkpl, Param distance)
&lt;/pre&gt;

&lt;p&gt;Representative of a distance parallel a work plane.&lt;/p&gt;
&lt;h2&gt;&lt;a name="Workplane"&gt;&lt;/a&gt;Work Plane&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Workplane&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_WORKPLANE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Workplane(Point3d origin, Normal3d normal)
&lt;/pre&gt;

&lt;p&gt;Representative of a work plane through the origin, perpendicular to a normal.&lt;/p&gt;
&lt;h2&gt;&lt;a name="Line"&gt;&lt;/a&gt;Line Segment&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_LINE_SEGMENT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;LineSegment&lt;/kbd&gt; / &lt;kbd&gt;LineSegment3d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
LineSegment3d(Point3d a, Point3d b)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;LineSegment&lt;/kbd&gt; / &lt;kbd&gt;LineSegment2d&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
LineSegment2d(Workplane wrkpl, Point2d a, Point2d b)
&lt;/pre&gt;

&lt;p&gt;Draw a straight line between two &lt;code&gt;Point2d / 3d&lt;/code&gt; point.&lt;/p&gt;
&lt;p&gt;Representative of a connection between two points.&lt;/p&gt;
&lt;h2&gt;&lt;a name="Cubic"&gt;&lt;/a&gt;Cubic&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_CUBIC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Cubic&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Cubic(Point3d pt0, Point3d pt1, Point3d pt2, Point3d pt3)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Cubic(Workplane wrkpl, Point2d pt0, Point2d pt1, Point2d pt2, Point2d pt3)
&lt;/pre&gt;

&lt;p&gt;Bezier curve consisting of four points, whether it be 2D or 3D construction, will be treated as 3D objects.&lt;/p&gt;
&lt;p&gt;Four point formula is as follows:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Equation (t from 0 to 1 points)
p(t) = P0*(1 - t)^3 + 3*P1*(1 - t)^2*t + 3*P2*(1 - t)*t^2 + P3*t^3&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a name="Circle"&gt;&lt;/a&gt;Circle&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;Entity&lt;/kbd&gt; / &lt;kbd&gt;Circular&lt;/kbd&gt; / &lt;kbd&gt;Circle&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_CIRCLE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Circle(Workplane wrkpl, Normal3d normal, Point2d center, Distance radius)
&lt;/pre&gt;

&lt;p&gt;Representative of a circle perpendicular with a &lt;code&gt;Normal3d&lt;/code&gt; normal, parallel with a &lt;code&gt;Workplane&lt;/code&gt; plane, constitute by a &lt;code&gt;Point2d&lt;/code&gt; center and a &lt;code&gt;Distance&lt;/code&gt; radius.&lt;/p&gt;
&lt;h2&gt;&lt;a name="Arc"&gt;&lt;/a&gt;Arc of Circle&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_E_ARC_OF_CIRCLE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;Circular&lt;/kbd&gt; / &lt;kbd&gt;ArcOfCircle&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
ArcOfCircle(Workplane wrkpl, Normal3d normal, Point2d center, Point2d start, Point2d end)
&lt;/pre&gt;

&lt;p&gt;Representative of an arc perpendicular with a &lt;code&gt;Normal3d&lt;/code&gt; normal, parallel with a &lt;code&gt;Workplane&lt;/code&gt; plane, constitute by a &lt;code&gt;Point2d&lt;/code&gt; center, a &lt;code&gt;Point2d&lt;/code&gt; start point, and a &lt;code&gt;Point2d&lt;/code&gt; endpoint.&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="CONSTRAINTS"&gt;&lt;/a&gt;Types of Constrains&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;SLVS_C&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Constraints type. Most of the instruction will automatically determine the situation.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Such constraints can only be used in 3D or projected onto a plane.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Such constraints can only be used in a 2D plane.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;kbd&gt;Val&lt;/kbd&gt; Such constraints must be set additional reference value.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Enter the value of the last side to join the group numbers can be specified group (Default &lt;code&gt;Slvs_hGroup group = USE_DEFAULT_GROUP&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Direct command constraint(But you should filled zero in empty entry):&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Slvs_MakeConstraint(h, group, type, wrkpl, valA, ptA, ptB, entityA, entityB,  entityC,  entityD, other, other2)
&lt;/pre&gt;

&lt;h2&gt;&lt;a name="C-Distance"&gt;&lt;/a&gt;Distance &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_PT_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Point3d p1, Point3d p2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Workplane wrkpl, Point p1, Point p2)
&lt;/pre&gt;

&lt;p&gt;Constraints two &lt;code&gt;Point 2d / 3d&lt;/code&gt; distance.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PROJ_PT_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance_proj(double value, Point3d p1, Point3d p2, Workplane wrkpl)
&lt;/pre&gt;

&lt;p&gt;Constraints two &lt;code&gt;Point 3d&lt;/code&gt; projected to&lt;code&gt;Workplane&lt;/code&gt; distance.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_PLANE_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Workplane wrkpl, Point3d p)
&lt;/pre&gt;

&lt;p&gt;Distance from a &lt;code&gt;Point3d&lt;/code&gt; to a &lt;code&gt;Workplane&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Positive and negative values will be predetermined distance above or below the plane.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_LINE_DISTANCE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Point3d p, LineSegment3d line)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.distance(double value, Workplane wrkpl, Point p, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;Distance from a &lt;code&gt;Point 2d/3d&lt;/code&gt; to a&lt;code&gt;LineSegment2d/3d&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Positive and negative values will be predetermined distance above or below the line segment.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-On"&gt;&lt;/a&gt;On&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_POINTS_COINCIDENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Point3d p1, Point3d p2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point p1, Point p2)
&lt;/pre&gt;

&lt;p&gt;Two &lt;code&gt;Point2d/3d&lt;/code&gt; coordinates equal.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_IN_PLANE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point3d p)
&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Point3d&lt;/code&gt; will be fixed on a &lt;code&gt;Workplane&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_ON_LINE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Point3d p, LineSegment3d line)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point p, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Point2d/3d&lt;/code&gt; will be fixed on a &lt;code&gt;LineSegment2d/3d&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that this constraint removes one degree of freedom when projected in to the plane, but two degrees of freedom in 3d.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PT_ON_CIRCLE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.on(Workplane wrkpl, Point p, Circle circle)
&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Point2d&lt;/code&gt; will be fixed on a &lt;code&gt;Circle&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Equal"&gt;&lt;/a&gt;Equal&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_LENGTH_LINES&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal(Workplane wrkpl, LineSegment2d line1, LineSegment2d line line2)
&lt;/pre&gt;

&lt;p&gt;Two length of &lt;code&gt;LineSegment2d&lt;/code&gt; will be same.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQ_LEN_PT_LINE_D&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal(Workplane wrkpl, Point2d p, LineSegment2d line1, LineSegment2d line line2)
&lt;/pre&gt;

&lt;p&gt;Length of first &lt;code&gt;LineSegment2d&lt;/code&gt; will as same as a distance of a &lt;code&gt;Point2d&lt;/code&gt; to second &lt;code&gt;LineSegment2d&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQ_PT_LN_DISTANCES&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal_point_line(Workplane wrkpl, Point2d p1, Point2d p2, LineSegment2d line1, LineSegment2d line2)
&lt;/pre&gt;

&lt;p&gt;Distance of first &lt;code&gt;Point2d&lt;/code&gt; to first &lt;code&gt;LineSegment2d&lt;/code&gt; will as same as next distance of second &lt;code&gt;Point2d&lt;/code&gt;to second &lt;code&gt;LineSegment2d&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_ANGLE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal_angle(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2, LineSegment2d line3, LineSegment2d line4)
&lt;/pre&gt;

&lt;p&gt;Angle of first &lt;code&gt;LineSegment2d&lt;/code&gt; to second &lt;code&gt;LineSegment2d&lt;/code&gt; will as same as next angle of third &lt;code&gt;LineSegment2d&lt;/code&gt;to fourth &lt;code&gt;LineSegment2d&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_LINE_ARC_LEN&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal(Workplane wrkpl, LineSegment2d line, Circular c)
&lt;/pre&gt;

&lt;p&gt;Length of a &lt;code&gt;LineSegment2d&lt;/code&gt; and Arc length of a &lt;code&gt;Circular&lt;/code&gt; will be same.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_EQUAL_RADIUS&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.equal_radius(Workplane wrkpl, Circular c1, Circular c2)
&lt;/pre&gt;

&lt;p&gt;Two radius of &lt;code&gt;Circular&lt;/code&gt; will be same.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SAME_ORIENTATION&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.orientation(Normal3d nrml1, Normal3d nrml2)
&lt;/pre&gt;

&lt;p&gt;Two direction of &lt;code&gt;Normal3d&lt;/code&gt; will be same.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Ratio"&gt;&lt;/a&gt;Ratio of Length &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_LENGTH_RATIO&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.ratio(double value, Workplane wrkpl, LineSegment2d line1, LineSegment2d line2)
&lt;/pre&gt;

&lt;p&gt;The ratio of first &lt;code&gt;LineSegment2d&lt;/code&gt; to second &lt;code&gt;LineSegment2d&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Symmetric"&gt;&lt;/a&gt;Symmetric&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric(Workplane wrkpl, Point3d p1, Point3d p2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric(Workplane wrkpl, Point2d p1, Point2d p2)
&lt;/pre&gt;

&lt;p&gt;Two &lt;code&gt;Point2d/3d&lt;/code&gt; will symmetric to a work plane.&lt;/p&gt;
&lt;p&gt;This means that they are on opposite sides of the plane and at equal distances from the plane, and that the line connecting ptA and ptB is normal to the plane.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC_HORIZ&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric_H(Workplane wrkpl, Point2d p1, Point2d p2)
&lt;/pre&gt;

&lt;p&gt;Two &lt;code&gt;Point2d&lt;/code&gt; will be locked in the same horizontal coordinate.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC_VERT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric_V(Workplane wrkpl, Point2d p1, Point2d p2)
&lt;/pre&gt;

&lt;p&gt;Two &lt;code&gt;Point2d&lt;/code&gt;will be locked in the same vertical coordinate.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_SYMMETRIC_LINE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.symmetric(Workplane wrkpl, Point2d p1, Point2d p2, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;Two &lt;code&gt;Point2d&lt;/code&gt; will symmetric to the &lt;code&gt;LineSegment2d&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Midpoint"&gt;&lt;/a&gt;Middle point&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_AT_MIDPOINT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.midpoint(Point3d p, LineSegment3d line)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.midpoint(Workplane wrkpl, Point2d p, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;Let a &lt;code&gt;Point2d/3d&lt;/code&gt; locate on a middle point of the &lt;code&gt;LineSegment2d&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-HV"&gt;&lt;/a&gt;Horizontal &amp;amp; Vertical&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_HORIZONTAL&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.horizontal(Workplane wrkpl, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SLVS_C_VERTICAL&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.vertical(Workplane wrkpl, LineSegment2d line)
&lt;/pre&gt;

&lt;p&gt;Let a &lt;code&gt;LineSegment2d&lt;/code&gt; to horizontal or vertical.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Diameter"&gt;&lt;/a&gt;Diameter &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_DIAMETER&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.diameter(double diameter, Workplane wrkpl, Circular c)
&lt;/pre&gt;

&lt;p&gt;Diameter of a &lt;code&gt;Circular&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Angle"&gt;&lt;/a&gt;Angle &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_ANGLE&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.angle(Workplane wrkpl, double value, LineSegment2d line1, LineSegment2d line2, bool other)
&lt;/pre&gt;

&lt;p&gt;Angle of two &lt;code&gt;LineSegment2d&lt;/code&gt;. In degrees.&lt;/p&gt;
&lt;p&gt;The following formula (&lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are vector of two lines):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(A dot B)/(|A||B|) = cos(valA)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;where A and B are vectors in the directions of lines A and B. This equation does not specify the angle unambiguously; for example, note that valA = +/- 90 degrees will produce the same equation.&lt;/p&gt;
&lt;p&gt;If other is true, then the constraint is instead that&lt;/p&gt;
&lt;p&gt;(A dot B)/(|A||B|) = -cos(valA)&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PERPENDICULAR&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.perpendicular(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2, bool other)
&lt;/pre&gt;

&lt;p&gt;From constraint &lt;code&gt;SLVS_C_ANGLE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This constraint is defined angle constraint when it is 90 degrees.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Parallel"&gt;&lt;/a&gt;Parallel&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_PARALLEL&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.parallel(LineSegment3d line1, LineSegment3d line2)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.parallel(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2)
&lt;/pre&gt;

&lt;p&gt;Two &lt;code&gt;LineSegment2d/3d&lt;/code&gt; are parallel each other.&lt;/p&gt;
&lt;p&gt;Note that this constraint removes one degree of freedom when projected in to the plane, but two degrees of freedom in 3d.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Tangent"&gt;&lt;/a&gt;Tangent &lt;kbd&gt;Val&lt;/kbd&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_ARC_LINE_TANGENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.tangent(ArcOfCircle arc, LineSegment2d line, bool other)
&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;ArcOfCircle&lt;/code&gt; and a &lt;code&gt;LineSegment2d&lt;/code&gt; are tangent.&lt;/p&gt;
&lt;p&gt;If the bool value is &lt;code&gt;False&lt;/code&gt;, than it will tangent at its beginning &lt;code&gt;s&lt;/code&gt;. If other is &lt;code&gt;True&lt;/code&gt;, then the arc is tangent at its end &lt;code&gt;e&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_CUBIC_LINE_TANGENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.tangent(Cubic c, LineSegment3d l, bool other)
&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Cubic&lt;/code&gt; and a &lt;code&gt;LineSegment3d&lt;/code&gt; are tangent.&lt;/p&gt;
&lt;p&gt;If the bool value is &lt;code&gt;False&lt;/code&gt;, than it will tangent at its beginning &lt;code&gt;p0&lt;/code&gt;. If other is &lt;code&gt;True&lt;/code&gt;, then the arc is tangent at its end &lt;code&gt;p3&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_CURVE_CURVE_TANGENT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; &lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.tangent(ArcOfCircle c1, ArcOfCircle c2, bool other, bool other2)
Constraint.tangent(Cubic c1, Cubic c2, bool other, bool other2)
Constraint.tangent(ArcOfCircle c1, Cubic c2, bool other, bool other2)
Constraint.tangent(Cubic c1, ArcOfCircle c2, bool other, bool other2)
&lt;/pre&gt;

&lt;p&gt;Tangent combination of two curves.&lt;/p&gt;
&lt;p&gt;If the bool value is &lt;code&gt;False&lt;/code&gt;, than it will tangent at its beginning &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;p0&lt;/code&gt;. If other is &lt;code&gt;True&lt;/code&gt;, then the arc is tangent at its end &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;p3&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a name="C-Dragged"&gt;&lt;/a&gt;Dragged&lt;/h2&gt;
&lt;h2&gt;&lt;code&gt;SLVS_C_WHERE_DRAGGED&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.dragged(Point3d p)
&lt;/pre&gt;

&lt;p&gt;&lt;kbd&gt;2D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
Constraint.dragged(Workplane wrkpl, Point2d p)
&lt;/pre&gt;

&lt;p&gt;Permanently lock the &lt;code&gt;Point2d/3d&lt;/code&gt; point coordinates in the current calculation of the coordinates, never change.&lt;/p&gt;
&lt;p&gt;This constrains two degrees of freedom in a workplane, and three in free space.&lt;/p&gt;
&lt;h2&gt;Set Dragged &lt;kbd&gt;Tips&lt;/kbd&gt;&lt;/h2&gt;
&lt;p&gt;About lock the position,  another constraint of system as follows:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
sys.set_dragged(Point p)
&lt;/pre&gt;

&lt;p&gt;It is command that try to fix the &lt;code&gt;Point2d/3d&lt;/code&gt;, instead to move other entities.&lt;/p&gt;
&lt;p&gt;This point will get a little of movement.&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;&lt;a name="ADD"&gt;&lt;/a&gt;Additional Types of Constrains&lt;/h1&gt;
&lt;p&gt;Some additional constraints, there is no corresponding entity items available for them.&lt;/p&gt;
&lt;h2&gt;Point and Face&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_C_PT_FACE_DISTANCE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#This feature is not Construction
&lt;/pre&gt;

&lt;h2&gt;Point on Face&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SLVS_C_PT_ON_FACE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;kbd&gt;3D&lt;/kbd&gt; Use the command:&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#This feature is not Construction
&lt;/pre&gt;</content><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/16</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050816.html" rel="alternate"></link><published>2016-08-16T21:00:00+08:00</published><updated>2016-08-16T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-16:/blog/40323230ri-zhi-1050816.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Jupyterhub 繪圖 - 漸開線範例（已儲存8888.kmol.info）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CentOS 安裝 Python 3.3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Jupyterhub 繪圖 - 漸開線範例（已儲存8888.kmol.info）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CentOS 安裝 Python 3.3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;漸開線範例&lt;/h1&gt;
&lt;p&gt;嘗試使用純 &lt;code&gt;slvs&lt;/code&gt; 程式庫（而非使用 matlab 的公式）的方式畫出漸開線。&lt;/p&gt;
&lt;p&gt;雖然程式庫中有比較弧長和線段長的公式，但是無法因應多圈的狀況，所以使用內建math的 &lt;code&gt;pi&lt;/code&gt; 來計算弧長。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Dgdmbxm.jpg" &gt;&lt;/p&gt;
&lt;p&gt;越多圈的漸開線計算越久，角度參照是基圓而非漸開線尾。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
%matplotlib inline
#漸開線解題
#由端點Point3畫出圖形
from slvs import *
import matplotlib.pyplot as plt
from math import *

#參數
r = 10.0#基圓半徑

def Involute(degree):
    #角度換算：degree去除重複圈數
    d = r*(degree*pi/180)
    n = degree//360
    degree -= 360*n

    #開始繪圖
    sys = System(500)
    g = 1

    #3D原點Point0
    p0 = sys.add_param(0.0)
    p1 = sys.add_param(0.0)
    p2 = sys.add_param(0.0)
    Point0 = Point3d(p0, p1, p2)

    #XY法線
    qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal1 = Normal3d(p3, p4, p5, p6)

    #工作平面
    Workplane1 = Workplane(Point0, Normal1)

    #2D原點Point1
    p7 = sys.add_param(0.0)
    p8 = sys.add_param(0.0)
    Point1 = Point2d(Workplane1, p7, p8)
    Constraint.dragged(Workplane1, Point1)

    #Angle約束判斷
    if degree &gt;= 180:
        other = -1
    else:
        other = 1

    #Point2繞行圓周，距離r
    p9 = sys.add_param(0.0)
    p10 = sys.add_param(10.0*other)
    Point2 = Point2d(Workplane1, p9, p10)
    Constraint.distance(r, Workplane1, Point1, Point2)
    Line1 = LineSegment2d(Workplane1, Point1, Point2)

    #Point3距離Point2為目前圓周長
    #並且連線d會垂直半徑連線r
    p11 = sys.add_param(10.0*other)
    p12 = sys.add_param(10.0*other)
    Point3 = Point2d(Workplane1, p11, p12)
    if d == 0:
        Constraint.on(Workplane1, Point2, Point3)
    else:
        Line2 = LineSegment2d(Workplane1, Point2, Point3)
        Constraint.distance(d, Workplane1, Point2, Point3)
        Constraint.perpendicular(Workplane1, Line1, Line2, False)

    #輔助基線Line0
    p13 = sys.add_param(10.0)
    p14 = sys.add_param(0.0)
    Point4 = Point2d(Workplane1, p13, p14)
    Constraint.dragged(Workplane1, Point4)
    Line0 = LineSegment2d(Workplane1, Point1, Point4)

    #約束角度
    Constraint.angle(Workplane1, degree, Line1, Line0, False)

    #以下解題
    sys.solve()
    if (sys.result == SLVS_RESULT_OKAY):
        #回傳Point7
        x = sys.get_param(11).val
        y = sys.get_param(12).val
        return x, y
    elif (sys.result == SLVS_RESULT_INCONSISTENT):
        print ("solve failed")
        print ("SLVS_RESULT_INCONSISTENT")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
        print ("solve failed")
        print ("SLVS_RESULT_DIDNT_CONVERGE")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
        print ("solve failed")
        print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
        print ("%d DOF" % sys.dof)

#主程式
Xval  = []
Yval  = []
degree = 720
for i in range(0, degree+1, 1):
    x, y = Involute(i)
    Xval += [x]
    Yval += [y]
print ("Solve Completed")

plt.plot(Xval, Yval)
plt.xlabel('x coordinate')
plt.ylabel('y coordinate')
plt.title("Involute - "+str(degree)+" deg")
plt.show()
&lt;/pre&gt;

&lt;p&gt;由於 &lt;code&gt;Point2&lt;/code&gt; 是逆時針旋轉，必須保持 &lt;code&gt;Point3&lt;/code&gt; 在它的後方，之間的連線也必須相切基圓，即與其半徑垂直。&lt;/p&gt;
&lt;p&gt;然而 &lt;code&gt;slvs&lt;/code&gt; 程式庫無法解決距離為 &lt;code&gt;0&lt;/code&gt; 的情況，必須自己改成重合約束，目前在程式庫說明中加上註解，不過應該有辦法透過原始碼的標頭檔避開這個問題，晚點會修正這個情況，如果情況順利，明天的網誌中會更新。&lt;/p&gt;
&lt;p&gt;結果圖形：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nbCrMjE.png" &gt;&lt;/p&gt;
&lt;p&gt;Jupyter 運行結果（計算時間較長）：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/QjE2qEl.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;CentOS 7&lt;/h1&gt;
&lt;p&gt;為虛擬機（研究室的電腦）安裝官方的 Everything 版本（ISO映像檔），但是電腦效能只能同時跑一個程式，所以安裝很緩慢。&lt;/p&gt;
&lt;p&gt;最後還是灌好了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/BfVtw6K.png" &gt;&lt;/p&gt;
&lt;p&gt;但是安裝完後之前選的 Python 工具包中竟然只有 Python 2.7，所以上網找了一下資料，用手動make的方式安裝 Python 3.3.6。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://tecadmin.net/install-python-3-4-on-centos-rhel-fedora/" title="tecadmin.net"&gt;http://tecadmin.net/install-python-3-4-on-centos-rhel-fedora/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/OVS9mZ2.png" &gt;&lt;/p&gt;
&lt;p&gt;CentOS 相較於 Ubuntu 操作方式不太一樣，而雖然安裝畫面是寫 KDE 圖形介面，但卻是 GNOME 包著 KDE 的附屬程式，而且它們的介面還比 Ubuntu 陽春。&lt;/p&gt;
&lt;p&gt;慶幸的是 CentOS 的開發者工具包十分完善，應該是不用 Netbeans 了，可以直接用終端機make。&lt;/p&gt;</content><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/15</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050815.html" rel="alternate"></link><published>2016-08-15T21:00:00+08:00</published><updated>2016-08-15T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-15:/blog/40323230ri-zhi-1050815.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Jupyterhub 繪圖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多連桿機構的程式及註解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Jupyterhub 繪圖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多連桿機構的程式及註解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Jupyterhub&lt;/h1&gt;
&lt;p&gt;用學校 Gmail 登入後用 notebook 進行運算，程式碼開頭只要加上 &lt;code&gt;%matplotlib inline&lt;/code&gt; 就能使用 matplotlib 了。&lt;/p&gt;
&lt;p&gt;不過 notebook 目前是唯獨模式，無法建立檔案或是編輯。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/MyRvGoJ.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;程式碼&lt;/h1&gt;
&lt;p&gt;這次將畫圖順序統整了一下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/s8rsywg.jpg" &gt;&lt;/p&gt;
&lt;pre class="brush: python"&gt;
%matplotlib inline
#多連桿機構端點（Point7）路徑圖形
#主動軸為［曲柄］Point1-Point2
#圖形將在程式中解釋
from slvs import *
import matplotlib.pyplot as plt

def Multi_link(degree):
    #開始繪圖
    sys = System(500)
    g = 1

    #3D原點Point0
    p0 = sys.add_param(0.0)
    p1 = sys.add_param(0.0)
    p2 = sys.add_param(0.0)
    Point0 = Point3d(p0, p1, p2)

    #XY法線
    qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal1 = Normal3d(p3, p4, p5, p6)

    #工作平面
    Workplane1 = Workplane(Point0, Normal1)

    #2D原點Point1
    p7 = sys.add_param(0.0)
    p8 = sys.add_param(0.0)
    Point1 = Point2d(Workplane1, p7, p8)
    Constraint.dragged(Workplane1, Point1)

    #Angle約束判斷
    if degree &gt;= 180:
        other = -1
    else:
        other = 1

    #［曲柄］Point1-Point2長15mm
    p9 = sys.add_param(0.0)
    p10 = sys.add_param(20.0*other)
    Point2 = Point2d(Workplane1, p9, p10)
    Constraint.distance(15.0, Workplane1, Point1, Point2)
    Line1 = LineSegment2d(Workplane1, Point1, Point2)

    #第一組［呆鍊］Point3-Point4-Point5（Point3固定）
    #長度41.5-55.8-40.1mm
    p11 = sys.add_param(-38.0)
    p12 = sys.add_param(-7.8)
    Point3 = Point2d(Workplane1, p11, p12)
    Constraint.dragged(Workplane1, Point3)
    p13 = sys.add_param(-50.0)
    p14 = sys.add_param(30.0)
    Point4 = Point2d(Workplane1, p13, p14)
    p15 = sys.add_param(-70.0)
    p16 = sys.add_param(-15.0)
    Point5 = Point2d(Workplane1, p15, p16)
    Constraint.distance(41.5, Workplane1, Point3, Point4)
    Constraint.distance(55.8, Workplane1, Point4, Point5)
    Constraint.distance(40.1, Workplane1, Point3, Point5)

    #第二組［呆鍊］Point6-Point7-Point8
    #長度65.7-49.0-36.7mm
    p17 = sys.add_param(-50.0)
    p18 = sys.add_param(-50.0)
    Point6 = Point2d(Workplane1, p17, p18)
    p19 = sys.add_param(-10.0)
    p20 = sys.add_param(-90.0)
    Point7 = Point2d(Workplane1, p19, p20)
    p21 = sys.add_param(-20.0)
    p22 = sys.add_param(-40.0)
    Point8 = Point2d(Workplane1, p21, p22)
    Constraint.distance(65.7, Workplane1, Point6, Point7)
    Constraint.distance(49.0, Workplane1, Point7, Point8)
    Constraint.distance(36.7, Workplane1, Point6, Point8)

    #兩段［呆鍊-呆鍊］連接桿
    #Point5-Point6長39.4mm
    #Point3-Point8長39.3mm
    Constraint.distance(39.4, Workplane1, Point5, Point6)
    Constraint.distance(39.3, Workplane1, Point3, Point8)

    #兩段［區柄-呆鍊］連接桿
    #Point2-Point4長50.0mm
    #Point2-Point8長61.9mm
    Constraint.distance(50.0, Workplane1, Point2, Point4)
    Constraint.distance(61.9, Workplane1, Point2, Point8)

    #水平輔助Line0
    p23 = sys.add_param(20.0)
    p24 = sys.add_param(0.0)
    Point9 = Point2d(Workplane1, p23, p24)
    Constraint.dragged(Workplane1, Point9)
    Line0 = LineSegment2d(Workplane1, Point1, Point9)

    #區柄角度（手動項目務必放最後）
    Constraint.angle(Workplane1, degree, Line1, Line0, False)

    #以下解題
    sys.solve()
    if (sys.result == SLVS_RESULT_OKAY):
        #回傳Point7
        x = sys.get_param(19).val
        y = sys.get_param(20).val
        return x, y
    elif (sys.result == SLVS_RESULT_INCONSISTENT):
        print ("solve failed")
        print ("SLVS_RESULT_INCONSISTENT")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
        print ("solve failed")
        print ("SLVS_RESULT_DIDNT_CONVERGE")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
        print ("solve failed")
        print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
        print ("%d DOF" % sys.dof)

#主程式
Xval  = []
Yval  = []

for i in range(0, 361, 1):
    x, y = Multi_link(i)
    Xval += [x]
    Yval += [y]
print ("Solve Completed")

plt.plot(Xval, Yval)
plt.xlabel('x coordinate')
plt.ylabel('y coordinate')
plt.show()
&lt;/pre&gt;

&lt;p&gt;因為是變速機構，如果將精度調成5度的話，圖形會比較粗糙，目前用1度的精度會比較平滑，不過相對運算時間會比較久。&lt;/p&gt;
&lt;h2&gt;執行結果（5度）&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CvjRTBI.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;執行結果（1度）&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xHnFqdE.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;經過多次範例，若要使用 slvs 程式庫畫圖，要先看一下機構節點的大約位置，尤其是運動範圍跨象限的主動節點（即參數控制約束的點）。&lt;/p&gt;
&lt;p&gt;機構中會360度繞軸旋轉的區柄端點，起始位置要定在90度（輸入值在0～180）或-90度（輸入值在181～359），要用 &lt;code&gt;if&lt;/code&gt; 函式判斷。&lt;/p&gt;</content><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/14</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050814.html" rel="alternate"></link><published>2016-08-14T21:00:00+08:00</published><updated>2016-08-14T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-14:/blog/40323230ri-zhi-1050814.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用研究室網路設定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;架站問題&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python 3.3 版本製作中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用研究室網路設定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;架站問題&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python 3.3 版本製作中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;網路設定&lt;/h1&gt;
&lt;p&gt;由於之前上網是用手機網路，為了取得固定IP，使用的是原本給新電腦用的網路 &lt;code&gt;140.130.17.117&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Su0D9Oc.png" &gt;&lt;/p&gt;
&lt;p&gt;Windows 和 Ubuntu 中的設定是一樣的，兩個OS都能連到網際網路。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Oauthenticator&lt;/h1&gt;
&lt;p&gt;參考 Cadlab 有關 Jupyterhub 的安裝，在 Python 中安裝了 jupyterhub、notebook 和 oauthenticator。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cadlab.mde.tw/post/jupyterhub-oauth2-deng-ru-she-ding.html" title="cadlab.mde.tw"&gt;http://cadlab.mde.tw/post/jupyterhub-oauth2-deng-ru-she-ding.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://cadlab.mde.tw/post/chun-ipv6-huan-jing-xia-an-zhuang-jupyterhub.html" title="cadlab.mde.tw"&gt;http://cadlab.mde.tw/post/chun-ipv6-huan-jing-xia-an-zhuang-jupyterhub.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;利用指令產生 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;crt&lt;/code&gt; 兩個憑證檔案。&lt;/p&gt;
&lt;pre&gt;sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout jupyterhub.key -out jupyterhub.crt&lt;/pre&gt;

&lt;p&gt;起動指令是：&lt;/p&gt;
&lt;pre&gt;jupyterhub --ip 140.130.17.117 --port 9443 --ssl-key jupyterhub.key --ssl-cert jupyterhub.crt&lt;/pre&gt;

&lt;p&gt;從&lt;a href="https://github.com/jupyterhub/oauthenticator/tree/master/example" title="github.com"&gt;https://github.com/jupyterhub/oauthenticator/tree/master/example&lt;/a&gt;下載了範例資料夾，不過 &lt;code&gt;jupyterhub_config.py&lt;/code&gt; 結構跟說明不太一樣，所以把他的指令碼改成 Cadlab 的方式，只是白名單和使用者清單的檔案可能不一樣，改一下資料夾或連結名稱就能對應。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/AkO0IE6.png" &gt;&lt;/p&gt;
&lt;p&gt;接著進 Github 註冊新的app，取得 Client ID 和 Client Secret，不過不知道網域名稱該填甚麼，只能填上電腦IP名稱。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/l4FqQ1c.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而 Google 方面也是一樣，但是重新導向 callback 的方面要使用頂層網域，就是包含 &lt;code&gt;.com&lt;/code&gt; 或 &lt;code&gt;.org&lt;/code&gt; 的名稱，這樣就沒辦法導向給 IP 名稱的網站用了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/u5TFwgH.png" &gt;&lt;/p&gt;
&lt;p&gt;另外就是檔案瀏覽器沒有權限在 &lt;code&gt;etc&lt;/code&gt; 或 &lt;code&gt;srv&lt;/code&gt; 目錄裡編輯或是建立檔案，要自動啟動就必須用終端機設定了。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;pyenv&lt;/h1&gt;
&lt;p&gt;裝了 pyenv 來管理 Python 版本。&lt;/p&gt;
&lt;p&gt;安裝時還需要 Mercurial。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/yZbLONl.png" &gt;&lt;/p&gt;
&lt;p&gt;Python 3.3 dev 下載和安裝時都比較久，等了一段時間才弄好。&lt;/p&gt;
&lt;p&gt;接下來會編譯 3.3 的版本來測試。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;由於對網路方面不熟悉，所以可能設定方面有所缺失，還要花一些時間檢查。&lt;/p&gt;</content><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050813.html" rel="alternate"></link><published>2016-08-13T21:00:00+08:00</published><updated>2016-08-13T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-13:/blog/40323230ri-zhi-1050813.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 版本與 Openshift 不合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Openshift 的 cartridge 自訂？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 版本與 Openshift 不合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Openshift 的 cartridge 自訂？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;版本不合&lt;/h1&gt;
&lt;p&gt;後來發現為何找不到 &lt;code&gt;_slvs.so&lt;/code&gt; 的檔案了，因為 &lt;code&gt;.gitignore&lt;/code&gt; 中包含了 &lt;code&gt;*.so&lt;/code&gt;，而不會上傳這兩個檔案，註解掉就行了。&lt;/p&gt;
&lt;p&gt;但是上傳後仍無法執行，回報的訊息為：&lt;/p&gt;
&lt;pre&gt;
Traceback (most recent call last):
  File "/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/wsgi.py", line 5, in &lt;module&gt;
    import myflaskapp
  File "/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/myflaskapp.py", line 18, in &lt;module&gt;
    import users.b.g9.bg9_40323230
  File "/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/users/b/g9/bg9_40323230.py", line 2, in &lt;module&gt;
    from slvs import *
  File "/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/slvs.py", line 28, in &lt;module&gt;
    _slvs = swig_import_helper()
  File "/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/slvs.py", line 24, in swig_import_helper
    _mod = imp.load_module('_slvs', fp, pathname, description)
  File "/opt/rh/python33/root/usr/lib64/python3.3/imp.py", line 183, in load_module
    return load_dynamic(name, filename, file)
ImportError: libpython3.4m.so.1.0: cannot open shared object file: No such file or directory
&lt;/pre&gt;

&lt;p&gt;看來開發時使用 Python 3.4 dev 會造成 Python 3.3 無法讀取。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jUsRUi4.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Openshift custom cartridge&lt;/h1&gt;
&lt;p&gt;上網找了一下文章，找到有人問能不能建立其他版本的 cartridge。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/34073473/openshift-custom-cartridge-with-python-3-4" title="stackoverflow.com"&gt;http://stackoverflow.com/questions/34073473/openshift-custom-cartridge-with-python-3-4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而回應的是如果使用 s2i-python-container 這個工具，可以建立一個名為 Python 3.3 的其他版本 Python 鏡像檔，甚至有支援 Python 3.5。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/sclorg/s2i-python-container" title="github.com"&gt;https://github.com/sclorg/s2i-python-container&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不過這個工具只能給 Fedora 類型的 Linux 作業系統使用，看起來是沒有 Debian 的版本。&lt;/p&gt;
&lt;p&gt;要解決 Linux 相容的問題，Ubuntu 上可能要裝 3.3 版本的 Python 了，會先研究看看 Openshift 方可以安裝和執行的指令。&lt;/p&gt;
&lt;p&gt;不知道如果其他 Ubuntu 沒安裝 Python-dev（或版本不同）的話能不能執行這些檔案。&lt;/p&gt;
&lt;p&gt;Windows 的 Python 連結庫是自己做的，而非安裝 Python-dev，所以沒這個問題。&lt;/p&gt;</content><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/12</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050812.html" rel="alternate"></link><published>2016-08-12T21:00:00+08:00</published><updated>2016-08-12T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-12:/blog/40323230ri-zhi-1050812.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 版本編譯完畢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 版本編譯完畢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Ubuntu 執行成功&lt;/h1&gt;
&lt;p&gt;後來將 &lt;code&gt;slvs_python.hpp&lt;/code&gt; 的 &lt;code&gt;__mingw_vasprintf&lt;/code&gt; 暫時改為 &lt;code&gt;vasprintf&lt;/code&gt; 就沒問題了，不過若要使用MinGW編譯的話要再改回來。&lt;/p&gt;
&lt;p&gt;編譯出來的檔案名稱為 &lt;code&gt;_slvs.so&lt;/code&gt;，類型是共享連結庫。&lt;/p&gt;
&lt;p&gt;在終端機中使用python3執行所有範例檔都沒問題。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/gcEM8h0.png" &gt;&lt;/p&gt;
&lt;p&gt;Windows 用的 &lt;code&gt;_slvs.pyd&lt;/code&gt; ，在檔案瀏覽器中被視為 Windows 可執行檔，而非共享連結庫。&lt;/p&gt;
&lt;p&gt;將 Makefile 存成兩個版本（加上次檔名），不同平台間用 &lt;code&gt;-f&lt;/code&gt; 參數切換make就行了。&lt;/p&gt;
&lt;p&gt;不過目前手邊沒有虛擬機，所以還沒測試是否所有使用 Python 3.4 的 Ubuntu 都能使用程式庫。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;倉儲更新&lt;/h1&gt;
&lt;p&gt;統一將make完畢的 Library 放在 Windows 和 Ubuntu 資料夾。&lt;/p&gt;
&lt;p&gt;將倉儲清理了一下，讓原始碼回到 make clean 狀態。&lt;/p&gt;
&lt;p&gt;將原本 Windows 的範例code複製一份到 Ubuntu 資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nIY73qM.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;不過將 &lt;code&gt;_slvs.so&lt;/code&gt; 和編譯好的附屬文件上傳到 Openshift 後仍然找不到 &lt;code&gt;_slvs&lt;/code&gt; 模組。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/juGSqv4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著會測試看看小型的pyd能不能用。&lt;/p&gt;</content><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/11</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050811.html" rel="alternate"></link><published>2016-08-11T21:00:00+08:00</published><updated>2016-08-11T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-11:/blog/40323230ri-zhi-1050811.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝 Linux 版工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 版本編譯&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝 Linux 版工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu 版本編譯&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;工作環境&lt;/h1&gt;
&lt;p&gt;用以前安裝的雙系統做 Ubuntu 版本的編譯。&lt;/p&gt;
&lt;p&gt;作業系統是基於 Ubuntu 14.04 的 ezgo 12，圖形介面為KDE。&lt;/p&gt;
&lt;p&gt;原本 ezgo 中的python3版本為 3.4.0，安裝python3.4-dev後升級到最新的3.4.5。&lt;/p&gt;
&lt;p&gt;而原版的GNU工具沒有裝入g++，所以就用apt安裝了。&lt;/p&gt;
&lt;p&gt;在 Ubuntu 上運行 Netbeans 和 gcc 比 Windows 流暢，make的速度更快。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;產生問題&lt;/h1&gt;
&lt;p&gt;因為作業系統換了環境，所以Makefile的位置研究並調整了一下。&lt;/p&gt;
&lt;p&gt;不過在編譯&lt;code&gt;slvs_python.hpp&lt;/code&gt;時出現&lt;code&gt;‘__mingw_vasprintf’ was not declared in this scope&lt;/code&gt;的訊息。&lt;/p&gt;
&lt;p&gt;這個函式應該是&lt;code&gt;stdio.h&lt;/code&gt;的，不知道為何無法找到它。&lt;/p&gt;
&lt;p&gt;檢查了系統目錄，這個檔案應該都在&lt;code&gt;include&lt;/code&gt;的範圍內，所以應該是使用GNU和原本MinGW兩種版本gcc的問題。&lt;/p&gt;
&lt;p&gt;不過這次並非在虛擬機測試，所以使用上會更小心。&lt;/p&gt;</content><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/10</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050810.html" rel="alternate"></link><published>2016-08-10T21:00:00+08:00</published><updated>2016-08-10T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-10:/blog/40323230ri-zhi-1050810.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;檢視python.log的錯誤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python Solvespace 的介紹圖&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;檢視python.log的錯誤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python Solvespace 的介紹圖&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;FileZilla 登入&lt;/h1&gt;
&lt;p&gt;用FileZilla進入網站查看和下載檔案。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/oXaiwCp.jpg" &gt;&lt;/p&gt;
&lt;p&gt;在Openshift的網頁中按下"Want to log in to your application?"連結，能取得一個字串，形式如下。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh 使用者名稱@主機&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dpua4rp.jpg" &gt;&lt;/p&gt;
&lt;p&gt;將其內容填入FileZilla的站台設定中，協定選擇SFTP，登入形式選擇交談式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/nmtCVUg.jpg" &gt;&lt;/p&gt;
&lt;p&gt;然後連線後，在&lt;code&gt;/var/lib/openshift/使用者名稱/app-root/logs&lt;/code&gt;資料夾中可以找到python.log，下載後開啟。&lt;/p&gt;
&lt;p&gt;最下方是最新的執行紀錄和連線紀錄。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/l8Xoe0b.jpg" &gt;&lt;/p&gt;
&lt;p&gt;看到問題是錯在模組導入錯誤，雖然訊息跟之前模組匯入的問題一樣，但是造成原因應該不一樣。&lt;/p&gt;
&lt;p&gt;不知道是python版本還是openshift不使用anaconda的關係。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;slvs.py&lt;/code&gt;無法像先前一般將&lt;code&gt;_slvs.pyd&lt;/code&gt;的名稱傳給python用。&lt;/p&gt;
&lt;h1&gt;介紹圖&lt;/h1&gt;
&lt;p&gt;用免費軟體XMind做兩張Python Solvespace的概念圖。&lt;/p&gt;
&lt;p&gt;軟體中不能調整解析度，目前的比例還能符合網頁或文件中的說明。&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;製作過程&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/e6JWCWW.png" &gt;&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;利用規劃&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/62SVuDT.png" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;在想是否要將slvs的檔案做成模組的方式裝入Python，再裝到Openshift的python上。&lt;/p&gt;
&lt;p&gt;做成模組後用途應該會增加。&lt;/p&gt;
&lt;p&gt;近期將整理網誌內容改成書面格式，先存成Markdown檔，再另外參照學長的目錄做分類排序成章節。&lt;/p&gt;</content><category term="Kmol"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/08</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050808.html" rel="alternate"></link><published>2016-08-08T21:00:00+08:00</published><updated>2016-08-08T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-08:/blog/40323230ri-zhi-1050808.html</id><summary type="html">&lt;p&gt;將bokeh繪圖搬入Flask，使用的是上學期的倉儲。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;將bokeh繪圖搬入Flask，使用的是上學期的倉儲。&lt;/p&gt;


&lt;h1&gt;bokeh網頁原始碼&lt;/h1&gt;
&lt;p&gt;bokeh在使用後，可以不選擇存檔，而是變成網頁原始碼的型態，讓程式利用。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#不使用from bokeh.plotting import figure, output_file, show, save

#而導入：
from bokeh.plotting import figure
from bokeh.resources import CDN
from bokeh.embed import file_html

#照常畫圖
plot = figure(...)
plot.line(...)

#最後傳出給outstring
outstring = str(file_html(plot, CDN, "網頁視窗標題"))
&lt;/pre&gt;

&lt;p&gt;變成這樣的形態後，會先讓SLVS程式庫和bokeh計算完原始碼後才使用，算是靜態結果，這樣會產生一個缺點，稍後會提到。&lt;/p&gt;
&lt;p&gt;bokeh也有自己的附加功能"JavaScript Callbacks"，屬於動態運算，讓圖形能及時更新，不用重新整理。&lt;/p&gt;
&lt;p&gt;參考連結：&lt;a href="http://bokeh.pydata.org/en/latest/docs/user_guide/interaction/callbacks.html#customjs-for-widgets" title="bokeh.pydata.org"&gt;http://bokeh.pydata.org/en/latest/docs/user_guide/interaction/callbacks.html#customjs-for-widgets&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;試過了範例Slider的方法（最接近需求：給角度求機構當前狀態），在JavaScript中卻不知所以然，不知道要如何把callback的內容帶入我的函式中。&lt;/p&gt;
&lt;p&gt;上網看過別人的範例，不同利用方式都不一樣，但是不知道如何修改JS迴圈中的內容。因為機構的圖形要回傳所有的點，可能要了解一下這些物件的關係。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;Flask&lt;/h1&gt;
&lt;p&gt;和上學期的專案一樣，用&lt;code&gt;python wsgi.py&lt;/code&gt;啟動後就能呼叫程式並帶入變數求解。&lt;/p&gt;
&lt;p&gt;不同的是用到新模組和自己的程式庫。&lt;/p&gt;
&lt;p&gt;在自己的檔案中再插入一段&lt;code&gt;Mango(k)&lt;/code&gt;來嵌入bokeh的圖形，並希望能控制機構的角度狀態。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jTqqiDg.jpg" &gt;&lt;/p&gt;
&lt;p&gt;稍微調整了bokeh的選項，隱藏工具、取消預設工具、不可拖移、放大介面等等。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
@bg9_40323230.route('/crank_rock/＜k&gt;')
def Mango(k):
    outstring = ""
    #相關參數
    d0 = 90 #基線長度(mm)
    n1 = 35 #短連桿長度(mm)
    n2 = 70 #長連桿長度(mm)
    t1 = 40 #三角形第一邊(mm)
    t2 = 40 #三角形第二邊(mm)
    t3 = 70 #三角形第三邊(mm)

    #迴圈求路徑用
    def crank_rock(degree):
        ...
    #當前機構狀態用
    def crank_rock_M(degree):
        ...
    #主程式
    X1val  = []
    Y1val  = []
    for i in range(0, 361):
        x, y = crank_rock(i)
        X1val += [x]
        Y1val += [y]
    x1, y1, x2, y2, x3, y3, x4, y4, x5, y5 = crank_rock_M(float(k))
    X2val = [x1, x4, x3, x5, x4, x5, x2]
    Y2val = [y1, y4, y3, y5, y4, y5, y2]
    X3val = [x1, x2]
    Y3val = [y1, y2]
    #bokeh
    plot = figure(title="simple line example", x_axis_label='x', y_axis_label='y', toolbar_location=None, plot_width=700, plot_height=700)
    plot.line(X1val, Y1val, legend="Path.", line_width=2, line_color="blue")
    plot.line(X2val, Y2val, legend="Mechanism.", line_width=4, line_color="red")
    plot.line(X3val, Y3val, line_width=3, line_dash=[4, 4], line_color="orange")
    plot.toolbar.active_drag = None

    outstring = str(file_html(plot, CDN, "Crank Rocker: "+str(k)+" degree"))

    return outstring
&lt;/pre&gt;

&lt;p&gt;這樣子程式會計算出HTML的原始碼給網頁，而bokeh的網頁中不會用到python程式。&lt;/p&gt;
&lt;p&gt;在這裡&lt;code&gt;k&lt;/code&gt;是以&lt;strong&gt;字串&lt;/strong&gt;的方式帶進來的，所以必須轉成Float才能計算。&lt;/p&gt;
&lt;p&gt;但是如果預先設置了&lt;code&gt;defaults&lt;/code&gt;值時（例如&lt;code&gt;120&lt;/code&gt;），這裡的&lt;code&gt;120&lt;/code&gt;可以代表字串或整數或浮點數，python會搶先認定&lt;code&gt;defaults&lt;/code&gt;值能用，儘管自訂的&lt;code&gt;k&lt;/code&gt;值後來轉成浮點數，結果仍然會是&lt;code&gt;defaults&lt;/code&gt;值。&lt;/p&gt;
&lt;p&gt;所以最後不得以把&lt;code&gt;defaults&lt;/code&gt;值捨棄。&lt;/p&gt;
&lt;p&gt;最後結果：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/kuaUOnR.jpg" &gt;&lt;/p&gt;
&lt;p&gt;建立了一支Openshift程式，但是上傳後卻無法使用，不知道是Python 3.3還是其他的問題，整個程式都跑不了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/tSmySff.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;最近因為有點感冒，研究bokeh的互動功能函式滿久的。&lt;/p&gt;
&lt;p&gt;嘗試過用3D的方式解手臂極限範圍，但是程式庫有些盲點。&lt;/p&gt;
&lt;p&gt;SLVS似乎會認定4個約束在同平面的3D點，他們之間的2條連線如果約束為平行，是重複約束，目前不知道要怎麼辦。&lt;/p&gt;</content><category term="Kmol"></category><category term="bokeh"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/08/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050805.html" rel="alternate"></link><published>2016-08-05T21:00:00+08:00</published><updated>2016-08-05T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-05:/blog/40323230ri-zhi-1050805.html</id><summary type="html">&lt;p&gt;使用bokeh繪圖&lt;/p&gt;
</summary><content type="html">&lt;p&gt;使用bokeh繪圖&lt;/p&gt;


&lt;h1&gt;bokeh&lt;/h1&gt;
&lt;p&gt;由於mpld3沒有支援Python 3.5，測試過執行產生的頁面是空白頁，所以選擇使用bokeh來繪製，但是後者不支援3D繪圖。&lt;/p&gt;
&lt;p&gt;使用Anaconda的指令安裝bokeh。&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ana install bokeh
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/mjv0nNb.jpg" &gt;&lt;/p&gt;
&lt;p&gt;參照了一下官方的說明頁：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://bokeh.pydata.org/en/latest/docs/installation.html" title="bokeh.pydata.org"&gt;http://bokeh.pydata.org/en/latest/docs/installation.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://bokeh.pydata.org/en/latest/docs/reference/io.html" title="bokeh.pydata.org"&gt;http://bokeh.pydata.org/en/latest/docs/reference/io.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://bokeh.pydata.org/en/latest/docs/user_guide/notebook.html" title="bokeh.pydata.org"&gt;http://bokeh.pydata.org/en/latest/docs/user_guide/notebook.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;

&lt;h1&gt;Exercise&lt;/h1&gt;
&lt;p&gt;將之前的Crank Rocker改寫一下。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#一三角形呆鍊，由一長一短的連桿固定在水平基線上。
#短連桿鎖固在原點上，長連桿鎖固在距原點90mm處。
#短連桿長度35mm；長連桿長度70mm。
#三角形呆鍊邊長分別為40mm、40mm、70mm
from slvs import *
from math import *
from bokeh.plotting import figure, output_file, show

#相關參數
d0 = 90 #基線長度(mm)
n1 = 35 #短連桿長度(mm)
n2 = 70 #長連桿長度(mm)
t1 = 40 #三角形第一邊(mm)
t2 = 40 #三角形第二邊(mm)
t3 = 70 #三角形第三邊(mm)

#開始繪圖

def crank_rock(degree):

    sys = System(500)
    g = 1
    #原點Point0
    p0 = sys.add_param(0.0)
    p1 = sys.add_param(0.0)
    p2 = sys.add_param(0.0)
    Point0 = Point3d(p0, p1, p2)

    #XY法線
    qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal1 = Normal3d(p3, p4, p5, p6)

    #工作平面
    Workplane1 = Workplane(Point0, Normal1)

    #3D版的Point0=&gt;Point1
    p7 = sys.add_param(0.0)
    p8 = sys.add_param(0.0)
    Point1 = Point2d(Workplane1, p7, p8)
    Constraint.dragged(Workplane1, Point1)

    #長連桿轉軸Point2，還有基線Line0。
    p9 = sys.add_param(d0)
    p10 = sys.add_param(0.0)
    Point2 = Point2d(Workplane1, p9, p10)
    Constraint.dragged(Workplane1, Point2)
    Line0 = LineSegment2d(Workplane1, Point1, Point2)

    #Angle約束判斷
    if degree &gt;= 180:
        other = -1
    else:
        other = 1

    #三角形Point3 / Point4 / Point5
    p11 = sys.add_param(20.0)
    p12 = sys.add_param(20.0)
    Point3 = Point2d(Workplane1, p11, p12)
    p13 = sys.add_param(0.0)
    p14 = sys.add_param(10.0*other)
    Point4 = Point2d(Workplane1, p13, p14)
    p15 = sys.add_param(30.0)
    p16 = sys.add_param(20.0)
    Point5 = Point2d(Workplane1, p15, p16)
    Constraint.distance(t1, Workplane1, Point4, Point3)
    Constraint.distance(t2, Workplane1, Point3, Point5)
    Constraint.distance(t3, Workplane1, Point4, Point5)

    #連桿約束
    Constraint.distance(n1, Workplane1, Point1, Point4)
    Constraint.distance(n2, Workplane1, Point2, Point5)
    Line1 = LineSegment2d(Workplane1, Point1, Point4)

    #短連桿與水平軸的角度
    Constraint.angle(Workplane1, degree, Line1, Line0, False)

    #以下解題

    sys.solve()

    if (sys.result == SLVS_RESULT_OKAY):
        x = sys.get_param(11).val
        y = sys.get_param(12).val
        return x, y
    elif (sys.result == SLVS_RESULT_INCONSISTENT):
        print ("solve failed")
        print ("SLVS_RESULT_INCONSISTENT")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
        print ("solve failed")
        print ("SLVS_RESULT_DIDNT_CONVERGE")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
        print ("solve failed")
        print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
        print ("%d DOF" % sys.dof)

#主程式
Xval  = []
Yval  = []

for i in range(0, 361):
    x, y = crank_rock(i)
    Xval += [x]
    Yval += [y]
print ("Solve Completed")

#bokeh
output_file("mango.html")
plot = figure(title="simple line example", x_axis_label='x', y_axis_label='y')
plot.line(Xval, Yval, legend="Temp.", line_width=2)
show(plot)
&lt;/pre&gt;

&lt;p&gt;使用的是簡單的show指令，會產生一個&lt;code&gt;html&lt;/code&gt;的檔案。&lt;/p&gt;
&lt;p&gt;內容是和matplotlib一樣的圖形。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/05kAM03.png" &gt;&lt;/p&gt;
&lt;p&gt;另外bokeh也可以在Jupyter notebook上使用。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from tmp.workplace.exposed.slvs import *
from math import *
from bokeh.plotting import figure, output_notebook, show

d0 = 90 #基線長度(mm)
n1 = 35 #短連桿長度(mm)
n2 = 70 #長連桿長度(mm)
t1 = 40 #三角形第一邊(mm)
t2 = 40 #三角形第二邊(mm)
t3 = 70 #三角形第三邊(mm)

#開始繪圖

def crank_rock(degree):
    ...

#主程式
Xval  = []
Yval  = []

for i in range(0, 361):
    x, y = crank_rock(i)
    Xval += [x]
    Yval += [y]
print ("Solve Completed")

#bokeh
output_notebook()
plot = figure(title="simple line example", x_axis_label='x', y_axis_label='y')
plot.line(Xval, Yval, legend="Temp.", line_width=2)
show(plot)
&lt;/pre&gt;

&lt;p&gt;程式庫名稱必須改為&lt;code&gt;tmp.workplace.exposed.slvs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;執行結果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/WHoVdrV.jpg" &gt;&lt;/p&gt;
&lt;p&gt;另一支跑手臂極限範圍的程式：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dQM4kck.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;有找到另一個套件Vispy可以畫3D物件，也可以在Jupyter notebook上執行。&lt;/p&gt;
&lt;p&gt;另外Solvespace的運算方面無法同時計算2D和3D的物件，儲存的項目也不一樣。&lt;/p&gt;
&lt;p&gt;不知道能不能用球座標系或圓柱坐標系轉換的方式，做一個將3D點鎖定到2D點的功能。&lt;/p&gt;</content><category term="Kmol"></category><category term="bokeh"></category></entry><entry><title>40323230日誌 - 105/08/03</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050803.html" rel="alternate"></link><published>2016-08-03T21:00:00+08:00</published><updated>2016-08-03T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-08-03:/blog/40323230ri-zhi-1050803.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;研究Scoop的使用方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;檢查錯誤&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;研究Scoop的使用方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;檢查錯誤&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://scoop.readthedocs.io/en/latest/usage.html" title="scoop.readthedocs.io"&gt;http://scoop.readthedocs.io/en/latest/usage.html&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;啟動Scoop&lt;/h1&gt;
&lt;p&gt;為了讓自己製作的函式庫能進行分工運算，想要用一些工具讓SLVS Library能夠支援平行運算功能。&lt;/p&gt;
&lt;p&gt;用pip安裝scoop。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install scoop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Scoop的需求：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Distribute &amp;gt;= 0.6.2 or setuptools &amp;gt;= 0.7
Greenlet &amp;gt;= 0.3.4
pyzmq &amp;gt;= 13.1.0 and libzmq &amp;gt;= 3.2.0
ssh for remote execution
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;上述的套件Anaconda都有安裝了，不過在連線方面還不知道如何設定。&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;python -m scoop&lt;/code&gt;啟動後會顯示［WinError 10022］，上網找資料發現是沒有指定特定目標。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/9SKyqDY.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Scoop的Help指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XjVDlDJ.jpg" &gt;&lt;/p&gt;
&lt;h1&gt;Scoop函式&lt;/h1&gt;
&lt;p&gt;啟動後，在python程式中導入scoop。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
from scoop import futures, shared

def myParallelFunc(inValue):
    myValue = shared.getConst('myValue')
    return inValue + myValue

if __name__ == '__main__':
    shared.setConst(myValue=5)
    print(list(futures.map(myParallelFunc, range(10))))
&lt;/pre&gt;

&lt;p&gt;或是使用指令執行單一檔案也可以。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;python -m scoop --hostfile hosts -vv -n 6 your_program.py [your arguments]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Scoop可以分享函式給其他電腦，並在同時間回饋相同訊息。&lt;/p&gt;
&lt;p&gt;而每台電腦可以平均分配需要運算的項目，達成多工的目的。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天花太多時間檢查ZeroMQ (libzmq)的安裝狀態，因為不同語言的需求好像都不一樣，Python已經包含在pyzmq中（Windows版本應該是如此，但是Linux要另外裝和設定lib位置）；而C語言是安裝後從安裝位置include。&lt;/p&gt;
&lt;p&gt;而ZeroMQ也能導入Python中，不過Scoop給的指令更方便。&lt;/p&gt;
&lt;p&gt;關於Scoop的說明和介紹資料好像滿少的，而網路方面不知道如何架設。&lt;/p&gt;</content><category term="Kmol"></category><category term="pyScoop"></category></entry><entry><title>40323231日誌 - 指令(G碼、M碼...)</title><link href="http://project.mde.tw/blog/40323231ri-zhi-zhi-ling-gma-mma.html" rel="alternate"></link><published>2016-08-02T14:00:00+08:00</published><updated>2016-08-02T14:00:00+08:00</updated><author><name>40323231</name></author><id>tag:project.mde.tw,2016-08-02:/blog/40323231ri-zhi-zhi-ling-gma-mma.html</id><summary type="html">&lt;p&gt;常用指令與解說&lt;/p&gt;
</summary><content type="html">&lt;p&gt;常用指令與解說&lt;/p&gt;


&lt;h3&gt;常用指令&lt;/h3&gt;

&lt;h4&gt;G28 : 原點複歸&lt;/h4&gt;

&lt;h4&gt;G29 : 自動校正&lt;/h4&gt;

&lt;h4&gt;G01 X70 Y60 Z5 : 快速定位  X70 Y60 高度5&lt;/h4&gt;

&lt;h4&gt;M104 : 設定噴頭溫度&lt;/h4&gt;

&lt;h4&gt;M105 : 查詢溫度(噴頭和熱床)&lt;/h4&gt;

&lt;h4&gt;M106 : 開啟風扇&lt;/h4&gt;

&lt;h4&gt;M107 : 關閉風扇&lt;/h4&gt;

&lt;h4&gt;M114 : 查詢目前位置(例如:X40 Y50 Z5)&lt;/h4&gt;

&lt;h4&gt;M119 : 查詢限位開關目前狀態&lt;/h4&gt;

&lt;h4&gt;M500 : 儲存參數&lt;/h4&gt;

&lt;p&gt;&lt;br&gt;
&lt;h3&gt;字母定義&lt;/h3&gt;
&lt;h4&gt;G:範例說明&lt;/h4&gt;
&lt;h4&gt;M:範例說明&lt;/h4&gt;
&lt;h4&gt;T:選擇工具，單一噴頭所以無用&lt;/h4&gt;
&lt;h4&gt;S:命令參數，如電壓，控制轉速、溫度等等&lt;/h4&gt;
&lt;h4&gt;P:命令參數，多少毫秒&lt;/h4&gt;
&lt;h4&gt;F:每分鐘進給(毫米)&lt;/h4&gt;
&lt;h4&gt;E:擠出材料的長度(毫米)&lt;/h4&gt;
&lt;br&gt;
&lt;h3&gt;其他指令說明&lt;/h3&gt;
&lt;h4&gt;G4的：暫停&lt;/h4&gt;
&lt;h4&gt;例如：G4 P200&lt;/h4&gt;
&lt;h4&gt;在這種狀態下暫停200秒不工作。在延時時的機器狀態下(例如:擠出機溫度)仍然會被保留和控制。&lt;/h4&gt;
&lt;h4&gt;G20 設定從現在開始為英寸&lt;/h4&gt;
&lt;h4&gt;G21 設定從現在開始為毫米&lt;/h4&gt;
&lt;h4&gt;G90 從現在開始，所有的座標都是絕對座標&lt;/h4&gt;
&lt;h4&gt;G91 設定現在位置為原點，之後的都為相對座標&lt;/h4&gt;&lt;/p&gt;
&lt;h4&gt;M0 停止&lt;/h4&gt;

&lt;h4&gt;M18 禁止所有步進馬達&lt;/h4&gt;

&lt;h4&gt;M20：列出SD卡&lt;/h4&gt;

&lt;h4&gt;M21：初始化SD卡&lt;/h4&gt;

&lt;h4&gt;M22：釋放SD卡&lt;/h4&gt;

&lt;h4&gt;M23：選擇SD文件&lt;/h4&gt;

&lt;h4&gt;M24：啟動/恢復SD列印&lt;/h4&gt;

&lt;h4&gt;M25：暫停SD列印&lt;/h4&gt;

&lt;h4&gt;M26：設置的SD位置&lt;/h4&gt;

&lt;h4&gt;M27：報告SD列印狀態&lt;/h4&gt;

&lt;h4&gt;M28：開始寫入到SD卡&lt;/h4&gt;

&lt;h4&gt;M29：停止向SD卡寫入&lt;/h4&gt;

&lt;h4&gt;M42：用盡材料時停止(XY回歸原點但Z沒有，關閉所有電器和加熱器，要重新開始必須複歸，之後繼續列印)&lt;/h4&gt;

&lt;h4&gt;M43: 用盡材料時等待(與M42相似，可是M43還可以下指令如G碼和M碼)&lt;/h4&gt;

&lt;h4&gt;M101:正轉啟動擠出馬達&lt;/h4&gt;

&lt;h4&gt;M102:逆向啟動擠出馬達&lt;/h4&gt;

&lt;h4&gt;M109:設定擠出溫度&lt;/h4&gt;

&lt;h4&gt;M112：緊急停止(全部動作停止包括電器關閉)&lt;/h4&gt;

&lt;h4&gt;M113：設定擠出機的的PWM，例如:M113 S0.7，設定為擠出機70%速度，未用過猜測與軟體內的流量設定相同功用&lt;/h4&gt;

&lt;h4&gt;M303 S200 C8 : 設定目標溫度200，並做8次震盪&lt;/h4&gt;

&lt;p&gt;&lt;a href = "http://www.simplyalt.com/atom/viewthread.php?tid=1560&amp;highlight=PID"&gt; 震盪參考 &lt;/a&gt;&lt;/p&gt;</content><category term="3DP"></category></entry><entry><title>40323250日誌 - v-rep實做心得</title><link href="http://project.mde.tw/blog/40323250ri-zhi-v-repshi-zuo-xin-de.html" rel="alternate"></link><published>2016-08-02T11:15:00+08:00</published><updated>2016-08-02T11:15:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-08-02:/blog/40323250ri-zhi-v-repshi-zuo-xin-de.html</id><summary type="html">&lt;p&gt;V-rep 與 Solvespace的結合應用&lt;/p&gt;
</summary><content type="html">&lt;p&gt;V-rep 與 Solvespace的結合應用&lt;/p&gt;


&lt;h3&gt;最近開了很多V-rep的範例檔來看 ,但都不太有收穫 ,為了避免浪費時間 ,回去找了之前老師提到的solvespace和vrep的共同運用 ,也因為要完成3D - Printer就要先了解基本觀念和用法 ,所以就抓了檔案來測試 &lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vrep_solvespace.png" &gt;
&lt;h3&gt;(檔案位於solvespace官網的 tutorial : linkages)
&lt;/h3&gt;&lt;p&gt;&lt;a href="http://solvespace.com/dl/mechanisms.zip "&gt;壓縮檔載點&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;h3&gt;由於各零件之軸孔沒有軸連接 ,導致旋轉軸無法放置 ,所以我把軸都畫上去了 ,檔案為g2目錄下的solvespcae_vrep&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_vrep.png"&gt;
&lt;/br&gt;
&lt;h3&gt;Solvespace的長料與除料功能真的不太習慣 ,很容易造成運算錯誤&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;軸都放好了 ,只是從屬關係還是不太清楚要如何放置&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_vrep_allaxis.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;結果我又弄了一個圖 ,試圖從這邊學習從屬設定&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_test.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目前只會讓它亂轉&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_test.gif"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;感覺和各個旋轉軸速度也有關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_test2.gif"&gt;
&lt;hr&gt;
&lt;h3&gt;105 - 07/10更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;現在能夠讓連桿旋轉了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;想要測試能否以固定角度來回旋轉 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/links_move.gif" &gt;
&lt;/br&gt;
&lt;h3&gt;但是要達到這樣的動作需要編寫程式 ,且還在研究script的類別以及revolute的type到底要用哪一種 ,這些花了很多時間...&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_types.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目前先以控單軸為主 ,但是遇到以下狀況&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_control2.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/example_code1.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/code_error1.png" &gt;
&lt;h3&gt;如果是用左邊的script就不會有simWait的錯誤 ,但是它只會走90度 ,然後simWait就不會動了&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;參考 :&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/jointDescription.htm "&gt;Joint types and operation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/childScripts.htm#threaded "&gt;Child Scripts&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/11更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Joint 種類分成以下4種 :&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/joint-types.png" &gt;
&lt;/br&gt;
&lt;h4&gt;1. 為旋轉軸, 只有一個自由度 (旋轉), 用於一般旋轉軸。&lt;/h4&gt;
&lt;h4&gt;2. 為平移軸, 只有一個自由度 (平移), 物體能沿著軸線做平移。 &lt;/h4&gt;
&lt;h4&gt;3. 為旋轉與平移軸的結合, 只有一個自由度, 能夠使物體沿著軸做旋轉移動, 如同螺絲。&lt;/h4&gt;
&lt;h4&gt;4. 為球窩接頭, 有三個自由度, 用於類似關節的地方。&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;Control the joint :&lt;/h3&gt;
&lt;h4&gt;1.simSetJointPosition : when your joint is not in force/torque mode&lt;/h4&gt;
&lt;h4&gt;2.simSetJointTargetPosition : when your joint is in force/torque mode, its motor enabled and its control loop also enabled&lt;/h4&gt;
&lt;h4&gt;3.simSetJointTargetVelocity : when your joint is in force/torque mode, its motor enabled, and its control loop NOT enabled&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;今天回去翻老師的信, 才發現裡面有四連桿的範例, 以下為測試:&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links_move.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/4_links_move.gif" &gt;
&lt;/br&gt;
&lt;h3&gt;只要設定一個轉軸, 其他設定好就可以跟著一起做動, 但是在程式部分, if 條件還是不太懂, 很容易出現lua錯誤, 還有很多語法要理解。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/12更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天拿老師的程式去跑小車子 ,但是joint的角度只要定在360就跟0度一樣 ,要如何才能超過這個範圍還在思考... &lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/little_car.ttt?raw=true"&gt;little_car.ttt&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/little_car.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/14更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天參照了irb360範例, 試著組了printer, 前面還算順利, 在中間的 close chain部分 還要加上重疊的Revolute 來限制移動, 最後再搭上dummy 應該就可以控制了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Printer_new.png" &gt;
&lt;/br&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/printer_new.ttt?raw=true"&gt;printer_new.ttt&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/printer_new_2.ttt?raw=true"&gt;printer_new_2.ttt&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/15更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天開始研究Inverse Kinematic 逆向運動學(IK) ,透過矩正及向量運算 ,就可以得到參數 ,且恰巧有學長論文和此相關 ,從中學到了不少 ,但還沒能弄懂 ,最後要結合進V-rep模擬中 ,腳步要加快了&lt;/h3&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/17更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Solvespace測試連桿運動方式&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_tutorial.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;旋轉軸定義&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_pic.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;子屬關係設定 (測試) ,加上dummy固定&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/relation_test.png" &gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;經過一番波折 ,終於和同學弄出來了 ,只要無法封閉的部分利用dummy固定就可以了 ,至於實體轉軸部分要搭接在桿子上才可以&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/solvespace_successful.ttt?raw=true"&gt;solvespace_successful&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_successful.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/solvespace_successful.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/18更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;嘗試幫第一組 組裝手臂, 除了夾爪部分外 ,其餘都組裝好了 ,過程發現部分零件拆解後會有座標不對的問題 ,只要將做標調整和world相同就比較容易了&lt;/h3&gt;
&lt;h3&gt;(參照範例: 7 DoF manipulator 設定ik值)&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/arm_test.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/arm_test.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/24更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天預計要測試馬達控制 ,但是沒有多的12V power supply ,所以先把Onshape ,printer的細部畫一畫 ,現在大概有300個特徵 ,本來可以輕鬆的拉動滑塊 ,現在要用箭頭才能拉動了 ,估計不會畫電路板部分 ,戲偶衣服穿太多了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/printer_top.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/printer_bottom.gif" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;script src="https://embed.github.com/view/3d/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/printer.stl"width="300"height="300"&gt;&lt;/script&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 07/28更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;暫時利用可變電阻取代步進馬達 ,並加入馬達轉軸 ,控制加熱頭移動&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/printer_control.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/Nsgt8YPSDpU" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;105 - 08/02更新&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;V-rep定位&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;在繪圖時 ,需要有一個對稱零件(輔助零件)在vrep內訂定位置 ,在定位之前 ,座標系要先調整&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/pos1.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/pos2.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;之後將主體設為此零件子屬&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/pos3.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;定位完之後就可以設為一個群組了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/pos4.png" &gt;
&lt;/br&gt;&lt;/p&gt;</content><category term="solvespace&amp;v-rep"></category></entry><entry><title>40323231日誌 - 105/08/01</title><link href="http://project.mde.tw/blog/40323231ri-zhi-1050801.html" rel="alternate"></link><published>2016-08-01T19:00:00+08:00</published><updated>2016-08-01T19:00:00+08:00</updated><author><name>40323231</name></author><id>tag:project.mde.tw,2016-08-01:/blog/40323231ri-zhi-1050801.html</id><summary type="html">&lt;p&gt;網誌更新，列印組合件，觀看新軟體&lt;/p&gt;
</summary><content type="html">&lt;p&gt;網誌更新，列印組合件，觀看新軟體&lt;/p&gt;


&lt;h4&gt;今天把問題那篇網誌做新增和整理 ，並整理出常用指令一篇。&lt;/h4&gt;

&lt;h4&gt;列印組合件時，孔和外型的公差不太穩定，多次列印出來的公差也都不太一樣，有時會差到20條，還需要做改進和調整。&lt;/h4&gt;

&lt;h4&gt;今天列印需要支撐材的物件時，發現cura會生成很多不必要的支撐材，導致浪費，所以去尋找很多方法，其中有看到新的軟體Meshmixer，它的操作方式很獨特，跟其他3D繪圖軟體不一樣。網路教學讓軟體很多變，像是製作卡扣、拆解物件、填補漏洞、手動生成支撐材......等等，很多好用的功能，可是滿複雜的，還在學習。因為是新的軟體，所以花了比較多時間觀看，明天會把重心拉回來，繼續製作。&lt;/h4&gt;</content><category term="3DP"></category></entry><entry><title>40323230日誌 - 105/07/31</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050731.html" rel="alternate"></link><published>2016-07-31T21:00:00+08:00</published><updated>2016-07-31T21:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-31:/blog/40323230ri-zhi-1050731.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新增範例Crank Rocker&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;準備整理函式庫內容，再製作英文版副本&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新增範例Crank Rocker&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;準備整理函式庫內容，再製作英文版副本&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Crank Rocker範例&lt;/h1&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/EeRYe4H.jpg" &gt;&lt;/p&gt;
&lt;p&gt;模仿三角形呆鍊的圖形解題。&lt;/p&gt;
&lt;p&gt;用迴圈方式旋轉短連桿，讓三角形頂點畫出點座標。&lt;/p&gt;
&lt;p&gt;以下程式將輸出每一度畫出的點座標。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#一三角形呆鍊，由一長一短的連桿固定在水平基線上。
#短連桿鎖固在原點上，長連桿鎖固在距原點90mm處。
#短連桿長度35mm；長連桿長度70mm。
#三角形呆鍊邊長分別為40mm、40mm、70mm
from slvs import *
from math import *
import unittest

#相關參數
d0 = 90 #基線長度(mm)
n1 = 35 #短連桿長度(mm)
n2 = 70 #長連桿長度(mm)
t1 = 40 #三角形第一邊(mm)
t2 = 40 #三角形第二邊(mm)
t3 = 70 #三角形第三邊(mm)

#開始繪圖

def crank_rock(degree):
    sys = System(500)
    g = 1
    #原點Point0
    p0 = sys.add_param(0.0)
    p1 = sys.add_param(0.0)
    p2 = sys.add_param(0.0)
    Point0 = Point3d(p0, p1, p2)

    #XY法線
    qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
    p3 = sys.add_param(qw)
    p4 = sys.add_param(qx)
    p5 = sys.add_param(qy)
    p6 = sys.add_param(qz)
    Normal1 = Normal3d(p3, p4, p5, p6)

    #工作平面
    Workplane1 = Workplane(Point0, Normal1)

    #3D版的Point0=&gt;Point1
    p7 = sys.add_param(0.0)
    p8 = sys.add_param(0.0)
    Point1 = Point2d(Workplane1, p7, p8)
    Constraint.dragged(Workplane1, Point1)

    #長連桿轉軸Point2，還有基線Line0。
    p9 = sys.add_param(d0)
    p10 = sys.add_param(0.0)
    Point2 = Point2d(Workplane1, p9, p10)
    Constraint.dragged(Workplane1, Point2)
    Line0 = LineSegment2d(Workplane1, Point1, Point2)

    #Angle約束判斷
    if degree &gt;= 180:
        other = -1
    else:
        other = 1

    #三角形Point3 / Point4 / Point5
    p11 = sys.add_param(20.0)
    p12 = sys.add_param(20.0)
    Point3 = Point2d(Workplane1, p11, p12)
    p13 = sys.add_param(0.0)
    p14 = sys.add_param(10.0*other)
    Point4 = Point2d(Workplane1, p13, p14)
    p15 = sys.add_param(30.0)
    p16 = sys.add_param(20.0)
    Point5 = Point2d(Workplane1, p15, p16)
    Constraint.distance(t1, Workplane1, Point4, Point3)
    Constraint.distance(t2, Workplane1, Point3, Point5)
    Constraint.distance(t3, Workplane1, Point4, Point5)

    #連桿約束
    Constraint.distance(n1, Workplane1, Point1, Point4)
    Constraint.distance(n2, Workplane1, Point2, Point5)
    Line1 = LineSegment2d(Workplane1, Point1, Point4)

    #短連桿與水平軸的角度
    Constraint.angle(Workplane1, degree, Line1, Line0, False)

    #以下解題

    sys.solve()

    if (sys.result == SLVS_RESULT_OKAY):
        print ("點座標：")
        print(("P3(%.3f %.3f %.3f)")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val))
        print(("P4(%.3f %.3f %.3f)")%(sys.get_param(13).val, sys.get_param(14).val, sys.get_param(2).val))
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_INCONSISTENT):
        print ("solve failed")
        print ("SLVS_RESULT_INCONSISTENT")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
        print ("solve failed")
        print ("SLVS_RESULT_DIDNT_CONVERGE")
        print ("%d DOF" % sys.dof)
    elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
        print ("solve failed")
        print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
        print ("%d DOF" % sys.dof)

#主程式
for i in range(0, 360):
    print ("Degree: %3s deg"%(i))
    crank_rock(i)
    print ("=======")
print ("Solve Completed")
&lt;/pre&gt;

&lt;p&gt;輸出結果圖：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/r6qocmD.jpg" &gt;&lt;/p&gt;
&lt;p&gt;圖解法：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/LfDHVAi.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這次旋轉的時候，角度約束似乎無法支援超過180度的角度，而會使用正值，讓原本在第一二象限的點&lt;code&gt;Point4&lt;/code&gt;座標無法移動至第三四象限。&lt;/p&gt;
&lt;p&gt;因此在起始定點時的象限位置非常重要，加入了&lt;code&gt;if&lt;/code&gt;判斷式讓&lt;code&gt;Point4&lt;/code&gt;更改初始位置，就解決了這個問題。&lt;/p&gt;
&lt;p&gt;只有用來畫線，且線段有約束角度的點座標有限制。&lt;/p&gt;
&lt;p&gt;另一個要注意的是，要約束成三角形的三個點不可以共線。&lt;/p&gt;
&lt;p&gt;以下是正確值比對：&lt;/p&gt;
&lt;h2&gt;0&amp;deg;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/L9IQWoY.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;45&amp;deg;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/FQRIlkm.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;135&amp;deg;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/TTFfRil.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;180&amp;deg;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iA1lXcy.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;225&amp;deg;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jZNqz0W.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;解了多個圖形題目後，發現之前寫的那篇還滿不容易查詢資料，而且前作者的內容有些錯誤。&lt;/p&gt;
&lt;p&gt;由於當初紀錄是靠&lt;code&gt;DOC.txt&lt;/code&gt;的順序寫的，所以要自己重新閱讀多次，將使用比例分配一下。&lt;/p&gt;</content><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323231 -3DP注意事項</title><link href="http://project.mde.tw/blog/40323231-3dpzhu-yi-shi-xiang.html" rel="alternate"></link><published>2016-07-31T16:00:00+08:00</published><updated>2016-07-31T16:00:00+08:00</updated><author><name>40323231</name></author><id>tag:project.mde.tw,2016-07-31:/blog/40323231-3dpzhu-yi-shi-xiang.html</id><summary type="html">&lt;p&gt;注意事項&lt;/p&gt;
</summary><content type="html">&lt;p&gt;注意事項&lt;/p&gt;


&lt;h3&gt;一.固件安裝 :&lt;/h3&gt;

&lt;h4&gt;1.鎖固個螺絲時請依循鎖固方向(對角或順逆時鐘)，而且不要一次就鎖緊，分兩次至三次，避免不平或無法微調&lt;/h4&gt;

&lt;h4&gt;2.安裝滑塊時請勿推出滑軌外，避免滑塊內的滾珠掉出&lt;/h4&gt;

&lt;h4&gt;3.鎖固滑塊上用來控制限位的螺絲時，不要鎖太裡面，避免限位開關接收不到訊號，導致撞機，或者校機時無法做調整(圖.A)&lt;/h4&gt;

&lt;h4&gt;4.安裝喉管和噴頭塊以及噴嘴時一定要確定鎖緊，不然可能會有液料或漏料的問題(圖.B)&lt;/h4&gt;

&lt;h4&gt;5.安裝噴頭塊時不要直接接觸噴頭座，避免噴頭座過熱(圖.C)&lt;/h4&gt;

&lt;h4&gt;6.安裝擠出機時不要將料壓得太緊，避免進料不順&lt;/h4&gt;

&lt;h4&gt;7.安裝位於噴頭座上方的鐵氟龍管時，要量測插入的深度，以免列印時喉管堵塞&lt;/h4&gt;

&lt;h4&gt;8.安裝料和鐵氟龍管時可將前端剪成斜狀，方便安裝和進料&lt;/h4&gt;

&lt;h4&gt;9.安裝加熱棒時，請置中洞中，勿太裡面或太外面，以免加熱不確實，或加熱到其他地方(圖.D)&lt;/h4&gt;

&lt;h4&gt;10.安裝皮帶上面的固定鎖時勿一開始就鎖到緊，避免皮帶太鬆時無法做調整(圖.E)&lt;/h4&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://i.imgur.com/zGKlktf.jpg" &gt;
&lt;h4&gt;(圖.A)&lt;/h4&gt;
&lt;br&gt;
&lt;img src="http://i.imgur.com/hNHGnCJ.jpg" &gt;
&lt;h4&gt;(圖.B)&lt;/h4&gt;
&lt;br&gt;
&lt;img src="http://i.imgur.com/iPPgmVk.jpg" &gt;
&lt;h4&gt;(圖.C)&lt;/h4&gt;
&lt;br&gt;
&lt;img src="http://i.imgur.com/hidvXCI.jpg" &gt;
&lt;h4&gt;(圖.D)&lt;/h4&gt;
&lt;br&gt;
&lt;img src="http://i.imgur.com/xDtP6BW.jpg" &gt;
&lt;h4&gt;(圖.E)&lt;/h4&gt;
&lt;br&gt;
&lt;h3&gt;二.配電 :&lt;/h3&gt;
&lt;h4&gt;1.裸露的線要用熱縮管(套到需要的地方後用打火機讓館子收縮即可)或者PVC電氣絕緣膠帶包覆&lt;/h4&gt;
&lt;h4&gt;2.delta機型的噴頭上所有的線用捲束管包覆，避免電線纏繞打結或扯斷&lt;/h4&gt;
&lt;h4&gt;3.鐵氟龍管以及噴頭上方的電線長度要夠長，避免噴頭到最下方時被扯斷或撞機&lt;/h4&gt;
&lt;h4&gt;4.控制板上所有電線都需整線，避免內部過熱燒毀&lt;/h4&gt;
&lt;br&gt;
&lt;h3&gt;三.測機 :&lt;/h3&gt;
&lt;br&gt;
&lt;h4&gt;切記:如發生意外，請迅速切斷電源，切斷後不要立即開啟電源，請先關閉軟體的訊號，之後再做開電的動作，避免開電後訊號依
舊在，導致機台繼續損壞。&lt;/h4&gt;
&lt;h4&gt;切記:要跑動X、Y方向時噴頭高度不能在最高點，不然機台可能損壞&lt;/h4&gt;
&lt;h4&gt;切記:列印機與電腦操控軟體(如:pronterface)連接後務必G28原點複歸&lt;/h4&gt;
&lt;br&gt;
&lt;h4&gt;1.要確定三軸速度不要太高，避免回歸或者移動速度太快&lt;/h4&gt;
&lt;h4&gt;2.確定訊號為多少(250000或其他)&lt;/h4&gt;
&lt;h4&gt;3.確定噴頭高度(程式)&lt;/h4&gt;
&lt;h4&gt;4.不要把列印範圍(平台大小)設最大，因為噴頭座可能會撞到各軸，或跑出外面導致列印品質低&lt;/h4&gt;
&lt;h4&gt;5.要確定限位開關是否有作用&lt;/h4&gt;
&lt;h4&gt;6.要下降Z方向時要注意高度，G1 Z20，避免撞機&lt;/h4&gt;
&lt;h4&gt;7.確定XYZ和擠出軸轉向是否正常&lt;/h4&gt;
&lt;h4&gt;8.跑動X、Y方向時噴頭高度不要靠近熱床，因為跑動時可能是碗公型，可能會撞擊熱床&lt;/h4&gt;
&lt;br&gt;
&lt;h3&gt;四.列印 :&lt;/h3&gt;
&lt;h4&gt;1.務必檢查列印成品是否超過列印大小&lt;/h4&gt;
&lt;h4&gt;2.列印前請用口紅膠或特定膠帶弄在熱床上，可避免列印時材料不能貼緊熱床&lt;/h4&gt;
&lt;h4&gt;3.前幾次列印請注意列印狀況以及擠料狀況(跳線、擠不進去等等)&lt;/h4&gt;&lt;/p&gt;</content><category term="3DP"></category></entry><entry><title>40323250日誌 - V-rep &amp; 3D-Printer</title><link href="http://project.mde.tw/blog/40323250ri-zhi-v-rep-3d-printer.html" rel="alternate"></link><published>2016-07-30T22:10:00+08:00</published><updated>2016-07-30T22:10:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-30:/blog/40323250ri-zhi-v-rep-3d-printer.html</id><summary type="html">&lt;p&gt;之後的 V-rep模擬Printer都整理於本文章中&lt;/p&gt;
</summary><content type="html">&lt;p&gt;之後的 V-rep模擬Printer都整理於本文章中&lt;/p&gt;


&lt;h3&gt;透過Tkinter介面及remote api 控制printer參數&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;程式碼&lt;/h3&gt;&lt;/p&gt;
&lt;pre class="brush: python"&gt;

from tkinter import *
import serial
import sys
import numpy as np
from matplotlib import pyplot, rcParams
import vrep
import math



class printer(Frame):
    def __init__(self, master=None):
        Frame.__init__(self, master)
        self.grid()
        self.createWidgets()

    def createWidgets(self):



        Label(pri, text="Axis").grid(column=0, row=0)
        Label(pri, text="").grid(column=0, row=1)
        Label(pri, text="X").grid(column=0, row=2)
        Label(pri, text="").grid(column=0, row=3)
        Label(pri, text="Y").grid(column=0, row=4)
        Label(pri, text="").grid(column=0, row=5)
        Label(pri, text="Z").grid(column=0, row=6)

        Label(pri, text="Position").grid(column=1, row=0)
        Label(pri, text="-125&lt;=X&lt;=125").grid(column=1, row=1)
        Label(pri, text="-125&lt;=Y&lt;=125").grid(column=1, row=3)
        Label(pri, text="0&lt;=Z&lt;=400").grid(column=1, row=5)

        a = Entry(pri, width=12, justify=RIGHT)
        b = Entry(pri, width=12, justify=RIGHT)
        c = Entry(pri, width=12, justify=RIGHT)
                #x.delete(0,END)
                #y.delete(0,END)
        a.grid(row=2, column=1)
        b.grid(row=4, column=1)
        c.grid(row=6, column=1)


        def show_entry_fields():

            deg = math.pi/180

            x = a.get()
            y = b.get()
            z = c.get()

            if x =='' or y==''or z =='':
                x = 0
                y = 0
                z = 0
                print("Error")

            else:
                x = float(a.get())
                y = float(b.get())
                z = float(c.get())


                if float(x) &gt;= 125:
                    x = 125
                    print("X_axis is out of range")
                if float(y) &gt;= 125:
                    y = 125
                    print("Y_axis is out of range")
                if float(z) &gt;= 400:
                    z = 400     
                    print("Z_axis is out of range")
                if float(x) &lt;= -125:
                    x = -125
                    print("X_axis is out of range")
                if float(y) &lt;= -125:
                    y = -125
                    print("Y_axis is out of range")
                if float(z) &lt; 0:
                    z = 0
                    print("Z_axis is out of range")

                if (float(x) &lt;= -125*math.sin(30*deg)) &amp; (float(y) &gt;= 125*math.cos(30*deg)):
                    x = -125*math.sin(30*deg)
                    y = 125*math.cos(30*deg)

                if (float(x) &lt;= -125*math.sin(30*deg)) &amp; (float(y) &lt;= -125*math.cos(30*deg)):
                    x = -125*math.sin(30*deg)
                    y = -125*math.cos(30*deg)

                if (float(x) &gt;= 125*math.sin(30*deg)) &amp; (float(y) &gt;= 125*math.cos(30*deg)):
                    x = 125*math.sin(30*deg)
                    y = 125*math.cos(30*deg)

                if (float(x) &gt;= -125*math.sin(30*deg)) &amp; (float(y) &lt;= -125*math.cos(30*deg)):
                    x = 125*math.sin(30*deg)
                    y = -125*math.cos(30*deg)


                e=x/1000
                r=y/1000
                t=z/889
                if t &lt;= 0.11656:
                    t = t+0.11656


                vrep.simxFinish(-1)
                clientID = vrep.simxStart('127.0.0.1', 19999, True, True, 5000, 5)
                if clientID!= -1:
                    print("Connected to remote server")
                else:
                    print('Connection not successful')
                    sys.exit('Could not connect')
                errorCode,plate=vrep.simxGetObjectHandle(clientID,'plate',vrep.simx_opmode_oneshot_wait)
                if errorCode == -1:
                    print('Can not find left or right motor')
                    sys.exit()                
                errorCode=vrep.simxSetObjectPosition(clientID,plate,-1,[e,r,t], vrep.simx_opmode_oneshot)
                print(x,y,z)


                #print("%s,%s,%s" % (x, y, z))


        Button(pri, text='Quit', width=5, command=pri.quit).grid(row=8, column=2, sticky=W, pady=4)
        Button(pri, text='Go', width=5, command=show_entry_fields).grid(row=8, column=0, sticky=W, pady=4)



if __name__ == '__main__':
    pri = Tk()
    pri.title("Printer")
    pri.geometry('180x220');  #設定視窗大小
    pri.resizable(0, 0) #鎖定視窗大小
    app = printer(master=pri)

    app.mainloop()


#print(x,y,z)

&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/printer_final.ttt?raw=true"&gt;printer_final.ttt&lt;/a&gt;&lt;/p&gt;
&lt;/br&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/UhC2eP_vbrA" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/br&gt;&lt;/p&gt;</content><category term="v-rep&amp;tkinter"></category></entry><entry><title>40323231日誌 - 105/07/30</title><link href="http://project.mde.tw/blog/40323231ri-zhi-1050730.html" rel="alternate"></link><published>2016-07-30T21:00:00+08:00</published><updated>2016-07-30T21:00:00+08:00</updated><author><name>40323231</name></author><id>tag:project.mde.tw,2016-07-30:/blog/40323231ri-zhi-1050730.html</id><summary type="html">&lt;p&gt;3DP維修&lt;/p&gt;
</summary><content type="html">&lt;p&gt;3DP維修&lt;/p&gt;


&lt;h4&gt;今天維修3DP，因為3DP擠出的料變得非常的少，導致成品稀疏和脆弱，而且還發現進料馬達有在旋轉，可是料卻擠不進去。&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;一開始先加熱之後開始清理喉管，清完後校機重新印製，可是情況還是一樣，再來我改變進料速度(80%.60%)，可是依舊如此。&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;再來將噴頭座整組拔出，測量鐵氟龍管插入喉管的深度和全新的做比較，發現深度差很多因此用燈照進去，發現有整塊白色的硬塊堵住，所以又加熱再拿尖銳物將裡面清空，並重新測量鐵氟龍管插入深度，確定可以後校機再重新印製，情況還是一樣，之後加熱更換噴頭，弄完校機後再印製，情況有所改善，可是進料有時候料會擠不進去，所以更改進料速度(最新值:65%)，現在情況已經穩定，印出的公差也調整過，公差在+4條。&lt;/h4&gt;
&lt;h4&gt;列印兩次後發現噴頭座有部分地方會有液料情況，重新鎖固鎖緊後就OK。(重組後須檢查是否鎖緊。)&lt;/h4&gt;&lt;/p&gt;
&lt;h4&gt;拆卸下來的噴頭需要用0.3大小的鑽頭去清理，還需要討論要怎麼處理噴頭。&lt;/h4&gt;</content><category term="3DP"></category></entry><entry><title>40323230日誌 - 105/07/30</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050730.html" rel="alternate"></link><published>2016-07-30T19:00:00+08:00</published><updated>2016-07-30T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-30:/blog/40323230ri-zhi-1050730.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新增範例Nutcraker&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;新增範例Nutcraker&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;Nutcraker範例&lt;/h1&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/OlGMGj4.jpg" &gt;&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#行程解題解題：兩個長1.5mm、2.3mm的連桿，在一直線上作動。
#原點的基座塊比工作路徑高0.5mm，寬0.75mm（占用0.38mm）。
#底線距離基座面3.25mm。
#2.3mm的連桿寬0.25mm，半圓頭。
#求最小行程（2.3mm的連桿與基座接觸）。
#求最大行程（半圓頭與底線接觸）。
from slvs import *
from math import *
sys = System(500)
g = 1

#相關參數
h0 = 0.5 #基塊高度(mm)
b0 = 0.75 #基塊寬度(mm)
n1 = 1.5 #後連桿長度(mm)
n2 = 2.3 #前連桿長度(mm)
R0 = 0.25 #半圓頭半徑(mm)
L0 = 3.25 #底線距離(mm)

#開始繪圖

#原點Point0
p0 = sys.add_param(0.0)
p1 = sys.add_param(0.0)
p2 = sys.add_param(0.0)
Point0 = Point3d(p0, p1, p2)

#XY法線
qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
p3 = sys.add_param(qw)
p4 = sys.add_param(qx)
p5 = sys.add_param(qy)
p6 = sys.add_param(qz)
Normal1 = Normal3d(p3, p4, p5, p6)

#工作平面
Workplane1 = Workplane(Point0, Normal1)

#3D版的Point0=&gt;Point1
p7 = sys.add_param(0.0)
p8 = sys.add_param(0.0)
Point1 = Point2d(Workplane1, p7, p8)
Constraint.dragged(Workplane1, Point1)

#連桿中繼點Point2和行程點Point3
p9 = sys.add_param(2.0)
p10 = sys.add_param(2.0)
Point2 = Point2d(Workplane1, p9, p10)
p11 = sys.add_param(2.0)
p12 = sys.add_param(0.0)
Point3 = Point2d(Workplane1, p11, p12)
Line0 = LineSegment2d(Workplane1, Point1, Point3)
Constraint.horizontal(Workplane1, Line0)

#前連桿碰到基座
Line1 = LineSegment2d(Workplane1, Point2, Point3)
p13 = sys.add_param(b0/2)
p14 = sys.add_param(h0)
Point4 = Point2d(Workplane1, p13, p14)
Constraint.dragged(Workplane1, Point4) #必須鎖住已知點
Constraint.distance(R0, Workplane1, Point4, Line1)
Constraint.distance(n1, Workplane1, Point1, Point2)
Constraint.distance(n2, Workplane1, Point2, Point3)

#以下解題

sys.solve()

Ansmin = sys.get_param(11).val - b0/2
Ansmax = L0 - R0 - b0/2

if (sys.result == SLVS_RESULT_OKAY):
    print ("點座標：")
    print(("P1(%.3f %.3f %.3f)")%(sys.get_param(7).val, sys.get_param(8).val, sys.get_param(2).val))
    print("P1(0.000 0.000 0.000)")
    print(("P2(%.3f %.3f %.3f)")%(sys.get_param(9).val, sys.get_param(10).val, sys.get_param(2).val))
    print("P2(-0.400 1.450 0.000)")
    print(("P3(%.3f %.3f %.3f)")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val))
    print("P4(1.390 0.000 0.000)\n")
    print("Min:")
    print(("(%.3f)")%(Ansmin))
    print("Max:")
    print(("(%.3f)")%(Ansmax))
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_INCONSISTENT):
    print ("solve failed")
    print ("SLVS_RESULT_INCONSISTENT")
    print ("%d DOF" % sys.dof)
    for i in range(sys.faileds):
        print(" %lu", sys.failed[i]);
elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
    print ("solve failed")
    print ("SLVS_RESULT_DIDNT_CONVERGE")
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
    print ("solve failed")
    print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
    print ("%d DOF" % sys.dof)
&lt;/pre&gt;

&lt;p&gt;解題結果：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/TQjsd3C.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Nutcracker只有單純的連桿，非常簡單。&lt;/p&gt;
&lt;p&gt;而之前的題目有相切約束，Solvespace解這種會有極限的約束都十分不便，常常會出現約束衝突或是正負不分的狀況。&lt;/p&gt;
&lt;p&gt;目前還不知道如何解決，只能多注意圓弧曲線的地方，可以用距離約束取代的地方就盡量不用額外輔助線。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;倉儲中嵌入副模組&lt;/h1&gt;
&lt;p&gt;在倉儲中加入了BBBSnowball的模組SolidPython，不過不知道怎麼用。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
git submodule add https://github.com/BBBSnowball/SolidPython.git solid-python
&lt;/pre&gt;

&lt;p&gt;應該只是單純放著支援功能。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/QBhyKgH.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;之前"SLVS資料庫函式"那篇還需要檢查一下，或是做一個英文版副本連結到倉儲Readme。&lt;/p&gt;
&lt;p&gt;雖然轉到Python介面中不只那些指令，但是只靠這些指令就能解題目了。&lt;/p&gt;
&lt;p&gt;進階應用如切換群組等，稍微看一下原本的範例code或CDemo的原始碼應該就能瞭解。&lt;/p&gt;</content><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/29</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050729.html" rel="alternate"></link><published>2016-07-29T19:00:00+08:00</published><updated>2016-07-29T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-29:/blog/40323230ri-zhi-1050729.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CDemo資料庫內容補正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料庫解題成功&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CDemo資料庫內容補正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;資料庫解題成功&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;修復內容&lt;/h1&gt;
&lt;p&gt;使用修復過的資料庫內容解題，新增將近三分之一的對應函式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/7iQxUpJ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這些函式中也包括需要的相切約束。&lt;/p&gt;
&lt;p&gt;由於這些函式都未有對應名稱，所以都是自己編名的，例如&lt;code&gt;equal_angle( )&lt;/code&gt;。&lt;/p&gt;
&lt;h1&gt;解題成功&lt;/h1&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XddGS1n.jpg" &gt;&lt;/p&gt;
&lt;p&gt;使用的是下列程式碼，在SciTE中解題成功：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#鍊條解題：18齒與30齒的鏈條，上下外切線長為200。
#小圓圓心為原點，大圓圓心在X軸上，求四個切點的座標
from slvs import *
from math import *
sys = System(500)
g = 1

#相關參數
n0 = 20 #鍊條長度(mm)
n1 = 18 #小輪齒數(t)
n2 = 30 #大輪齒數(t)
#邊長為a的的正n邊形外接圓半徑為：
#R=a/(2*sin(pi/n)) or R=(a/2)*csc(pi/n)
R1 = n0/(2*sin(pi/n1))
R2 = n0/(2*sin(pi/n2))

#開始繪圖

#原點Point0
p0 = sys.add_param(0.0)
p1 = sys.add_param(0.0)
p2 = sys.add_param(0.0)
Point0 = Point3d(p0, p1, p2)


#XY法線
qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
p3 = sys.add_param(qw)
p4 = sys.add_param(qx)
p5 = sys.add_param(qy)
p6 = sys.add_param(qz)
Normal1 = Normal3d(p3, p4, p5, p6)

#工作平面
Workplane1 = Workplane(Point0, Normal1)

#3D版的Point0=&gt;Point1
p7 = sys.add_param(0.0)
p8 = sys.add_param(0.0)
Point1 = Point2d(Workplane1, p7, p8)
Constraint.dragged(Workplane1, Point1)

#Point2
p9 = sys.add_param(0.0)
p10 = sys.add_param(200.0)
Point2 = Point2d(Workplane1, p9, p10)

#上端外切線的兩個點Point3和Point4
p11 = sys.add_param(0.0)
p12 = sys.add_param(500.0)
Point3 = Point2d(Workplane1, p11, p12)
p13 = sys.add_param(500.0)
p14 = sys.add_param(500.0)
Point4 = Point2d(Workplane1, p13, p14)

#下端外切線的兩個點Point5和Point6
p15 = sys.add_param(0.0)
p16 = sys.add_param(-500.0)
Point5 = Point2d(Workplane1, p15, p16)
p17 = sys.add_param(500.0)
p18 = sys.add_param(-500.0)
Point6 = Point2d(Workplane1, p17, p18)

#外切線
Line1 = LineSegment2d(Workplane1, Point3, Point4)
Line2 = LineSegment2d(Workplane1, Point5, Point6)

#圓弧
Arc1 = ArcOfCircle(Workplane1, Normal1, Point1, Point3, Point5)
Constraint.diameter(R1*2, Workplane1, Arc1)
Arc2 = ArcOfCircle(Workplane1, Normal1, Point2, Point6, Point4)
Constraint.diameter(R2*2, Workplane1, Arc2)

#X軸Line0
Line0 = LineSegment2d(Workplane1, Point1, Point2)
Constraint.horizontal(Workplane1, Line0)

#約束
Constraint.tangent(Arc1, Line1, False)
Constraint.tangent(Arc2, Line1, False)
Constraint.tangent(Arc2, Line2, True)
Constraint.distance(200.0, Workplane1, Point3, Point4)

#以下解題

sys.solve()

if (sys.result == SLVS_RESULT_OKAY):
    print ("兩點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(7).val, sys.get_param(8).val, sys.get_param(2).val))
    print(("(%.3f %.3f %.3f)\n")%(sys.get_param(9).val, sys.get_param(10).val, sys.get_param(2).val))
    print ("上切點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val))
    print("(-10.770 56.570 0.000)")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(13).val, sys.get_param(14).val, sys.get_param(2).val))
    print("(185.700 93.980 0.000)\n")
    print ("下切點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(15).val, sys.get_param(16).val, sys.get_param(2).val))
    print("(-10.770 -56.570 0.000)")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(17).val, sys.get_param(18).val, sys.get_param(2).val))
    print("(185.700 -93.98 0.000)\n")
    print ("導入函數測試：")
    print ("R1：")
    print(R1)
    print ("R2：")
    print(R2)
    print ("pi：")
    print(pi)
    print ("%d DOF" % sys.dof)
elif (sys.result == SLVS_RESULT_INCONSISTENT):
    print ("solve failed")
    print ("SLVS_RESULT_INCONSISTENT")
    print ("%d DOF" % sys.dof)
    for i in range(sys.faileds):
        print(" %lu", sys.failed[i]);
elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE):
    print ("solve failed")
    print ("SLVS_RESULT_DIDNT_CONVERGE")
    print ("%d DOF" % sys.dof)
    for i in range(sys.faileds):
        print(" %lu", sys.failed[i]);
elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS):
    print ("solve failed")
    print ("SLVS_RESULT_TOO_MANY_UNKNOWNS")
    print ("%d DOF" % sys.dof)
&lt;/pre&gt;

&lt;p&gt;弧與直線相切的函式只能鎖住一頭（布林值調整鎖住頭或尾），所以要下兩次。&lt;/p&gt;
&lt;p&gt;不過由於Solvespace對約束的要求十分嚴謹，所以只要下了衝突約束或是重複約束，前者會顯示&lt;code&gt;SLVS_RESULT_INCONSISTENT&lt;/code&gt;，後者會顯示&lt;code&gt;SLVS_RESULT_DIDNT_CONVERGE&lt;/code&gt;，就得重新檢查寫的程式。&lt;/p&gt;
&lt;p&gt;以下是圖解法比對（其實已經記錄在上面的程式中供比對），兩者使用的資料庫函式應該是一樣的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/FWVqdhW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;結果是零誤差。&lt;/p&gt;
&lt;p&gt;以下是SciTE的顯示結果，較上方的是Python運算的結果。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/iqkIH4L.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;使用這個函式庫非常簡單，跟在Solvespace上畫圖一樣。&lt;/p&gt;
&lt;p&gt;先設定起始值後，利用約束調整這些值（而且可以將固定值鎖住），確定之後就能算出答案。&lt;/p&gt;
&lt;p&gt;第一次使用自己寫的介面，由於以熟悉它們的從屬關係和解題公式，所以用起來十分上手。&lt;/p&gt;
&lt;p&gt;這個函式庫最大的缺點應該是取值不太方便吧，雖然仍可以使用自己命名或是直接內嵌進函式中，可是取值時是按照註冊順序取的，所以養成輸入值時給編號比較不容易亂掉。&lt;/p&gt;</content><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/28</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050728.html" rel="alternate"></link><published>2016-07-28T19:00:00+08:00</published><updated>2016-07-28T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-28:/blog/40323230ri-zhi-1050728.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CDemo資料庫內容補正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CDemo資料庫內容補正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h1&gt;未支援項目&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;＊某些項目未紀錄於DOC.exe中&lt;/em&gt;&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SLVS_C_PT_FACE_DISTANCE
SLVS_C_PT_ON_FACE
SLVS_C_LENGTH_RATIO
SLVS_C_EQ_LEN_PT_LINE_D
SLVS_C_EQ_PT_LN_DISTANCES
SLVS_C_EQUAL_ANGLE
SLVS_C_EQUAL_LINE_ARC_LEN
SLVS_C_SYMMETRIC
SLVS_C_SYMMETRIC_HORIZ
SLVS_C_SYMMETRIC_VERT
SLVS_C_SYMMETRIC_LINE
SLVS_C_AT_MIDPOINT
SLVS_C_SAME_ORIENTATION
SLVS_C_ANGLE
SLVS_C_PARALLEL
SLVS_C_PERPENDICULAR
SLVS_C_ARC_LINE_TANGENT
SLVS_C_CUBIC_LINE_TANGENT
SLVS_C_PROJ_PT_DISTANCE
SLVS_C_WHERE_DRAGGED
SLVS_C_CURVE_CURVE_TANGENT
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;今天編譯完&lt;code&gt;slvs_python.hpp&lt;/code&gt;，並推送至倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;因為大部分都是強硬約束的關係，只測試過部分功能。&lt;/p&gt;
&lt;hr&gt;

&lt;h1&gt;編譯流程&lt;/h1&gt;
&lt;p&gt;使用Netbeans編譯&lt;code&gt;slvs_python.hpp&lt;/code&gt;和&lt;code&gt;slvs.i&lt;/code&gt;，旁邊的&lt;code&gt;constrainteq.cpp&lt;/code&gt;供參考函式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zjppe0U.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;slvs.i&lt;/em&gt;&lt;/h2&gt;
&lt;pre class="brush: c"&gt;
class Constraint {
    Constraint();
public:
...
    static Constraint some_other_constraint(
            System* system,
            int type, Workplane workplane, double value,
            Point ptA, Point ptB, Entity entityA, Entity entityB,
            Slvs_hGroup group = USE_DEFAULT_GROUP);
&lt;/pre&gt;

&lt;p&gt;標準的約束條件格式如上，其實所有的約束函式都是透過&lt;code&gt;slvs_python.hpp&lt;/code&gt;輸入&lt;code&gt;constrainteq.cpp&lt;/code&gt;的約束做計算。&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;slvs_python.hpp&lt;/em&gt;&lt;/h2&gt;
&lt;pre class="brush: c"&gt;
class Constraint {
...
public:
static Constraint some_other_constraint(
            System* system,
            int type, Workplane workplane, double value,
            Point ptA, Point ptB, Entity entityA, Entity entityB,
            Slvs_hGroup group = USE_DEFAULT_GROUP) {
        return init(system, Slvs_MakeConstraint(
            0, group,
            type,
            workplane.handle(),
            value,
            ptA.handle(), ptB.handle(),
            entityA.handle(), entityB.handle()));
    }
...
&lt;/pre&gt;

&lt;p&gt;但是由於約束&lt;code&gt;SLVS_C_EQUAL_ANGLE&lt;/code&gt;會用到四個Entity，預設只有開啟2個，另外的&lt;code&gt;EntityC&lt;/code&gt;、&lt;code&gt;EntityD&lt;/code&gt;沒有開啟，而相切約束需要的布林值&lt;code&gt;other&lt;/code&gt;和&lt;code&gt;other2&lt;/code&gt;亦沒有加入。&lt;/p&gt;
&lt;p&gt;所以只能從&lt;code&gt;slvs.h&lt;/code&gt;添加這4個值。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/cV0HyKc.jpg" &gt;&lt;/p&gt;
&lt;p&gt;其他項目也要加上4個空位，以免出錯。&lt;/p&gt;
&lt;p&gt;對照&lt;code&gt;constrainteq.cpp&lt;/code&gt;中需要的項目，在&lt;code&gt;slvs_python.hpp&lt;/code&gt;中填上需要的值的類型，應該就可以運作了。&lt;/p&gt;
&lt;p&gt;測試了一些新加入的約束，如果&lt;code&gt;slvs_python.hpp&lt;/code&gt;中填上的類型正確，就會解題，不過「重複約束」的結果似乎是歸類在「過度約束」裡。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Ej4JQHF.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而如果本身類型填錯，就會回傳錯誤碼&lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/n3iIuhW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;但是函式庫中只有&lt;code&gt;SLVS_C_WHERE_DRAGGED&lt;/code&gt;會抓住點（而且還是有移動量），還要研究一下如何鎖住這些點的位置。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天幫忙編寫CDemo，使其擁有Solvespace全部約束的功能。&lt;/p&gt;
&lt;p&gt;會找時間翻修一下之前的紀錄。&lt;/p&gt;</content><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/27</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050727.html" rel="alternate"></link><published>2016-07-27T19:00:00+08:00</published><updated>2016-07-27T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-27:/blog/40323230ri-zhi-1050727.html</id><summary type="html">&lt;p&gt;規劃解題與檢驗函式&lt;/p&gt;
&lt;p&gt;&lt;em&gt;檢驗出功能缺損&lt;/em&gt;&lt;/p&gt;
</summary><content type="html">&lt;p&gt;規劃解題與檢驗函式&lt;/p&gt;
&lt;p&gt;&lt;em&gt;檢驗出功能缺損&lt;/em&gt;&lt;/p&gt;


&lt;h2&gt;規劃解題 :&lt;/h2&gt;

&lt;p&gt;計算題目，並一邊利用SciTE的偵錯窗來檢查之前寫的函式資料。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/tfgUIVX.jpg" &gt;&lt;/p&gt;
&lt;p&gt;之前的題目：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://chiamingyen.github.io/kmolab/blog/zi-xing-che-chuan-dong-2d-lian-tiao-hui-tu-er.html" title="chiamingyen.github.io"&gt;http://chiamingyen.github.io/kmolab/blog/zi-xing-che-chuan-dong-2d-lian-tiao-hui-tu-er.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;規劃了一支程式來計算鍊輪的點座標（半成品）：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#鍊條解題：18齒與30齒的鏈條，上下外切線長為200。
#小圓圓心為原點，大圓圓心在X軸上，求四個切點的座標
from slvs import *
from math import *
sys = System(500)
g = 1

#相關參數
n0 = 20 #鍊條長度(mm)
n1 = 18 #小輪齒數(t)
n2 = 30 #大輪齒數(t)
#邊長為a的的正n邊形外接圓半徑為：
#R=a/(2*sin(pi/n)) or R=(a/2)*csc(pi/n)
R1 = n0/(2*sin(pi/n1))
R2 = n0/(2*sin(pi/n2))

#開始繪圖

#原點Point0
p0 = sys.add_param(0.0)
p1 = sys.add_param(0.0)
p2 = sys.add_param(0.0)
Point0 = Point3d(p0, p1, p2)

#XY法線
qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0)
p3 = sys.add_param(qw)
p4 = sys.add_param(qx)
p5 = sys.add_param(qy)
p6 = sys.add_param(qz)
Normal1 = Normal3d(p3, p4, p5, p6, sys)

#工作平面
Workplane1 = Workplane(Point0, Normal1)

#3D版的Point0=&gt;Point1
Point1 = Point2d(Workplane1, p0, p1)

#小圓
p7 = sys.add_param(R1)
Distance1 = Distance(Workplane1, p7)
Circle1 = Circle(Workplane1, Normal1, Point1, Distance1)

#Point2
p8 = sys.add_param(500.0)
p9 = sys.add_param(0.0)
Point2 = Point2d(Workplane1, p7, p8)

#大圓
p10 = sys.add_param(R2)
Distance2 = Distance(Workplane1, p10)
Circle2 = Circle(Workplane1, Normal1, Point2, Distance2)

#上端外切線的兩個點Point3和Point4
p11 = sys.add_param(300.0)
p12 = sys.add_param(500.0)
Point3 = Point2d(Workplane1, p11, p12)
p13 = sys.add_param(500.0)
p14 = sys.add_param(500.0)
Point4 = Point2d(Workplane1, p13, p14)

#下端外切線的兩個點Point5和Point6
p15 = sys.add_param(300.0)
p16 = sys.add_param(-500.0)
Point5 = Point2d(Workplane1, p15, p16)
p17 = sys.add_param(500.0)
p18 = sys.add_param(-500.0)
Point6 = Point2d(Workplane1, p17, p18)

...

#以下解題

sys.solve()

if (sys.result == SLVS_RESULT_OKAY):
    print ("兩點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(0).val, sys.get_param(1).val, sys.get_param(2).val))
    print(("(%.3f %.3f %.3f)\n")%(sys.get_param(8).val, sys.get_param(9).val, sys.get_param(2).val))
    print ("上切點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val))
    print(("(%.3f %.3f %.3f)\n")%(sys.get_param(13).val, sys.get_param(14).val, sys.get_param(2).val))
    print ("下切點座標：")
    print(("(%.3f %.3f %.3f)")%(sys.get_param(15).val, sys.get_param(16).val, sys.get_param(2).val))
    print(("(%.3f %.3f %.3f)\n")%(sys.get_param(17).val, sys.get_param(18).val, sys.get_param(2).val))
    print ("導入函數測試：")
    print(pi)
    print ("%d DOF" % sys.dof)
else:
    print ("solve failed")
&lt;/pre&gt;

&lt;p&gt;但是在使用畫線並約束與圓相切的指令時，之前臆測的程式碼卻沒有這個功能，於是去倉儲搜尋函式名稱。&lt;/p&gt;
&lt;p&gt;發現某些Solvespace的功能並沒有轉給CDemo使用，之前&lt;code&gt;DOC.txt&lt;/code&gt;簡介只是說明出本體支援的功能。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;在&lt;code&gt;h++&lt;/code&gt;的標頭檔&lt;code&gt;slvs_python.hpp&lt;/code&gt;中，有以下項目：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
class Constraint {
...
public:
    // This constructor can be used to make arbitrary
    // constraints. It has a very ugly name to discourage
    // its use. If you need a constraint that the library
    // doesn't support, you should implement it.
//以下是所有約束函式
...
&lt;/pre&gt;

&lt;p&gt;而那些沒做出的功能都用註解的方式放在這些做好的函式之間，所以看來好像是要自己做了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/3x4fBiB.jpg" &gt;&lt;/p&gt;
&lt;p&gt;目前瞭解需要編寫的檔案為&lt;code&gt;slvs.i&lt;/code&gt;的Interface檔、&lt;code&gt;slvs_python.hpp&lt;/code&gt;標頭檔、&lt;code&gt;constrainteq.cpp&lt;/code&gt;約束方程式的函式。&lt;/p&gt;
&lt;p&gt;畢竟是用別人寫好的架構，自己修改應該沒甚麼太大的障礙，以一個Python模組而言，拓展所需才是協同作業重要之處。&lt;/p&gt;</content><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323231日誌 - 105/07/25</title><link href="http://project.mde.tw/blog/40323231ri-zhi-1050725.html" rel="alternate"></link><published>2016-07-25T21:00:00+08:00</published><updated>2016-07-25T21:00:00+08:00</updated><author><name>40323231</name></author><id>tag:project.mde.tw,2016-07-25:/blog/40323231ri-zhi-1050725.html</id><summary type="html">&lt;p&gt;3DP問題、測試、解決方法&lt;/p&gt;
</summary><content type="html">&lt;p&gt;3DP問題、測試、解決方法&lt;/p&gt;


&lt;h3&gt;固件組裝時的問題 : &lt;/h3&gt;

&lt;h4&gt;1.熱床的安裝較不容易，因為它是暗孔所以比較難對齊，鎖固的時間較長，之後有要組一台的話要考慮是否改換成明孔&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;配電的問題 : &lt;/h3&gt;
&lt;h4&gt;1.限位開關的接法，因為限位開關有分兩種，一種是機械式微動開關，一種是光學限位開關，要怎麼接?
接法和注意事項:&lt;/h4&gt;
&lt;h4&gt;  a. 機械微動開關接法
機械微動開關只需接2個腳位的：單純使用微動開關當作限位器，那一定要接RAMPS上的 "S" 跟 "-" 腳位。絕對不要把3個腳位都接了，如果不小心接了3個腳位，那在觸發時會發生火花，會把5V穩壓 IC燒毀。&lt;/h4&gt;
&lt;h4&gt;  b. 光學限位開關接法(我們的)
光學限位開關則是需要用到3條線，接到RAMPS上的"S"、"-"及"+" 3個腳位。&lt;/h4&gt;
&lt;h4&gt;  c.程式碼也需要改(由於我們的是光學限位所以都改成false)&lt;/h4&gt;
&lt;h4&gt;const bool X_MIN_ENDSTOP_INVERTING = false;&lt;/h4&gt;
&lt;h4&gt;const bool Y_MIN_ENDSTOP_INVERTING = false;&lt;/h4&gt;
&lt;h4&gt;const bool Z_MIN_ENDSTOP_INVERTING = false;&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;測機問題 : &lt;/h3&gt;
&lt;h4&gt;1.用arduino燒入韌體時會說缺少東西，這時用(u8glib_arduino_v1.16)壓縮檔即可。&lt;/h4&gt;
&lt;h4&gt;操作方法是 : &lt;/h4&gt;
&lt;h4&gt;     a.先到網站下載u8glib_arduino_v1.16這包壓縮檔&lt;/h4&gt;
&lt;h4&gt;     b.點開arduino&lt;/h4&gt;
&lt;h4&gt;     c.點選Sketch  &lt;/h4&gt;
&lt;h4&gt;     d.點選Include Library &lt;/h4&gt;
&lt;h4&gt;     e.點選Add .ZIP Library...&lt;/h4&gt;
&lt;h4&gt;     f.選擇u8glib_arduino_v1.16&lt;/h4&gt;
&lt;h4&gt;     g.完成&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;2.擠出馬達不能運作,其他xyz馬達皆能動&lt;/h4&gt;
&lt;h4&gt;測試方法:&lt;/h4&gt;
&lt;h4&gt;    a.將擠出馬達的訊號線接到X軸的訊號端(馬達是否正常)，測試馬達正常&lt;/h4&gt;
&lt;h4&gt;    b.將擠出軸的訊號線由E0接到E1(測試控制板和韌體是否正常)，測試結果無法作動&lt;/h4&gt;
&lt;h4&gt;    c.將電源線和擠出訊號線接到ramps1.4和arduino上(測試控制板是否正常)，測試結果無法作動&lt;/h4&gt;
&lt;h4&gt;解決方法:因為程式碼中有保護措施，保護措施為噴頭溫度要先加熱到指定的溫度後才能啟動，怕擠料不正常。可修改此程式碼define MIN_EXTRUDER_TEMP 170&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;3.馬達旋轉方向不符&lt;/h4&gt;
&lt;h4&gt;解決方法:調整程式碼&lt;/h4&gt;
&lt;h4&gt;Repetier(0、1為正反轉)&lt;/h4&gt;
&lt;h4&gt;#define INVERT_X_DIR 0&lt;/h4&gt;
&lt;h4&gt;#define INVERT_Y_DIR 0&lt;/h4&gt;
&lt;h4&gt;#define INVERT_Z_DIR 0&lt;/h4&gt;
&lt;h4&gt;#define EXT0_INVERSE 0&lt;/h4&gt;
&lt;h4&gt;Marlin(true、false為正反轉)&lt;/h4&gt;
&lt;h4&gt;#define INVERT_X_DIR true&lt;/h4&gt;
&lt;h4&gt;#define INVERT_Y_DIR true&lt;/h4&gt;
&lt;h4&gt;#define INVERT_Z_DIR true&lt;/h4&gt;
&lt;h4&gt;#define INVERT_E0_DIR true&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;4.G28回歸的時候，Z軸不動其他兩軸馬達回歸，導致噴頭座往外跑出&lt;/h4&gt;
&lt;h4&gt;測試方法 : &lt;/h4&gt;
&lt;h4&gt;    a.打指令M119檢查限位開關是否有開，測試結果有開&lt;/h4&gt;
&lt;h4&gt;    b.用手讓限位器偵測是否會感應，測試結果有感應&lt;/h4&gt;
&lt;h4&gt;    c.檢查程式碼true/false是否正確，正確(有說明此功能的一篇)&lt;/h4&gt;
&lt;h4&gt;解決方法:更換新的杜邦端子，因為測量多次後發現時好時壞，所以猜測是訊號接收不正常，更換後能夠順利回歸&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;5.軟體關掉訊號後滑軌依然鎖住&lt;/h4&gt;
&lt;h4&gt;解決方法:關掉訊號後再連接(connect)，之後再斷掉，就可以解鎖了&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;使用韌體Repetier所碰到的問題 : &lt;/h3&gt;
&lt;h4&gt;1.噴嘴高度不管怎麼改都是319.2mm不知道為什麼?&lt;/h4&gt;
&lt;h4&gt;解決方法(還未真正找到解決方法)&lt;/h4&gt;
&lt;h4&gt;    a.修改程式碼中噴頭最大高度，可是不管怎麼改依然都是319.2mm&lt;/h4&gt;
&lt;h4&gt;    b.修改程式碼中噴頭最小高度，可是依然319.2mm&lt;/h4&gt;
&lt;h4&gt;    c.修改3軸的補正值，依然不變&lt;/h4&gt;
&lt;h4&gt;    d.修改xyz軸的最大值，發現xyz軸會超出設定的最大值，發現好像是code燒不進去，而且有看到RAM大小所以猜測是空間不足&lt;/h4&gt;
&lt;h4&gt;    e.將空白的arduino燒進控制板後，機器不能運轉表示燒入成功，之後再把修改過的韌體在燒進去，可是依然還是319.2mm&lt;/h4&gt;
&lt;h4&gt;    f.用軟體Repetier-Host直接修改高度，可是一樣還是319.2mm&lt;/h4&gt;
&lt;h4&gt;    g.改用韌體Marlin，可是Marlin卻有更多的不穩定&lt;/h4&gt;
&lt;h4&gt;    h.用Cura_15.04特別版，才成功修改，並能順利列印&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;使用韌體Marlin所碰到的問題 : &lt;/h3&gt;
&lt;h4&gt;1.G28回歸後，只能單軸單軸進行復歸補正，導致速度較慢，而且有時候複歸的途中會停下來，之後單軸複歸導致噴頭座跑出機台外。(備註:機台斷電後，軟體也要切斷訊號，不然機台重新開電後還是會繼續執行)&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;2.執行G28時個軸的速度，寫法與Repetier不太一樣，所以一開始沒注意到，導致速度過快差點撞機。&lt;/h4&gt;
&lt;h4&gt;#define HOMING_FEEDRATE {50&lt;em&gt;60, 50&lt;/em&gt;60, 50*60, 0}&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;列印時碰到的問題 : &lt;h3&gt;
&lt;h4&gt;1.翹邊&lt;/h4&gt;
&lt;h4&gt;解決方法:塗口紅膠在平台上，以及再加熱期間把溢出來的料弄掉，因為溢出來的料會把底層弄掀，導致沒有地基、材料高低不平&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;2.列印出來的東西很稀疏，而且一捏就碎&lt;/h4&gt;
&lt;h4&gt;解決方法:&lt;/h4&gt;
&lt;h4&gt;a.先加熱，之後用細的鐵絲或夾子將堵塞住的料全部清除(清理時要注意不要直接觸摸噴頭組，請用工具夾持，夾持時勿將熱敏電阻和加熱棒弄壞)，清完後用鐵氟龍管測試深度(避免之後再裝鐵氟龍管時無法到達最深部，導致又回流堵料)&lt;/h4&gt;
&lt;h4&gt;b.如果上述不行，再清理噴頭，或直接更換，我是清理完喉管後還是不行，直接更換噴頭，之後就改善了&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;3.擠出馬達持續轉動，料則是斷斷續續的進料，有時甚至完全停止&lt;/h4&gt;
&lt;h4&gt;解決方法:&lt;/h4&gt;
&lt;h4&gt;a.進入軟體(cura)的基本 -&amp;gt; 列印材料(Filament) -&amp;gt; 流量(Flow)(%) -&amp;gt;更改此數值(擠料速度會降低)&lt;/h4&gt;
&lt;h4&gt;b.還是未改善請依循:列印時碰到的問題2進行改善&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;4.列印時噴頭和熱床無法同時加熱&lt;/h4&gt;
&lt;h4&gt;還未解決&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;5.噴頭液料(部位有噴頭、喉管的鎖固部分)&lt;/h4&gt;
&lt;h4&gt;解決方法:重新鎖固，或者鎖緊即可&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;6.口紅膠的殘留，以及要拿下產品時要用刮刀拆下，導致平板會有刮傷&lt;/h4&gt;
&lt;h4&gt;還未解決，有看到網路上有人是購買專用的膠帶，不知道實不實用&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;7.馬達很燙&lt;/h4&gt;
&lt;h4&gt;還未解決，有想要在熱床下加裝風扇&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;8.如何放置料桶&lt;/h4&gt;
&lt;h4&gt;還未解決，想要製作料座，然後用軸承放置兩邊讓他能順利進料&lt;/h4&gt;
&lt;/br&gt;
&lt;h4&gt;持續更新&lt;/h4&gt;&lt;/p&gt;</content><category term="3DP"></category></entry><entry><title>40323230紀錄 - Python-Solvespace編譯完畢</title><link href="http://project.mde.tw/blog/40323230ji-lu-python-solvespacebian-yi-wan-bi.html" rel="alternate"></link><published>2016-07-24T19:00:00+08:00</published><updated>2016-07-24T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-24:/blog/40323230ji-lu-python-solvespacebian-yi-wan-bi.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Windows執行成功！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu執行失敗（需重生&lt;code&gt;_slvs.so&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公開倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Windows執行成功！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ubuntu執行失敗（需重生&lt;code&gt;_slvs.so&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公開倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已更新。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;編譯結果 :&lt;/h2&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/E4PEUbR.jpg" &gt;&lt;/p&gt;
&lt;p&gt;最後編譯時把&lt;code&gt;_slvs.so&lt;/code&gt;改成了&lt;code&gt;_slvs.pyd&lt;/code&gt;就能使用了。&lt;/p&gt;
&lt;p&gt;有測試過改成&lt;code&gt;.dll&lt;/code&gt;的方式，但是反而不能使用，可能是Windows平台Python辨認的問題。&lt;/p&gt;
&lt;p&gt;不過由於&lt;code&gt;_slvs.pyd&lt;/code&gt;是參照&lt;code&gt;libslvs.so&lt;/code&gt;的內容生成的，所以這四個檔案必須放在同一個資料夾：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;solvespace/exposed/_slvs.pyd
solvespace/exposed/libslvs.so
solvespace/exposed/slvs.py
solvespace/exposed/Usage.py
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;倉儲的Readme也做了一下說明。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;test.py&lt;/code&gt;執行結果中，偵測到&lt;code&gt;long&lt;/code&gt;還沒定義，所以資料庫還需要修理一下。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Ejc5KDo.jpg" &gt;&lt;/p&gt;
&lt;p&gt;搬到新電腦虛擬機的Ubuntu上測試時，使用的是&lt;code&gt;_slvs.so&lt;/code&gt;的樣式。&lt;/p&gt;
&lt;p&gt;會顯示ELF標頭檔錯誤，而無法執行，應該是因為在Windows上生成的關係，重新在Ubuntu上編譯應該就行了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jolKcHW.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;另外在新電腦虛擬機的Ubuntu上裝了一下Git、Netbeans和GNU工具包，可以正常運作，不過可能是跨系統模擬的關係，反應還滿慢的。&lt;/p&gt;
&lt;p&gt;然後Python3不知道怎麼更新，一直在3.4.2沒辦法升上去。&lt;/p&gt;</content><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/23</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050723.html" rel="alternate"></link><published>2016-07-23T20:37:00+08:00</published><updated>2016-07-23T20:37:00+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-23:/blog/40323218ri-zhi-1050723.html</id><summary type="html">&lt;p&gt;V-rep   printer_control&lt;/p&gt;
</summary><content type="html">&lt;p&gt;V-rep   printer_control&lt;/p&gt;


&lt;h2&gt;嘗試組裝3Dprinter&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;h3&gt;現在已嘗試兩種方式操控&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;分別是：&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/40323218/Printer_position_control.ttt?raw=true"&gt;Printer_position_control.ttt&lt;/a&gt;&lt;/p&gt;&lt;br&gt;
&lt;h3&gt;可以操控position(需用滑鼠移動)&lt;/h3&gt;&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/position.gif" weight=600 &gt;
&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/40323218/Printer_motor_control.ttt?raw=true"&gt;Printer_motor_control.ttt&lt;/a&gt;&lt;/p&gt;&lt;br&gt;
&lt;h3&gt;可以操控motor(需用參數移動)&lt;/h3&gt;
&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/motor.gif" weight=600 &gt;
&lt;br&gt;&lt;br&gt;
&lt;h3&gt;串列通訊：&lt;/h3&gt;
&lt;br&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/1-CW00QXwwk" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;br&gt;
&lt;iframe width="854" height="480" src="https://www.youtube.com/embed/y1vbxmeJ4M0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;</content><category term="Kmol"></category></entry><entry><title>40323230紀錄 - C語言資料庫格式</title><link href="http://project.mde.tw/blog/40323230ji-lu-cyu-yan-zi-liao-ku-ge-shi.html" rel="alternate"></link><published>2016-07-23T19:00:00+08:00</published><updated>2016-07-23T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-23:/blog/40323230ji-lu-cyu-yan-zi-liao-ku-ge-shi.html</id><summary type="html">&lt;p&gt;關於各平台程式使用之連結庫類型。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Static libraries&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shared libraries&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dynamically loaded libraries&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;p&gt;關於各平台程式使用之連結庫類型。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Static libraries&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shared libraries&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dynamically loaded libraries&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;參考資料來源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://terrycslife.blogspot.tw/2010/07/so.html" title="terrycslife.blogspot.tw"&gt;http://terrycslife.blogspot.tw/2010/07/so.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://kaineshu.wordpress.com/2007/05/02/%E8%BD%89%E8%B2%BC%E7%94%A8gcc-%E8%87%AA%E8%A3%BD-library/" title="kaineshu.wordpress.com"&gt;https://kaineshu.wordpress.com/2007/05/02/%E8%BD%89%E8%B2%BC%E7%94%A8gcc-%E8%87%AA%E8%A3%BD-library/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://www.jianshu.com/p/09994c9d8489" title="jianshu.com"&gt;http://www.jianshu.com/p/09994c9d8489&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Object File :&lt;/h2&gt;

&lt;p&gt;通常副檔名為&lt;code&gt;.o&lt;/code&gt;或是&lt;code&gt;.obj&lt;/code&gt;，後者為Windows使用的格式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zpxnXLj.jpg" &gt;&lt;/p&gt;
&lt;p&gt;將&lt;code&gt;.c&lt;/code&gt;或&lt;code&gt;.cpp&lt;/code&gt;、&lt;code&gt;.cxx&lt;/code&gt;的C語言程式碼包裝成的物件檔，無法直接使用。&lt;/p&gt;
&lt;p&gt;使用編譯工具的"Link"功能可以將這些單獨的物件檔合併成連結庫或是可執行檔。&lt;/p&gt;
&lt;h2&gt;Static libraries - 靜態資料庫 :&lt;/h2&gt;

&lt;p&gt;通常副檔名為&lt;code&gt;.a&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;作用方式：將連結庫包入程式中執行，處理效率高，缺點是檔案大且不易更新。&lt;/p&gt;
&lt;p&gt;若要建立一個靜態資料庫，可以使用DllTool從&lt;code&gt;.dll&lt;/code&gt;檔解出或是用GNU的&lt;code&gt;ar&lt;/code&gt;工具連結物件檔編譯。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ar&lt;/code&gt;的指令中，&lt;code&gt;rcs&lt;/code&gt;或是&lt;code&gt;-r&lt;/code&gt;後接上輸出的檔案名稱，如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ar rcs libmylib.a first.o second.o&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;產生靜態資料庫後，可以使用gcc的&lt;code&gt;-L&lt;/code&gt;和&lt;code&gt;-l&lt;/code&gt;指令連結，對象包含程式碼、物件檔和其他靜態資料庫。&lt;/p&gt;
&lt;h2&gt;Shared libraries - 共用資料庫 :&lt;/h2&gt;

&lt;p&gt;通常副檔名為&lt;code&gt;.so&lt;/code&gt;，後面可加掛版本編號。&lt;/p&gt;
&lt;p&gt;作用方式：資料庫和執行檔是分離的，剛開始就要載入，並且資料庫必須一直和執行檔待在一起，優點是修改方便。&lt;/p&gt;
&lt;p&gt;gcc在產生物件檔時必須加上&lt;code&gt;-fPIC&lt;/code&gt;參數，紀錄"position-independent code"，就是獨立位置碼，以紀錄存取位置的資訊。沒有使用的話只會用相對位置，不利於共享內容。&lt;/p&gt;
&lt;p&gt;再來將物件檔合併成資料庫時，加上&lt;code&gt;-shared&lt;/code&gt;參數，接著要自訂義"soname"、"real name"、"linker name"。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;soname是資料庫的名稱，通常以&lt;code&gt;lib&lt;/code&gt;開頭，包含附檔名和大版號，如&lt;code&gt;libexample.so.1&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;real name是真正使用程式的資料庫名稱，包含小版號，如&lt;code&gt;libexample.so.1.0.0&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;linker name是連結時的資料庫名稱，不包含版號，如&lt;code&gt;libexample.so&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;gcc使用&lt;code&gt;-Wl&lt;/code&gt;參數向內建的Link工具"ln"傳入資訊，如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gcc -shared -Wl,-soname,libexample.so.1 -o libexample.so.1.0.0 first.o second.o&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;-Wl,-soname&lt;/code&gt;定義soname；輸出的檔案名稱為real name；使用&lt;code&gt;-l&lt;/code&gt;或&lt;code&gt;-l:&lt;/code&gt;連結的名稱為linker name。&lt;/p&gt;
&lt;p&gt;尋找了下&lt;a href="https://en.wikipedia.org/wiki/Soname" title="https://en.wikipedia.org/wiki/Soname"&gt;維基百科&lt;/a&gt;，似乎也能使用&lt;code&gt;-h&lt;/code&gt;和&lt;code&gt;-soname=&lt;/code&gt;來定義soname的名稱。&lt;/p&gt;
&lt;p&gt;資料庫連結時使用&lt;code&gt;ln&lt;/code&gt;指令連結兩個&lt;code&gt;.so&lt;/code&gt;檔。使用&lt;code&gt;-s&lt;/code&gt;參數為軟連結，類似捷徑式的參照；使用&lt;code&gt;-d&lt;/code&gt;參數為硬連結，類似副本的備份。&lt;/p&gt;
&lt;p&gt;最後必須用以下指令為real name創造linker name和soname的檔案（使用&lt;code&gt;-s&lt;/code&gt;或&lt;code&gt;-d&lt;/code&gt;就隨喜好了）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;linker name&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ln -s libexample.so.1.0.0 libexample.so&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;soname&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ln -s libexample.so.1.0.0 libexample.so.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;之後可以用GNU的另一個工具"objdump"檢查連結。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objdump -p libexample.so.1.3 | grep SONAME&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;產生共用資料庫後，可以像靜態資料庫一樣包裝，也可以用程式呼叫。&lt;/p&gt;
&lt;p&gt;連結時有同名資料庫時會以共用資料庫優先，加上&lt;code&gt;-static&lt;/code&gt;參數可以指定靜態資料庫。&lt;/p&gt;
&lt;p&gt;而調用資料庫時是先找soname的檔案，否則會尋找linker name的檔案，可執行檔亦同。&lt;/p&gt;
&lt;h2&gt;Dynamically loaded libraries - 動態載入庫 :&lt;/h2&gt;

&lt;p&gt;為Windows中&lt;code&gt;.dll&lt;/code&gt;檔標準的模式，不過並非所有&lt;code&gt;.dll&lt;/code&gt;都是如此。&lt;/p&gt;
&lt;p&gt;作用方式：使用時才會載入，編譯時不須要相關資料庫檔案，因此常用於附加元件。&lt;/p&gt;
&lt;p&gt;使用一套DLL function來處理，標頭檔和編譯的程式碼中都會使用來傳遞訊息。&lt;/p&gt;
&lt;p&gt;gcc編譯時要加上&lt;code&gt;-ldl&lt;/code&gt;參數連結。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;後來發現gcc有時編譯「成功」的樣子可能包含著錯誤。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Pk6DJDw.jpg" &gt;&lt;/p&gt;
&lt;p&gt;今天測試了一些方法，但是明明CDemo和Python的&lt;code&gt;.so&lt;/code&gt;都是差不多的參數，編譯出的結果卻不如預期。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;libslvs.so&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -shared -o libslvs.so ../obj/util.obj ... ../obj/w32util.obj
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;_slvs.so&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -shared -o _slvs.so ../obj/util.obj ... ../obj/slvs_wrap.o -LW:/Anaconda3/libs -lPython35 -L. -l:libslvs.so
&lt;/pre&gt;

&lt;p&gt;如果編譯&lt;code&gt;_slvs.so&lt;/code&gt;時不加上後面的&lt;code&gt;-LW:/Anaconda3/libs&lt;/code&gt;、&lt;code&gt;-lPython35&lt;/code&gt;等等就會因為&lt;code&gt;slvs_wrap.o&lt;/code&gt;的&lt;code&gt;slvs_wrap.cxx&lt;/code&gt;出問題，但是沒加上就和&lt;code&gt;libslvs.so&lt;/code&gt;一樣了。&lt;/p&gt;
&lt;p&gt;但是這樣另一個問題就產生了，因為編出來的&lt;code&gt;_slvs.so&lt;/code&gt;是「可執行檔」，不指定&lt;code&gt;-o _slvs.so&lt;/code&gt;的話就會編譯成&lt;code&gt;a.exe&lt;/code&gt;，所以其他Python程式碼都找不到（有搬到虛擬機的Ubuntu測試，也找不到）。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/A9ITgDd.jpg" &gt;&lt;/p&gt;
&lt;p&gt;想過學範例用&lt;code&gt;.c&lt;/code&gt;跳過Object File的階段直接轉成&lt;code&gt;.so&lt;/code&gt;檔，但是只有&lt;code&gt;libslvs.so&lt;/code&gt;成功，&lt;code&gt;_slvs.so&lt;/code&gt;反而在系統暫存檔Temp資料夾中找不到Python連結。&lt;/p&gt;
&lt;p&gt;之後稍微看了一下SWIG轉出的&lt;code&gt;slvs.py&lt;/code&gt;結構，呼叫的&lt;code&gt;.py&lt;/code&gt;檔必須先導入&lt;code&gt;slvs.py&lt;/code&gt;後，&lt;code&gt;slvs.py&lt;/code&gt;會視Python版本取用&lt;code&gt;_slvs.so&lt;/code&gt;的內容，再傳給需要的&lt;code&gt;.py&lt;/code&gt;檔，所以&lt;code&gt;slvs.py&lt;/code&gt;和&lt;code&gt;_slvs.so&lt;/code&gt;都必須和撰寫的&lt;code&gt;.py&lt;/code&gt;檔放在一起。&lt;/p&gt;</content><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/22</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050722.html" rel="alternate"></link><published>2016-07-22T19:00:00+08:00</published><updated>2016-07-22T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-22:/blog/40323230ri-zhi-1050722.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Python-Solvespace編譯完畢。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;進行&lt;code&gt;_slvs.so&lt;/code&gt;呼叫測試。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公開倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已推送。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Python-Solvespace編譯完畢。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;進行&lt;code&gt;_slvs.so&lt;/code&gt;呼叫測試。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公開倉儲&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;已推送。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;編譯成功 :&lt;/h2&gt;

&lt;p&gt;上次編譯時一直找不到&lt;code&gt;Slvs_&lt;/code&gt;相關名稱的問題。&lt;/p&gt;
&lt;p&gt;最後發現編譯&lt;code&gt;_slvs.so&lt;/code&gt;時加入參照&lt;code&gt;libslvs.so&lt;/code&gt;資料庫的指令（&lt;code&gt;-L&lt;/code&gt;和&lt;code&gt;-l&lt;/code&gt;），就成功編譯了。&lt;/p&gt;
&lt;p&gt;結束編譯時，Makefile執行了CDemo.exe證明C語言調用&lt;code&gt;libslvs.so&lt;/code&gt;是完全沒問題的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/M7G0AH3.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著要試著執行Python調用&lt;code&gt;_slvs.so&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;測試test.py和Usage.py :&lt;/h2&gt;

&lt;p&gt;作者提供了2個範例使用，將它們和&lt;code&gt;_slvs.so&lt;/code&gt;放在相同目錄中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Usage.py&lt;/code&gt;是參照Readme的說明，將範例code抓下來存在&lt;code&gt;exposed&lt;/code&gt;資料夾的程式檔。&lt;/p&gt;
&lt;p&gt;然而若直接執行會出下列錯誤：&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;test.py&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Dp86EeP.jpg" &gt;&lt;/p&gt;
&lt;h2&gt;&lt;em&gt;Usage.py&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/goKX3du.jpg" &gt;&lt;/p&gt;
&lt;p&gt;意思是Python無法調用&lt;code&gt;_slvs&lt;/code&gt;這個模組，大部分的原因是名稱錯誤或是沒有導入。&lt;/p&gt;
&lt;p&gt;SWIG手冊的"Using distutils"之後的幾章是講導出模組後的應用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xm3XyRs.jpg" &gt;&lt;/p&gt;
&lt;p&gt;看了一下內容，Python導出後的模組可以作為Python的附加元件、直接呼叫、動態模組、靜態連結之類的。&lt;/p&gt;
&lt;p&gt;不過沒有解答一些例外的錯誤。&lt;/p&gt;
&lt;p&gt;但是一直找不到&lt;code&gt;_slvs.so&lt;/code&gt;，不知道是出了甚麼問題，會繼續尋找資料。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;公開倉儲 :&lt;/h2&gt;

&lt;p&gt;把目前進度推到了自己的&lt;a href="https://github.com/40323230/python-solvespace" title="github.com"&gt;python-solvespace&lt;/a&gt;倉儲，在&lt;code&gt;exposed&lt;/code&gt;資料夾中的Makefile編輯工具位置，就能Make和Clean。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/u5OAbuX.jpg" &gt;&lt;/p&gt;</content><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323250日誌 - V-rep 功能 (持續更新中)</title><link href="http://project.mde.tw/blog/40323250ri-zhi-v-rep-gong-neng-chi-xu-geng-xin-zhong.html" rel="alternate"></link><published>2016-07-20T20:37:00+08:00</published><updated>2016-07-20T20:37:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-07-20:/blog/40323250ri-zhi-v-rep-gong-neng-chi-xu-geng-xin-zhong.html</id><summary type="html">&lt;p&gt;V-rep 的使用與學習&lt;/p&gt;
</summary><content type="html">&lt;p&gt;V-rep 的使用與學習&lt;/p&gt;


&lt;p&gt;&lt;/br&gt;
&lt;h2&gt;Onshape繪製V-rep零件 : &lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;在Onshape新增一個零件檔 ,選擇隱私或者公開 ,目前每個人擁有的容量為10mb。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;在part studio部分選擇平面當作草圖繪圖 ,功能和大多繪圖軟體相同。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;單位設置 :&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_units.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;功能表有一個(x)函數圖示 ,能夠設定變數值 ,方便用於零件設計 ,若新增一個x ,命名為a且值為10的值 ,之後在填入尺寸部分輸入#a ,則該尺寸為10。 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_a.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;零件繪製好之後 ,在Assembly中引入零件。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_insert.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;先按右鍵將底座設定為fix(固定) ,組裝零件須注意 ,因為使用V-rep模擬 ,組裝時零件和零件設定小段距離(offset) ,不要完全貼合(在V-rep較易拆解零件) ,旋轉軸先透過cylindrical_mate和孔配合 ,再利用planar_mate讓軸偏移小段距離。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_offset.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;組合完畢後 ,在Assembly點選右鍵 ,輸出成stl格式檔案。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/onshape_export.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;V-rep 教學 :&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;導入stl檔案 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;點選左上方工具列File ,import ,mesh ,選取繪製的stl檔案後 ,就可以看到零件了。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_import.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_import2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;h3&gt;調整座標 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;若只看到零件的一部分 ,就是零件倒過來了 ,這時候點選左方零件圖示 ,再選上方工具列 ,將零件座標系設定成V-rep內(World)座標 ,最後點選上方旋轉功能 ,旋轉零件至理想角度。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_setaxis.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_setaxis2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;轉好角度之後 ,點選上方平移功能 ,並調整Z軸高度。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_setaxis3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;若零件被地板遮住 ,看不到零件 ,可先使用選平移功能 。&lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;h3&gt;拆解零件 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;在V-rep導入的stl檔都會變成一個整體零件 ,而在Onshape先組好是因為零件拆解後較容易定位 ,且座標較容易設定等等。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;點選欲拆解之零件後 ,點選工具列 ,編輯 ,Grouping/Merging ,Divide select shapes。 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_divide.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;若有照上方Onshape繪製零件方式 ,零件就可以順利拆開。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/v_rep/vrep_divide2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;加入旋轉軸 : &lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;在右側視窗點選右鍵 , Add → Joint → Revolute
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;新增完成 ,快點兩下圖示 ,可以設定相關性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_icon.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;橘色框框為旋轉軸長度及直徑 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;移動旋轉軸至零件主軸 : 先點選欲移動之物件(a.)後 ,按著shift並點選欲移動到的物件(b.) ,之後點選移動調整性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/move.png" &gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;綠色框框內分別為X、Y、Z重合 ,使旋轉軸與物體在同一軸線上 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/move_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;如果相關參數都設定好了 ,點選右鍵→Edit→使旋轉軸與零件結合成一物件(也可以直接用滑鼠拖曳)&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/object_combine.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;結合後的從屬關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/object_parent.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;旋轉軸(馬達)設定 :&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;先將各部位組立完成&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/Revolute_pin.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定底座Dynamic性質 , ( X = 不打勾 )&lt;/h3&gt;
&lt;h3&gt;Body is respondable 指 是否實體化 ,若兩個實體化物件互相碰撞 ,會依照物理設定做相對反應。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定Revolute_joint(馬達)性質 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定旋轉軸Dynamic性質 ,設為動態物件
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定旋轉桿Dynamic性質&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dynamic_properties_4.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;都設定好之後 ,設定旋轉軸(馬達)程式 ,點選左方文件圖示 ,之後在右方Scripts新增一個子程式&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_code_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;在Assciated object選擇STL_Imported_sub(主體) &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/scripts_code_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;之後打開左方script ,並加入下面那行程式&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/child_script.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;設定完之後就可以按start ,跑老師的python範例了&lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h2&gt;加入攝影機&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;在物件視窗點選滑鼠右鍵 → add → vision sensor →選擇其中一種類型&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;vision_sensor類型可分為 :
a.為orthographic type  及  b.為perspective type&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_types.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點兩下圖示設定攝影機性質 ,橘色框框為攝影範圍 ,
綠色框框為範圍內的解析度 (2^n ,2~256) ,棕色框框為攝影機大小&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_properties.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;將旋轉桿和攝影機結合並設定從屬關係&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sensor_combine.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;在物件視窗點選右鍵 ,點選 Remove page ,再次按右鍵新增2個視窗&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/add_2views.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點選左方第一台預設攝影機後 ,在上方視窗點選右鍵輸入攝影鏡頭&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/first_view.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;下方視窗則點選新增的攝影機 ,一樣新增攝影鏡頭
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/second_view.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;下方視窗會是黑色的 ,因為鏡頭所照的地方都是黑色 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sight.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;若將攝影機向下轉 ,就可以照到地板了 ,紅框內是照到旋轉桿 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision_sight2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;啟動程式來跑看看囉~&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/vision.gif"&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;dummy ( 虛擬座標 ) :&lt;/h3&gt;
&lt;h3&gt;dummy 能夠讓不是從屬性質的物件做相對移動, 常用於close chain, 以irb360範例來說 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;a. b.桿為示範物件&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dummy_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;將a.及b.桿實體隱藏之後 ,能夠看到從屬於a、b桿下的dummy為重疊狀態 ,並且為互相對應(target)  &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dummy_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/dummy_3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;目的是因為 ,若a桿做出任何動作(移動) ,在它從屬下的dummy會隨著target的dummy做相對運動 ,因此兩桿距離始終會保持固定 &lt;/h3&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;零件大小 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;size factor 為 目前模型的 比例 ,透過下方 Scaling 可以設定模型倍率 ,若Scaling factor 設為2 ,上方的size factor 會變成2 ,就是原始模型的2倍大&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/size_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;零件座標系 :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;導入零件後 ,拆解發現零件的角度與V-rep右下角(World)的座標不同 ,有時對於joint的放置會變得不方便 &lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_1.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點選要改變座標的零件後 ,在edit選單下點選Reorient bounding box→with reference frame of world 即可&lt;/h3&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_3.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;hr&gt;
&lt;/br&gt;
&lt;h3&gt;利用三角建構零件放入joint :&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;因為手臂有個齒輪 ,且有傾斜角度 ,所以需要透過零件轉換 ,並插入一個圓軸來輔助joint&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/axis_4.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;點選零件後右鍵選取 Edit→Decimate selected shape後 ,選擇三角形數量 (太少圓形會變多角形 ,太多運算會變慢) ,之後點選左方 Toggle shape edit mode&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/icon.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;全選所有三角形 ,並點選Extract cylinder後按OK&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/shape.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;之後就可以順利放上joint了&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/shape_2.png"&gt;&lt;/p&gt;</content><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/20</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050720.html" rel="alternate"></link><published>2016-07-20T19:00:00+08:00</published><updated>2016-07-20T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-20:/blog/40323230ri-zhi-1050720.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;gcc的&lt;code&gt;-M&lt;/code&gt;類型參數問題。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;math.h與pyconfig.h衝突修正。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用libpython35.a解決_wrap.cxx找不到函式的問題。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;gcc的&lt;code&gt;-M&lt;/code&gt;類型參數問題。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;math.h與pyconfig.h衝突修正。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用libpython35.a解決_wrap.cxx找不到函式的問題。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;Solvespace Makefile :&lt;/h2&gt;

&lt;p&gt;目前發現obj檔案無法辨識的原因是原始Makefile中加上了&lt;code&gt;-MT&lt;/code&gt;這個參數，然而沒有這個參數，只能改用&lt;code&gt;-MD&lt;/code&gt;來取代。&lt;/p&gt;
&lt;p&gt;直到Link這些obj檔時才發現，這些obj檔竟然是文字文件，而另一個Makefile導出的obj檔都相當正常。&lt;/p&gt;
&lt;p&gt;最後決定把Makefile中gcc的參數統一化，剩下才發現&lt;code&gt;-M&lt;/code&gt;系的參數會輸出信息檔，而不是物件。&lt;/p&gt;
&lt;p&gt;但是將obj檔重新連結成&lt;code&gt;solvespace.exe&lt;/code&gt;時就開始顯示大大小小的錯誤了，而且並非&lt;code&gt;-W&lt;/code&gt;的普通警告。相反的另一邊exposed資料夾就沒出現過警告。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/fnQrcS8.jpg" &gt;&lt;/p&gt;
&lt;p&gt;所以要成功編譯就必須將錯誤修正，看一些關於C++的資料。這些錯誤貌似都是物件繼承、指標項的用法問題。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2dtnGX0.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過今天專注在如何克服exposed資料夾的錯誤。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;MinGW的math.h和Python的pyconfig.h :&lt;/h2&gt;

&lt;p&gt;上網搜尋了許多文章，大部分的人使用MinGW編譯C轉Python的文件時，同時導入&lt;code&gt;cmath&lt;/code&gt;和&lt;code&gt;Python.h&lt;/code&gt;都會遇到這個衝突。&lt;/p&gt;
&lt;p&gt;主要原因是＜math.h＞中有一段&lt;code&gt;_hypot(double _X, double _Y)&lt;/code&gt;的函式，而它的名稱剛好與&lt;code&gt;pyconfig.h&lt;/code&gt;中的&lt;code&gt;define hypot _hypot&lt;/code&gt;衝突。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xdCKbBE.jpg" &gt;&lt;/p&gt;
&lt;p&gt;上網搜尋時找到一系列2013年的信件：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.vtk.org/pipermail/vtk-developers/2013-March/013475.html" title="vtk.org"&gt;http://www.vtk.org/pipermail/vtk-developers/2013-March/013475.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要是討論如何處理這個問題，信中曾建議在自己的程式碼的&lt;code&gt;include ＜Python.h＞&lt;/code&gt;下加上這段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include ＜cmath＞
#include ＜Python.h＞
#ifdef hypot
#undef hypot
#endif
&lt;/pre&gt;

&lt;p&gt;但是這樣根本不可行，因為導入&lt;code&gt;Python.h&lt;/code&gt;時就會同時導入&lt;code&gt;pyconfig.h&lt;/code&gt;，一旦導入&lt;code&gt;pyconfig.h&lt;/code&gt;就會產生衝突，後面再undefine也不會有用。&lt;/p&gt;
&lt;p&gt;所以根本的問題就是修改&lt;code&gt;pyconfig.h&lt;/code&gt;，變成這一段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifndef _MATH_H_
#define hypot _hypot
#endif
&lt;/pre&gt;

&lt;p&gt;讓它只能在沒有&lt;code&gt;math.h&lt;/code&gt;的時候才能使用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/4OWuZG1.jpg" &gt;&lt;/p&gt;
&lt;p&gt;更改後編譯就沒有問題了。&lt;/p&gt;
&lt;p&gt;不過不知道這樣更改會不會讓Anaconda的Python衍生其他狀況。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;libpython35.a :&lt;/h2&gt;

&lt;p&gt;出現了&lt;code&gt;slvs_wrap.cxx&lt;/code&gt;匯入函式的問題。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
slvs_wrap.o: In function `_SWIG_Py_None':
slvs_wrap.cxx:1446: undefined reference to `__imp__Py_RefTotal'
...
&lt;/pre&gt;

&lt;p&gt;這些是SWIG自動產生的，interface無法修改。&lt;/p&gt;
&lt;p&gt;上網搜尋了一下，應該是軟體位元問題，找到了類似的問題。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.gdomc.com/0423/how-can-i-build-my-c-extensions-with-mingw-w64-in-python/" title="gdomc.com"&gt;http://www.gdomc.com/0423/how-can-i-build-my-c-extensions-with-mingw-w64-in-python/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接著參考另一篇文章生成&lt;code&gt;libpython35.a&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/kivy/kivy/wiki/Creating-a-64-bit-development-environment-with-MinGW-on-Windows" title="github.com"&gt;https://github.com/kivy/kivy/wiki/Creating-a-64-bit-development-environment-with-MinGW-on-Windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，將Python的DLL檔複製一份進Python的libs資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/6CGP2VW.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著下載&lt;code&gt;gendef.exe&lt;/code&gt;，它也是MinGW的工具之一，從下列網址下載&lt;code&gt;gendef-1.0.1346-1-mingw32-bin.tar.lzma&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sourceforge.net/projects/mingw/files/MinGW/Extension/gendef/gendef-1.0.1346/" title="sourceforge.net"&gt;https://sourceforge.net/projects/mingw/files/MinGW/Extension/gendef/gendef-1.0.1346/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解壓縮進MinGW的bin資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/CsH45V5.jpg" &gt;&lt;/p&gt;
&lt;p&gt;接著用CMD進入Python的libs資料夾中使用以下命令。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
gendef python35.dll
dlltool --dllname python35.dll --def python35.def --output libpython35.a
&lt;/pre&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/nMybQmX.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dlltool&lt;/code&gt;是GNU內建的工具，有安裝過安裝版的GNU工具包就能在本機端環境使用。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/wAdo8A1.jpg" &gt;&lt;/p&gt;
&lt;p&gt;做完後就會產生&lt;code&gt;libpython35.a&lt;/code&gt;這個檔案。&lt;/p&gt;
&lt;p&gt;然後到Python的include資料夾開啟&lt;code&gt;pyconfig.h&lt;/code&gt;這個檔案編輯。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/oSfNLI9.jpg" &gt;&lt;/p&gt;
&lt;p&gt;搜尋並將以下內容剪下：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifdef _WIN64
#define MS_WIN64
#endif
&lt;/pre&gt;

&lt;p&gt;貼到以下內容的「上方」：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifdef _MSC_VER
...
&lt;/pre&gt;

&lt;p&gt;再到Python的&lt;code&gt;Lib\distutils&lt;/code&gt;資料夾中，開啟&lt;code&gt;cygwinccompiler.py&lt;/code&gt;這個檔案。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/XwvABHb.jpg" &gt;&lt;/p&gt;
&lt;p&gt;搜尋以下內容並註解掉：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
self.dll_libraries = get_msvcr()
&lt;/pre&gt;

&lt;p&gt;注意四周會有相似的內容，不要弄錯註解。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/xfY1FU0.jpg" &gt;&lt;/p&gt;
&lt;p&gt;範例在編譯&lt;code&gt;slvs_wrap.o&lt;/code&gt;時加上&lt;code&gt;-DMS_WIN64&lt;/code&gt;參數。&lt;/p&gt;
&lt;p&gt;不過這時因為已經修改過&lt;code&gt;pyconfig.h&lt;/code&gt;的內容，會自動宣告&lt;code&gt;MS_WIN64&lt;/code&gt;，所以加上會提示說重複宣告。&lt;/p&gt;
&lt;p&gt;最後編譯用的指令如下。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -IW:/Anaconda3/include -Wno-unused-but-set-variable -c -o ../obj/slvs_wrap.o slvs_wrap.cxx
g++ -shared -fPIC -o _slvs.so ... ../extlib/si/siapp.lib  -LW:/Anaconda3/libs -lPython35
&lt;/pre&gt;

&lt;p&gt;但是最後還是出現一點錯誤：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Ie05RYb.jpg" &gt;&lt;/p&gt;
&lt;p&gt;應該是內部的導入問題。&lt;/p&gt;
&lt;p&gt;由於時間不多，所以這個部分之後再解決。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天有稍微比較下Whitequark的原始碼，不過用法已經完全不一樣，相同的變數也改變了型態，更有系統性，但是也更難判讀，所以&lt;code&gt;.cpp&lt;/code&gt;的部分還得熟悉相關的知識。&lt;/p&gt;
&lt;p&gt;Solvespace Makefile的部分是編譯&lt;code&gt;solvespace.exe&lt;/code&gt;的部分，不過Python呼叫的部分應該是不用那麼多，畢竟那些大部分都是介面檔，真正的本體只需要判斷是否衝突。&lt;/p&gt;
&lt;p&gt;所以Solvespace Makefile的部分才做得漫不經心吧。&lt;/p&gt;
&lt;p&gt;exposed Makefile部分的&lt;code&gt;all&lt;/code&gt;為三個目標：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
all: cdemo _slvs.so slvs.py
    LD_LIBRARY_PATH=. ./cdemo
&lt;/pre&gt;

&lt;p&gt;CDemo的部分已經成功轉出可執行檔；&lt;code&gt;_slvs.so&lt;/code&gt;還在最後階段的編譯中；&lt;code&gt;slvs.py&lt;/code&gt;則是原作者撰寫好的（不過是Python 2）。&lt;/p&gt;
&lt;p&gt;預計不久後就能夠測試&lt;code&gt;_slvs.so&lt;/code&gt;的功能。&lt;/p&gt;</content><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="Python-Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/19</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050719.html" rel="alternate"></link><published>2016-07-19T20:37:00+08:00</published><updated>2016-07-19T20:37:00+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-19:/blog/40323218ri-zhi-1050719.html</id><summary type="html">&lt;p&gt;V-rep 翻譯 Inverse kinematics&lt;/p&gt;
</summary><content type="html">&lt;p&gt;V-rep 翻譯 Inverse kinematics&lt;/p&gt;


&lt;p&gt;&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/IK1.png" weight=600 &gt;&lt;br&gt;&lt;br&gt;
&lt;h3&gt;•  Inverse kinematics enabled:   啟用或禁用所有IK計算。&lt;br&gt;
&lt;br&gt;&lt;br&gt;
•  Add new IK group: &lt;br&gt;&lt;br&gt;新增一個空的 IK group. IK groups 可以包含一個或多個 IK elements.&lt;br&gt;&lt;br&gt; IK elements 是基本運動學綁著IK任務, IK groups可以組合他們來同時運行.&lt;br&gt;&lt;br&gt; 當需要時只使用同時運行(比依序運算花較長的計算時間).&lt;br&gt;&lt;br&gt; 一個IK element 總必須被一個IK group連結，而且不能單獨存在. &lt;br&gt;&lt;br&gt;在按鈕下方的列表中顯示所有的IK groups將會在IK計算時被運行.&lt;br&gt;&lt;br&gt; 在列表中一個 IK group需要被選擇，為了顯現它的參數在剩餘的對話框中.&lt;br&gt;&lt;br&gt; 在列表中的順序很重要(IK group 1的結果可能被IK group 2需要來正確地或更快的執行).&lt;br&gt;&lt;br&gt; 在列表旁的兩個按鈕可以改變被選擇的IK group的位置.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  IK group is active:     允許啟動這個IK groups.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Explicit handling: &lt;br&gt;&lt;br&gt;表示被選擇的IK group 是否應該被明確地處理. &lt;br&gt;&lt;br&gt;如果打勾, 當呼叫simHandleIkGroup(sim_handle_all_except_explicit)時，&lt;br&gt;&lt;br&gt;在IK 計算這個IK group將不會被處理，但只有當&lt;br&gt;&lt;br&gt;simHandleIkGroup(sim_handle_all) or&lt;br&gt;&lt;br&gt; simHandleIkGroup(ikGroupHandle) 呼叫時除外. &lt;br&gt;&lt;br&gt;這是非常有用的當如果用戶希望在  child script 而不是在  main script&lt;br&gt;&lt;br&gt;處理IK group裡的kinematics  (如果沒有打勾, IK計算將會被執行兩次,一次是在&lt;br&gt;&lt;br&gt;main script呼叫simHandleIkGroup(sim_handle_all_except_explicit) 時, &lt;br&gt;&lt;br&gt;另一次是在child script 呼叫simHandleIkGroup(ikGroupHandle)時. &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Mechanism is redundant: &lt;br&gt;&lt;br&gt;當被打勾時, 在IK解析時joint限制校正將被啟用. &lt;br&gt;&lt;br&gt;否則，joint limits 將會簡單地被強制執行在IK 解析之後，可能導致不穩定.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Ignore max. step sizes:   如果被勾選，在  joint properties 裡的maximum step sizes 將會被忽略.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Calc. method: &lt;br&gt;&lt;br&gt;具體說明IK group 決定使用的計算方式. &lt;br&gt;&lt;br&gt; Pseudo inverse  是最快的方式但可能不穩定當目標與 tip lie 距離太遠, 當一個運動鏈超過限制或當機構靠近一個單一組態 或 超出目標.&lt;br&gt;&lt;br&gt;  DLS 是較慢但更穩定因為它是一個阻尼分析方式(阻尼因子可以被指定（阻尼）). &lt;br&gt;&lt;br&gt;這是一個好的選擇當  pseudo inverse可能失敗.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Damping: &lt;br&gt;&lt;br&gt;阻尼因子當使用DLS.  較大的值導致更穩定的分辨率，但速度很慢。適當地調整值是重要的。&lt;br&gt;&lt;br&gt;&lt;br&gt;
•  Max. iterations: &lt;br&gt;&lt;br&gt;重複的最大數值可以被指定. 這是計算經過的最大數量對於給予的IK group，直到它指定的結果精度到達. DLS 經常需要比  Pseudo inverse更多的重複.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Joint limits (calculation weights): &lt;br&gt;&lt;br&gt;the calculation weight 應該被使用在 joint limitation constraints &lt;br&gt;&lt;br&gt;(joint limitation constraints 是被指定在  joint properties &lt;br&gt;&lt;br&gt;(position minimum andposition range).&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Obstacle avoidance (calculation weights): &lt;br&gt;&lt;br&gt;the calculation weight 應該被使用對於 obstacle avoidance(避開障礙物) constraints.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Joint limit thresholds:   線性和角度的臨界值應該和joint limitation constraints 一起被使用.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Edit conditional parameters:   調整選擇的IK group裡附加的參數 .&lt;/h3&gt;
&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/IK2.png" weight=600 &gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;•  Perform if... : &lt;br&gt;&lt;br&gt;這是有條件的分析部分. &lt;br&gt;&lt;br&gt;使用者可以選擇下拉一個在列表中的IK group，&lt;br&gt;&lt;br&gt;這個IK分析結果將會決定當前IK group是否會被解決。&lt;br&gt;&lt;br&gt;被認為是成功的IK group計算的IK elements都位於指定的線性/角度精度內。&lt;br&gt;&lt;br&gt;&lt;br&gt;
•  Restore if... : &lt;br&gt;&lt;br&gt;允許恢復初始IK group配置（goint values）如果分析沒有成功 (位置和/或定向精度沒有達到).&lt;br&gt;&lt;br&gt; 與上述條件的解結合時，用戶可以例如結合兩個不同的計算方法。&lt;br&gt;&lt;br&gt;這是有用的如果在操作者的目標可能超出範圍或靠近一個單一組態: &lt;br&gt;&lt;br&gt;第一次分析嘗試將試著求解IK group與non-damped resolution method (pseudo inverse, fast), &lt;br&gt;&lt;br&gt;而且如果不成功, 第二次嘗試將會試著解決它與damped resolution method (DLS, slower). &lt;br&gt;&lt;br&gt;使用者也當然可以自由手動地處理IK resolution 從script, plugin, 等.&lt;br&gt;&lt;br&gt;&lt;br&gt;
•  Edit obstacle avoidance parameters: &lt;br&gt;&lt;br&gt;允許調整避障參數。&lt;br&gt;&lt;br&gt;請注意，這只是對熟練的操作者有意義, &lt;br&gt;&lt;br&gt;而且模擬速度會大幅度地放緩。&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/IK3.png" weight=600 &gt;&lt;br&gt;&lt;br&gt;
&lt;h3&gt;•  Select avoidance entities / Remove avoidance constraint: &lt;br&gt;&lt;br&gt;允許選擇/移除avoidance entities. &lt;br&gt;&lt;br&gt;一個整體通常是機器人，其他實體是障礙物。&lt;br&gt;&lt;br&gt; 使用簡單地measurable objects 來快速分析.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Distance threshold: &lt;br&gt;&lt;br&gt;在兩個avoidance entities 之間應該保持最小的距離.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;•  Edit IK elements: &lt;br&gt;&lt;br&gt;允許編輯各種被選擇的IK group有關聯的IK elements.
&lt;/h3&gt;&lt;/p&gt;</content><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/19</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050719.html" rel="alternate"></link><published>2016-07-19T19:00:00+08:00</published><updated>2016-07-19T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-19:/blog/40323230ri-zhi-1050719.html</id><summary type="html">&lt;p&gt;Python-Solvespace編譯除錯中。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Python-Solvespace編譯除錯中。&lt;/p&gt;


&lt;h2&gt;Netbeans的版次管理與自訂工具列 :&lt;/h2&gt;

&lt;p&gt;Netbeans有內建檔案版本紀錄的功能，只要在檔案左上角的按鈕切換到&lt;code&gt;History&lt;/code&gt;，就會出現修改紀錄表。&lt;/p&gt;
&lt;p&gt;點擊其中的項目就會顯示並和目前版本的檔案做比較。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/dwmVZD4.jpg" &gt;&lt;/p&gt;
&lt;p&gt;其中紅色是刪除；綠色是新增；藍色是取代。&lt;/p&gt;
&lt;p&gt;如果想復原其中的項目，可以移到顏色區塊上，左側的版本會出現箭頭，能夠將舊版的內容復原至當前的區段中，十分方便。&lt;/p&gt;
&lt;p&gt;若是想直接復原整個檔案，可以在紀錄上案右鍵，選擇&lt;code&gt;Revert from History&lt;/code&gt;就會復原檔案。特別的是，一但復原檔案，Netbeans就會直接儲存檔案，成為新的歷史紀錄，這方面需要多注意。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/2Ih9AVd.jpg" &gt;&lt;/p&gt;
&lt;p&gt;而專案中的檔案名稱也會配上顏色，不論是在左側的檔案樹或是分頁上。&lt;/p&gt;
&lt;p&gt;黑色是一般clone下來的專案；藍色是使用者修改過的檔案（縱使已經復原到原始版本）；灰色是透過MinGW以外程式編寫的檔案；綠色是自己撰寫或是由MinGW編譯出的檔案。&lt;/p&gt;
&lt;p&gt;Netbeans是以Git功能為基礎架設的（雖然不一定要使用），因此十分注重版次管理，也支援圖形化顯示&lt;code&gt;git pull&lt;/code&gt;的修改處。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/H2v8Lve.jpg" &gt;&lt;/p&gt;
&lt;p&gt;另一個個人化的功能就是自訂工具列，能夠將內建或模組的功能鈕設置在工具列上。&lt;/p&gt;
&lt;p&gt;排列方法跟Firefox一樣是抓取的。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/W7kSbRH.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;上次的問題 :&lt;/h2&gt;

&lt;p&gt;上一篇網誌中的問題：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Icons&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Netbeans找不到外部程式的問題已解決，只要指定程式的確切位置就能執行。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jVeAaE3.jpg" &gt;&lt;/p&gt;
&lt;p&gt;所以指定Perl在W:槽的位置，上次發現的Perl其實是MinGW的附加工具，版本是5.8。&lt;/p&gt;
&lt;p&gt;但是新下載的是5.24，並且有安裝需要的模組"GD"。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/zSV5yLU.jpg" &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/NjpIYjZ.jpg" &gt;&lt;/p&gt;
&lt;p&gt;修改成下面這段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
PERL = W:\Perl524\bin\perl.exe

...

$(OBJDIR)/icons.h: png2c.pl icons/*
    @echo icons
    $(PERL) $＜ $@ $(OBJDIR)/icons-proto.h
&lt;/pre&gt;

&lt;p&gt;指定後就可以執行。&lt;/p&gt;
&lt;p&gt;而後來又有一個"rc"的指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
$(RES): win32/$(@B).rc icon.ico
    rc win32/$(@B).rc
    mv win32/$(@B).res $(OBJDIR)/$(@B).res
&lt;/pre&gt;

&lt;p&gt;（原始版本的錯誤用法＄(＠B)應該為＄(＠F)，都改為＄＜或＄^較明瞭）&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/jVeAaE3.jpg" &gt;&lt;/p&gt;
&lt;p&gt;經查詢資料，"rc.exe"原是Windows Kits的一個工具。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/QWfaVfq.jpg" &gt;&lt;/p&gt;
&lt;p&gt;所以就改寫用變數指定。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
RC = "C:\Program Files (x86)\Windows Kits\$(RCVER)\bin\$(RCBIT)\rc.exe"
RCVER = 10
RCBIT = x64

...

$(RES): resource.rc icon.ico
    @echo RES
    $(RC) $＜
    mv win32/resource.res  $@
&lt;/pre&gt;

&lt;p&gt;同理，其他如SWIG都可以呼叫所在位置來執行了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ld.exe does not find libraries&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;要改一下語法，之前使用的&lt;code&gt;-lslvs&lt;/code&gt;應該指定名稱&lt;code&gt;-l:libslvs.so&lt;/code&gt;並指定同目錄：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
cdemo: CDemo.c libslvs.so
    @echo cdemo
    @$(CXX) $(CFLAGS) -o $@ $＜ -L. -l:libslvs.so $(LIBS)
&lt;/pre&gt;

&lt;p&gt;接著就能夠找到libslvs.so。&lt;/p&gt;
&lt;p&gt;不知道是因為沒有&lt;code&gt;-L&lt;/code&gt;指定目錄還是&lt;code&gt;-l&lt;/code&gt;不會看附檔名的關係，一定要標定到檔案才會容許。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;錯誤紀錄 :&lt;/h2&gt;

&lt;h4&gt;已解決&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Function "vasprintf"&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在"slvs_python.hpp"中，導入了一個stdio.h的函式&lt;code&gt;vasprintf&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不過其實正確名稱應該要增加父項式，因此修改成&lt;code&gt;__mingw_vasprintf(&amp;amp;buf, fmt, args)&lt;/code&gt;就沒問題了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/czsgUbf.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Netbeams應該是支援h++的標頭檔，但是"slvs_python.hpp"的前半段錯誤累累，應該是從屬關係和宣告的部分沒弄清楚。&lt;/p&gt;
&lt;p&gt;目前並沒有干擾MinGW的編譯，但是這些東西應該重新整理一下，尤其是下面的導入：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include ＜string＞
#include ＜exception＞
&lt;/pre&gt;

&lt;p&gt;在編寫時好像連結不到，但是編譯時MinGW抓得到，不知道Netbeams的錯誤有沒有算入這種情形。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;CMath&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;用SWIG剛轉出"slvs_wrap.cxx"時產生的問題。&lt;/p&gt;
&lt;p&gt;出現一段錯誤：&lt;code&gt;error: '::hypot' has not been declared&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在其他人的commit中有解答：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/casadi/casadi/issues/622" title="github.com"&gt;https://github.com/casadi/casadi/issues/622&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是說要新增&lt;code&gt;include ＜cmath＞&lt;/code&gt;進"slvs_wrap.cxx"中，而且必須在"Python.h"之前。&lt;/p&gt;
&lt;p&gt;所以我就在interface檔中新增了，讓轉換時會自動加入這段。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/cqgzD3B.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過這個問題是暫時解決，後來又有相關的麻煩。&lt;/p&gt;
&lt;h4&gt;未解決&lt;/h4&gt;

&lt;p&gt;分成兩部分的Makefile，主要是exposed資料夾的python函式比較重要。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Solvespace Makefile&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在最後一個要生成"solvespace.exe"時無法辨識&lt;code&gt;.obj&lt;/code&gt;檔案？&lt;/p&gt;
&lt;pre class="brush: c"&gt;
g++ -D_WIN32_WINNT=0x500 -DISOLATION_AWARE_ENABLED -D_WIN32_IE=0x500 -DWIN32_LEAN_AND_MEAN -DWIN32 -g -m32 -MT -Iextlib -I..\common\win32 -I. -D_DEBUG -D_CRT_SECURE_NO_WARNINGS   obj/ratpoly.obj ... obj/resource.res -o obj/solvespace.exe
w:/mingw/bin/../lib/gcc/x86_64-w64-mingw32/6.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe:obj/ratpoly.obj: file format not recognized; treating as linker script
w:/mingw/bin/../lib/gcc/x86_64-w64-mingw32/6.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe:obj/ratpoly.obj:1: syntax error
collect2.exe: error: ld returned 1 exit status
make.exe": *** [obj/solvespace.exe] Error 1
&lt;/pre&gt;

&lt;p&gt;目前還不知道怎麼辦，因為不太了解&lt;code&gt;.o&lt;/code&gt;和&lt;code&gt;.obj&lt;/code&gt;的關係。&lt;/p&gt;
&lt;p&gt;前者是暫時等待編譯的物件，後者是給記憶體參照的。&lt;/p&gt;
&lt;p&gt;gcc對於副檔名是很重視的，可能要調整參數之類的？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Exposed Makefile&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;剩下幾步可以編成"slvs_wrap.o"。&lt;/p&gt;
&lt;p&gt;最後跳出的錯誤，竟然是內建資料庫的問題。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
In file included from W:/Anaconda3/include/Python.h:8:0,
                 from slvs_wrap.cxx:14:
W:/Anaconda3/include/pyconfig.h:262:15: error: 'std::_hypot' has not been declared
 #define hypot _hypot
               ^
make.exe": *** [../obj/slvs_wrap.o] Error 1
&lt;/pre&gt;

&lt;p&gt;導入"Python.h"和相關的"pyconfig.h"時出現了錯誤。是從上面cmath衍生的問題。&lt;/p&gt;
&lt;p&gt;上網搜尋了一下，好像找不到解決方法，&lt;code&gt;'std::_hypot' has not been declared&lt;/code&gt;好像有出現在MinGW的Bug紀錄中。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這兩個Makefile的使用參數大相逕庭，以下是比較：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Solvespace&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DEFINES = -D_WIN32_WINNT=0x500 -DISOLATION_AWARE_ENABLED -D_WIN32_IE=0x500 -DWIN32_LEAN_AND_MEAN -DWIN32
CFLAGS = -g -m32 -MT -Iextlib -I..\common\win32 -I. -D_DEBUG -D_CRT_SECURE_NO_WARNINGS
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Exposed&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
WIN_DEFINES = -D_WIN32_WINNT=0x500 -D_WIN32_IE=0x500 -DWIN32_LEAN_AND_MEAN
DEFINES = -DISOLATION_AWARE_ENABLED -DLIBRARY
CFLAGS  = -I../extlib -I../../common/win32 -I. -I.. -D_DEBUG -D_CRT_SECURE_NO_WARNINGS -O2 -g -Wno-write-strings -fpermissive
CFLAGS_SHARED = -fPIC -shared $(CFLAGS)
&lt;/pre&gt;

&lt;p&gt;兩個Makefile編譯階段都進入整合階段，剩下的一些編譯問題主要是對MinGW的編譯程式不熟悉的緣故。&lt;/p&gt;
&lt;p&gt;像是一般的&lt;code&gt;.so&lt;/code&gt;、&lt;code&gt;.o&lt;/code&gt;都較為廣用，可是將obj檔直接轉換成可執行檔，卻找不到範例。&lt;/p&gt;
&lt;p&gt;之後要再找找看gcc和g++的編譯範例。&lt;/p&gt;</content><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="Python-Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/18</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050718.html" rel="alternate"></link><published>2016-07-18T19:00:00+08:00</published><updated>2016-07-18T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-18:/blog/40323230ri-zhi-1050718.html</id><summary type="html">&lt;p&gt;改寫Python-Solvespace的Makefile運作方式。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;改寫Python-Solvespace的Makefile運作方式。&lt;/p&gt;


&lt;h2&gt;前言 :&lt;/h2&gt;

&lt;p&gt;閱讀GNU-Make的手冊之後，已經了解Makefile基本的運作方式，所以試圖解決Python-Solvespace編譯程序中出現的問題。&lt;/p&gt;
&lt;p&gt;手冊連結：&lt;a href="https://www.gnu.org/software/make/manual/make.pdf" title="gnu.org"&gt;https://www.gnu.org/software/make/manual/make.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;利用Interface來轉換Whitequark的新版Solvespace應該是不太可行的方式了，何況Python-Solvespace也未使用全部的功能，我們需要的是解題的函式就好。&lt;/p&gt;
&lt;p&gt;而另一方面Solid-python現在已經完全支援Python 3，若之後要調用其功能，應該也不會有太大的障礙。&lt;/p&gt;
&lt;p&gt;所以決定把Python-Solvespace的Makefile重新寫好，將Python-Solvespace的資料庫建構完成。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;Netbeans的支援 :&lt;/h2&gt;

&lt;p&gt;其實Netbeans與$GNU開發者工具包$周邊的軟體都有良好的相依性，因此在撰寫Makefile時方便不少。&lt;/p&gt;
&lt;p&gt;在編寫完Makefile時，可以在個別的Makefile上點擊右鍵，選擇需要的命令讓make執行，諸如all、clean等等的功能可以選擇。&lt;/p&gt;
&lt;p&gt;Makefile中可以撰寫功能讓工程師執行，連基本的clean功能也可以自訂要刪除哪些檔案。&lt;/p&gt;
&lt;p&gt;當然利用這點，Makefile中也可以利用Echo做help的功能，Whitequark的Solvespace就有支援。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/9DDeyVj.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編寫Makefile :&lt;/h2&gt;

&lt;p&gt;原本Python-Solvespace的Makefile是將檔案分類，再一類類用一樣的式子做轉換，而且語法冗長還有許多錯誤。若有新增檔案，就必須填入參數的名單中登記。&lt;/p&gt;
&lt;p&gt;一個小型程式專案的Makefile事實上只需要下列的式子就能轉換：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
$(ADIR)/%.obj: $(BDIR)/%.cpp $(HEADERS)
    $(CXX) $(FLAGS) -c -o $@ $＜
&lt;/pre&gt;

&lt;p&gt;意思是ADIR中的obj檔都與BDIR的cpp檔、標頭檔有關聯，而每個obj檔是由每個cpp檔透過＄(CXX)命令式產生的。&lt;/p&gt;
&lt;p&gt;$後面的＄＠表示每個目標項（包括其位置）$；同理，$＄＜亦代表每個參照項$，不過＄＜是只包含第一個條件的參照項，所以後面的多個標頭檔就不會帶入＄(CXX)命令中。&lt;/p&gt;
&lt;p&gt;若要在命令式中使用所有條件的參照項，要使用＄+，但是更好的選擇是使用＄^，會自動排除重複名稱的參照項。&lt;/p&gt;
&lt;p&gt;這樣寫固然簡單，但是每個檔案都在不同的資料夾中，要如何讓make搜尋？&lt;/p&gt;
&lt;p&gt;所以必須加上VPath這個參數，讓尋找參照檔案時可以搜尋到所有符合的項目。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/wpUqKDX.jpg" &gt;&lt;/p&gt;
&lt;p&gt;make在找檔案時最大的特性就是$按邏輯去找$。&lt;/p&gt;
&lt;p&gt;也因為這點，不用顧慮產生檔案的順序問題。只要"填寫"檔案是如何產生的，make就會根據需要的檔案來做順序調整。&lt;/p&gt;
&lt;p&gt;make會先忽略還沒產生的參照檔案，尋找已經備齊參照檔案的項目先做，指令亦可使用外部程式來執行。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編譯瓶頸 :&lt;/h2&gt;

&lt;p&gt;經過重新整理的Makefile，應該是沒有問題了，都將指令分配完整沒有衝突。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/IkKQSqe.jpg" &gt;&lt;/p&gt;
&lt;p&gt;但是仍然遇到Makefile以外的一些問題。&lt;/p&gt;
&lt;h4&gt;已解決&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Stdint.h&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;這個原先是C語言的額外函式庫，幫助統一化使用的格式，但是如果沒裝，就會選擇作者寫的指令。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Rz3xBwO.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過這個地方應該是寫錯了，會一直認為這些是未定義的格式。&lt;/p&gt;
&lt;p&gt;其實導入"stdint.h"的地方也只有上圖的前半段，所以最快的解決方法就是讓solvespace.h擁有stdint.h一部份的能力。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/BireSqB.jpg" &gt;&lt;/p&gt;
&lt;p&gt;在上面這張Netbeans的比較圖中，直接把前半段的功能插進來用了，並成功解決問題。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Min &amp;amp; Max Functions&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下列solvespace.h的函式出了問題。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#ifndef min
#define min(x, y) ((x) &lt; (y) ? (x) : (y))
#endif
#ifndef max
#define max(x, y) ((x) &gt; (y) ? (x) : (y))
#endif
&lt;/pre&gt;

&lt;p&gt;上網搜尋了一下，找到基本款的用法：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#define min(x, y) (((x)＜(y)) ? (x):(y))
#define max(x, y) (((x)&gt;(y)) ? (x):(y))
&lt;/pre&gt;

&lt;p&gt;加上括弧其實非必要，因為三元運算子的優先度本身就比大於小於還低。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/l5u0t2N.jpg" &gt;&lt;/p&gt;
&lt;p&gt;不過這個判斷式使用上怪怪的，移除後直接define就沒這個問題了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Object-oriented problem&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在surface.h中有一段是這樣描述的：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
class STrimBy {
...
    static STrimBy STrimBy::EntireCurve(SShell *shell, hSCurve hsc, bool bkwds);
...
};
&lt;/pre&gt;

&lt;p&gt;到stackoverflow.com的論壇尋找後，有相似的問題。&lt;/p&gt;
&lt;p&gt;是物件導向的從屬錯誤，不應該重複稱呼，但是編譯器通常不會抓這種錯誤，解決方法是刪掉前面的父項名稱。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/PC43snc.jpg" &gt;&lt;/p&gt;
&lt;p&gt;最後變成：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
class STrimBy {
...
    static EntireCurve(SShell *shell, hSCurve hsc, bool bkwds);
...
};
&lt;/pre&gt;

&lt;p&gt;也是成功解決。&lt;/p&gt;
&lt;h4&gt;未解決&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Icons&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;首先是圖示(icon)的問題。&lt;/p&gt;
&lt;p&gt;Python-Solvespace的作者使用另一個語言$Perl$的程式來做出"icons.h"這個檔案。&lt;/p&gt;
&lt;p&gt;Perl是一個高階語言，特點就是除了自己的寫法，還可以安裝大量模組來改變撰寫方式，甚至還繼承許多C語言的標準式。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/eXwWp0J.jpg" &gt;&lt;/p&gt;
&lt;p&gt;安裝方式跟Python相同，複製檔案跟設定環境變數就能使用了。&lt;/p&gt;
&lt;p&gt;作者用了"GD"這個模組來導出"icons.h"。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/Y1p6Mck.jpg" &gt;&lt;/p&gt;
&lt;p&gt;Netbeans雖然也有Perl的附加元件，但是功能比SciTE還陽春，就沒使用它了。&lt;/p&gt;
&lt;p&gt;Perl的副檔名是pl，專案中有"png2c.pl"和"pngchar2c.pl"，應該就是將PNG檔導入C語言中的意思，Makefile中是要執行"png2c.pl"並產生出"icons.h"和"icons-proto.h"的樣子，不過"icons-proto.h"不會用到。&lt;/p&gt;
&lt;p&gt;在Netbeans中似乎無法呼叫外部程式，會顯示無法找到Perl指令的訊息。&lt;/p&gt;
&lt;p&gt;可是到CMD中執行時又會發生無法回應的情況，接著make就會因為找不到"icons.h"而無法編譯。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ld.exe does not find libraries&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在exposed資料的Makefile中，g++的參數中需要導入資料庫"-lslvs"。&lt;/p&gt;
&lt;p&gt;而在上一個步驟中，"libslvs.so"確定已經產生，但是找不到的狀況。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/67n3jzL.jpg" &gt;&lt;/p&gt;
&lt;p&gt;網路上普遍都是需要資料連結和打錯名稱，但是好像沒這種狀況，莫非是"libslvs.so"產生失敗，或是並非"slvs"這個名稱？&lt;/p&gt;
&lt;p&gt;Python-Solvespace的作者有特別指名不要使用DLL做副檔名。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這次學到了編譯程式重要的一環，雖然make的過程中很煩人，也要一直注意是否出錯，但是最後成功時滿有成就感的。&lt;/p&gt;
&lt;p&gt;有些錯誤當下想不出來，不過換一種想法後就能克服許多障礙，訓練眼光放遠也是一件重要的事情。&lt;/p&gt;</content><category term="Kmol"></category><category term="Solvespace"></category><category term="Python-Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/17</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050717.html" rel="alternate"></link><published>2016-07-17T20:37:00+08:00</published><updated>2016-07-17T20:37:00+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-17:/blog/40323218ri-zhi-1050717.html</id><summary type="html">&lt;p&gt;V-rep_solvespace_linkages&lt;/p&gt;
</summary><content type="html">&lt;p&gt;V-rep_solvespace_linkages&lt;/p&gt;


&lt;h2&gt;嘗試 vrep_solvespace_linkages&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/linkages.png" weight=600 &gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;影片教學：&lt;/h2&gt;
&lt;br&gt;
&lt;iframe src="https://player.vimeo.com/video/175117655" width="640" height="480" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt; &lt;p&gt;&lt;a href="https://vimeo.com/175117655"&gt;vrep_solvespace_linkages&lt;/a&gt; from &lt;a href="https://vimeo.com/user44943624"&gt;Li Steven&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;檔案：&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/g2_files/40323218/solvespace_successful.ttt?raw=true"&gt;solvespace_successful.ttt&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;br&gt;
&lt;h2&gt;心得：&lt;/h2&gt;
&lt;h3&gt;組裝這個物件的重點我認為是在零件的順序和Dummy放置的位置，嘗試了兩天終於作了出來，對零件的從屬關係有比較OK了，有學會dummy的應用，再來就是把這些統整可以試著弄我們的 printer。&lt;/h3&gt;&lt;/p&gt;</content><category term="Kmol"></category></entry><entry><title>40323230紀錄 - Makefile的建構</title><link href="http://project.mde.tw/blog/40323230ji-lu-makefilede-jian-gou.html" rel="alternate"></link><published>2016-07-16T19:00:00+08:00</published><updated>2016-07-16T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-16:/blog/40323230ji-lu-makefilede-jian-gou.html</id><summary type="html">&lt;p&gt;閱讀GNU-Make相關的知識。&lt;/p&gt;
&lt;p&gt;嘗試了解Python-Solvespace的Makefile運作方式。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;閱讀GNU-Make相關的知識。&lt;/p&gt;
&lt;p&gt;嘗試了解Python-Solvespace的Makefile運作方式。&lt;/p&gt;


&lt;h2&gt;Makefile簡介 :&lt;/h2&gt;

&lt;p&gt;閱讀資料來源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://mropengate.blogspot.tw/2015/06/makefile-makefile.html" title="mropengate.blogspot.tw"&gt;http://mropengate.blogspot.tw/2015/06/makefile-makefile.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://jeff71321.pixnet.net/blog/post/92143030-makefile%E6%95%99%E5%AD%B8(%E4%B8%80)" title="jeff71321.pixnet.net"&gt;http://jeff71321.pixnet.net/blog/post/92143030-makefile%E6%95%99%E5%AD%B8(%E4%B8%80)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GNU-Make在開發者工具包有著極其重要的地位，最大的好處就是「自動化編譯」。&lt;/p&gt;
&lt;p&gt;相較於要用shell來執行編譯的Script，GNU-Make可以只針對部分內容作測試，相當有自由度。&lt;/p&gt;
&lt;p&gt;make.exe依靠著Makefile的設定來將整個專案按照原作者的設定，編譯成可執行文件或是連結庫。&lt;/p&gt;
&lt;p&gt;也因為如此，只要是願意加入專案協同的工程師，裝好原作者使用的工具，無論使用哪個編譯程式，就能利用一個make命令，從頭到尾將專案編譯好進行測試或除錯。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;注意事項 :&lt;/h2&gt;

&lt;p&gt;GNU-Make在閱讀一份Makefile時有幾個重點。&lt;/p&gt;
&lt;p&gt;首先若直接執行make指令，會尋找當前目錄中叫"Makefile"或"makefile"的文件。若Makefile並非這兩個名稱（亦能自訂附檔名），可以加上"-f"參數指定Makefile的名稱。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Makefile中包含了&lt;/em&gt;：&lt;/p&gt;
&lt;p&gt;1.&lt;em&gt;顯式規則&lt;/em&gt;：說明如何生成一個或多個文件，有使用工具、依賴文件、使用參數等等。&lt;/p&gt;
&lt;p&gt;2.&lt;em&gt;隱晦規則&lt;/em&gt;：不太瞭解這個功能，大約是利用自動推導原則，可以比較簡略地寫定義，篩選檔案。&lt;/p&gt;
&lt;p&gt;3.&lt;em&gt;變量&lt;/em&gt;：自訂參數的功能，能自由更改位置或目標名稱、使用工具和參數等等。&lt;/p&gt;
&lt;p&gt;4.&lt;em&gt;文件指示&lt;/em&gt;：Makefile之間是可以互相溝通的，也可以透過情況作出判斷。&lt;/p&gt;
&lt;p&gt;5.&lt;em&gt;註解&lt;/em&gt;：Makefile的註解符號是"#"，如果要使用井字符號，必須使用反斜線"#"。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;特別注意，在Makefile中，命令項的起始一定要使用Tab縮排，不可使用空白字元。&lt;/p&gt;
&lt;p&gt;一般撰寫程式的編譯器都能檢視空白字元的類型。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SciTE&lt;/em&gt;：View -&amp;gt; Whitespace&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Netbeams&lt;/em&gt;：View -&amp;gt; Show Non-printable Characters&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_03.jpg"&gt;&lt;/p&gt;
&lt;p&gt;在此會發現Tab（→）和空白字元（.）的差異。&lt;/p&gt;
&lt;p&gt;不過某些像是SciTE的編譯器，在按下Tab鍵時，會幫使用者轉換成四個空白字元，甚至會用空白字元補齊縮排，所以使用上需要注意。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_04.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_05.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Makefile中的目錄分隔號是斜線"/"，換行閱讀符號是反斜線"\"。&lt;/p&gt;
&lt;p&gt;GNU-Make在執行途中遇到錯誤就會停止並跳出，所以必須要整個Makefile和編譯過程都沒有干擾執行問題，才會編譯完畢。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;主要規則 :&lt;/h2&gt;

&lt;p&gt;語法的結構就是目標文件（未生成）後方加上冒號和空格，接著同一行中必須接上會利用到的檔案名稱（不包含工具和include參數的項目）。&lt;/p&gt;
&lt;p&gt;第二行是寫下如何產生目標文件的命令。&lt;/p&gt;
&lt;p&gt;一個項目中有多個檔案時會用一個空白字元分隔。換行時如果想縮排以便閱讀，必須使用空白字元縮排，不然Tab起始的項目都會視為命令。&lt;/p&gt;
&lt;p&gt;而如果命令不能執行時就會中斷操作。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_06.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Makefile中的參數定義和大部分的語言雷同。不過為了明顯標示，大部分使用者習慣大寫字母。&lt;/p&gt;
&lt;p&gt;定義項目後，使用"＄( )"符號括住來使用變數。變數可以是目錄位置、命令名稱、參數名稱，亦有如"＄＄(basename ＄＄(notdir ＄＄@))"內定的用法。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_07.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編譯結果 :&lt;/h2&gt;

&lt;p&gt;途中用Netbeams作輔助檢查檔案關聯性和編寫文件，並make專案。&lt;/p&gt;
&lt;p&gt;不過用cmd下指令也是可行。只是直接打make會用到MinGW的make，必須先指定MSYS的make。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_08.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Python-Solvespace中的Makefile編寫有一些小缺漏，是Tab和空白字元的問題，後來改正就沒問題了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_09.jpg"&gt;&lt;/p&gt;
&lt;p&gt;不過後來在Netbeams編譯外層"Solvespace"時出現了一些問題：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_10.jpg"&gt;&lt;/p&gt;
&lt;p&gt;檢查了一下，似乎中間的檔案"＄(SRFOBJS)"找不到？而"＄(SRFOBJS)"的檔案是從"srf\＄(@B).cpp"和"＄(HEADERS)"產生的。&lt;/p&gt;
&lt;p&gt;其中"srf\＄(@B).cpp"應該就是取下所有\srf資料夾的cpp檔案，配上標頭檔後生成obj檔。途中不知道什麼原因obj檔沒有產生，所以才會無法找到？&lt;/p&gt;
&lt;p&gt;但是只編譯exposed資料夾的Makefile時又有這個問題：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_11.jpg"&gt;&lt;/p&gt;
&lt;p&gt;上網檢查了一下這段的用途是編碼對應，可是語法照常來講應該沒錯才是。&lt;/p&gt;
&lt;p&gt;而且後面對應的檔案導入時都出錯，所以就停止了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0716_12.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Makefile和cmake的CMakelist.txt一樣都是工程師自己要創建的，所以又是一項工程，不過除了一些內定代號，其他都滿好理解的。&lt;/p&gt;
&lt;p&gt;找了一下Python-Solvespace相關的網站，但是內容都好少。不過在Github的說明已經滿詳盡了，只是倉儲內的資料時間有點久遠，所以要花些時間偵錯。&lt;/p&gt;</content><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category><category term="Python-Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/15</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050715.html" rel="alternate"></link><published>2016-07-15T20:37:00+08:00</published><updated>2016-07-15T20:37:00+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-15:/blog/40323218ri-zhi-1050715.html</id><summary type="html">&lt;p&gt;V-rep 程式應用&lt;/p&gt;
</summary><content type="html">&lt;p&gt;V-rep 程式應用&lt;/p&gt;


&lt;h2&gt;從 irb360 程式中找尋可能用到的並嘗試解釋和整理。 &lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;h3&gt;
simGetObjectHandle - 對物件命名&lt;br&gt;
&lt;br&gt;
用法： number objectHandle=simGetObjectHandle(string objectName)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSetJointTargetPosition - 設置目標位置(if the joint is in torque/force mode)(motor and position control are enabled)&lt;br&gt;
&lt;br&gt;
用法： number result=simSetJointTargetPosition(number objectHandle,number targetPosition)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simGetJointPosition - 得到軸的位置(不能使用在關節上 , 用simGetJointMatrix取代)&lt;br&gt;
&lt;br&gt;
用法： number position=simGetJointPosition(number objectHandle)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSwitchThread - 轉換到另一個程式&lt;br&gt;
&lt;br&gt;
用法： number result=simSwitchThread()&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simAddStatusbarMessage - 增加一則訊息到狀態欄&lt;br&gt;
&lt;br&gt;
用法： number result=simAddStatusbarMessage(string message)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSetIkElementProperties - 設置性質的特定反向運動元素&lt;br&gt;
&lt;br&gt;
用法：  number result=simSetIkElementProperties(number ikGroupHandle,number tipDummyHandle,number constraints,table_2 precision=nil,table_2 weight=nil&lt;br&gt;
&lt;br&gt;
補充：  IK = Inverse kinematics(在左邊功能區第三個裡)&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simSetJointMode - 設置joint的操作模式&lt;br&gt;
&lt;br&gt;
用法：  number result=simSetJointMode(number jointHandle,number jointMode,number options)&lt;br&gt;
&lt;br&gt;
補充：  option(現在設定為0是可以被使用，如果設定為1會啟用hybrid mode)&lt;br&gt;
&lt;br&gt;
jointMode&lt;br&gt; 
sim_jointmode_passive&lt;br&gt;
sim_jointmode_motion_deprecated&lt;br&gt;
sim_jointmode_ik&lt;br&gt;
sim_jointmode_ikdependent&lt;br&gt;
sim_jointmode_dependent&lt;br&gt;
sim_jointmode_force&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simGetObjectAssociatedWithScript - 擷取角本附加到物體處理&lt;br&gt;
&lt;br&gt;
用法：  number objectHandle=simGetObjectAssociatedWithScript (number scriptHandle)&lt;br&gt;
&lt;br&gt;
補充：  scriptHandle = sim_handle_self&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
simRMLMoveToJointPositions - 在同一時間幾個關節一起使用Reflexxes Motion Library type IV移動（驅動）。這功能只能在child scripts中一個thread中運行（因為這是一個阻塞的操作），而且C-API的不可使用。&lt;br&gt;
&lt;br&gt;
用法：number result , table newPos , table newVel , table newAccel , number timeLeft =
simRMLMoveToJointPositions ( table jointHandles , number flags , table currentVel , table currentAccel , table maxVel , table maxAccel , table maxJerk , table targetPos , table targetVel , table direction)&lt;br&gt;
&lt;br&gt;
補充：&lt;br&gt; 
jointHandles: 要驅動的joint&lt;br&gt;
flags: RML flags. -1 for default flags.&lt;br&gt;
currentVel: the current velocity of the joints. Can be nil in which case a velocity vector of 0 is used.&lt;br&gt;
currentAccel: the current acceleration of the joints. Can be nil in which case an acceleration vector of 0 is used.&lt;br&gt;
maxVel: the maximum allowed velocity of the joints&lt;br&gt;
maxAccel: the maximum allowed acceleration of the joints&lt;br&gt;
maxJerk: the maximum allowed jerk of the joints&lt;br&gt;
targetPos: the desired target positions of the joints&lt;br&gt;
targetVel: the desired velocity of the joints at the target. Can be nil in which case a velocity vector of 0 is used.&lt;br&gt;
direction: the desired rotation direction for cyclic revolute joints: 0 for the shortest distance, -x for a movement towards negative values, +x for a movement towards positive values (n=(x-1) represents the number of additional turns). Can be nil or omitted, in which case a value of 0 is used for all joints&lt;br&gt;
&lt;br&gt;
&lt;br&gt;&lt;/p&gt;
&lt;p&gt;(待補充)&lt;/p&gt;</content><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/15</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050715.html" rel="alternate"></link><published>2016-07-15T19:00:00+08:00</published><updated>2016-07-15T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-15:/blog/40323230ri-zhi-1050715.html</id><summary type="html">&lt;p&gt;研究Python-Solvespace。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;研究Python-Solvespace。&lt;/p&gt;


&lt;h2&gt;更新Anaconda3 :&lt;/h2&gt;

&lt;p&gt;從官方網站下載最新的Anaconda 3，配有Python 3.5.2。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.continuum.io/downloads" title="continuum.io"&gt;https://www.continuum.io/downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Path指令檢查環境變數。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;確定無誤後放入可攜式環境中，並把原本的Python 3.5移除，將start.bat的環境位置改成Anaconda的資料夾。&lt;/p&gt;
&lt;p&gt;接著再檢查Anaconda程式的運作狀態。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;安裝了其他工具，也包含Leo 5.3。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_03.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;說明 :&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://github.com/BBBSnowball/python-solvespace" title="github.com"&gt;Python-Solvespace&lt;/a&gt;是由BBBSnowball所開發的Solvespace函式庫，另外能調用Solid-python來協助運算。&lt;/p&gt;
&lt;p&gt;Python-Solvespace最後一次更新是在2013年，所以使用的是Python 2，SWIG可能也是舊版的。&lt;/p&gt;
&lt;p&gt;而根據協同者們留下的"VbDemo.vb"紀錄，應該是用VC來編譯它的。&lt;/p&gt;
&lt;p&gt;若要使用Solid-python，必須用"git submodule update --init"指令額外下載它，不然只有空資料夾。&lt;/p&gt;
&lt;p&gt;不過目前沒有要使用Solid-python，所以可以不用下載。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_04.jpg"&gt;&lt;/p&gt;
&lt;p&gt;按照Readme的說明，要用make指令來編譯檔案。&lt;/p&gt;
&lt;p&gt;但是在make的時候出錯了，顯示"missing separator. Stop."的錯誤，查了下面的網站，貌似是make.exe的新版本讀取舊的Makefile的問題，必須改寫他們的Makefile或使用舊版的MSYS。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.crifan.com/error_missing_separator_stop_while_make_in_windows_cmd/" title="crifan.com"&gt;http://www.crifan.com/error_missing_separator_stop_while_make_in_windows_cmd/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而顯示的錯誤如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_05.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;與Whitequark的版本比較 :&lt;/h2&gt;

&lt;p&gt;不過Python-Solvespace有留下來interface的檔案，但是它的檔案結構已經跟Whitequark的版本不一樣了，所以也不能直接讓interface對應新版的檔案來創建。&lt;/p&gt;
&lt;p&gt;好消息是SWIG的interface檔案改變不大，新版仍能使用。只要切換到\exposed資料夾，使用下列指令就能生成"slvs_wrap.cxx"。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
swig -c++ -python -py3 slvs.i
&lt;/pre&gt;

&lt;p&gt;新版有用到cmake來建置檔案，但是Python-Solvespace沒有，所以沒有CMakelist的清單。而CMakelist是要手動編寫的，視規模大小來分配。&lt;/p&gt;
&lt;p&gt;Python-Solvespace似乎是只有原本Solvespace的"src"資料夾部分（不過外面原本就是給編譯器介紹用）。&lt;/p&gt;
&lt;p&gt;並將"exposed"、"extlib"、"win32"等資料夾放了進來，並且將總標頭檔"slvs.h"和DLL的"lib.cpp"加入"exposed"中，讓CDemo成為主幹，調用Solvespace裡的約束函式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_06.jpg"&gt;&lt;/p&gt;
&lt;p&gt;但是"exposed"中除了原本的CDemo，還有一個h++的標頭檔"slvs_python.hpp"、一個"DOC.txt"說明Python要如何呼叫編譯好的函式列表，以及一些Python的小程式。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;test.py :&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_07.jpg"&gt;&lt;/p&gt;
&lt;p&gt;py檔總共有3個，其中一個是使用Solid-python的呼叫工具，其他的"test.py"分別用"2.scad"和"3.scad"命名。&lt;/p&gt;
&lt;p&gt;檢查了一下Python-Solvespace附上的py檔，最後作者做了3個測試，並寫下了一些註解。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_08.jpg"&gt;&lt;/p&gt;
&lt;p&gt;第一個"test.py"，展示了Python要如何取用slvs.dll的函式，長得跟原先的"CDemo.c"十分相似。&lt;/p&gt;
&lt;p&gt;在這裡，可以注意到SWIG轉換後的函式名稱還是一樣，用法也極其相似。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_09.jpg"&gt;&lt;/p&gt;
&lt;p&gt;第二個"test2.scad.py"匯入了slvs和solid。&lt;/p&gt;
&lt;p&gt;由於Python只要在附近資料中尋找到宣告的項目就可運作，所以不太確定它們的副檔名究竟是DLL還是SO、PYD之類的連結庫或Python程式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_10.jpg"&gt;&lt;/p&gt;
&lt;p&gt;第三個"test3.scad.py"明顯使用了"slvs_solid.py"的內容，不過只有稍微閱讀過Solid-python的Readme，所以不太知道它的函式，但是看似比Solvespace更方便。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0715_11.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這次在Python-Solvespace碰上一些小瓶頸。&lt;/p&gt;
&lt;p&gt;主要是MSYS的Makefile問題，論壇上滿多人討論它在編譯時的障礙，有時連參數前加個空格都會顯示錯誤，無法進行。&lt;/p&gt;
&lt;p&gt;而Python-Solvespace應該是用不到cmake（因為原作者是用VC），如果需要用到Netbeams，就要自行撰寫一份CMakelist，或是在編譯器中捨棄它的功能。&lt;/p&gt;
&lt;p&gt;至於需要Python 2轉Python 3的部分比較少，除非要動用Solid-python的內容。&lt;/p&gt;</content><category term="Kmol"></category><category term="SWIG"></category><category term="Solvespace"></category></entry><entry><title>40323231日誌 - 105/07/14</title><link href="http://project.mde.tw/blog/40323231ri-zhi-1050714.html" rel="alternate"></link><published>2016-07-14T21:00:00+08:00</published><updated>2016-07-14T21:00:00+08:00</updated><author><name>40323231</name></author><id>tag:project.mde.tw,2016-07-14:/blog/40323231ri-zhi-1050714.html</id><summary type="html">&lt;p&gt;3DP碰到的問題及解決&lt;/p&gt;
</summary><content type="html">&lt;p&gt;3DP碰到的問題及解決&lt;/p&gt;


&lt;h3&gt;第一次組裝3D列印機，所以各個零件和電子元件的功用都不知道，所以只能從型號去著手，知道並了解運用。&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;在研究電子板的時候發現，熱床是時麼?而且我手邊怎麼沒有熱床?&lt;/h3&gt;
&lt;h3&gt;解決:我們有熱床，只是我們的跟網路上和現有的3DP不一樣。它的功用是防止成品翹邊，由於料出來是熱的，經過板子和空氣冷卻導致成品收縮，所以熱床需給予溫度，減輕翹邊，可是不能完全避免，而且會因材料不同，需要的溫度也不同(我們的材料PLA大約60度，)。電壓不能輕易更改或太高，因為電壓高一倍，功率大四倍，所以一開始要確定給定的電壓。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;在接限位開關線路的時候發現，在夢工廠老師接的線路和網路上的不一樣，三條線路分別為"+""-""S"顏色分別為"紅""藍""黑"，夢工老師接的是"+"接紅，"-"接藍，"S"接黑。網路是"+"接紅，"-"接黑，"S"接藍。而且3個限位開關的線路有的接3條，有的接2條，很混亂，沒有頭緒。&lt;/h3&gt;
&lt;h3&gt;問題:1. "+""-""S"如何接?  2.為何線路有的接兩條有的接三條?&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;限位開關分兩種:&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;1. 機械微動開關接法&lt;/h3&gt;
&lt;h4&gt;機械微動開關只需接2個腳位的：單純使用微動開關當作限位器，那一定要接RAMPS上的 "S" 跟 "-" 腳位。絕對不要把3個腳位都接了，如果不小心接了3個腳位，那在觸發時會發生火花，會把5V穩壓 IC燒毀。&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;2. 光學限位開關接法(我們的)&lt;/h3&gt;
&lt;h4&gt;光學限位開關則是需要用到3條線，接到RAMPS上的"S"、"-"及"+" 3個腳位。&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;1.S為藍，+為紅，-為黑&lt;/h3&gt;
&lt;h3&gt;2.常開型和常關型只有微動開關才有，所以光學開關一定要3調都接&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;今天進度&lt;/h3&gt;
&lt;h4&gt;組裝 3DP，將缺少的材料抄寫下來，將跟工廠管理員詢問，使用VREP，看組員的所寫的網誌並實際操作&lt;/h4&gt;&lt;/p&gt;</content><category term="3DP"></category></entry><entry><title>40323218日誌 - 105/07/14</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050714.html" rel="alternate"></link><published>2016-07-14T20:37:00+08:00</published><updated>2016-07-14T20:37:00+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-14:/blog/40323218ri-zhi-1050714.html</id><summary type="html">&lt;p&gt;V-rep&lt;/p&gt;
</summary><content type="html">&lt;p&gt;V-rep&lt;/p&gt;


&lt;h2&gt;翻譯文章重點&lt;/h2&gt;

&lt;p&gt;&lt;br&gt;
&lt;h2&gt;原文章網址：&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm "&gt;http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm &lt;/a&gt;&lt;/p&gt; 
&lt;br&gt;
&lt;h2&gt;Building the visible shapes：&lt;/h2&gt;
&lt;br&gt;
&lt;h3&gt;1. Automatic mesh division：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Grouping/Merging --&amp;gt; Divide selected shapes]&lt;br&gt;
(自動分割物件，有時候會無作用)&lt;br&gt;
[Menu bar --&amp;gt; Edit -&amp;gt; Grouping/Merging --&amp;gt; Merge selected shapes]&lt;br&gt;(使選擇的物件組合在一起)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;2. Extract the convex hull：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Morph selection into convex shapes]&lt;br&gt;
(使物件轉換成convex hull)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;3. Decimate the mesh：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Decimate selected shape...]&lt;br&gt;
(減少mesh三角形量)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;4. Remove the inside of the mesh：&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Extract inside of selected shape]&lt;br&gt;
(此功能是基於視覺傳感器，可以依靠設定得到更多或更少滿意的結果。)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;上述功能沒有先後順序(除了第一項應該先嘗試)，主要取決於我們如何嘗試精簡mesh。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;下圖說明上述功能應用到imported mesh（沒有第一項）：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep1.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;再來我們要分割imported mesh，有兩種方式可使用。&lt;br&gt;&lt;br&gt;
1. Automatic mesh division：跟上面一樣
&lt;br&gt;
2. Manual mesh division：這使用 triangle edit mode (左邊功能列第六個)，選擇你要的物體的三角形，再點 Extract shape，他會投影物件出來，再把原先選擇的三角形刪除。&lt;/h3&gt;
&lt;br&gt;
&lt;h2&gt;Building the joints&lt;/h2&gt;&lt;br&gt;
&lt;h3&gt;再來我們要創建 joint，先 import mesh，使用 triangle edit mode 使物件三角形化。&lt;/h3&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep2.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;我們需要使 joint 在圓心中間，所以我們點選圓形的三角形，點選 Extract cylinder 或 Extract shape ，他會在選擇的三角形上投影一個圓形出來。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt; 右鍵→Add→Joint→Revolute(創建一個Revolute joint)，
再來我們點Revolute joint、Ctrl點投影的圓型，點 Position/Translation 按鈕，然後在 Object/item position section裡，我們點 Apply to selection (使兩物體位置相同)。再來我們點Orientation/Rotation 按鈕，然後在Object/item orientation section裡，我們點 Apply to selection(使兩物體坐標軸相同)。&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep3.png" weight=600 &gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/vrep4.png" weight=600 &gt;
&lt;br&gt;
&lt;h2&gt;Building the dynamic shapes&lt;/h2&gt;
&lt;br&gt;
&lt;h3&gt;如果我們想要使 Robot 作動，那麼我們就需要適當地創建/配置形狀。形狀可以是：&lt;br&gt;&lt;br&gt;
1. dynamic or static：&lt;br&gt;
dynamic 是動態，如果這個形狀是動態的，它將會有重量會往下掉，也會對力/力矩造成影響。&lt;br&gt;
static是靜態，他跟 dynamic 相反，他會固定在位置上或隨著
運動移動。&lt;br&gt;&lt;br&gt;
2. respondable or non-respondable：&lt;br&gt;
respondable shape 是會跟其他的 respondable shape 造成碰撞效應，他們或其對撞機，將會影響其運動(如果它們是動態的) 。&lt;br&gt;non-respondable shapes 是相反，他們不會造成碰撞運動。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;respondable shape應盡可能簡單，以允許快速和穩定的模擬。一個物理引擎將能夠模擬以下5種不同程度的速度和穩定的形狀：&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;1. Pure shapes：&lt;br&gt;
 [Menu bar --&amp;gt; Add --&amp;gt; Primitive shape]&lt;br&gt;
一個Pure shapes是穩定的，並由物理引擎非常有效地處理。Pure shapes在幾何限制：大部分長方體，圓柱體或球體。&lt;br&gt;
&lt;br&gt;
2. Pure compound shapes：&lt;br&gt;
 [Menu bar --&amp;gt; Edit --&amp;gt; Grouping/Merging --&amp;gt; Group selected shapes]&lt;br&gt;
它是由多個Pure shape組合而成的，功能跟Pure shape雷同。
&lt;br&gt;
&lt;br&gt;
3. Convex shapes：&lt;br&gt;
[Menu bar --&amp;gt; Add --&amp;gt; Convex hull of selection] &lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Morph selection into convex shapes]&lt;br&gt;
Convex shapes會有點不太穩定，當物理引擎處理時需要多一點點計算時間。它允許一個比純形狀更一般的幾何形狀（唯一的要求：它必須是 convex）。
&lt;br&gt;
&lt;br&gt;
4. Compound convex shapes, or convex decomposed shapes&lt;br&gt;
 [Menu bar --&amp;gt; Edit --&amp;gt; Grouping/Merging --&amp;gt; Group selected shapes]&lt;br&gt;
[Menu bar --&amp;gt; Add --&amp;gt; Convex decomposition of selection...]&lt;br&gt;
[Menu bar --&amp;gt; Edit --&amp;gt; Morph selection into its convex decomposition...]&lt;br&gt;
它是由多個convex shapes組合而成的，功能跟convex shapes雷同。
&lt;br&gt;
&lt;br&gt;
5. Random shapes：&lt;br&gt;
一個Random shapes是一個形狀不是convex也不是pure。它一般具有性能差（計算速度和穩定性）。盡可能地避免使用隨機的形狀。&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;因此，優先順序是：pure shapes → pure compound shapes → convex shapes → compound convex shapes → random shapes。&lt;/h3&gt;&lt;br&gt;&lt;/p&gt;</content><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/14</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050714.html" rel="alternate"></link><published>2016-07-14T19:00:00+08:00</published><updated>2016-07-14T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-14:/blog/40323230ri-zhi-1050714.html</id><summary type="html">&lt;p&gt;試圖解決SWIG問題&lt;/p&gt;
</summary><content type="html">&lt;p&gt;試圖解決SWIG問題&lt;/p&gt;


&lt;h2&gt;撰寫批次檔 :&lt;/h2&gt;

&lt;p&gt;依照&lt;a href="http://www.ittc.ku.edu/kusp/kusp_docs/kusp_swig_guide/index.html" title="ittc.ku.edu"&gt;http://www.ittc.ku.edu/kusp/kusp_docs/kusp_swig_guide/index.html&lt;/a&gt;提供的gcc指令，撰寫了3個批次檔來執行。&lt;/p&gt;
&lt;p&gt;第一個命名為interface.bat，用來讓swig生成"_wrap.c"檔，並建立"build"和"dist"兩個資料夾。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
@echo off
set interface_name=example

echo 編譯接口
swig -python -py3 %interface_name%.i
echo 編譯完成
pause

REM MKDIR
echo 正在建立目錄
MKDIR "build"
MKDIR "dist"
echo 目錄已建立
pause
&lt;/pre&gt;

&lt;p&gt;第二個是pyd.bat，主要是下gcc的編譯指令並執行runme.py，不過不知道修改後正不正確。&lt;/p&gt;
&lt;p&gt;原理是將example.c和它的_wrap.c參照W:/Python35/include的內容變成".o"檔，再將它們參照W:/Python35/libs/libpython35.a編譯成".pyd"檔。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
@echo off
set target_name=example
set module_name=example

echo 正在建立暫存檔
gcc -c -g %target_name%.c %target_name%_wrap.c -IW:/Python35/include
move %target_name%.o build\%target_name%.o
move %target_name%_wrap.o build\%target_name%_wrap.o
echo 暫存檔建立
pause

echo 正在建立PYD
gcc -shared build/%target_name%.o build/%target_name%_wrap.o W:/Python35/libs/libpython35.a -o dist/%module_name%.pyd
echo PYD建立

copy /Y runme.py dist\runme.py

python dist\runme.py

pause
&lt;/pre&gt;

&lt;p&gt;第三個式失敗後重來的清除工具，刪掉前面建立的檔案和成果檔。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
@echo off
set target_name=example

echo RMDIR...
RMDIR /S /Q .\build
RMDIR /S /Q .\dist

echo DEL...
del /F /S /Q %target_name%_wrap.c
del /F /S /Q %target_name%.py

pause
&lt;/pre&gt;

&lt;p&gt;檔案如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0714_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;將interface.bat和pyd.bat分開的原因是為了檢察途中example.i和example_wrap.c是否出了問題。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;執行測試 :&lt;/h2&gt;

&lt;p&gt;之前的example.c和example.i內容並沒有更動。&lt;/p&gt;
&lt;p&gt;第一次執行後，發現會出現以下錯誤：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0714_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;然後就發現example_wrap.c中的這句錯誤了，多了一個底線符號，刪除後就能導入了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0714_03.jpg"&gt;&lt;/p&gt;
&lt;p&gt;這個錯誤經過搜索後是SWIG本身的問題，要解決的話必須重新編譯原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0714_04.jpg"&gt;&lt;/p&gt;
&lt;p&gt;但是這個舉動實在是太耗費時間了，所以後來放棄了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0714_05.jpg"&gt;&lt;/p&gt;
&lt;p&gt;不過更改那行後，runme.py就可以導入example.pyd，不過卻會出現TypeError，如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0714_06.jpg"&gt;&lt;/p&gt;
&lt;p&gt;估計是這裡有錯誤：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0714_07.jpg"&gt;&lt;/p&gt;
&lt;p&gt;不過不知道怎麼調整。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;SWIG在自身的編譯上有點小錯誤，但是有些地方因為不了解Python的模組，所以不知道要怎麼修改。&lt;/p&gt;
&lt;p&gt;另外有些不知道C語言的格式轉換是怎麼套用到Python的，所以在Python.h的函式不知該怎麼用。&lt;/p&gt;</content><category term="Kmol"></category><category term="SWIG"></category></entry><entry><title>40323230日誌 - 105/07/13</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050713.html" rel="alternate"></link><published>2016-07-13T19:00:00+08:00</published><updated>2016-07-13T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-13:/blog/40323230ri-zhi-1050713.html</id><summary type="html">&lt;p&gt;Python 3.5.2軟體更新&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Python 3.5.2軟體更新&lt;/p&gt;


&lt;h2&gt;軟體更新目標 :&lt;/h2&gt;

&lt;p&gt;之前W:沒安裝Python和Leo，所以暫時把Y:的複製過來用。&lt;/p&gt;
&lt;p&gt;以W:為主，Y:用來撰寫網誌暫不需要更新。&lt;/p&gt;
&lt;p&gt;1.Python 3.5及之前安裝的套件。&lt;/p&gt;
&lt;p&gt;2.Leo 5.3正式版。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;Python及套件更新步驟 :&lt;/h2&gt;

&lt;p&gt;將W:槽的Python 3.4.4 RC1更新至最新的3.5.2。&lt;/p&gt;
&lt;p&gt;Python 3.5.2下載處：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.python.org/downloads/" title="python.org"&gt;https://www.python.org/downloads/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刪除Python34資料的所有內容後，將安裝完的Python35放進W:內，並將start.bat內的Python34位置全數改成Python35。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0713_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;在Y:槽中執行以下指令以取得舊有的軟體資訊，存成名為rq.txt的清單。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
pip freeze &gt; rq.txt
&lt;/pre&gt;

&lt;p&gt;清單中列的就是Python 3.4安裝的套件版本。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0713_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;進入Python 3.5後使用pip指令時出現類似"Fatal error in launcher"的訊息，原因是官方的pip版本較舊。&lt;/p&gt;
&lt;p&gt;如果不更新，只能用"python -m pip"的方式驅動它，所以先命令它為自己升級。&lt;/p&gt;
&lt;pre&gt;
python -m pip install pip --upgrade
&lt;/pre&gt;

&lt;p&gt;然後再利用Y:槽傳來的清單安裝，不過之前的Leo 5.1沒有在pip的下載網站裡，5.3版也要從Leo的官方下載，所以暫時先把leo剔除。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0713_03.jpg"&gt;&lt;/p&gt;
&lt;p&gt;接著利用下列指令更新：&lt;/p&gt;
&lt;pre&gt;
pip install -r rq.txt
&lt;/pre&gt;

&lt;p&gt;就會裝回所有的套件了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0713_04.jpg"&gt;&lt;/p&gt;
&lt;p&gt;使用下列指令可以查看已安裝的套件。&lt;/p&gt;
&lt;p&gt;而只要在安裝時加入--upgrade參數就能更新，不過目前沒有全部更新的指令。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
//已安裝套件
pip freeze
//過期套件
pip list --outdated
&lt;/pre&gt;

&lt;hr&gt;

&lt;h2&gt;Leo更新步驟 :&lt;/h2&gt;

&lt;p&gt;至於安裝Leo，到&lt;a href="http://sourceforge.net/projects/leo/files/Leo/" title="sourceforge.net"&gt;http://sourceforge.net/projects/leo/files/Leo/&lt;/a&gt;下載5.3的安裝檔，並暫時解壓縮到根目錄。&lt;/p&gt;
&lt;p&gt;接著進入\Leo-5.3-final\leo\dist資料夾，執行下面指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
python setup.py install
&lt;/pre&gt;

&lt;p&gt;安裝完後，接著就能把解壓縮的檔案刪除了。&lt;/p&gt;
&lt;p&gt;不過在pip的紀錄中還是5.0 Bata2的樣子。&lt;/p&gt;
&lt;p&gt;新版的Leo介面（設定檔複製之前的）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0713_05.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;上次的swig還是沒成功，"_wrap.c"中似乎還要加一些python3的判斷式。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://python3porting.com/cextensions.html#module-initialization" title="python3porting.com"&gt;http://python3porting.com/cextensions.html#module-initialization&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這裡的作者描述還是有點看不懂，雖然下了-py3的指令，但是設定還是沒調。&lt;/p&gt;</content><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/12</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050712.html" rel="alternate"></link><published>2016-07-12T19:00:00+08:00</published><updated>2016-07-12T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-12:/blog/40323230ri-zhi-1050712.html</id><summary type="html">&lt;p&gt;瞭解SWIG的用法。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;瞭解SWIG的用法。&lt;/p&gt;


&lt;h2&gt;軟體修正 :&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;NetBeans&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;為NetBeans安裝python的附加元件，使其可以編譯python文件。&lt;/p&gt;
&lt;p&gt;這些附加元件還包含了jython2.7.0。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0712_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SWIG&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上次載的版本沒有Windows使用的可執行檔，需要從原始code編譯太麻煩了，所以從以下網址下載了Windows使用的版本。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://sourceforge.net/projects/swig/files/swigwin/" title="sourceforge.net"&gt;https://sourceforge.net/projects/swig/files/swigwin/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解壓縮後就有可執行檔了，再把它的所在目錄加入start.bat的環境參數中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0712_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;接著就能用它下參數了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0712_03.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;SWIG簡介 :&lt;/h2&gt;

&lt;p&gt;SWIG的功能就是利用自己的Interface檔案".i"，產生出一個"_wrap.c"檔，如果DLL專案一起將這個".c"編譯的話，就可以讓其他高階語言呼叫了。&lt;/p&gt;
&lt;p&gt;SWIG內有個\Examples資料夾，裡面有所有支援語言的轉換函式，參照它們的格式來撰寫自己的Interface，放在專案中。&lt;/p&gt;
&lt;p&gt;諸如：D語言、java、javascript、lua、php、python、ruby。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0712_04.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;練習應用 :&lt;/h2&gt;

&lt;p&gt;參考範例：&lt;/p&gt;
&lt;p&gt;/Examples/python/simple/index.html&lt;/p&gt;
&lt;p&gt;先寫一個".c"程式碼。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
/* File : example.c */

/* A global variable */
double Foo = 3.0;

/* Compute the greatest common divisor of positive integers */
int gcd(int x, int y) {
  int g;
  g = y;
  while (x &gt; 0) {
    g = x;
    x = y % x;
    y = g;
  }
  return g;
}
&lt;/pre&gt;

&lt;p&gt;然後再寫一個Interface的".i"文件。&lt;/p&gt;
&lt;p&gt;至於格式可能要參考手冊的其他內容。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
/* File: example.i */
%module example

extern int gcd(int x, int y);
extern double Foo;
&lt;/pre&gt;

&lt;p&gt;然後用cmd到/Examples/python/simple中下指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
swig -python example.i
&lt;/pre&gt;

&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0712_05.jpg"&gt;&lt;/p&gt;
&lt;p&gt;然後simple資料夾中就會產生example_wrap.c與example_wrap.py檔，再拿進編譯器Build。&lt;/p&gt;
&lt;p&gt;但是Netbeans卻無法編譯檔案，照常來說最新的SWIG已經支援到Python 3.5，還是說有參數需要調整。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0712_06.jpg"&gt;&lt;/p&gt;
&lt;p&gt;而且在動態連結庫的專案中，不知道怎麼調Build的參數成為pyd檔。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;SWIG的操作大致知道了，但是仍有些許不瞭解的地方。&lt;/p&gt;
&lt;p&gt;像是Interface的檔案撰寫，有將網路上一些範例存起來，但是下swig的指令時就出現".i"文件格式錯誤的訊息。&lt;/p&gt;
&lt;p&gt;而在Netbeans裡要如何設定gcc編譯成pyd呢？在CMD裡下了跟2015cp.leo按鈕一樣的參數，可是好像都會出現上面Build的錯誤。&lt;/p&gt;
&lt;p&gt;另外，按照SWIG的邏輯，萬一使用者的Python版本比它還低，它會修改編譯語法嗎？覺得在編譯時的錯誤可能是3.4到3.5之間的衝突。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;今天上網找資料的時候，發現了ctype，可以讓python直接讀取DLL的文件，好像是SWIG之後的產物，只是Python本身必須加裝模組。&lt;/p&gt;</content><category term="Kmol"></category><category term="SWIG"></category></entry><entry><title>40323218日誌 - 105/07/11</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050711.html" rel="alternate"></link><published>2016-07-11T20:37:00+08:00</published><updated>2016-07-11T20:37:00+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-11:/blog/40323218ri-zhi-1050711.html</id><summary type="html">&lt;p&gt;V-rep&lt;/p&gt;
</summary><content type="html">&lt;p&gt;V-rep&lt;/p&gt;


&lt;h4&gt;嘗試四連桿機構&lt;/h4&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h1&gt;&lt;h3&gt;理想狀態：&lt;/h3&gt;&lt;/h1&gt;
&lt;h1&gt;&lt;br&gt;&lt;/h1&gt;
&lt;h3&gt;前期嘗試：&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/before.gif" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;前期階級排列：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step10.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;查詢資料：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step11.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;(在兩個dynamic item之間不能有static item)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;修改後：&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step12.png" weight=600 &gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/after.gif" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;未來嘗試：製作搖擺機構&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;參考網站：http://www.coppeliarobotics.com/helpFiles/en/jointDescription.htm &lt;/h3&gt;&lt;/p&gt;</content><category term="Kmol"></category></entry><entry><title>40323230練習 - 105/07/11</title><link href="http://project.mde.tw/blog/40323230lian-xi-1050711.html" rel="alternate"></link><published>2016-07-11T19:00:00+08:00</published><updated>2016-07-11T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-11:/blog/40323230lian-xi-1050711.html</id><summary type="html">&lt;p&gt;使用2015cp範本練習".py"呼叫".pyd"。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;使用2015cp範本練習".py"呼叫".pyd"。&lt;/p&gt;


&lt;h2&gt;編譯出Python的動態連結庫 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="https://github.com/coursemdetw/2015cp" title="coursemdetw/2015cp"&gt;https://github.com/coursemdetw/2015cp&lt;/a&gt;下載老師的範本練習。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0710_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;C程式的部分分成pymod和pyfun。&lt;/p&gt;
&lt;p&gt;這兩組底下都有3個Node，分別是編譯Python動態連結庫用的button、呼叫用的Python程式和一個C++編成的函式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0710_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;button裡的內容如下：&lt;/p&gt;
&lt;pre class="brush: python"&gt;
...
# compile
os.system("Z:/C/MinGW/bin/gcc.exe -c -g -IV:/IDE/Python33/include  -MMD -MP -MF build/"+target_name+".o.d -o build/"+target_name+".o "+filename)
# link 因為 .c 程式中起始為 PyInit_sum, 因此
os.system("Z:/C/MinGW/bin/gcc.exe -shared -o dist/"+module_name+".pyd build/"+target_name+".o V:/IDE/Python33/libs/libpython33.a")
g.es("done")
&lt;/pre&gt;

&lt;p&gt;在執行時顯然對應不到W:槽的MinGW和Python34，所以必須改一下它的指令。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
...
# compile
os.system("gcc -c -g -IW:/Python34/include  -MMD -MP -MF build/"+target_name+".o.d -o build/"+target_name+".o "+filename)
# link 因為 .c 程式中起始為 PyInit_sum, 因此
os.system("gcc -shared -o dist/"+module_name+".pyd build/"+target_name+".o W:/Python34/libs/python34.lib")
g.es("pymod done")
&lt;/pre&gt;

&lt;p&gt;而另一邊的pyfun同理。&lt;/p&gt;
&lt;p&gt;接著就能在\dist資料夾中編譯出sum.pyd和pyfun.pyd了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0710_03.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;使用mypy.py :&lt;/h2&gt;

&lt;p&gt;接著回到@edit programs/dist/mypy.py和mypy2.py的兩個Node，只要在.leo中存檔就能建立和編輯它們。&lt;/p&gt;
&lt;p&gt;mypy.py中導入sum，並使用它裡面的函式sum()。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print(sum.sum(1, 30))
&lt;/pre&gt;

&lt;p&gt;在sum.pyd中，函式sum()是sum2()在sum.pyd中被定義的外部名稱，由以下可知。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
// 定義內部運算的函式內容
int sum2(int a, int b)
{
    return a+b;
}

// sum 函式的 interface
static PyObject* mod_sum(PyObject *self, PyObject *args)
{
    int a;
    int b;
    int s;
    // ii 表示兩個輸入變數都是整數
    if (!PyArg_ParseTuple(args,"ii",&amp;a,&amp;b))
       return NULL;
    // 這裡的 sum2 則是內部的函式定義, 與外部呼叫模組或函式名稱沒有直接關係
    s = sum2(a,b);
    // i 表示 s 為整數
    return Py_BuildValue("i",s);
}

// 這裡的 sum 是外部模組的呼叫名稱, 而 mod_sum 則是內部的呼叫名稱 (即 interface function)
// Mod_Methods 為函式 (方法) 結構定義
static struct PyMethodDef Mod_Methods[] = {
    {"sum", mod_sum, METH_VARARGS, "Description.."},
    {NULL,NULL,0,NULL}
};
&lt;/pre&gt;

&lt;p&gt;sum2()函式回傳的是兩個輸入值（pyd內部名為a和b），所以mypy.py收到後會顯示在畫面上。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0710_04.jpg"&gt;&lt;/p&gt;
&lt;p&gt;另一邊的mypy2.py是使用pyfun.pyd，不過有兩個檔案太麻煩了，乾脆讓mypy.py導入兩個pyd就好了。&lt;/p&gt;
&lt;p&gt;這次是加入一段字串。&lt;/p&gt;
&lt;pre class="brush: python"&gt;
print(pyfun.pyfun("我的字串"))
&lt;/pre&gt;

&lt;p&gt;在pyfun.pyd中，pyfun()的外部名稱和它同名，在它的函式中，建立了一個指標to_who，偵測使用動態連結庫的對象，並把輸入進來的字串傳回。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
pyfun(PyObject *self,PyObject *args)
{
    const char *to_who;
    if(!PyArg_ParseTuple(args,"s",&amp;to_who))
        return NULL;
     // pyfun 函式會將輸入字串變數傳回
    return PyUnicode_FromString(to_who);
}
&lt;/pre&gt;

&lt;p&gt;執行後的結果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0710_05.jpg"&gt;&lt;/p&gt;
&lt;p&gt;不過這兩個pyd的結尾不太一樣。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;sum.pyd&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
// 模組啟始, PyInit_ 後必須使用"名稱".pyd 中的模組名稱, 以便啟動
// 換言之, 若編譯連結後的動態模組名稱為 sum.pyd, 則此地的起始函式名稱必須為 PyInit_sum
PyMODINIT_FUNC
PyInit_sum(void)
{
    // 建立模組的起始, 輸入為模組結構名稱之 address
    (void) PyModule_Create(&amp;ModMethods);
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;pyfun.pyd&lt;/em&gt;&lt;/p&gt;
&lt;pre class="brush: c"&gt;
// 此 pyd 必須命名為 pyfun.pyd, 因為必須與 PyInit_後的名稱相同
PyInit_pyfun(void)
{
    PyObject *m;
    m = PyModule_Create(&amp;moduledef);
    return m;
}
&lt;/pre&gt;

&lt;p&gt;意思似乎是一樣的，不過pyfun.pyd將PyModule_Create當作回傳值回傳了，不知道用意為何。&lt;/p&gt;
&lt;p&gt;若要瞭解Python的函式用法，應該要查閱Python.h或是相關說明才能明白。&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;延伸應用 :&lt;/h2&gt;

&lt;p&gt;只使用既定的範本實在是太簡略了，所以試著在pyd中加一些自己寫的函式。&lt;/p&gt;
&lt;p&gt;在sum中加入新的函式sum3，並讓它的傳回值設定為a和b相加後開平方根，再乘上10。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0710_06.jpg"&gt;&lt;/p&gt;
&lt;p&gt;添加了下列指令：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
//導入
#include "math.h"
//宣告
int sum3(int a, int b);
//副程式sum3
int sum3(int a, int b)
{
    return sqrt(a+b)*10;
}
//定義輸入值和sum3的外部名稱score
static PyObject* mod_score(PyObject *self, PyObject *args)
{
    int a;
    int b;
    int t;
    if (!PyArg_ParseTuple(args,"ii",&amp;a,&amp;b))
       return NULL;
    t = sum3(a,b);
    return Py_BuildValue("i",t);
}
&lt;/pre&gt;

&lt;p&gt;並在PyMethodDef Mod_Methods[]中再新增一串：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
{"score", mod_score, METH_VARARGS, "Description.."},
&lt;/pre&gt;

&lt;p&gt;接著在mypy.py中呼叫sum.score()就行了。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Leo的搜尋功能和復原功能真的不太實在。常常搜尋時就跳到其他Node去，搜尋目標也要每次都重新調整；復原直接還原到存檔前的樣子，所以用它來編譯程式真的滿吃力的。&lt;/p&gt;
&lt;p&gt;這次使用的是Python，所以SciTE和只能寫C語言的NetBeans幫不上忙，因為無法呼叫Python.h。說不定設定環境係數可以奏效？&lt;/p&gt;
&lt;p&gt;不然只靠Leo編輯，它的函式分類也不是很清楚，常常不知道Python.h中的函式原型用法是甚麼，不像NetBeans可以連進去查看stdio.h或是windows.h所引用的函式。&lt;/p&gt;</content><category term="Kmol"></category><category term="CDemo"></category></entry><entry><title>40323230練習 - 105/07/10</title><link href="http://project.mde.tw/blog/40323230lian-xi-1050710.html" rel="alternate"></link><published>2016-07-10T19:00:00+08:00</published><updated>2016-07-10T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-10:/blog/40323230lian-xi-1050710.html</id><summary type="html">&lt;p&gt;由於不熟悉動態連結庫的運作方式，先練習C語言呼叫動態連結庫，之後再研究python的方式。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;由於不熟悉動態連結庫的運作方式，先練習C語言呼叫動態連結庫，之後再研究python的方式。&lt;/p&gt;


&lt;h2&gt;編譯出C的動態連結庫 :&lt;/h2&gt;

&lt;p&gt;找到了一個別人學校的DLL簡單範例。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pws.niu.edu.tw/~ttlee/sp.100.2/dll/" title="niu.edu.tw"&gt;http://pws.niu.edu.tw/~ttlee/sp.100.2/dll/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;雖然NetBeans在截圖時很容易閃退，但是Visual Studio的專案又會把檔案搞得太複雜，所以就將就點使用NetBeans了。&lt;/p&gt;
&lt;p&gt;使用NetBeans建立了一個C/C++ Dynamic Library。&lt;/p&gt;
&lt;p&gt;若沒有預設Make file，也不是二進位資料，又需要動態連結庫的話，這個類別的專案是項很好的選擇。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/vLbLF1a.jpg" &gt;&lt;/p&gt;
&lt;p&gt;新建完成後，Projects的欄位就會幫使用者分類：&lt;/p&gt;
&lt;p&gt;Header Files, Resource Files, Source Files, Test Files.&lt;/p&gt;
&lt;p&gt;這些分類預設是空的，而在NetBeans中沒有分類的檔案是不能編譯的。&lt;/p&gt;
&lt;p&gt;如果要讓既有的檔案歸類，在想添加的目錄上按下右鍵，選擇"Add Existing Item..."，再選擇想加入的檔案就行了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/K1LuZ3T.jpg" &gt;&lt;/p&gt;
&lt;p&gt;按照範例先在SciTE中寫好了三個檔案。&lt;/p&gt;
&lt;p&gt;編譯成DLL文件的是dllmain.c和dll.h，編譯成執行檔的是call DLL.c，在標頭檔dll.h中有相關紀錄。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/acz9z6v.jpg" &gt;&lt;/p&gt;
&lt;p&gt;DLL中的Add函式中輸入三個類型分別是char、int、int的值，會回傳一串文字，類型是char。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DLLIMPORT char* Add(char*str, int a, int b)
{
    printf("This is your ID(8):\n");
    printf("Your ID: %s\n", str);
    printf("%d+%d=%d:\n", a, b, a+b);
    return "OK";
}
&lt;/pre&gt;

&lt;p&gt;標頭檔中也有這一段匯入，供可執行檔呼叫。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DLLIMPORT char* Add(char*, int, int);
&lt;/pre&gt;

&lt;p&gt;這時候先編譯動態連結庫，在專案上按右鍵，選擇Properties。&lt;/p&gt;
&lt;p&gt;在Build的設定中，Configuration Type的選項選擇Dynamic Library，設定好後按下Build鈕。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/B5driZY.jpg" &gt;&lt;/p&gt;
&lt;p&gt;這時候會顯示成功，並在\dist\Debug\MinGW的資料中編譯出dll檔，動態連結庫就算是成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/L3U9skL.jpg" &gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;編譯出C的可執行檔 :&lt;/h2&gt;

&lt;p&gt;這時再把call DLL.c加入Source File中。&lt;/p&gt;
&lt;p&gt;call DLL.exe主要就是接受使用者輸入的三個值，並讓動態連結庫處理完顯示值後，再把顯示值回傳，顯示給使用者看。&lt;/p&gt;
&lt;p&gt;call DLL.c的主程式如下：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
int main(void)
{
    int i1, i2;
    char str1[9];
    printf("Key in:\n");
    scanf("%s,%d,%d", &amp;str1, i1, i2);
    printf("\n");

    HMODULE hInst=LoadLibrary("DLLtest.dll");
    if(hInst==NULL){
        printf("Can't load library.\n");
        system("PAUSE");
        return 1;
    }
    char* (*CallDll)(char*, int, int);
    (FARPROC*)(CallDll)=GetProcAddress(hInst, "Add");
    if(CallDll==NULL){
        printf("NO Value.\n");
        system("PAUSE");
        return 2;
    }
    printf("Result: %s\n", CallDll(str1, i1,i2));
    FreeLibrary(hInst);
    system("PAUSE");
    return 0;
}
&lt;/pre&gt;

&lt;p&gt;然而在編譯時，NetBeans卻顯示了下列訊息：&lt;/p&gt;
&lt;p&gt;&lt;img src="http://i.imgur.com/JjwIcXD.jpg" &gt;&lt;/p&gt;
&lt;p&gt;顯示是在這段出了問題：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
(FARPROC*)(CallDll)=GetProcAddress(hInst, "Add");
&lt;/pre&gt;

&lt;p&gt;這裡的問題是定義項和被定義項的關係錯誤。&lt;/p&gt;
&lt;p&gt;上網查了一些資料，使用的語法都試過了，但是問題仍然無法解決。&lt;/p&gt;
&lt;p&gt;由於是內建函式，所以不太了解其格式甚麼的。&lt;/p&gt;
&lt;p&gt;於是回去觀察Solvespace的標頭檔，發現CDemo是直接使用這段：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
DLL void Slvs_Solve(Slvs_System *sys, Slvs_hGroup hg);
&lt;/pre&gt;

&lt;p&gt;完全不用呼叫dll名稱什麼的。&lt;/p&gt;
&lt;p&gt;因為在slvs.h中，所有的格式在開始就寫得清清楚楚，所以若要使用，必須將需要的數值按照規定的格式填入，然後由最高層的"Slvs_"指派計算。&lt;/p&gt;
&lt;p&gt;編譯後，動態連結庫取代了標頭檔的功能，包裝各項副程式後，在同個目錄下，可以供其他想使用函式的可執行檔使用。&lt;/p&gt;
&lt;p&gt;至於工程師規定的格式在slvs.h的註解中有所說明。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;雖然這次編譯基礎程式時失敗了，但是瞭解這些引用功能的方式，仍然是有所收穫。&lt;/p&gt;
&lt;p&gt;下次應該是模仿CDemo寫題目給libslvs.dll求解，不過若之後是要使用python的話還需要再研究一下SWIG的功能。&lt;/p&gt;</content><category term="Kmol"></category><category term="CDemo"></category></entry><entry><title>40323230紀錄 - 瞭解SWIG &amp; CDemo的資源</title><link href="http://project.mde.tw/blog/40323230ji-lu-liao-jie-swig-cdemode-zi-yuan.html" rel="alternate"></link><published>2016-07-09T19:00:00+08:00</published><updated>2016-07-09T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-09:/blog/40323230ji-lu-liao-jie-swig-cdemode-zi-yuan.html</id><summary type="html">&lt;p&gt;安裝SWIG&lt;/p&gt;
&lt;p&gt;並檢視下列檔案：&lt;/p&gt;
&lt;p&gt;CDemo.exe&lt;/p&gt;
&lt;p&gt;CDemo.c&lt;/p&gt;
</summary><content type="html">&lt;p&gt;安裝SWIG&lt;/p&gt;
&lt;p&gt;並檢視下列檔案：&lt;/p&gt;
&lt;p&gt;CDemo.exe&lt;/p&gt;
&lt;p&gt;CDemo.c&lt;/p&gt;


&lt;h2&gt;安裝工具 :&lt;/h2&gt;

&lt;p&gt;除了英文的資料，另外還讀了一下關於SWIG的相關中文資料：&lt;/p&gt;
&lt;p&gt;1.Python的資料庫形式&lt;/p&gt;
&lt;p&gt;&lt;a href="https://read01.com/PnGeDg.html" title="read01.com"&gt;https://read01.com/PnGeDg.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.Python在Windows中用SWIG呼叫C/C++的函式（VC）&lt;/p&gt;
&lt;p&gt;&lt;a href="http://falldog7.blogspot.tw/2013/07/python-swig-c-function.html" title="falldog7.blogspot.tw"&gt;http://falldog7.blogspot.tw/2013/07/python-swig-c-function.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.SWIG概念&lt;/p&gt;
&lt;p&gt;&lt;a href="http://user.frdm.info/ckhung/b/mi/swig.php" title="user.frdm.info"&gt;http://user.frdm.info/ckhung/b/mi/swig.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接著從&lt;a href="http://www.swig.org/download.html" title="swig.org"&gt;swig.org&lt;/a&gt;下載最新版的SWIG 3.0.10，將壓縮包解至W:內。&lt;/p&gt;
&lt;p&gt;SWIG能夠給Windows/Unix/MacOSX三個平台使用，所以壓縮檔的附檔名是三個平台都共通的".tar.gz"。&lt;/p&gt;
&lt;p&gt;解壓縮後，在Windows環境中有很多檔案是打不開的，不過說明檔是沒有附檔名的，隨便用任何一款文字編輯軟體都能查看。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709-2_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;如果該步驟需要完整的流程，\Doc\Manual中有寫好的html網頁手冊，用網頁瀏覽器就能開啟。&lt;/p&gt;
&lt;p&gt;在閱讀\Doc\Manual\Windows.html的說明之後，手冊解釋SWIG並不是使用通常的Windows類型安裝程式。&lt;/p&gt;
&lt;p&gt;只要在編譯器中（手冊的範例是Visual Studio）設置環境變數就能使用其範例檔。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709-2_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;手冊上也有說明能夠用MinGW和MSYS，Build出SWIG的可執行檔swig.exe。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709-2_03.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;CDemo.exe :&lt;/h2&gt;

&lt;p&gt;CDemo.exe是由CDemo.c編譯出來的可執行檔，取用libslvs.dll的動態連結庫運作。&lt;/p&gt;
&lt;p&gt;在原本的\exposed資料夾中還有工程師留下的VbDemo.vb，Visual Basic或是Visual C#的專案文件，不過不使用這兩個編譯器的話就用不到。&lt;/p&gt;
&lt;p&gt;為此特別將CDemo.exe和libslvs.dll拿出來放在獨立的資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709-2_04.jpg"&gt;&lt;/p&gt;
&lt;p&gt;由CMD進入資料夾中執行CDemo.exe，會發現CDemo是直接顯示了結果。&lt;/p&gt;
&lt;p&gt;顯然CDemo.exe原先已經設定好題目，於是打開CDemo.c看看工程師的註解怎麼說。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709-2_05.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;CDemo.c :&lt;/h2&gt;

&lt;p&gt;由於NetBeans和Windows的截圖程式似乎有衝突，會常常截完圖後自動閃退，所以改用簡便的SciTE。&lt;/p&gt;
&lt;p&gt;用SciTE開啟CDemo.c，可以發現CDemo的原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709-2_06.jpg"&gt;&lt;/p&gt;
&lt;p&gt;而為了方便，將它部分的原始碼貼在下面：&lt;/p&gt;
&lt;pre class="brush: c"&gt;
/*---------------------------
 * Some sample code for slvs.dll. We draw some geometric entities, provide
 * initial guesses for their positions, and then constrain them. The solver
 * calculates their new positions, in order to satisfy the constraints.
 *
 * Copyright 2008-2013 Jonathan Westhues.
 *-------------------------*/
#ifdef HAVE_CONFIG_H
...
#endif
#ifdef WIN32
...
#endif
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#ifdef HAVE_STDINT_H
...
#endif

#include &lt;slvs.h&gt;

static Slvs_System sys;

static void *CheckMalloc(size_t n)
{
    void *r = malloc(n);
    if(!r) {
        printf("out of memory!\n");
        exit(-1);
    }
    return r;
}

/*---------------------------
 * An example of a constraint in 3d. We create a single group, with some
 * entities and constraints.
 *-------------------------*/
void Example3d()
{
...
}

/*---------------------------
 * An example of a constraint in 2d. In our first group, we create a workplane
 * along the reference frame's xy plane. In a second group, we create some
 * entities in that group and dimension them.
 *-------------------------*/
void Example2d()
{
...
}

int main()
{
    sys.param      = CheckMalloc(50*sizeof(sys.param[0]));
    sys.entity     = CheckMalloc(50*sizeof(sys.entity[0]));
    sys.constraint = CheckMalloc(50*sizeof(sys.constraint[0]));

    sys.failed  = CheckMalloc(50*sizeof(sys.failed[0]));
    sys.faileds = 50;

    /*Example3d();*/
    for(;;) {
        Example2d();
        sys.params = sys.constraints = sys.entities = 0;
        break;
    }
    return 0;
}

&lt;/pre&gt;

&lt;p&gt;在CDemo.c的主程式中，最後執行Example3d()副程式的部分被註解掉了。&lt;/p&gt;
&lt;p&gt;所以程式的運行主要是跑Example2d()，就把它的程式碼抓出來看一下。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
void Example2d()
{
    Slvs_hGroup g;
    double qw, qx, qy, qz;

    g = 1;
    /* First, we create our workplane. Its origin corresponds to the origin
     * of our base frame (x y z) = (0 0 0) */
    sys.param[sys.params++] = Slvs_MakeParam(1, g, 0.0);
    sys.param[sys.params++] = Slvs_MakeParam(2, g, 0.0);
    sys.param[sys.params++] = Slvs_MakeParam(3, g, 0.0);
    sys.entity[sys.entities++] = Slvs_MakePoint3d(101, g, 1, 2, 3);
    /* and it is parallel to the xy plane, so it has basis vectors (1 0 0)
     * and (0 1 0). */
    Slvs_MakeQuaternion(1, 0, 0,
                        0, 1, 0, &amp;qw, &amp;qx, &amp;qy, &amp;qz);
    sys.param[sys.params++] = Slvs_MakeParam(4, g, qw);
    sys.param[sys.params++] = Slvs_MakeParam(5, g, qx);
    sys.param[sys.params++] = Slvs_MakeParam(6, g, qy);
    sys.param[sys.params++] = Slvs_MakeParam(7, g, qz);
    sys.entity[sys.entities++] = Slvs_MakeNormal3d(102, g, 4, 5, 6, 7);

    sys.entity[sys.entities++] = Slvs_MakeWorkplane(200, g, 101, 102);

    /* Now create a second group. We'll solve group 2, while leaving group 1
     * constant; so the workplane that we've created will be locked down,
     * and the solver can't move it. */
    g = 2;
    /* These points are represented by their coordinates (u v) within the
     * workplane, so they need only two parameters each. */
    sys.param[sys.params++] = Slvs_MakeParam(11, g, 10.0);
    sys.param[sys.params++] = Slvs_MakeParam(12, g, 20.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(301, g, 200, 11, 12);

    sys.param[sys.params++] = Slvs_MakeParam(13, g, 20.0);
    sys.param[sys.params++] = Slvs_MakeParam(14, g, 10.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(302, g, 200, 13, 14);

    /* And we create a line segment with those endpoints. */
    sys.entity[sys.entities++] = Slvs_MakeLineSegment(400, g,
                                        200, 301, 302);

    /* Now three more points. */
    sys.param[sys.params++] = Slvs_MakeParam(15, g, 100.0);
    sys.param[sys.params++] = Slvs_MakeParam(16, g, 120.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(303, g, 200, 15, 16);

    sys.param[sys.params++] = Slvs_MakeParam(17, g, 120.0);
    sys.param[sys.params++] = Slvs_MakeParam(18, g, 110.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(304, g, 200, 17, 18);

    sys.param[sys.params++] = Slvs_MakeParam(19, g, 115.0);
    sys.param[sys.params++] = Slvs_MakeParam(20, g, 115.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(305, g, 200, 19, 20);

    /* And arc, centered at point 303, starting at point 304, ending at
     * point 305. */
    sys.entity[sys.entities++] = Slvs_MakeArcOfCircle(401, g, 200, 102,
                                    303, 304, 305);

    /* Now one more point, and a distance */
    sys.param[sys.params++] = Slvs_MakeParam(21, g, 200.0);
    sys.param[sys.params++] = Slvs_MakeParam(22, g, 200.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(306, g, 200, 21, 22);

    sys.param[sys.params++] = Slvs_MakeParam(23, g, 30.0);
    sys.entity[sys.entities++] = Slvs_MakeDistance(307, g, 200, 23);

    /* And a complete circle, centered at point 306 with radius equal to
     * distance 307. The normal is 102, the same as our workplane. */
    sys.entity[sys.entities++] = Slvs_MakeCircle(402, g, 200,
                                    306, 102, 307);


    /* The length of our line segment is 30.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            1, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            30.0,
                                            301, 302, 0, 0);

    /* And the distance from our line segment to the origin is 10.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            2, g,
                                            SLVS_C_PT_LINE_DISTANCE,
                                            200,
                                            10.0,
                                            101, 0, 400, 0);
    /* And the line segment is vertical. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            3, g,
                                            SLVS_C_VERTICAL,
                                            200,
                                            0.0,
                                            0, 0, 400, 0);
    /* And the distance from one endpoint to the origin is 15.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            4, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            15.0,
                                            301, 101, 0, 0);
#if 0
    /* And same for the other endpoint; so if you add this constraint then
     * the sketch is overconstrained and will signal an error. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            5, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            18.0,
                                            302, 101, 0, 0);
#endif /* 0 */

    /* The arc and the circle have equal radius. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            6, g,
                                            SLVS_C_EQUAL_RADIUS,
                                            200,
                                            0.0,
                                            0, 0, 401, 402);
    /* The arc has radius 17.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            7, g,
                                            SLVS_C_DIAMETER,
                                            200,
                                            17.0*2,
                                            0, 0, 401, 0);

    /* If the solver fails, then ask it to report which constraints caused
     * the problem. */
    sys.calculateFaileds = 1;

    /* And solve. */
    Slvs_Solve(&amp;sys, g);

    if(sys.result == SLVS_RESULT_OKAY) {
        printf("solved okay\n");
        printf("line from (%.3f %.3f) to (%.3f %.3f)\n",
                sys.param[7].val, sys.param[8].val,
                sys.param[9].val, sys.param[10].val);

        printf("arc center (%.3f %.3f) start (%.3f %.3f) finish (%.3f %.3f)\n",
                sys.param[11].val, sys.param[12].val,
                sys.param[13].val, sys.param[14].val,
                sys.param[15].val, sys.param[16].val);

        printf("circle center (%.3f %.3f) radius %.3f\n",
                sys.param[17].val, sys.param[18].val,
                sys.param[19].val);
        printf("%d DOF\n", sys.dof);
    } else {
        int i;
        printf("solve failed: problematic constraints are:");
        for(i = 0; i &lt; sys.faileds; i++) {
            printf(" %d", sys.failed[i]);
        }
        printf("\n");
        if(sys.result == SLVS_RESULT_INCONSISTENT) {
            printf("system inconsistent\n");
        } else {
            printf("system nonconvergent\n");
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;"Slvs_hGroup g"中的g能在群組編號中切換，離開後的群組會被鎖定。裡面的成員無法新增和編輯，不過可以被呼叫。&lt;/p&gt;
&lt;p&gt;之後便能用"sys.param[sys.params++]"或是"sys.entity[sys.entities++]"的指令在群組下建立工作物件（回傳值，物件格式是%.3f）和建立實體（檢查結果）。&lt;/p&gt;
&lt;p&gt;比較特別的是本程式建立座標的編號是從1開始的；建立工作點的編號是從101開始的；建立工作平面是從200開始的（這題只有一個工作平面）；建立點的編號是從301開始的（使用的座標和工作點相同層級）。之後層級越高編號都以100的倍數成長。&lt;/p&gt;
&lt;p&gt;畫完圖之後，最後解決的程式是使用Slvs_Solve(&amp;amp;sys, g);，取得程式結果和輸入群組編號。至於這個範疇就是libslvs.dll和其他Solvespace部件的工作了。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;閱讀完pyd檔案的作用後，大約知道它和dll的關聯性了。&lt;/p&gt;
&lt;p&gt;不過libslvs.dll究竟是從哪裡編譯出來的呢？是從主要的cpp檔還是標頭檔建立的？Build完之後多出了libslvs.dll.a和config.h。&lt;/p&gt;
&lt;p&gt;雖然一些簡單的dll可以直接打開編輯，不過libslvs.dll應該是不能這樣做。&lt;/p&gt;</content><category term="Kmol"></category><category term="Solvespace"></category><category term="CDemo"></category><category term="SWIG"></category></entry><entry><title>40323230練習 - 105/07/09</title><link href="http://project.mde.tw/blog/40323230lian-xi-1050709.html" rel="alternate"></link><published>2016-07-09T12:00:00+08:00</published><updated>2016-07-09T12:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-09:/blog/40323230lian-xi-1050709.html</id><summary type="html">&lt;p&gt;嘗試用C語言解題&lt;/p&gt;
</summary><content type="html">&lt;p&gt;嘗試用C語言解題&lt;/p&gt;


&lt;h2&gt;BUG fix :&lt;/h2&gt;

&lt;p&gt;W:槽的SciTE有點小問題，因為設定檔是從Y:複製來的，所以需要重新定義TinyC的位置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="(https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;只要修改cpp.properties的路徑就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="(https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_02.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;h2&gt;Nutcracker Solution :&lt;/h2&gt;

&lt;p&gt;上學期的&lt;a href="http://chiamingyen.github.io/kmolab/blog/2015-fall-cadp-w16.html" title="github.io"&gt;Nutcracker網誌內容&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="(https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_03.jpg"&gt;&lt;/p&gt;
&lt;p&gt;之前的python題目，稍微研究一下後轉成C語言。&lt;/p&gt;
&lt;p&gt;不過如果直接運行會跑很久。但是這裡可以練習一下小型演算法的模式。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="(https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_04.jpg"&gt;&lt;/p&gt;
&lt;p&gt;先做了兩個程式，不過第一是介面而已，第二個才是主要架構。&lt;/p&gt;
&lt;p&gt;撰寫的途中使用Solvespace研究，由於數學邏輯不太好，很多幾何的東西沒那麼直觀。&lt;/p&gt;
&lt;p&gt;有時候會偷吃步測試一些解法。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="(https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_05.jpg"&gt;&lt;/p&gt;
&lt;p&gt;第二支程式是從python的範例改來的，不過後來做了很多變化，只有解最小路徑最大角度。&lt;/p&gt;
&lt;p&gt;演算法概念：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="(https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_06.jpg"&gt;&lt;/p&gt;
&lt;p&gt;途中查了很多數學公式，無奈常常打錯又不知道正確性，重複試了很多次才成功。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int k=40;
int h=10;
int a=40;
int b=80;
double r=10;
double pi=M_PI;
int num=1000;

int main()
{
    double deg =pi/180;
    for (int j=45*num; j&lt;=180*num; j++){
        double num0=num;
        double th=j/num0*deg;
        double x1=a*cos(th);
        double y1=a*sin(th);
        double x2=x1+sqrt(b*b-y1*y1);
        double m=tan(th);
        double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1));
        printf("%g\n", (int)(j/num0*100000+.5)/100000.);
        if(r1&lt;=r){
            printf("(%f,%f) (%f,0)\n%f\n%f r=%f\nm=%f\n", x1, y1, x2, th/deg, r, r1, m);
            break;
        }
    }
    return 0;
}
&lt;/pre&gt;

&lt;p&gt;第二支程式的最後成果。&lt;/p&gt;
&lt;p&gt;最後精確度還是沒有很高，不知道問題出在哪裡。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="(https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_07.jpg"&gt;&lt;/p&gt;
&lt;p&gt;第一支程式是剛開始寫輸入端介面，供使用者輸入自訂參數，後來再把第二支程式的模型搬回來用，並另外寫一個解最大路徑和最小角度的程式，所有例外狀況也是在這裡排除。&lt;/p&gt;
&lt;p&gt;後來還不知道怎麼讓副程式傳回double或其他浮點數，查一下才知道要在開始前宣告一次。&lt;/p&gt;
&lt;pre class="brush: c"&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int a, b, k, h, r, lim;
double o, wp, thmin, thmax;
double pi=M_PI;
int num=1000;

double solve_minpath(int, int, int, int, int);
double solve_maxangle(int, int, int, int, int);
double solve_maxpath(int, int, int, int);
double solve_minangle(int, int, int, int);

int main()
{
    scanf("%d,%d,%d,%d,%d,%d", &amp;a, &amp;b, &amp;k, &amp;h, &amp;r, &amp;lim);
//強制正值
    a=abs(a);
    b=abs(b);
    h=abs(h);
    k=abs(k);
    r=abs(r);
    lim=abs(lim);
    printf("\n---\n");
    printf("Used pi= %f\n", pi);
    printf("---\n");
    printf("Connecting Rod:\n");
    printf("a= %d b= %d\n", a, b);
    printf("Rod radius= %d\n", r);
    printf("Rod width= %d\n", r*2);
    printf("Space Usage:\n");
    printf("h= %d k= %d\n", h, k);
    printf("Work Path= %d\n", lim);
    printf("---\n\n");
//相關參數代入副程式解題
    o=solve_minpath(k, h, a, b, r);
    wp=solve_maxpath(lim, a, b, r)-o;
    thmin=solve_minangle(lim, a, b, r);
    thmax=solve_maxangle(k, h, a, b, r);
    if(a*b*lim==0){
        printf("---ERRO---\nSome value can't be zero.\n");
        return 1;
    }
    else{
        if(o+r&gt;lim){
            printf("---ERRO---\nSpace is not enough.\n");
            return 2;
        }
        else{
            printf("\n---\n---Result---\n");
            printf("Distance:\n");
            printf("Offset distance:\n");
            printf("o= %f\n", o);
            printf("Work distance:\n");
            printf("wp= %f\n", wp);
            printf("Angle(Degree):\n");
            printf("min= %f max= %f\n---\n", thmin, thmax);
            return 0;
        }
    }
}

double solve_minpath(int k, int h, int a, int b, int r)
{
    double deg =pi/180;
    for (int j=45*num; 180*num&gt;=j; j++){
        double num0=num;
        double th=j/num0*deg;
        double x1=a*cos(th);
        double y1=a*sin(th);
        double x2=x1+sqrt(b*b-y1*y1);
        double m=tan(th);
        double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1));
        if(r&gt;=r1){
            printf("(%f,%f) (%f,0)\n%f\n%f r=%f\nm=%f\n", x1, y1, x2, th/deg, r, r1, m);
            return x2;
            break;
        }
    }
    return 0;
}

double solve_maxangle(int k, int h, int a, int b, int r)
{
    double deg =pi/180;
    for (int j=45*num; 180*num&gt;=j; j++){
        double num0=num;
        double th=j/num0*deg;
        double x1=a*cos(th);
        double y1=a*sin(th);
        double x2=x1+sqrt(b*b-y1*y1);
        double m=tan(th);
        double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1));
        if(r&gt;=r1){
            printf("(%f,%f) (%f,0)\n%f\n%f r=%f\nm=%f\n", x1, y1, x2, th/deg, r, r1, m);
            return th/deg;
            break;
        }
    }
    return 0;
}

double solve_maxpath(int lim, int a, int b, int r)
{
    double n;
    double th;
    if (lim&gt;a+b+r){
        n=a+b;
        th=0;
    }
    else{
        n=lim-r;
        th=acos((a*a+n*n-b*b)/2*a*n);
    }
    return n;
}

double solve_minangle(int lim, int a, int b, int r)
{
    double n;
    double th;
    if (lim&gt;a+b+r){
        n=a+b;
        th=0;
    }
    else{
        n=lim-r;
        th=acos((a*a+n*n-b*b)/(2*a*n));
    }
    return th;
}

&lt;/pre&gt;

&lt;p&gt;最後執行的結果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0709_08.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;剛開始還以為是用公式推導座標點的結果，後來回去看網誌才知道用演算法計算。電腦演算時如果一邊列出結果，會拖慢速度，所以在最後的程式碼中只留檢查用的結果。&lt;/p&gt;
&lt;p&gt;後來也有上網看其他人使用基因演算法的案例，未能完全了解，還有很多要學習的地方。這次解題複習了一些C語言的概念，希望在往後利用上能夠駕輕就熟。&lt;/p&gt;</content><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230紀錄 - 編譯Solvespace流程</title><link href="http://project.mde.tw/blog/40323230ji-lu-bian-yi-solvespaceliu-cheng.html" rel="alternate"></link><published>2016-07-07T19:00:00+08:00</published><updated>2016-07-07T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-07:/blog/40323230ji-lu-bian-yi-solvespaceliu-cheng.html</id><summary type="html">&lt;p&gt;由原始碼編譯出Solvespace和CDemo的執行檔&lt;/p&gt;
</summary><content type="html">&lt;p&gt;由原始碼編譯出Solvespace和CDemo的執行檔&lt;/p&gt;


&lt;h2&gt;安裝工具 :&lt;/h2&gt;

&lt;p&gt;必須存放於可攜式環境內的工具，可以協助我們建立Solvespace和CDemo的執行檔。&lt;/p&gt;
&lt;p&gt;連結為下載處。&lt;/p&gt;
&lt;p&gt;1.MinGW (Not official version), &lt;a href="https://nuwen.net/mingw.html" title="nuwen.net"&gt;https://nuwen.net/mingw.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.msys (Official version), &lt;a href="http://www.mingw.org/wiki/msys" title="mingw.org"&gt;http://www.mingw.org/wiki/msys&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.CMake  (Official version), &lt;a href="https://cmake.org/download/" title="cmake.org"&gt;https://cmake.org/download/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.NetBeans (Our storage), &lt;a href="http://140.130.17.17/public/Netbeans/" title="140.130.17.17/public/"&gt;http://140.130.17.17/public/Netbeans/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;存放位置除了CMake之外皆為W:內，CMake存於W:\app資料夾中。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_01.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;下載Solvespace原始碼 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="https://github.com/whitequark/solvespace/tree/master" title="github.com"&gt;Whitequark的倉儲&lt;/a&gt;git clone最新的原始碼到W:\tmp資料夾內，並執行git submodule update --init命令以從相關倉儲下載submodule的原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_02.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;NetBeans設定 :&lt;/h2&gt;

&lt;p&gt;從\NetBeans\bin執行NetBeans，亦可編輯start.bat和stop.bat後，在啟動時呼叫和關閉它。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_03.jpg"&gt;&lt;/p&gt;
&lt;p&gt;在Tools-&amp;gt;Options的C/C++中新增編譯工具，選擇GNU MinGW，並填入MinGW的存放位置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_04.jpg"&gt;&lt;/p&gt;
&lt;p&gt;大部分的程式位置會自動填入，不過還要指定msys的make.exe和cmake的位置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_05.jpg"&gt;&lt;/p&gt;
&lt;p&gt;若有必要可以為NetBeans安裝CMake的附加元件。&lt;/p&gt;
&lt;p&gt;在Tools-&amp;gt;Plugins的Available Plugins中搜尋cmake就能找到，勾選後按下Install鈕就能夠安裝。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_06.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;執行Build :&lt;/h2&gt;

&lt;p&gt;接著按下New Project...新增專案。&lt;/p&gt;
&lt;p&gt;選擇Project with Existing Sources繼續。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_07.jpg"&gt;&lt;/p&gt;
&lt;p&gt;然後選擇Whitequark的Solvespace原始碼目錄。&lt;/p&gt;
&lt;p&gt;並使用Automatic讓cmake自動清理專案，直接按完成就會開始Clean和嘗試Build。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_08.jpg"&gt;&lt;/p&gt;
&lt;p&gt;這時在Build時會出現錯誤，顯示一串類似undefined reference to `BZ2_bzDecompressEnd'的訊息，是因為沒有加入bz2的程式庫連結所致。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_09.jpg"&gt;&lt;/p&gt;
&lt;p&gt;這時開啟專案內的\src\CMakeLists.txt，找到target_link_libraries這一行，並將bz2加到最後的括弧內，就可以繼續完成Build。&lt;/p&gt;
&lt;p&gt;註：如果不是填在最後一項會有讀取順序錯誤的問題。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_10.jpg"&gt;&lt;/p&gt;
&lt;p&gt;修改CMake的清單後，就能順利建立solvespace.exe和CDemo.exe，分別存放在\src和\exposed資料夾下。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0707_11.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;接下來就是研究如何應用CDemo的解題程式協助解開範例，最後再修改供Python3呼叫和取用其動態連結庫。&lt;/p&gt;</content><category term="Kmol"></category><category term="Solvespace"></category><category term="CDemo"></category></entry><entry><title>40323230紀錄 - Solvespace</title><link href="http://project.mde.tw/blog/40323230ji-lu-solvespace.html" rel="alternate"></link><published>2016-07-06T19:00:00+08:00</published><updated>2016-07-06T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-06:/blog/40323230ji-lu-solvespace.html</id><summary type="html">&lt;p&gt;找到的Solvespace原始碼版本&lt;/p&gt;
</summary><content type="html">&lt;p&gt;找到的Solvespace原始碼版本&lt;/p&gt;


&lt;h2&gt;目前可攜式環境內存放的Solvespace原始碼 :&lt;/h2&gt;

&lt;h3&gt;超連結為下載處。&lt;/h3&gt;

&lt;p&gt;1.&lt;a href="https://github.com/whitequark/solvespace/tree/master" title="github.com"&gt;Whitequark的倉儲&lt;/a&gt;：非官方人員開發的原始碼。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0706_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="http://solvespace.com/download.pl" title="solvespace.com"&gt;Solvespace 2.0&lt;/a&gt;：官方舊版2.0的原始碼。結構很簡單，沒有cmake建置的檔案。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0706_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;a href="https://github.com/solvespace/solvespace/releases/tag/v2.1" title="github.com"&gt;Solvespace 2.1&lt;/a&gt;：官方最新穩定的版本。結構類似現在開發中的樣式。但是用NetBeans建置時會顯示\extlib資料夾中很多資料夾是空的錯誤，2.0版沒有這些資料夾，這些空的資料夾似乎和&lt;a href="https://github.com/solvespace/libdxfrw" title="github.com"&gt;solvespace/libdxfrw&lt;/a&gt;有關聯。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0706_03.jpg"&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;a href="https://github.com/solvespace/solvespace/tree/2.x" title="github.com"&gt;Solvespace的倉儲&lt;/a&gt;：官方開發中的2.2版。好像不能clone下來，只能載zip檔。也有2.1那些空資料夾。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0706_04.jpg"&gt;&lt;/p&gt;
&lt;p&gt;相關連結：版本差異紀錄-&lt;a href="https://github.com/solvespace/solvespace/blob/2.x/CHANGELOG.md" title="github.com"&gt;Solvespace的倉儲&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;NetBeans方面，同樣使用C/C++ Project with Existing Sources建置檔案，官方的版本都會因為libdxfrw、libfreetype、libpng、zlib沒東西而顯示建置錯誤。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0706_05.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0706_06.jpg"&gt;&lt;/p&gt;
&lt;p&gt;點開記錄錯誤的視窗：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0706_07.jpg"&gt;&lt;/p&gt;</content><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/05</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050705.html" rel="alternate"></link><published>2016-07-05T19:00:00+08:00</published><updated>2016-07-05T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-05:/blog/40323230ri-zhi-1050705.html</id><summary type="html">&lt;p&gt;NetBeans的相關探索-2&lt;/p&gt;
&lt;p&gt;註：發現目前最新的原始碼內好像很多錯誤，不知道該怎麼辦。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;NetBeans的相關探索-2&lt;/p&gt;
&lt;p&gt;註：發現目前最新的原始碼內好像很多錯誤，不知道該怎麼辦。&lt;/p&gt;


&lt;p&gt;目前NetBeans的&lt;a href="https://netbeans.org/kb/docs/intro-screencasts.html?utm_source=netbeans&amp;amp;utm_campaign=welcomepage" title="netbeans.org"&gt;官方網站&lt;/a&gt;並沒有很詳盡的介紹，只有放一些改版的導覽影片。&lt;/p&gt;
&lt;p&gt;基於如此就研究看看它跟其他編譯軟體有那些不一樣的地方。&lt;/p&gt;
&lt;h2&gt;NetBeans啟動 :&lt;/h2&gt;

&lt;p&gt;每次啟動可攜式環境，NetBeans portable都會保留之前的設定。&lt;/p&gt;
&lt;p&gt;只要上次編譯的專案沒有關閉或是刪除，NetBeans在啟動時都會自動載入，不需要重新導入專案。&lt;/p&gt;
&lt;p&gt;另外NetBeans需要連線的服務（ex.附加元件）也會在啟動時檢查更新。只要背景有程序執行，右下角的進度條就會提醒。&lt;/p&gt;
&lt;p&gt;不過NetBeans似乎有時載入太多東西或其他背景程式開太多，如果再對它下指令，會反應跟不上而閃退。也有可能是在可攜環境執行的關係，比較吃資源。&lt;/p&gt;
&lt;p&gt;設定start.bat在啟動後自動打開NetBeans。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;NetBeans在啟動時載入專案的提示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_02.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;NetBeans介面 :&lt;/h2&gt;

&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_03.jpg"&gt;&lt;/p&gt;
&lt;p&gt;跟大部分的文字編譯軟體差不多的介面。&lt;/p&gt;
&lt;p&gt;在畫面中按住Ctrl鍵選取#include或import的檔案能直接在分頁中開啟它們；如果是物件，點擊後會移到宣告的地方；如果是副程式，會移到其開始位置。&lt;/p&gt;
&lt;p&gt;行號中會標記錯誤或警告提示，滑鼠移上去就會解說，並且按下Alt+Enter可以顯示更多提示。&lt;/p&gt;
&lt;p&gt;捲軸的旁邊會標記標籤，顯示整個檔案中哪些位置有警告或錯誤，直接點擊可以快速移到該處。&lt;/p&gt;
&lt;p&gt;NetBeans還有內建自動拼寫校正（註解處）。不過有時候讀取和偵錯反應比較慢。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_04.jpg"&gt;&lt;/p&gt;
&lt;p&gt;主工具列比較簡單。新建獨立檔案／專案、讀取專案、全部儲存、復原／重做之類的基本功能。&lt;/p&gt;
&lt;p&gt;另外還有選取專案設定檔、Build／Clean than Build的功能、執行／除錯的功能。&lt;/p&gt;
&lt;p&gt;上方的選單比較特殊的是Team的功能，似乎能管理版次和執行git的指令，但是嘗試了一些似乎沒反應？&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_05.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Project的欄目可以快速選取開啟CMake的檔案，除此之外和File的檔案結構是一樣的。&lt;/p&gt;
&lt;p&gt;以下是File的檔案目錄和檔案總管顯示的比較。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_06.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_07.jpg"&gt;&lt;/p&gt;
&lt;p&gt;服務頁籤中會顯示一些工具，不過不知道怎麼使用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_08.jpg"&gt;&lt;/p&gt;
&lt;p&gt;讀取檔案後會顯示第4個欄位Class，是拆解程式後的物件樹，點擊兩下會開啟程式碼。&lt;/p&gt;
&lt;p&gt;在物件上點擊兩下會移到該物件所在的檔案位置。&lt;/p&gt;
&lt;p&gt;在物件上打關鍵字並使用上下鍵移動能夠搜尋檔案中的物件。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_09.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0705_10.jpg"&gt;&lt;/p&gt;
&lt;p&gt;工具列的功能說明：&lt;/p&gt;
&lt;p&gt;1：Source-切換至編輯原始碼模式。&lt;/p&gt;
&lt;p&gt;2：History-切換至編輯記錄模式。&lt;/p&gt;
&lt;p&gt;3：Last Edit-回到上次編輯（插入／刪除）過的位置。&lt;/p&gt;
&lt;p&gt;4：Go back to-上一個瀏覽過的檔案。&lt;/p&gt;
&lt;p&gt;5：Forward-下一個瀏覽過的檔案。&lt;/p&gt;
&lt;p&gt;6：Find Selection-在本檔案搜尋框選的文字。&lt;/p&gt;
&lt;p&gt;7：Find Previous Occurrence-尋找前一個關鍵字。&lt;/p&gt;
&lt;p&gt;8：Find Next Occurrence-尋找後一個關鍵字。&lt;/p&gt;
&lt;p&gt;9：Toggle Highlight Search-切換高亮度標示。&lt;/p&gt;
&lt;p&gt;10：Toggle Rectangular Selection-切換矩形框選模式。&lt;/p&gt;
&lt;p&gt;11：Previous Bookmark-前一個書籤。&lt;/p&gt;
&lt;p&gt;12：Next Bookmark-下一個書籤。&lt;/p&gt;
&lt;p&gt;13：Toggle Bookmark-切換書籤。&lt;/p&gt;
&lt;p&gt;14：Shift Line Left-往左縮排。&lt;/p&gt;
&lt;p&gt;15：Shift Line Right-往右縮排。&lt;/p&gt;
&lt;p&gt;16：Start Macro Recording-開始巨集（腳本）錄製。&lt;/p&gt;
&lt;p&gt;17：Stop Macro Recording-停止巨集錄製。&lt;/p&gt;
&lt;p&gt;18：Comment-註解。&lt;/p&gt;
&lt;p&gt;19：UNcomment-刪掉註解。&lt;/p&gt;
&lt;p&gt;20：Go to Header/Source-開啟源頭檔。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;使用一款未接觸過的軟體，都會先研究它的介面和基本操作方式還有額外的設定，不過有些專業用詞不知道影響的關聯性。&lt;/p&gt;
&lt;p&gt;以前只用過Visual Studio撰寫和測試一些簡單的程式，對這種大型的架構瞭解較少，應該會再找些相關資訊學習。&lt;/p&gt;</content><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323218日誌 - 105/07/04</title><link href="http://project.mde.tw/blog/40323218ri-zhi-1050704.html" rel="alternate"></link><published>2016-07-04T20:37:00+08:00</published><updated>2016-07-04T20:37:00+08:00</updated><author><name>40323218</name></author><id>tag:project.mde.tw,2016-07-04:/blog/40323218ri-zhi-1050704.html</id><summary type="html">&lt;p&gt;V-rep&lt;/p&gt;
</summary><content type="html">&lt;p&gt;V-rep&lt;/p&gt;


&lt;h3&gt;熟悉 V-Rep 基本操作&lt;/h3&gt;

&lt;p&gt;&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/introduce1.PNG"&gt;
&lt;br&gt;
&lt;h3&gt;1. 2D移動&lt;br&gt;
2. 3D旋轉&lt;br&gt;
3. 遠近&lt;br&gt;
4. 移動畫面至物體&lt;br&gt;
5. 物體定位(x,y,z)&lt;br&gt;
6. 物體旋轉(x,y,z)&lt;br&gt;
7. 開始模擬&lt;br&gt;
8. 暫停模擬&lt;br&gt;
9. 結束模擬&lt;br&gt;
10. 慢速&lt;br&gt;
11. 加速&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;嘗試製作 one_link_robot&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step1.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;File→import→Mesh...(從資料夾中輸入 stl檔)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;選擇單位和方向&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step3.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;點選物體使用"object shift"調整Z軸距離&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;點選物體 右鍵→Edit→Grouping/Merging→Divide selected shapes(使物體解體)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;右鍵→Add→Joint→Revolute(增加旋轉軸)&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;連點兩下Revolute icon 打開 Scene Object Properties , 下面 Visual properties修改旋轉軸的長和直徑&lt;/h3&gt;
&lt;br&gt;
&lt;h3&gt;接著點下面 Show dynamic properties dialog , 打勾Motor enabled 和 Lock motor ...
&lt;br&gt;
&lt;h3&gt;再來點旋轉軸 , Ctrl+左鍵點圓柱 , 使用"object shift"在XYZ都點Apply to selection , 在"Orientation/Rotations"也點 Apply , 使兩軸重疊&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step6.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;點選圓柱 icon , 點最下面Show dynamic properties dialog , 打勾Body is dynamic(使物體可作動)
&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step7.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;
使圓柱降階成為旋轉軸的Child&lt;br&gt;
使旋轉物降階成為圓柱的Child&lt;br&gt;
使旋轉軸降階成為底座的Child&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step8.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;按左側"Script" →Insert new script→Script type 選擇 Child script (threaded) , 下方 Associated object 選擇底座.&lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/step9.png" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;double - click the child script,  在最下面加上SimExtRemoteApiStart(19999)(參考老師範例研究中) &lt;/h3&gt;
&lt;br&gt;
&lt;img src="http://coursemdetw.github.io/project_site_files/files/2016spring/g2/40323218/Round.gif" weight=600 &gt;
&lt;br&gt;
&lt;h3&gt;點選"Start simulation" 啟動模擬 , 用SciTE 開啟老師的檔案 one_link_robot_remoteAPI.py , F5執行就會轉囉~~&lt;/h3&gt;&lt;/p&gt;
&lt;h3&gt;製作影片：&lt;/h3&gt;

&lt;iframe src="https://player.vimeo.com/video/173321561" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;p&gt;&lt;a href="https://vimeo.com/173321561"&gt;V-Rep one_link_robot&lt;/a&gt; from &lt;a href="https://vimeo.com/user44943624"&gt;Li Steven&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;&lt;/p&gt;</content><category term="Kmol"></category></entry><entry><title>40323230日誌 - 105/07/04-2</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050704-2.html" rel="alternate"></link><published>2016-07-04T19:00:00+08:00</published><updated>2016-07-04T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-04:/blog/40323230ri-zhi-1050704-2.html</id><summary type="html">&lt;p&gt;NetBeans的相關探索&lt;/p&gt;
</summary><content type="html">&lt;p&gt;NetBeans的相關探索&lt;/p&gt;


&lt;h2&gt;NetBeans設定 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="https://nuwen.net/mingw.html" title="nuwen.net"&gt;MinGW Distro - nuwen.net&lt;/a&gt;下載了新版配有gcc 6.1.0和Boost 1.61.0的MinGW，原本可攜式環境的MinGW是用gcc 4.9.3，暫且在名稱加上.old不使用。&lt;/p&gt;
&lt;p&gt;下圖是新版和舊版的比對。新版的資料夾有附一個README_STL.txt文件說明內含的附加元件版本。&lt;/p&gt;
&lt;p&gt;這個MinGW裡還配有一個比較簡單的git工具。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704-2_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;NetBeans的版本是8.1，存放於根目錄W:，已經是最新版。&lt;/p&gt;
&lt;p&gt;先在Option裡設定C語言用的Build Tool，在新增工具的下拉選單設定使用MinGW，並指定到MinGW的目錄。成功新增Tool後，NetBeans會自己抓到gcc.exe、g++.exe、as.exe、gdb.exe，最下方則是有QMake和CMake的選項，將CMake指定到存放的位置。&lt;/p&gt;
&lt;p&gt;設定裡所有的位置都是指定於可攜式環境內，沒用到任何外部資料夾。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704-2_02.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;NetBeans專案 :&lt;/h2&gt;

&lt;p&gt;之後新建專案，選擇C語言已有源代碼的專案。&lt;/p&gt;
&lt;p&gt;選擇模式部分選擇Solvespace的目錄。工具只有剛才設定的MinGW，並選擇自訂查看一下。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704-2_03.jpg"&gt;&lt;/p&gt;
&lt;p&gt;基本上是使用Predefined Command，使用的是CMake的gui設定，也就是Solvespace目錄存放的CMakeLists.txt檔。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704-2_04.jpg"&gt;&lt;/p&gt;
&lt;p&gt;接下來是清理和建置指令，就和打在CMD視窗裡的一樣。&lt;/p&gt;
&lt;p&gt;幾乎每個環節都會詢問工作環境，但是Solvespace沒特別區分的話就是原本目錄內，所以直接按下一步。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704-2_05.jpg"&gt;&lt;/p&gt;
&lt;p&gt;按下完成鈕後會花個幾秒載入。然後就會在左側讀入原始碼資料夾和檔案的結構。&lt;/p&gt;
&lt;p&gt;下面則會執行並顯示CMake和Clean指令輸出的訊息，最後完成後就完成編譯環境了。&lt;/p&gt;
&lt;p&gt;左側的欄位分成Project、Files和Services。只要在Project或Files的檔案樹點兩下就能在中央開啟文件編輯。Services則可以呼叫MinGW的附加元件來用（包含gcc）。&lt;/p&gt;
&lt;p&gt;左下的導航欄似乎能執行CMake的指令。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704-2_06.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;這次也是使用之前備份並更新過的Solvespace原始碼操作，免得被之前的檔案影響。&lt;/p&gt;
&lt;p&gt;雖然和SciTE一樣是文字編譯軟體，但是NetBeans能夠隨時呼叫需要使用的工具來支援。與Visual Studio相比還能夠在可攜環境中保存設定檔，更為方便。&lt;/p&gt;</content><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/04</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050704.html" rel="alternate"></link><published>2016-07-04T12:00:00+08:00</published><updated>2016-07-04T12:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-04:/blog/40323230ri-zhi-1050704.html</id><summary type="html">&lt;p&gt;改用CMD設定CMake&lt;/p&gt;
</summary><content type="html">&lt;p&gt;改用CMD設定CMake&lt;/p&gt;


&lt;h2&gt;CMD命令cmake連接Solvespace原始碼 :&lt;/h2&gt;

&lt;h3&gt;Readme的Command-line build&lt;/h3&gt;

&lt;p&gt;使用可攜式環境的Command Prompt到外部呼叫Visual Studio的vcvarsall.bat。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;然後為cmake的bin資料夾設定啟動位置(Path4)，可以正常呼叫。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;到CMD中下Readme中提供的指令。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704_03.jpg"&gt;&lt;/p&gt;
&lt;p&gt;接著下nmake的指令。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704_04.jpg"&gt;&lt;/p&gt;
&lt;p&gt;但是在最後出現一些錯誤，不知道原因為何。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704_05.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;與此同時可以用Visual Studio的相關功能。CMake也算是設定完成了。&lt;/p&gt;
&lt;p&gt;如果要改用NetBeans，就不用下nmake的指令。&lt;/p&gt;
&lt;hr&gt;

&lt;h3&gt;Readme的MSVC build&lt;/h3&gt;

&lt;p&gt;這次也把MinGW的bin設定進啟動位置(Path5)，可以正常呼叫。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704_06.jpg"&gt;&lt;/p&gt;
&lt;p&gt;接著同樣按照Readme的說明用CMD下指令。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0704_07.jpg"&gt;&lt;/p&gt;
&lt;p&gt;不過後面的make指令會說無法讀取makefile檔。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;Readme中說可以使用MinGW，只要確保git和MinGW的gcc在作業環境內就行了。至於gcc的功能繁多，還需要研究一下。&lt;/p&gt;</content><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/03-2</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050703-2.html" rel="alternate"></link><published>2016-07-03T19:00:00+08:00</published><updated>2016-07-03T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-03:/blog/40323230ri-zhi-1050703-2.html</id><summary type="html">&lt;p&gt;關於編譯 Solvespace(更新)&lt;/p&gt;
</summary><content type="html">&lt;p&gt;關於編譯 Solvespace(更新)&lt;/p&gt;


&lt;h2&gt;使用CMake連接Solvespace原始碼 :&lt;/h2&gt;

&lt;h3&gt;Readme的GUI build&lt;/h3&gt;

&lt;p&gt;下載了放在140.130.17.17/public/Netbeans/的可攜式環境git2016，該環境使用的是W:磁碟機，不會和撰寫網誌的Y:環境衝突，可以同時開啟；但是其一關閉時會把所有cmd關掉。之後放入了Netbeans套件，不過還尚未使用。&lt;/p&gt;
&lt;p&gt;在新的可攜式環境中存入了從GitHub下載的Solvespace的原始碼，並依照其Readme的方式，用git submodule update --init指令更新模組，並存了一個備份檔。&lt;/p&gt;
&lt;p&gt;CMake的方面使用可攜版的Zip檔，而非Msi安裝。將CMake放在W:的根目錄下。相較於使用指令，因為可攜式環境沒辦法呼叫外部程式支援，所以用cmake-gui.exe圖形介面來設定相關環境。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0703-2_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;一開始對cmake-gui.exe的兩個位置指向不太清楚，所以嘗試了很多次。&lt;/p&gt;
&lt;p&gt;要在Solvespace的目錄中建立一個/build資料夾，以存放binaries。&lt;/p&gt;
&lt;p&gt;Source code的部分是填程式專案的目錄，binaries的地方填/build資料夾，再按Configure鈕設定編譯器，完成後會設置CMake的檔案。&lt;/p&gt;
&lt;p&gt;雖然之前的目錄已經有檔案了，但是如果binaries直接設目錄內，貌似會衝突產生問題，也無法復原設定檔，幸好有先備份資料能復原。&lt;/p&gt;
&lt;p&gt;Configure的部分嘗試選擇MinGW的選項。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0703-2_02.jpg"&gt;&lt;/p&gt;
&lt;p&gt;下面則選Specify native compilers來自訂編譯器位置，這時執行出現一個錯誤，無法執行MinGW。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0703-2_03.jpg"&gt;&lt;/p&gt;
&lt;p&gt;上網尋找似乎要修改系統環境參數到MinGW的bin資料夾才找的到原本就存在的libgmp-10.dll，不知道可攜式環境有沒有其他解法。&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;暫時用Visual Studio的設定，但是結果似乎不理想。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0703-2_04.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;參考資料：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="https://www.youtube.com/watch?v=gYmgbqGfv-8" title="youtube.com"&gt;教學影片-Visual Studio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="https://www.youtube.com/watch?v=2A-iRgOhL8A" title="youtube.com"&gt;教學影片-Mingw&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前還不會使用MinGW或Netbeans套件，所以暫時先放在可攜環境git2016中，之後會找資料學習如何編譯Solvespace的功能。&lt;/p&gt;</content><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230日誌 - 105/07/03</title><link href="http://project.mde.tw/blog/40323230ri-zhi-1050703.html" rel="alternate"></link><published>2016-07-03T12:00:00+08:00</published><updated>2016-07-03T12:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-03:/blog/40323230ri-zhi-1050703.html</id><summary type="html">&lt;p&gt;關於編譯 Solvespace&lt;/p&gt;
</summary><content type="html">&lt;p&gt;關於編譯 Solvespace&lt;/p&gt;


&lt;h2&gt;編譯 Solvespace 前的準備 :&lt;/h2&gt;

&lt;p&gt;從&lt;a href="http://www.activestate.com/activeperl/downloads" title="activestate.com"&gt;Active State&lt;/a&gt;下載了 ActivePerl，使用的是5.24.0／x64版。&lt;/p&gt;
&lt;p&gt;從&lt;a href="https://www.visualstudio.com/downloads/download-visual-studio-vs" title="visualstudio.com"&gt;Microsoft&lt;/a&gt;下載並安裝了Visual Studio Professional 2015，安裝好像無法選擇C:以外的磁碟。&lt;/p&gt;
&lt;p&gt;從&lt;a href="https://github.com/whitequark/solvespace" title="github.com"&gt;GitHub&lt;/a&gt;下載Solvespace的原始碼，另外在&lt;a href="http://solvespace.com/download.pl" title="solvespace.com"&gt;Solvespace&lt;/a&gt;提供下載的頁面中也有一個較舊版的原始碼。&lt;/p&gt;
&lt;p&gt;裝完之後用Developer Command Prompt切換至專案目錄執行nmake，就能下相關指令了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0703_01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;用CMD從安裝目錄的\VC\bin啟動vcvars32.bat，執行nmake好像也可以，不知道其差異性。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://raw.githubusercontent.com/coursemdetw/project_site_files/gh-pages/files/2016spring/g2/Python_solvespace/0703_02.jpg"&gt;&lt;/p&gt;
&lt;hr&gt;

&lt;p&gt;關於NMAKE的使用方法，找了幾個中國的網站介紹：&lt;/p&gt;
&lt;p&gt;1.&lt;a href="http://www.cnblogs.com/kekec/archive/2013/04/21/3007277.html" title="cnblogs.com"&gt;NMAKE的指令&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href="http://blog.csdn.net/cneaglelee/article/details/11714803" title="csdn.net"&gt;NMAKE的開發環境設置&lt;/a&gt;&lt;/p&gt;</content><category term="Kmol"></category><category term="Solvespace"></category></entry><entry><title>40323230紀錄</title><link href="http://project.mde.tw/blog/40323230ji-lu.html" rel="alternate"></link><published>2016-07-02T19:00:00+08:00</published><updated>2016-07-02T19:00:00+08:00</updated><author><name>40323230</name></author><id>tag:project.mde.tw,2016-07-02:/blog/40323230ji-lu.html</id><summary type="html">&lt;p&gt;V-REP從範本學得的一些紀錄&lt;/p&gt;
</summary><content type="html">&lt;p&gt;V-REP從範本學得的一些紀錄&lt;/p&gt;


&lt;h2&gt;V-REP Example Learning Reviews&lt;/h2&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;嘗試用英文說明&lt;/h4&gt;
&lt;/br&gt;
&lt;h2&gt;Notes :&lt;/h2&gt;
&lt;/br&gt;
&lt;h3&gt;The "Scene hierarchy" panel can show whole of outward and entity in a tree.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy" title="coppeliarobotics.com"&gt;Scene hierarchy&lt;/a&gt; Description page
&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/cqIHtFn.jpg" &gt;
&lt;/br&gt;
&lt;h3&gt;In this case, a group of parts will in the same level. they are outward, entity and joint parts. Maybe some sensor parts will put into this group.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Any parts can insert a script to control them.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;"Dummy" parts is a calculation module. They are collidable, measurable and detectable like the entity. But now we are't clearly known it's application.&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
&lt;a href="http://www.coppeliarobotics.com/helpFiles/en/dummies.htm" title="coppeliarobotics.com"&gt;Dummy&lt;/a&gt; Description page
&lt;/h3&gt;
&lt;/br&gt;&lt;hr&gt;&lt;/br&gt;
&lt;h3&gt;組裝上可以使用「滑塊主動噴頭連動」或「噴頭主動滑塊連動」的方式，但是在從屬關係上必須顛倒，程式寫法也不一樣。「滑塊主動噴頭連動」的方式較符合3D印表機的物理運作。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/caU2SLx.jpg" &gt;
&lt;/br&gt;&lt;hr&gt;&lt;/br&gt;
&lt;h3&gt;目前整理完幾何部件的檔案。存於\users\g2_files\VREP_Simulation.ttt中。&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/jNvEHRc.jpg" &gt;&lt;/p&gt;</content><category term="Kmol"></category><category term="V-rep"></category></entry><entry><title>40323250日誌 - 105/06/29</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050629.html" rel="alternate"></link><published>2016-06-29T21:37:00+08:00</published><updated>2016-06-29T21:37:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-06-29:/blog/40323250ri-zhi-1050629.html</id><summary type="html">&lt;p&gt;暑期第一個禮拜的 星期三&lt;/p&gt;
</summary><content type="html">&lt;p&gt;暑期第一個禮拜的 星期三&lt;/p&gt;


&lt;h3&gt;進度&lt;/h3&gt;

&lt;h4&gt;目前組了兩個版本，一個是簡易版，沒有多餘零件，另一個是完整版，有畫的零件都組上去了，如圖:&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/OCcfYur.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;以下是零件&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/64Qlmfm.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;以下是v-rep拆解後的截圖&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;簡易版&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/1C9EKl2.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h4&gt;完整版&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/I7q77aX.png"&gt;
&lt;/br&gt;
&lt;h3&gt;明天應該就可以開始測試模擬了。&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;Onshape零件及兩個stl檔案都放在users/g2_files目錄下，歡迎取用。&lt;/h3&gt;&lt;/p&gt;</content><category term="Kmol"></category></entry><entry><title>40323250日誌 - 105/06/28</title><link href="http://project.mde.tw/blog/40323250ri-zhi-1050628.html" rel="alternate"></link><published>2016-06-28T20:48:00+08:00</published><updated>2016-06-28T20:48:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-06-28:/blog/40323250ri-zhi-1050628.html</id><summary type="html">&lt;p&gt;暑期第一個禮拜的 星期二&lt;/p&gt;
</summary><content type="html">&lt;p&gt;暑期第一個禮拜的 星期二&lt;/p&gt;


&lt;h3&gt;目前組合進度&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/D2k3uqk.gif"&gt;
&lt;/br&gt;
&lt;h3&gt;目前遇到的狀況&lt;/h3&gt;
&lt;h4&gt;我把滑塊設定為slider，能在滑軌上做相對移動，但是在拉到一半的時候，Onshape整個圖形就消失了，然後點選左方的zoom to section還是能顯示，但呈現以下狀態&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/W3N5pkC.png"&gt;
&lt;/br&gt;
&lt;h4&gt;滑鼠選轉及縮放也跟著出問題，點選右方試圖方塊圖又會不見，只能重新再組一次。&lt;/h4&gt;&lt;/p&gt;</content><category term="Kmol"></category></entry><entry><title>Summer Plan</title><link href="http://project.mde.tw/blog/summer-plan.html" rel="alternate"></link><published>2016-06-23T17:10:00+08:00</published><updated>2016-06-23T17:10:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-06-23:/blog/summer-plan.html</id><summary type="html">&lt;p&gt;Summer project&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Summer project&lt;/p&gt;


&lt;p&gt;1.畫3D Printer (V-rep ,Onshape)&lt;/p&gt;

&lt;p&gt;2.實驗室網站介面&lt;/p&gt;

&lt;p&gt;3.Octopi ,機械手臂&lt;/p&gt;

&lt;p&gt;4.OpenCV &lt;/p&gt;

&lt;p&gt;5.RGA演算&lt;/p&gt;

&lt;p&gt;6.認證主機(Virtual Box)&lt;/p&gt;

&lt;p&gt;7.Proxy&lt;/p&gt;

&lt;p&gt;8.報告(拍照 ,內容整理)&lt;/p&gt;

&lt;p&gt;9.找碩班教授&lt;/p&gt;

&lt;p&gt;&lt;/br&gt;
&lt;p&gt;暑期人數 : &lt;/p&gt;
&lt;p&gt;七月:第一組3人 ,第二組4人&lt;/p&gt;
&lt;p&gt;八月:第一組3人 ,第二組4人 ,第三組1人&lt;/p&gt;
&lt;p&gt;&lt;font size="5" face="Arial"&gt;&lt;marquee border="0" scrollamount="50" behavior="alternate"&gt;You can't see me&lt;/marquee&gt;&lt;/font&gt;&lt;/p&gt;&lt;/p&gt;</content><category term="Kmol"></category></entry><entry><title>OpenCv範例執行</title><link href="http://project.mde.tw/blog/opencvfan-li-zhi-xing.html" rel="alternate"></link><published>2016-06-10T17:50:00+08:00</published><updated>2016-06-10T17:50:00+08:00</updated><author><name>40323250</name></author><id>tag:project.mde.tw,2016-06-10:/blog/opencvfan-li-zhi-xing.html</id><summary type="html">&lt;p&gt;OpenCv example with python test&lt;/p&gt;
</summary><content type="html">&lt;p&gt;OpenCv example with python test&lt;/p&gt;


&lt;h3&gt;實作系統Ubuntu 14.04 以及 老師整合的檔案&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;p&gt;&lt;a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html#display-image"&gt;範例網址1.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/coursemdetw/project_site/blob/gh-pages/users/picture/messi.jpg"&gt;使用到的圖片&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
img = cv2.imread('messi.jpg',0)
cv2.imshow('image',img)
k = cv2.waitKey(0)
if k == 27:         # wait for ESC key to exit
    cv2.destroyAllWindows()
elif k == ord('s'): # wait for 's' key to save and exit
    cv2.imwrite('messigray.png',img)
    cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;img src="http://i.imgur.com/tI55TDf.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;p&gt;&lt;a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_video_display/py_video_display.html#display-video"&gt;範例網址2.&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
cap = cv2.VideoCapture(0)
while(True):
    # Capture frame-by-frame
    ret, frame = cap.read()
    # Our operations on the frame come here
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    # Display the resulting frame
    cv2.imshow('frame',gray)
    if cv2.waitKey(1) &amp;amp; 0xFF == ord('q'):
        break&lt;/p&gt;
&lt;h1&gt;When everything done, release the capture&lt;/h1&gt;
&lt;p&gt;cap.release()
cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;img src="http://i.imgur.com/MOL03LL.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;p&gt;範例網址3.(同上)&lt;/p&gt;
&lt;h4&gt;程式碼&lt;/h4&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
cap = cv2.VideoCapture(0)&lt;/p&gt;
&lt;h1&gt;Define the codec and create VideoWriter object&lt;/h1&gt;
&lt;p&gt;fourcc = cv2.VideoWriter_fourcc(*'XVID')
out = cv2.VideoWriter('output.avi',fourcc, 20.0, (640,480))
while(cap.isOpened()):
    ret, frame = cap.read()
    if ret==True:
        frame = cv2.flip(frame,1)
        # write the flipped frame
        out.write(frame)
        cv2.imshow('frame',frame)
        if cv2.waitKey(1) &amp;amp; 0xFF == ord('q'):
            break
    else:
        break&lt;/p&gt;
&lt;h1&gt;Release everything if job is finished&lt;/h1&gt;
&lt;p&gt;cap.release()
out.release()
cv2.destroyAllWindows()
&lt;/pre&gt;
&lt;h3&gt;執行結果&lt;/h3&gt;
&lt;h4&gt;得到檔案名稱為output的avi影片檔&lt;/h4&gt;&lt;/p&gt;</content><category term="OpenCv"></category></entry></feed>