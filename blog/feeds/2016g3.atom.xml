<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>機械設計專題 (虎尾科大MDE) - 2016g3</title><link href="http://project.mde.tw/blog/" rel="alternate"></link><link href="http://project.mde.tw/blog/feeds/2016g3.atom.xml" rel="self"></link><id>http://project.mde.tw/blog/</id><updated>2017-03-23T21:00:00+08:00</updated><entry><title>40323214日誌- Opencv&amp;Vrep 執行範例</title><link href="http://project.mde.tw/blog/40323214ri-zhi-opencvvrep-zhi-xing-fan-li.html" rel="alternate"></link><published>2017-03-23T21:00:00+08:00</published><updated>2017-03-23T21:00:00+08:00</updated><author><name>40323214</name></author><id>tag:project.mde.tw,2017-03-23:/blog/40323214ri-zhi-opencvvrep-zhi-xing-fan-li.html</id><summary type="html"></summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h3&gt;一.環境設定&lt;/h3&gt;

&lt;h4&gt;1.先建立一個資料夾(名稱可以自訂)，接著依循下面路徑C:\Program Files (x86)\V-REP3\V-REP_PRO_EDU\programming\remoteApiBindings找到python資料夾。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/YbLS81B.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
2.進入資料夾內，將檔案複製到建立好的資料夾中。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/PN9Ex5o.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
3.再依循路徑到C:\Program Files (x86)\V-REP3\V-REP_PRO_EDU\programming\remoteApiBindings\lib\lib\64Bit，將裡面的檔案複製到建立好的資料夾中。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/m9CUi2h.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
4.都放入建立好的資料夾後，就可以開始進行vrep的部分。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/4Olcnjg.png"&gt;
&lt;/br&gt;
&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;二.Vrep範例設定&lt;/h3&gt;
&lt;h4&gt;
1.開啟vrep後，先建立好兩個方體。
&lt;/br&gt;
&lt;/br&gt;
以下是如何建立方塊&amp;amp;更改尺寸顏色和座標的方法。
&lt;/br&gt;
&lt;/br&gt;
(1)在Scene hierarchy表單中按右鍵-&amp;gt;Add-&amp;gt;Primitive shape-&amp;gt;Cuboid。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/a9l08RD.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
(2)點選後可以直接按確定，也可以先設定好自己要的尺寸。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/7SZKKvm.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
(3)建立好兩個方塊後，可以利用下列步驟進行修改尺寸和顏色。
&lt;/br&gt;
&lt;/br&gt;
先點選下方圖示部分。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/ILfqYWp.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
接著點選尺寸設定的地方，進行尺寸更改。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/8pqZi7L.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
然後點選顏色設定的地方，進行顏色更改。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/yBmCSAx.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
(4)修改座標的部分。
&lt;/br&gt;
&lt;/br&gt;
點選下方圖示的部分就能更改物體座標，物體z座標的部分為物體z尺寸的一半。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/yc6DjPD.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
(5)建立好一個黑色方體和一個綠色圓柱以及一個藍色方體。
&lt;/br&gt;
&lt;/br&gt;
黑色方體設定
&lt;/br&gt;
尺寸:X:3 Y:3 Z:0.1
&lt;/br&gt;
座標:X:0 Y:0 Z:0.05
&lt;/br&gt;
綠色圓柱設定(可以在Primitive shape中點選Cylinder建立)
&lt;/br&gt;
尺寸:X:0.3 :Y:0.3 Z:0.1
&lt;/br&gt;
座標:X:0 Y:0 Z:0.15
&lt;/br&gt;
藍色方體設定(辨識程式中的基準)
&lt;/br&gt;
尺寸:X:0.2 Y:0.2 Z:0.01
&lt;/br&gt;
座標:X:-0.5 Y:0.5 Z:0.105
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/WfUBj33.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
(6)最後必須開啟物體的可偵測性，才能使後續的影像拍攝到物體。
&lt;/br&gt;
&lt;/br&gt;
將圖示中的選單打勾即可。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/fLHQ4kZ.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
2.建立攝影機
&lt;/br&gt;
&lt;/br&gt;
(1)點選DefaultCamera按右鍵-&amp;gt;Add-&amp;gt;Vision sensor-&amp;gt;Perspective。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/MKvYO3B.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
(2)點選圖示中的地方，更改框起來的部分。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/kXbzfZ9.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
更改的部分，分別為影像的距離和拍攝的角度以及解析度。
&lt;/br&gt;
&lt;/br&gt;
(3)接著改變攝影機的座標和拍攝方向
&lt;/br&gt;
&lt;/br&gt;
點選下列圖示部分，進行修改。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/Di9SfhL.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
座標:X:0 Y:0 Z:2.5
&lt;/br&gt;
方向部分:Alpha:180 Beta:0 Gamma:180
&lt;/br&gt;
&lt;/br&gt;
(4)建立影像屏幕
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/7Wfizry.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
(5)將屏幕與攝影機連結
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/Lzwi7X4.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
先點選Vision_sensor，在屏幕上點選右鍵-&amp;gt;View-&amp;gt;Associate view with selected vision sensor
&lt;/br&gt;
&lt;/br&gt;
(6)點選下列圖示，建立一個文件對應到攝影機上。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/ZwqhbBY.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
(7)在文件中加入simExtRemoteApiStart(19999)這行程式碼，為了連接到python的程式。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/HIBNzsC.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
(8)最後將檔案儲存於建立的資料夾中，再來就是建立python程式進行控制。
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;三.Python程式碼&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;
將下列程式碼建立好，儲存於建立的資料夾中。
&lt;/br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
#導入函式庫
from matplotlib import pyplot as plt
import vrep
import sys
import cv2
import numpy as np
import time
from scipy.spatial import distance as dist
from imutils import perspective
from imutils import contours
import argparse
import imutils

vrep.simxFinish(-1) #終止所有連接
clientID=vrep.simxStart('127.0.0.1',19999,True,True,5000,5) #設立一個連接口19999(默認地址)

if clientID!=-1:
    print ('Conexion establecida')

else:
    sys.exit("Error: no se puede conectar")

#保存參考相機
_, camhandle = vrep.simxGetObjectHandle(clientID, 'Vision_sensor', vrep.simx_opmode_oneshot_wait)
#啟動相機電源
_, resolution, image = vrep.simxGetVisionSensorImage(clientID, camhandle, 0, vrep.simx_opmode_streaming)
time.sleep(1)

while(1):
    #保存攝像機並轉換為BGR
    _, resolution, image=vrep.simxGetVisionSensorImage(clientID, camhandle, 0, vrep.simx_opmode_buffer)
    img = np.array(image, dtype = np.uint8)
    img.resize([resolution[0], resolution[1], 3])
    img = np.rot90(img,2)
    img = np.fliplr(img)
    img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)   
    #影像存檔 名為gear4
    tecla = cv2.waitKey(5) &amp; 0xFF
    file = "gear4.png"
    cv2.imwrite(file, img)



    def midpoint(ptA, ptB):
        return ((ptA[0] + ptB[0]) * 0.5, (ptA[1] + ptB[1]) * 0.5)

    ap = argparse.ArgumentParser()

#讓圖檔於開啟指令執行時輸入最左端的矩形寬度
#cmd進入py檔和圖檔所在資料夾後，輸入python 1117_distance.py --width 寬度(inch) 開啟
#寬度可直接輸入數字
    ap.add_argument("-w", "--width", type=float, required=True)

    args = vars(ap.parse_args())

#讀取圖檔→灰階→模糊
#cv2.GaussianBlur模糊程度可以用3x3, 5x5, 7x7
    img = cv2.imread("gear4.png", 1)
    Gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    gray = cv2.GaussianBlur(Gray, (3, 3), 0)

#輪廓描邊→補空&amp;侵蝕
    edged = cv2.Canny(gray, 50, 100)
    edged = cv2.dilate(edged, None, iterations=1)
    edged = cv2.erode(edged, None, iterations=1)

#進行偵測
    cnts = cv2.findContours(edged.copy(), cv2.RETR_EXTERNAL,
        cv2.CHAIN_APPROX_SIMPLE)
    cnts = cnts[0] if imutils.is_cv2() else cnts[1]

#以最左矩形四點&amp;中心為基準到其他物品的距離標示線顏色
    (cnts, _) = contours.sort_contours(cnts)
    colors = ((0, 0, 255), (240, 0, 159), (0, 165, 255), (255, 255, 0),
        (255, 0, 255))
    refObj = None

#進行一連串的輪廓校準
    for c in cnts:
    # 忽略過小的輪廓 (限定輪廓描繪範圍)
        if cv2.contourArea(c) &lt; 100: #後方的值若是太大則讀不到vrep照出來的形狀
            continue

    # 計算輪廓旋轉邊界
        gear4 = cv2.minAreaRect(c)
        gear4 = cv2.cv.BoxPoints(gear4) if imutils.is_cv2() else cv2.boxPoints(gear4)
        gear4 = np.array(gear4, dtype="int")

    # 重新設定邊界角落座標的順序, 由左上 右上 右下 左下, 順時針方向繞
        gear4 = perspective.order_points(gear4)

    # 計算物體的中心
        cX = np.average(gear4[:, 0])
        cY = np.average(gear4[:, 1])

# 以左邊邊界輪廓當基準, 當參考對象
        if refObj is None:
        # 計算物品左右邊界的中點
            (tl, tr, br, bl) = gear4
            (tlblX, tlblY) = midpoint(tl, bl)
            (trbrX, trbrY) = midpoint(tr, br)

        # 用座標法計算兩物體中心距離
            D = dist.euclidean((tlblX, tlblY), (trbrX, trbrY))
            refObj = (gear4, (cX, cY), D / args["width"])
            continue

    # 輪廓描繪
        orig = img.copy()
        cv2.drawContours(orig, [gear4.astype("int")], -1, (0, 255, 0), 2) # 其餘物品的輪廓描繪
        cv2.drawContours(orig, [refObj[0].astype("int")], -1, (0, 255, 0), 2) # 最左邊物品的輪廓描繪

    # refObj[0] = 最左邊物品輪廓邊緣的左上
    # refObj[1] = 物品中心
    # refCoords為基準物, objCoords為測量物
        refCoords = np.vstack([refObj[0], refObj[1]])
        objCoords = np.vstack([gear4, (cX, cY)])

        for ((xA, yA), (xB, yB), color) in zip(refCoords, objCoords, colors):
        # 基準物的四個角&amp;中心點 測量物的四個角&amp;中心點 點到點的距離
            cv2.circle(orig, (int(xA), int(yA)), 5, color, -1)
            cv2.circle(orig, (int(xB), int(yB)), 5, color, -1)
            cv2.line(orig, (int(xA), int(yA)), (int(xB), int(yB)), color, 2)

        #用座標距離法算出圖中的座標距離，並和實際的距離做比值，求出待測實際距離
            D = dist.euclidean((xA, yA), (xB, yB)) / refObj[2]
            (mX, mY) = midpoint((xA, yA), (xB, yB))
            cv2.putText(orig, "{:.1f}in".format(D), (int(mX), int(mY - 10)),
            cv2.FONT_HERSHEY_SIMPLEX, 0.55, color, 2)
        # "{:.1f}in" 取到小數點第一位

            cv2.imshow("Image2", orig)
            cv2.waitKey(0)

&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;
&lt;/h4&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;四.執行結果&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;
在Vrep上按下撥放，並在系統管理員上進入到建立的資料夾，打上Python test1.py -w (數字)，即可看到程式結果。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/CaEMD7w.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/hACkkS6.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;iframe src="https://player.vimeo.com/video/208655475" width="640" height="361" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;&lt;a href="https://vimeo.com/208655475"&gt;0316_vrep+opencv&lt;/a&gt; from &lt;a href="https://vimeo.com/user32554456"&gt;Wan Jing Huang&lt;/a&gt; on &lt;a href="https://vimeo.com"&gt;Vimeo&lt;/a&gt;.&lt;/p&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;/h4&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h3&gt;五.引用文獻&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;
1.Tutorial de Vrep y OpenCV-Python:http://robologs.net/2016/07/07/tutorial-de-vrep-y-opencv-python/ 
&lt;/h4&gt;&lt;/p&gt;</content><category term="OpenCv"></category></entry><entry><title>40323203&amp;05&amp;06日誌 - Mark Number</title><link href="http://project.mde.tw/blog/403232030506ri-zhi-mark-number.html" rel="alternate"></link><published>2017-03-23T10:30:00+08:00</published><updated>2017-03-23T10:30:00+08:00</updated><author><name>40323205</name></author><id>tag:project.mde.tw,2017-03-23:/blog/403232030506ri-zhi-mark-number.html</id><summary type="html">&lt;p&gt;以矩形框起辨識的物體，並依序標上記號。&lt;/p&gt;
</summary><content type="html">&lt;p&gt;以矩形框起辨識的物體，並依序標上記號。&lt;/p&gt;


&lt;h3&gt;★範例所使用的圖檔下載位置&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://imgur.com/pSaQUS0"&gt; http://imgur.com/pSaQUS0 &lt;/a&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★程式範例執行&lt;/h3&gt;

&lt;pre class="brush: bash"&gt;
from imutils import contours
import numpy as np
import argparse
import imutils
import cv2

def order_points_old(pts):
    #設定物體輪廓之四個點位置,左上右上右下左下(順時針)
    rect = np.zeros((4, 2), dtype="float32")

    s = pts.sum(axis=1)
    rect[0] = pts[np.argmin(s)]
    rect[2] = pts[np.argmax(s)]

    return rect

ap = argparse.ArgumentParser()
args = vars(ap.parse_args())

image = cv2.imread("03.png")
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
gray = cv2.GaussianBlur(gray, (7, 7), 0)

edged = cv2.Canny(gray, 50, 100)
edged = cv2.dilate(edged, None, iterations=1)
edged = cv2.erode(edged, None, iterations=1)

cnts = cv2.findContours(edged.copy(), cv2.RETR_EXTERNAL,
    cv2.CHAIN_APPROX_SIMPLE)
cnts = cnts[0] if imutils.is_cv2() else cnts[1]

#以順時針順序排列(刪除即相反)
(cnts, _) = contours.sort_contours(cnts)


for (i, c) in enumerate(cnts):

    if cv2.contourArea(c) &lt; 100:
        continue

    box = cv2.minAreaRect(c)
    box = cv2.cv.BoxPoints(box) if imutils.is_cv2() else cv2.boxPoints(box)
    box = np.array(box, dtype="int")
    cv2.drawContours(image, [box], -1, (0, 255, 200), 2)

    rect = order_points_old(box)

    cv2.putText(image, "Object #{}".format(i + 1),
        (int(rect[0][0] - 15), int(rect[0][1] - 15)),
        cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255, 200), 1)

    cv2.imshow("Image", image)
    cv2.waitKey(0)
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;★範例執行結果&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/ba1iTGT.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/N3YDrXP.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/iyCA4By.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★細部程式介紹&lt;/h3&gt;

&lt;p&gt;【numpy.sum】
&lt;/br&gt;
&lt;/br&gt;
◎使用格式：
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/nFmBGRe.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
◎範例程式：
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/JrkElRH.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
【numpy.diff】
&lt;/br&gt;
&lt;/br&gt;
◎使用格式：
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/casg6ha.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
◎範例程式：
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/8Z7jhoW.png"&gt;
&lt;/br&gt;&lt;/p&gt;</content><category term="Kmol &amp; OpenCV &amp; Python"></category></entry><entry><title>40323203&amp;05&amp;06日誌 - Measuring size</title><link href="http://project.mde.tw/blog/403232030506ri-zhi-measuring-size.html" rel="alternate"></link><published>2017-03-20T10:30:00+08:00</published><updated>2017-03-20T10:30:00+08:00</updated><author><name>40323206</name></author><id>tag:project.mde.tw,2017-03-20:/blog/403232030506ri-zhi-measuring-size.html</id><summary type="html">&lt;p&gt;辨識圖片中物體的最大長寬
&lt;/br&gt;
Measuring distance between objects in an image&lt;/p&gt;
</summary><content type="html">&lt;p&gt;辨識圖片中物體的最大長寬
&lt;/br&gt;
Measuring distance between objects in an image&lt;/p&gt;


&lt;h3&gt;★範例所使用的圖檔下載位置&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://imgur.com/pSaQUS0"&gt;http://imgur.com/pSaQUS0&lt;/a&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★程式範例執行&lt;/h3&gt;

&lt;pre class="brush: bash"&gt;
#以圖片最左物體最大寬為基準，量測其他物體最大長寬
from scipy.spatial import distance as dist
from imutils import perspective
from imutils import contours
import numpy as np
import argparse
import imutils
import cv2

def midpoint(ptA, ptB):
    return ((ptA[0] + ptB[0]) * 0.5, (ptA[1] + ptB[1]) * 0.5)


# 構造參數解析跟解析參數
ap = argparse.ArgumentParser()
ap.add_argument("-i", "--image", required=True,
    help="指定要開啟的圖檔 ")
ap.add_argument("-w", "--width", type=float, required=True,
    help="最左物體最大寬度 (英吋)")
args = vars(ap.parse_args())


# 讀取圖檔→灰階→模糊
# cv2.GaussianBlur模糊程度可以用3x3, 5x5, 7x7
image = cv2.imread(args["image"])
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
gray = cv2.GaussianBlur(gray, (7, 7), 0)

# 輪廓描邊→補空&amp;侵蝕
edged = cv2.Canny(gray, 50, 100)
edged = cv2.dilate(edged, None, iterations=1)
edged = cv2.erode(edged, None, iterations=1)


# 進行偵測
cnts = cv2.findContours(edged.copy(), cv2.RETR_EXTERNAL,
    cv2.CHAIN_APPROX_SIMPLE)
cnts = cnts[0] if imutils.is_cv2() else cnts[1]

# 'pixels Per Metric' = object_width / know_width (相機像素 / 已知物品的寬度)
(cnts, _) = contours.sort_contours(cnts)
pixelsPerMetric = None

# 進行一連串的輪廓校準
for c in cnts:

    # 忽略過小的輪廓 (限定輪廓描繪範圍)
    if cv2.contourArea(c) &lt; 100:
        continue

    # 計算輪廓旋轉邊界
    orig = image.copy()
    box = cv2.minAreaRect(c)
    box = cv2.cv.BoxPoints(box) if imutils.is_cv2() else cv2.boxPoints(box)
    box = np.array(box, dtype="int")

    # 繪製輪廓旋轉邊界
    box = perspective.order_points(box)
    cv2.drawContours(orig, [box.astype("int")], -1, (0, 255, 0), 2)

    # 繪製物體角落之點
    for (x, y) in box:
        cv2.circle(orig, (int(x), int(y)), 5, (0, 0, 255), -1)

    # 計算物品上下邊界之中點
    (tl, tr, br, bl) = box
    (tltrX, tltrY) = midpoint(tl, tr)
    (blbrX, blbrY) = midpoint(bl, br)

    # 計算物品左右邊界之中點
    (tlblX, tlblY) = midpoint(tl, bl)
    (trbrX, trbrY) = midpoint(tr, br)

    # 物品邊界的四個中點設定條件
    cv2.circle(orig, (int(tltrX), int(tltrY)), 5, (255, 0, 0), -1)
    cv2.circle(orig, (int(blbrX), int(blbrY)), 5, (255, 0, 0), -1)
    cv2.circle(orig, (int(tlblX), int(tlblY)), 5, (255, 0, 0), -1)
    cv2.circle(orig, (int(trbrX), int(trbrY)), 5, (255, 0, 0), -1)

    # 物品邊界的四個中點連線設定條件
    cv2.line(orig, (int(tltrX), int(tltrY)), (int(blbrX), int(blbrY)),
        (255, 0, 255), 2)
    cv2.line(orig, (int(tlblX), int(tlblY)), (int(trbrX), int(trbrY)),
        (255, 0, 255), 2)

            # 利用歐式定理算中點之間的距離
    dA = dist.euclidean((tltrX, tltrY), (blbrX, blbrY))
    dB = dist.euclidean((tlblX, tlblY), (trbrX, trbrY))

    # 如果未知 'pixelsPerMetric', 則使用下一行之算式
    if pixelsPerMetric is None:
        pixelsPerMetric = dB / args["width"]

    # 計算物品之中心
    dimA = dA / pixelsPerMetric
    dimB = dB / pixelsPerMetric

    # 顯示出畫面中物品的大小
    cv2.putText(orig, "{:.1f}in".format(dimA),
        (int(tltrX - 15), int(tltrY - 10)), cv2.FONT_HERSHEY_SIMPLEX,
        0.65, (255, 255, 255), 2)
    cv2.putText(orig, "{:.1f}in".format(dimB),
        (int(trbrX + 10), int(trbrY)), cv2.FONT_HERSHEY_SIMPLEX,
        0.65, (255, 255, 255), 2)

    cv2.imshow("Image", orig)
    cv2.waitKey(0)     
&lt;/pre&gt;

&lt;h4&gt;
◎輸入指令
&lt;/br&gt;
&lt;img src="http://i.imgur.com/pKNMwov.png"&gt;
&lt;/br&gt;
&lt;/h4&gt;

&lt;h3&gt;★範例執行結果&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;img src="http://i.imgur.com/66Bs8iR.png"&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/2AGmOeE.png"&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/rL4eMd8.png"&gt;
&lt;/br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★Numpy &amp; Scipy 運用的主要數學計算&lt;/h3&gt;

&lt;h4&gt;
用numpy找出物體四個邊界的中心
&lt;/br&gt;
用scipy進行長度換算，換算的方式是用座標法：
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/sSEWyxe.jpg"&gt;
&lt;/br&gt;
&lt;/br&gt;
◎計算過程
&lt;/br&gt;
1.以一開始輸入基準物(最左的物體)的實際寬度和用座標法在圖片中算出的寬度做比值
&lt;/br&gt;
2.中心點分別為上下、左右，測量出圖片中兩線段長
&lt;/br&gt;
3.把第二步驟求出的線段長帶入第一步驟求出的比值，算出待測物的最大長寬
&lt;/h4&gt;</content><category term="Kmol &amp; OpenCV &amp; Python"></category></entry><entry><title>40323203&amp;05&amp;06日誌 - Measuring distance</title><link href="http://project.mde.tw/blog/403232030506ri-zhi-measuring-distance.html" rel="alternate"></link><published>2017-03-06T19:30:00+08:00</published><updated>2017-03-06T19:30:00+08:00</updated><author><name>40323206</name></author><id>tag:project.mde.tw,2017-03-06:/blog/403232030506ri-zhi-measuring-distance.html</id><summary type="html">&lt;p&gt;辨識圖片中兩物體的實際距離
&lt;/br&gt;
Measuring distance between objects in an image&lt;/p&gt;
</summary><content type="html">&lt;p&gt;辨識圖片中兩物體的實際距離
&lt;/br&gt;
Measuring distance between objects in an image&lt;/p&gt;


&lt;h3&gt;★範例所使用的圖檔下載位置&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://imgur.com/pSaQUS0"&gt;http://imgur.com/pSaQUS0&lt;/a&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★程式範例執行&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
#以圖片最左矩形寬作為依據的距離測量
from scipy.spatial import distance as dist
from imutils import perspective
from imutils import contours
import numpy as np
import argparse
import imutils
import cv2

def midpoint(ptA, ptB):
    return ((ptA[0] + ptB[0]) * 0.5, (ptA[1] + ptB[1]) * 0.5)

ap = argparse.ArgumentParser()

#讓圖檔於開啟指令執行時輸入最左端的矩形寬度
#cmd進入py檔和圖檔所在資料夾後，輸入python 1117_distance.py --width 寬度(inch) 開啟
#寬度可直接輸入數字
ap.add_argument("-w", "--width", type=float, required=True)

args = vars(ap.parse_args())

#讀取圖檔→灰階→模糊
#cv2.GaussianBlur模糊程度可以用3x3, 5x5, 7x7
img = cv2.imread("gear4.png", 1)
Gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
gray = cv2.GaussianBlur(Gray, (3, 3), 0)

#輪廓描邊→補空&amp;侵蝕
edged = cv2.Canny(gray, 50, 100)
edged = cv2.dilate(edged, None, iterations=1)
edged = cv2.erode(edged, None, iterations=1)

#進行偵測
cnts = cv2.findContours(edged.copy(), cv2.RETR_EXTERNAL,
    cv2.CHAIN_APPROX_SIMPLE)
cnts = cnts[0] if imutils.is_cv2() else cnts[1]

#以最左矩形四點&amp;中心為基準到其他物品的距離標示線顏色
(cnts, _) = contours.sort_contours(cnts)
colors = ((0, 0, 255), (240, 0, 159), (0, 165, 255), (255, 255, 0),
    (255, 0, 255))
refObj = None

#進行一連串的輪廓校準
for c in cnts:
    # 忽略過小的輪廓 (限定輪廓描繪範圍)
    if cv2.contourArea(c) &lt; 1500:
        continue

    # 計算輪廓旋轉邊界
    gear4 = cv2.minAreaRect(c)
    gear4 = cv2.cv.BoxPoints(gear4) if imutils.is_cv2() else cv2.boxPoints(gear4)
    gear4 = np.array(gear4, dtype="int")

    # 重新設定邊界角落座標的順序, 由左上 右上 右下 左下, 順時針方向繞
    gear4 = perspective.order_points(gear4)

    # 計算物體的中心
    cX = np.average(gear4[:, 0])
    cY = np.average(gear4[:, 1])

# 以左邊邊界輪廓當基準, 當參考對象
    if refObj is None:
        # 計算物品左右邊界的中點
        (tl, tr, br, bl) = gear4
        (tlblX, tlblY) = midpoint(tl, bl)
        (trbrX, trbrY) = midpoint(tr, br)

        # 用座標法計算兩物體中心距離
        D = dist.euclidean((tlblX, tlblY), (trbrX, trbrY))
        refObj = (gear4, (cX, cY), D / args["width"])
        continue

    # 輪廓描繪
    orig = img.copy()
    cv2.drawContours(orig, [gear4.astype("int")], -1, (0, 255, 0), 2) # 其餘物品的輪廓描繪
    cv2.drawContours(orig, [refObj[0].astype("int")], -1, (0, 255, 0), 2) # 最左邊物品的輪廓描繪


    # refCoords為基準物, objCoords為測量物
    refCoords = np.vstack([refObj[0], refObj[1]])
    objCoords = np.vstack([gear4, (cX, cY)])

    for ((xA, yA), (xB, yB), color) in zip(refCoords, objCoords, colors):
        # 基準物的四個角&amp;中心點 測量物的四個角&amp;中心點 點到點的距離
        cv2.circle(orig, (int(xA), int(yA)), 5, color, -1)
        cv2.circle(orig, (int(xB), int(yB)), 5, color, -1)
        cv2.line(orig, (int(xA), int(yA)), (int(xB), int(yB)), color, 2)

        #用座標距離法算出圖中的座標距離，並和實際的距離做比值，求出待測實際距離
        D = dist.euclidean((xA, yA), (xB, yB)) / refObj[2]
        (mX, mY) = midpoint((xA, yA), (xB, yB))
        cv2.putText(orig, "{:.1f}in".format(D), (int(mX), int(mY - 10)),
        cv2.FONT_HERSHEY_SIMPLEX, 0.55, color, 2)
        # "{:.1f}in" 取到小數點第一位

        cv2.imshow("Image", orig)
        cv2.waitKey(0)

&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;★範例執行結果&lt;/h3&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/RmMEEJw.jpg"&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/A1h453s.jpg"&gt;
&lt;/br&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★Numpy &amp; Scipy 運用的主要數學計算&lt;/h3&gt;

&lt;h4&gt;
用numpy找出物體的中心
&lt;/br&gt;
用scipy進行距離計算，計算的方式是用座標法：
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/sSEWyxe.jpg"&gt;
&lt;/br&gt;
&lt;/br&gt;
◎計算過程
&lt;/br&gt;
1.以一開始輸入基準物(最左的物體)的實際寬度和用座標法在圖片中算出的寬度做比值
&lt;/br&gt;
2.分別假設基準物和待測物的座標為(X1,Y1)和(X2,Y2)帶入座標法計算出圖片中的距離
&lt;/br&gt;
3.把第二步驟求出的距離帶入第一步驟求出的比值，算出待測物的實際距離
&lt;/h4&gt;

&lt;h3&gt;★細部程式介紹&lt;/h3&gt;

&lt;h4&gt;
【cv2.GaussianBlur】圖像模糊
&lt;/br&gt;
&lt;/br&gt;
◎使用格式：
&lt;/br&gt;
&lt;img src="http://i.imgur.com/PLY5k4D.jpg"&gt;
&lt;/br&gt;
&lt;/br&gt;
◎範例程式
&lt;/br&gt;
&lt;pre class="brush: bash"&gt;
import cv2

img = cv2.imread('gear4.png')

# cv2.GaussianBlur模糊程度可以用3x3, 5x5, 7x7
# cv2.blur指令: blur = cv2.blur(img, (5,5))
# 相較於 cv2.blur, cv2.GaussianBlur多一個參數color σ（顏色空間的標準差），此數值越大使得模糊效果更明顯
blur = cv2.GaussianBlur(img, (5,5), 0)

cv2.imshow("Image", blur)
cv2.waitKey(0)
&lt;/pre&gt;
&lt;/br&gt;
◎結果：
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/E4SpYIr.jpg"&gt;

&lt;/br&gt;
&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;
【cv2.Canny &amp; cv2.dilate &amp; cv2.erode】描繪輪廓→擴張輪廓→修邊侵蝕
&lt;/br&gt;
&lt;/br&gt;
◎使用格式：
&lt;/br&gt;
&lt;img src="http://i.imgur.com/tUUUeEQ.jpg"&gt;
&lt;img src="http://i.imgur.com/C7ngCSo.jpg"&gt;
&lt;img src="http://i.imgur.com/YjrILr2.jpg"&gt;
&lt;/br&gt;
&lt;/br&gt;
◎範例程式
&lt;/br&gt;
&lt;pre class="brush: bash"&gt;
import cv2

img = cv2.imread('gear4.png',0)
edges = cv2.Canny(img,10,50)
edged = cv2.dilate(edges, None, iterations=1)
erosion = cv2.erode(edged,None,iterations = 1)

cv2.imshow("Image1", edges)
cv2.imshow("Image2", edged)
cv2.imshow("Image3", erosion)
cv2.waitKey(0)
&lt;/pre&gt;
&lt;/br&gt;
◎結果：
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/jNVKqS6.jpg"&gt;
&lt;img src="http://i.imgur.com/2qZJ5Z8.jpg"&gt;
&lt;img src="http://i.imgur.com/VLVWr8G.jpg"&gt;
&lt;/br&gt;
&lt;/h4&gt;</content><category term="Kmol &amp; OpenCV &amp; Python"></category></entry><entry><title>40323214日誌- Install Scipy on windows</title><link href="http://project.mde.tw/blog/40323214ri-zhi-install-scipy-on-windows.html" rel="alternate"></link><published>2017-01-20T21:00:00+08:00</published><updated>2017-01-20T21:00:00+08:00</updated><author><name>40323214</name></author><id>tag:project.mde.tw,2017-01-20:/blog/40323214ri-zhi-install-scipy-on-windows.html</id><summary type="html"></summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h3&gt;一.Scipy基本介紹&lt;/h3&gt;

&lt;h4&gt;SciPy是一個開源的Python演算法庫和數學工具包。
&lt;/br&gt;
SciPy包含的模組有最佳化、線性代數、積分、插值、特殊函式、快速傅立葉變換、訊號處理和圖像處理、常微分方程求解和其他科學與工程中常用的計算。與其功能相類似的軟體還有MATLAB、GNU Octave和Scilab。
&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;二.安裝過程&lt;/h3&gt;
&lt;h4&gt;1.首先到http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy 網址中下載對應python(3.4.4)版本的whl檔案。Numpy這個函式庫也可以在這邊下載http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/lmr28o6.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/4gJaBxP.png"&gt;
&lt;/br&gt;
2.接著利用系統管理員找到載好檔案的路徑。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/jpFKDDm.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
3.再來打上對應python版本資料夾的路徑，進到scripts中，打上pip install "載好檔案的名稱前兩個英文字再按tab鍵"也就是"sc然後按tab或是nu再按tab"按下enter後就會開始下載了。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/YOZfiTb.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
4.最後在python的互動端中，使用Import測試是否有安裝成功。
&lt;/br&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/UmOR6zH.png"&gt;
&lt;/h4&gt;
&lt;h3&gt;三.安裝原因&lt;/h3&gt;
&lt;h4&gt;
1.在Opencv執行範例時需要使用。
&lt;/br&gt;
&lt;/br&gt;
2.由於直接使用pip install scipy無法正常下載，所以上網找了其他的安裝方法。
&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;四.參考的網頁資料&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;
1.維基百科:https://zh.wikipedia.org/zh-tw/SciPy
&lt;/br&gt;
&lt;/br&gt;
2.whl檔載點:http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy
&lt;/br&gt;
&lt;/br&gt;
3.下載步驟參考影片:https://www.youtube.com/watch?v=jnpC_Ib_lbc
&lt;/h4&gt;&lt;/p&gt;</content><category term="OpenCv"></category></entry><entry><title>40323214日誌-齒輪計算</title><link href="http://project.mde.tw/blog/40323214ri-zhi-chi-lun-ji-suan.html" rel="alternate"></link><published>2016-11-23T10:00:00+08:00</published><updated>2016-11-23T10:00:00+08:00</updated><author><name>40323214</name></author><id>tag:project.mde.tw,2016-11-23:/blog/40323214ri-zhi-chi-lun-ji-suan.html</id><summary type="html"></summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h3&gt;一.齒輪的公式轉換&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;執行程式&lt;/h4&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import math
import sympy
from sympy import pi
#a=壓力角
#算節圓直徑
def tes1(m,t):
    d=m*t
    return(d)

#有效齒深
def tes2(m):
    h=2*m
    return(h)

#算模數 d1=外徑
def tes3(d1):
    m=d1/(t+2)
    return(m)

#基圓直徑
def tes4(d,a):
    dg=d *math.cos(a)
    return(dg)

#周節
def tes5(m):
    t0=pi.evalf()*m
    return(t0)
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;二.執行後心得&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;以上程式是關於計算正齒輪的數值，在小組做出辨識齒輪的外徑以及尺數之後，導入上述程式可以求得齒輪其他的數值，例如模數、節圓直徑...等。
&lt;/br&gt;
&lt;/br&gt;
而辨識出壓力角之後，就可以再計算更多關於齒輪的數值。
&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;三.執行後問題&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;
在寫完這些程式之後，發現 sympy函式庫出現問題"No module named 'sympy'"，而原因是導入pi這個函式需要使用到sympy，所以自己在網路上找了解答，發現原來是環境裡面並沒有這個函式庫，於是我從"https://pypi.python.org/pypi/sympy"網址中下載了安裝檔，並且把所需的資料拉進環境路徑裡面，就能夠正常執行計算式子。
&lt;/h4&gt;
&lt;/br&gt;
&lt;h3&gt;五.參考的網頁資料&lt;/h3&gt;
&lt;/br&gt;
&lt;h4&gt;
1.齒輪計算公式:http://coccad.com/subject/about/2427.html
&lt;/br&gt;
&lt;/br&gt;
2.Sympy安裝網頁:https://pypi.python.org/pypi/sympy
&lt;/br&gt;
&lt;/h4&gt;&lt;/p&gt;</content><category term="OpenCv"></category></entry><entry><title>40323205日誌 - OpenCV (繪圖函式)</title><link href="http://project.mde.tw/blog/40323205ri-zhi-opencv-hui-tu-han-shi.html" rel="alternate"></link><published>2016-11-17T22:30:00+08:00</published><updated>2016-11-17T22:30:00+08:00</updated><author><name>40323205</name></author><id>tag:project.mde.tw,2016-11-17:/blog/40323205ri-zhi-opencv-hui-tu-han-shi.html</id><summary type="html">&lt;h4&gt;繪圖函式 - cv2.line, cv2.circle, cv2.rectangle, cv2.ellipse&lt;/h4&gt;

</summary><content type="html">&lt;h4&gt;繪圖函式 - cv2.line, cv2.circle, cv2.rectangle, cv2.ellipse&lt;/h4&gt;



&lt;h4&gt;目前電腦都可畫出線、矩形、圓、橢圓，並更改黑色背景大小。&lt;/h4&gt;

&lt;h3&gt;【畫線】&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/dC0Jpmg.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;【畫線-程式範例執行】&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2

# 建立一個黑色背景
img = np.zeros((512,512,3), np.uint8)

# 以寬度 5 px 畫一條藍色的對角線
img = cv2.line(img,(0,0),(511,511),(255,0,0),5)
# 呈現此影像
cv2.imshow('image',img)
cv2.waitKey(0)
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;【畫矩形】&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/xHEpGBC.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;【畫矩形-程式範例執行】&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2

# 建立一個黑色背景
img = np.zeros((200,200,3), np.uint8)

# 以寬度 5 px 畫一條藍色的對角線
img = cv2.rectangle(img,(10,10),(100,150),(0,255,0),10)
# 呈現此影像
cv2.imshow('image',img)
cv2.waitKey(0)
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;【畫圓】&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/pIBit41.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;【畫圓-程式範例執行】&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2

# 建立一個黑色背景
img = np.zeros((300,300,3), np.uint8)

# 以寬度 5 px 畫一條藍色的對角線
img = cv2.circle(img,(100,150), 100, (0,0,255), -1)
# 呈現此影像
cv2.imshow('image',img)
cv2.waitKey(0)
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;【畫橢圓】&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/wkuBhn5.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;【畫橢圓-程式範例執行】&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2

# 建立一個黑色背景
img = np.zeros((450,450,3), np.uint8)

# 以寬度 5 px 畫一條藍色的對角線
img = cv2.ellipse(img,(256,256),(100,50),20,150,360, (255,0,255),3)
# 呈現此影像
cv2.imshow('image',img)
cv2.waitKey(0)
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;後記 - 目前正在研究其他OpenCV程式，在這裡先呈現最基礎的繪圖函式。&lt;/h4&gt;</content><category term="Kmol &amp; OpenCV"></category></entry><entry><title>40323203日誌 - OpenCV(載入圖像)</title><link href="http://project.mde.tw/blog/40323203ri-zhi-opencvzai-ru-tu-xiang.html" rel="alternate"></link><published>2016-11-17T22:00:00+08:00</published><updated>2016-11-17T22:00:00+08:00</updated><author><name>40323203</name></author><id>tag:project.mde.tw,2016-11-17:/blog/40323203ri-zhi-opencvzai-ru-tu-xiang.html</id><summary type="html">&lt;h3&gt;載入圖片及影像--cv2.imread,cv2.VideoCapture&lt;/h3&gt;

</summary><content type="html">&lt;h3&gt;載入圖片及影像--cv2.imread,cv2.VideoCapture&lt;/h3&gt;



&lt;hr&gt;
&lt;h4&gt;載入圖片程式&lt;/h4&gt;

&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2

#載入jpg圖檔
#imread:讀取圖片，並將資料寫入Mat/flags:影像標誌
#IMREAD_COLOR:彩色模式可用1表示
#IMREAD_GRAYSCALE:灰度圖可用0表示
#IMREAD_UNCHANGED:透明度可用-1表示
image = cv2.imread("DSC00040.jpg", flags=cv2.IMREAD_COLOR)

#WINDOW_NORMAL:調節窗口大小
#WINDOW_AUTOSIZE:固定窗口大小
cv2.namedWindow('image',cv2.WINDOW_NORMAL) 

cv2.imshow('image',image) 
cv2.waitKey(0) 
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h4&gt;顯示圖片結果可為彩色及黑白:&lt;/h4&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/1nXHjD7.png"&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;/br&gt;
&lt;h4&gt;載入影片程式&lt;/h4&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2

#Capture:拍攝,紀錄
cap = cv2.VideoCapture('00007.avi')

while(cap.isOpened()):
    ret, frame = cap.read()

    #cvtColor：轉換影像色域，程式以轉換RGB到gray為例
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    cv2.imshow('frame',gray)
    if cv2.waitKey(6) &amp; 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()
&lt;/pre&gt;</content><category term="Kmol &amp; OpenCV"></category></entry><entry><title>40323206日誌 - OpenCV (Dots)</title><link href="http://project.mde.tw/blog/40323206ri-zhi-opencv-dots.html" rel="alternate"></link><published>2016-11-15T20:53:00+08:00</published><updated>2016-11-15T20:53:00+08:00</updated><author><name>40323206</name></author><id>tag:project.mde.tw,2016-11-15:/blog/40323206ri-zhi-opencv-dots.html</id><summary type="html">&lt;p&gt;物體角落(點)的辨識 --- cv2.cornerHarris &amp;amp; cv2.dilate&lt;/p&gt;
</summary><content type="html">&lt;p&gt;物體角落(點)的辨識 --- cv2.cornerHarris &amp;amp; cv2.dilate&lt;/p&gt;


&lt;h3&gt;★cv2.cornerHarris的使用&amp;格式&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/zne7h7s.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★範例所使用的圖檔下載位置&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://imgur.com/F05kwRB"&gt;http://imgur.com/F05kwRB&lt;/a&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★程式範例執行&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import cv2
import numpy as np

filename = 'chessboard.png'
img = cv2.imread(filename)
gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)

gray = np.float32(gray)
dst = cv2.cornerHarris(gray,2,3,0.04)

#result is dilated for marking the corners, not important
dst = cv2.dilate(dst,None)

# Threshold for an optimal value, it may vary depending on the image.
img[dst&gt;0.01*dst.max()]=[0,0,255]

cv2.imshow('dst',img)
if cv2.waitKey(0) &amp; 0xff == 27:
    cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★範例執行(已灰階)前後之比較&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/chMPHbO.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★套用於齒輪辨識&lt;/h3&gt;

&lt;h4&gt;
有包含圓和圓心的辨識&amp;單獨作角落抓點
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
from matplotlib import pyplot as plt

img = cv2.imread("gear2.png", 1)
imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
cv2.imwrite('graygear.png', imgGray)

# 抓點
gray = np.float32(imgGray)
dst = cv2.cornerHarris(gray,2,3,0.04)

# result is dilated for marking the corners, not important
dst = cv2.dilate(dst,None)

# Threshold for an optimal value, it may vary depending on the image.
img[dst&gt;0.01*dst.max()]=[0,0,255]

cv2.imshow('dst',img)

# 抓圓
circles = cv2.HoughCircles(imgGray,cv2.HOUGH_GRADIENT,1,20,
                            param1=60,param2=50,minRadius=0,maxRadius=60)

circles = np.uint16(np.around(circles))
for i in circles[0,:]:
    # draw the outer circle
    cv2.circle(img,(i[0],i[1]),i[2],(255,0,255),2)
    # draw the center of the circle
    cv2.circle(img,(i[0],i[1]),2,(0,0,255),3)

cv2.imshow('detected circles',img)


cv2.waitKey(0)


cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;/br&gt;

&lt;h3&gt;★齒輪辨識目的&lt;/h3&gt;
&lt;h4&gt;配合之前的圓心可以初步抓出齒輪的外徑、內徑，方便之後直行計算相關程式的條件。&lt;/h4&gt;
&lt;/br&gt;

&lt;h3&gt;★齒輪辨識結果&lt;/h3&gt;
&lt;img src="http://i.imgur.com/116TeT4.jpg"&gt;
&lt;/br&gt;</content><category term="Kmol &amp; OpenCV"></category></entry><entry><title>40323206日誌 - OpenCV (Circles)</title><link href="http://project.mde.tw/blog/40323206ri-zhi-opencv-circles.html" rel="alternate"></link><published>2016-11-14T20:16:00+08:00</published><updated>2016-11-14T20:16:00+08:00</updated><author><name>40323206</name></author><id>tag:project.mde.tw,2016-11-14:/blog/40323206ri-zhi-opencv-circles.html</id><summary type="html">&lt;p&gt;圓形的辨識 --- cv2.HoughCircles&lt;/p&gt;
</summary><content type="html">&lt;p&gt;圓形的辨識 --- cv2.HoughCircles&lt;/p&gt;


&lt;h3&gt;★cv2.HoughCircles的使用&amp;格式&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/sSe92Wx.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★範例所使用的圖檔下載位置&lt;/h3&gt;

&lt;p&gt;&lt;a href="http://imgur.com/EyLp3Qx"&gt;http://imgur.com/EyLp3Qx&lt;/a&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★程式範例執行&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import cv2
import numpy as np

img = cv2.imread('opencv_logo.png',0)
img = cv2.medianBlur(img,5)
cimg = cv2.cvtColor(img,cv2.COLOR_GRAY2BGR)

circles = cv2.HoughCircles(img,cv2.HOUGH_GRADIENT,
                            1,20,
                            param1=50,
                            param2=40, 
                            minRadius=0,
                            maxRadius=0)

circles = np.uint16(np.around(circles))
for i in circles[0,:]:
    # draw the outer circle
    cv2.circle(cimg,(i[0],i[1]),i[2],(0,255,0),3)
    # draw the center of the circle
    cv2.circle(cimg,(i[0],i[1]),2,(0,0,255),3)

cv2.imshow('detected circles',cimg)
cv2.waitKey(0)
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★範例執行前後之比較&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/fSWa1OC.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★套用於齒輪辨識&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import numpy as np
import cv2
from matplotlib import pyplot as plt

# 讀取圖檔
img = cv2.imread("gear1.png", 1)
# 圖檔轉灰階
imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# 灰階後進行存檔
cv2.imwrite('graygear.png', imgGray)

# 使用灰階圖抓圓
circles = cv2.HoughCircles(imgGray,cv2.HOUGH_GRADIENT,
                            1,20,
                            param1=60,
                            param2=50,
                            minRadius=0,
                            maxRadius=60)

circles = np.uint16(np.around(circles))
for i in circles[0,:]:
    # 圓形的繪製
    cv2.circle(img,(i[0],i[1]),i[2],(255,0,255),2)
    # 圓心的繪製
    cv2.circle(img,(i[0],i[1]),2,(0,0,255),3)

cv2.imshow('detected circles',img)

cv2.waitKey(0)
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★齒輪辨識目的&lt;/h3&gt;

&lt;h4&gt;找出齒輪的圓心位置，方便之後直行計算相關程式的條件。&lt;/h4&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;★齒輪辨識結果&lt;/h3&gt;

&lt;p&gt;&lt;img src="http://i.imgur.com/1gvQ3vH.jpg"&gt;
&lt;/br&gt;&lt;/p&gt;</content><category term="Kmol &amp; OpenCV"></category></entry><entry><title>40323214日誌-Opencv範例</title><link href="http://project.mde.tw/blog/40323214ri-zhi-opencvfan-li.html" rel="alternate"></link><published>2016-08-04T15:00:00+08:00</published><updated>2016-08-04T15:00:00+08:00</updated><author><name>40323214</name></author><id>tag:project.mde.tw,2016-08-04:/blog/40323214ri-zhi-opencvfan-li.html</id><summary type="html"></summary><content type="html">&lt;!-- PELICAN_END_SUMMARY --&gt;

&lt;h3&gt;一.Windows執行範例程式&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;1.範例程式&lt;/h4&gt;
&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import cv2
import sys

cascPath = "haarcascade_frontalface_default.xml"
faceCascade = cv2.CascadeClassifier(cascPath)

video_capture = cv2.VideoCapture(0)

while True:
    # 逐一以影格取像
    ret, frame = video_capture.read()

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    faces = faceCascade.detectMultiScale(
        gray,
        scaleFactor=1.1,
        minNeighbors=5,
        minSize=(30, 30),
        flags=cv2.CASCADE_SCALE_IMAGE
     )

    # 在辨識的臉形外圍畫一個矩形
    for (x, y, w, h) in faces:
        cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 0), 2)

    # 呈現影像
    cv2.imshow('Video', frame)

    if cv2.waitKey(1) &amp; 0xFF == ord('q'):
        break

# 停止執行
video_capture.release()
cv2.destroyAllWindows()
&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;2.執行結果&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/H6NpM2F.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;二.網路上的相關範例&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;pre class="brush: bash"&gt;
import cv2
from webcam_gui import webcam_gui

def imgproc(frame):

    # convert color to gray scale and show it
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    cv2.imshow('gray', gray)

    blur = cv2.blur(gray, (5,5))
    edge = cv2.Canny(blur, 30, 100)
    edge = cv2.blur(edge, (2,2))
    cv2.imshow('blured edge', edge)


    # convert image to black and white and show it
    thresh1, thresh = cv2.threshold(edge, 60, 255, cv2.THRESH_BINARY)
    cv2.imshow('thresh', thresh)

    # find contours!
    _,contours, hry = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

    # draw all the contours
    cpframe = frame.copy()
    cv2.drawContours(cpframe, contours, -1, (0,255,0), 3)
    cv2.imshow('cpframe', cpframe)

    # ================== TODO ===================

    # Modify these code to suit your need
    contours = [ctr for ctr in contours if cv2.contourArea(ctr) &gt; 100]
    contours = [cv2.approxPolyDP(ctr, 5 , True) for ctr in contours]
    contours = [ctr for ctr in contours if cv2.isContourConvex(ctr)]

    # ============================================


    # draw on the frame
    cv2.drawContours(frame, contours, -1, (0,255,0), 3)

    return frame

if __name__ == "__main__":
    webcam_gui(imgproc, video_src=0)

&lt;/pre&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h4&gt;1.執行結果&lt;/h4&gt;
&lt;/br&gt;
&lt;img src="http://i.imgur.com/J9Z93mG.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;h3&gt;三.執行範例後心得&lt;/h3&gt;

&lt;p&gt;&lt;/br&gt;
&lt;h3&gt;執行老師範例後，配合視訊裝置，可以呼叫出影像，並且進行人臉辨識。另外，我也在網路上查詢了其他相關範例，但程式碼更為複雜難懂，而網路上的範例是使用python2.x版本，所以必須換成python3的版本。
&lt;/br&gt;
&lt;/br&gt;
由於剛接觸到程式以及Opencv，所以有很多範例的程式碼是尚未瞭解的。
&lt;/br&gt;
&lt;/br&gt;
因此，我從Opencv的基礎語法中開始學習，包含cv2.imread()，cv2.imshow()，cv2.imwrite()等，先從如何呼叫圖片視窗，再到呼叫影片視窗。
&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;四.目前碰到的問題&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
1.不知道如何學習範例程式中的辨識輪廓部分，以及辨識輪廓的數值是從何處來的。
&lt;/br&gt;
&lt;/br&gt;
2.有些程式中會提到Xml檔案，但不知道是如何製作出來。
&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;五.參考的網頁資料&lt;/h3&gt;
&lt;/br&gt;
&lt;h3&gt;
1.拍.電.視.時間Github範例程式:https://github.com/fatcloud/PyCV-time
&lt;/br&gt;
&lt;/br&gt;
2.OpenCv基礎語法學習網頁:http://docs.opencv.org/3.0-beta/doc/py_tutorials/py_gui/py_table_of_contents_gui/py_table_of_contents_gui.html
&lt;/br&gt;
&lt;/br&gt;
3.大兵萊恩學習OpenCv路程:http://gogoprivateryan.blogspot.tw/2015/09/opencv-3-opencv-python-face-recognition.html
&lt;/br&gt;
&lt;/br&gt;
4.Python2 to Python3程式改變部分:https://docs.python.org/2/library/2to3.html&lt;/p&gt;</content><category term="OpenCv"></category></entry></feed>