{"pages":[{"tags":"misc","title":"About","text":"機械設計專題網誌 https://project.mde.tw 是台灣國立虎尾科技大學機械設計工程系 (Department of Mechanical Design Engineering, National Formosa University, Taiwan ) KMOL 研究室 (Knowledge Management and Optimal utilization Laboratory) 專題網站, 與課程相關的網誌位於 https://chiamingyen.github.io/kmolab/blog/ . 與電腦輔助設計室相關的網誌則位於 https://cadlab.mde.tw . 本網誌的所有資料位於 https://github.com/coursemdetw/project_site , 除了所引用的資料特別聲明各自所宣告的使用授權外, 一律採用 AGPL 授權 https://github.com/coursemdetw/project_site/blob/gh-pages/LICENSE . 歡迎您的蒞臨! 專題成員 https://github.com/coursemdetw/project_site/watchers","url":"http://project.mde.tw/blog/pages/about/"},{"tags":"2016bg2","title":"專題模板說明","text":"置頂中 Leo Editor 專題模板 倉儲： https://github.com/KmolYuan/Leo-editor-report-template 設定 預覽圖 Leo Editor 專題模板 搭配 Pandoc 將 Markdown 文件轉為 PDF。 將 template.tex 調整過後，把中英文字型分開，並將英文名稱轉為中文，可以生成接近 Word 格式排版的狀態。 之後會盡快補完之前的 Markdown 語法說明 。 環境準備：Windows 與 Ubuntu 雙平台的 Pandoc 安裝說明 。 這個倉儲會持續更新，要獲得更新後的設定，可以下載新版的 template.tex 即可。 參考模板： https://github.com/kmollee/nfu-thesis-template/blob/master/template.tex 設定 採用以下設定： 語系：中文（ -V lang=chinese ） 自動生成：目錄、表目錄、圖目錄（ --toc ） 自動分節（ -N ） 程式碼標示：Kate（ --highlight-style kate ） 整體設定（ -V documentclass=report ） 使用模組：圖片參照 pandoc-fignos（ --filter pandoc-fignos ） 自訂模板：template.tex（ --template=template.tex ） 中文字型：Windows 標楷體；Ubuntu 教育部標準楷書（ -V \"CJKmainfont:標楷體\" ） 內文字體大小：12 號（ -V fontsize=12pt ） 邊界設定：1 英吋（ -V geometry:margin=1in ） 英文字型：Times New Roman 預覽圖","url":"http://project.mde.tw/blog/zhuan-ti-mo-ban-shuo-ming.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/03/16","text":"Pyslvs 開發進度： 卡車尾門範例 Pyslvs 開發進度 卡車尾門範例 新增伸縮桿的簡單範例，機構源自 https://www.google.com/patents/US7547055 改變 Point0 到 Point2 的距離可以收合尾門。 兩段式的升降裝置找不太到清楚的機構圖，可能要操控 2 個以上的伸縮桿才能達成。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060316.html"},{"tags":"2016bg2","title":"Pandoc - Markdown 基本語法介紹","text":"一些 Pandoc 常用的 Markdown 語法及注意事項 一些 Pandoc 常用的 Markdown 語法及注意事項 參考資料： https://pandoc.org/README.pdf 基礎須知：Markdown 相對於其他文書格式，並非「易撰寫」，而是「易閱讀」，因此在語法上有很多種表達方式，擇一即可。 在需要特殊排版要求時才會加入 html 語法，而 html 語法中的任何 Markdown 記號都會視為通常字元。 這裡介紹的為 Pandoc 支援的語法，Pelican 轉換網誌時可能無法支援。 為編輯方便，這篇文章使用 Leo Editor 的 @others 和 @clean 語法編輯文件。 目錄 書目與換頁 換行記號 標題 分隔線 粗體與斜體 清單 連結 表格 數學符號 程式碼 Pandoc 書目與換頁 書目 使用百分比符號隔著 1 到 4 格空白，插入置中封面文字。 % 封面標題 % 作者 % 28, January, 2017 --- 內文不能再使用 換頁 換頁記號使用後不用再換行。 \\newpage 換行記號 使用 空行 的方式來作換行，如下： 1 2 3 第一段文字 第二段文字 「看起來像」空行也會被視作空行，如該行只有空白或 tab 字元。 若是沒有換行，兩段緊貼的文字仍會視為同一段。 若要插入一段空行，可以用反斜線 \\ 符號加上一個以上的空白字元。 標題 每個標題中都內建錨點，相當於 html 的 h1, h2, h3。 分成 Setext 和 Atx 兩種形式，而這兩種形式是可以混用的。 在 Pandoc 中，每個標題都會轉為 PDF 的目錄書籤。 Setext 形式 使用 3 個或以上的「等於」與「減號」代表 h1 和 h2。 This is an H1 === This is an H2 ------------- Atx 形式 井字號的數量決定層級。 # This is an H1 ## This is an H2 ###### This is an H6 分隔線 使用 3 個或以上的「星號」、「減號」、「下底線」來畫出水平分隔線。 水平線的符號必須被空白圍繞，若是緊貼其他文字則會失效。 --- * * * * _____ 粗體與斜體 在內文中標記粗體與斜體，兩者可以混用，但是開頭與結尾必須一致。 論文中比較少用兩者，可以在寫網誌時畫重點。 使用「星號」或「下底線」代表斜體。 *斜體文字* _斜體文字_ 使用雙「星號」或「下底線」代表粗體。 **粗體文字** __粗體文字__ 清單 清單分為無序和有序，都可以使用降階不間段放入內容。 使用「星號」、「減號」、「加號」隔著 1 到 4 格空白來代表無序清單。 * 其中一項 + 還有一項 + 還有一項 - 還有一項 * 其中一項 * 其中一項 使用「普通數字」與「英文句號」隔著 1 到 4 格空白放入內容，產生有序清單。可以完全不照順序排版，在最終會自動轉換成順序排列。 1. 永遠的第一項 1. 永遠的第二項 6. 永遠的第三項 連結與圖片 基本的連結樣式： 有一個[連結文字](http://www.google.com)在這裡。 轉移的連結樣式。優點是可以統一放在同一處，並且能重複引用。 要注意冒號後必須有 1 到 4 個空白。 有一個[連結文字][]在這裡。 [連結文字]: http://www.google.com 圖片使用方式跟連結一樣，只須在前端加上驚嘆號。 圖片從自身檔案開始尋找，或是使用網路連結（轉檔時連網即可）。 ![圖片名稱][] [圖片名稱]: image/a.jpg Pandoc 會處理單行的圖片（同行不可有字元），為其置中、編入圖片編號（以章節出現排序），並且在下方置入圖片標籤。 安裝擴充套件 pandoc-fignos 後，使用下面的方式引用： ![圖片名稱][] 請參考圖 {@fig:圖片代稱} 中的內容。 [圖片名稱]: image/a.jpg {#fig:圖片代稱} 表格 Markdown 的表格分為 4 種樣式，並有不同表達法。 正式表格多用管表格表示： Table: 表格名稱 {#tbl:表格代號} | Tables | Are | Cool | |----------|:-------------:|------:| | col 1 is | left-aligned | $1600 | | col 2 is | centered | $12 | | col 3 is | right-aligned | $1 | 參照表 {@tbl:表格代號} 使用網頁服務生成： http://www.tablesgenerator.com/markdown_tables 數學符號 Pandoc 支援插入 Latex 的數學公式，可以藉由網頁服務轉換。 http://www.hostmath.com/ 使用時兩端包上錢幣符號，如下： $$\\frac{-b\\pm\\sqrt{b&#94;2-4ac}}{2a}$$ 會生成： $$\\frac{-b\\pm\\sqrt{b&#94;2-4ac}}{2a}$$ 程式碼 Markdown 用簡單的縮排插入程式碼，如： 這是一段 Python 程式： if __name__='__main__': print(\"Hello world!\") 印出 Hello world! 字樣。 或是使用重音符（Grave accent）包起單一程式碼： 一段程式： `print(\"Hello world!\")` 若一大串程式碼，可以用三個以上的重音符包起，也能用語言名稱加註： Bash 指令： ```bash sudo apt install python3-pip sudo pip3 install markdown ``` 注意事項 不像其他語言，在 Leo Editor 中使用 @others 與 @clean 編輯 Markdown 論文或技術手冊時， 子節點必須多留一個換行 。 否則 Leo Editor 在儲存時會把下一個子節點的第一行對齊到前個節點的最後一行，導致 沒有換行標記 ，會誤認這兩行的內容為同一行而沒做換行處理。 更多內容請參見： http://markdown.tw/","url":"http://project.mde.tw/blog/pandoc-markdown-ji-ben-yu-fa-jie-shao.html"},{"tags":"2016bg2","title":"Pandoc - Markdown 轉 PDF 格式","text":"Ubuntu 安裝方式 Windows 安裝方式 圖片與表格的參照擴充套件 使用範例 Pyslvs 手冊倉儲： https://github.com/KmolYuan/Pyslvs-manual Ubuntu 安裝方式 首先安裝 Pandoc、texLive、texLive-xetex、etoolbox。 到 Pandoc 的 Github 倉儲下載 debian 安裝檔，用 software center 安裝。 https://github.com/jgm/pandoc/releases/ 接著用 apt 安裝 texLive。 $sudo apt install texlive texlive-xetex texlive-lang-chinese etoolbox 若是有檔案缺損，直接轉檔，可能會缺少所需的轉換範本，出現類似下面的警告： ! LaTeX Error: File `etoolbox.sty' not found. Type X to quit or RETURN to proceed, or enter new name. (Default extension: sty) Enter file name: ! Emergency stop. read * l.8 \\RequirePackage pandoc: Error producing PDF Windows 安裝方式 Windows 只需安裝 Pandoc 與 MikTex。 到 Pandoc 的 Github 倉儲下載 msi 安裝檔。 https://github.com/jgm/pandoc/releases/ 然後根據 XeLaTex 的說明安裝 MikTex，並執行 MikTex Update 更新 xetex 的檔案。 http://www.texts.io/support/0002/ Windows 可以使用 MikTex Package Manager 來安裝套件，在過濾器中打上套件搜尋安裝即可。 以下是 Windows 必須安裝的套件名稱： etoolbox cjk（中文、日文、韓文語法支援，包含漢字數字） xecjk（基本的 CJK 支援） makecmds（Latex 的自定義函式，提供自訂與複寫參數） 圖片與表格的參照擴充套件 文章中常有「引用圖 1.1」之類的編號說明。 不過 Pandoc 沒有內建這個功能，所以必須安裝 pandoc-fignos 和 pandoc-tablenos。 pandoc-fignos 是 Python 套件，使用 pip 安裝。 $sudo pip3 install pandoc-fignos $sudo pip3 install pandoc-tablenos 之後在 pandoc 參數中增加 --filter pandoc-fignos 和 --filter pandoc-tablenos 來啟用這個語法。 使用範例 http://pandoc.org/demos.html 參照 pandoc 的 demo，下載 MANUAL.txt 這個 Markdown 檔案來測試。 使用以下指令： $pandoc MANUAL.txt --latex-engine=xelatex -o MANUAL.pdf 轉換後不會有任何提示，會直接輸出檔案。 平常使用 pandoc 指令，可以如同 Python 直譯器直接輸入 Markdown 語法，輸入後按下 Ctrl + D 來轉換並顯示 html 語法（Windows 是 Ctrl + C ）。 若是結合 --latex-engine=xelatex 或是 -o 參數，更可以直接輸出成 pdf 檔案。 而輸出的 pdf 檔案會自動分頁、排版、標記頁碼。demo 網頁上還有其他範例，可以轉換成不同格式的文件。 手冊方面全局使用 Leo editor 管理，並整合轉檔的工作，圖片則使用另一個倉儲儲存，不過這些 Markdown 樣板的語法跟網誌的語法不太相同，可能要稍微測試並習慣其用法。 另外還可以加入 --toc 參數自動生成目錄，為 table of contents 的縮寫。 生成的目錄如下的形式，並會自動加上連結。","url":"http://project.mde.tw/blog/pandoc-markdown-zhuan-pdf-ge-shi.html"},{"tags":"2016g1","title":"Pyquino 日誌 - 106/03/15","text":"開發日誌 完成gcode送值到Vrep 討論vrep的ik合成 開發日誌 ＝＝＝ 完成gcode送值到Vrep 利用gcode parser 解析gcode為點位置,及可以完成送刀尖點到vrep裡面進行模擬 Vrep的ik 和武鉦老師討論到vrep的可行性部份,做出一個任意的機構,列用vrep的ik解題方法,把逆向運動學解出來後,使用自己寫的控制器,完成一套任意機械,都可以直接做出來控制器,讓使用者使用 今天沒有很多時間來製作網誌,明天在詳細講述內容","url":"http://project.mde.tw/blog/pyquino-ri-zhi-1060315.html"},{"tags":"2016g1","title":"Pyquino 日誌 - 106/03/13","text":"開發日誌 製作gcode解析器 目標 開發日誌 推導並聯桿機器,推導ik逆向運動學 更新新的轉換界面設計 開發日誌 ＝＝＝ 逆向運動學推導 la 連桿長度 to 噴頭到中間圓盤的圓心差距(Z) pa 中間圓盤圓心到旁邊球頭接頭的距離 sp 中間圓心到旁邊滑塊的距離 先定義已知的項目 $$a_{1x} a_{1y} a_{1z}$$ $$a_{1x} = (tx + pa)$$ $$a_{1y} = (ty)$$ $$a_{1z} = (tz+to)$$ $$a_{2x} = sp $$ $$a_{2y} = 0 $$ $$a_{2z} = ??? $$ 因為要得到每個滑塊要移動的量(a2z),未知滑塊的高度 利用畢氏定理可以得到旁邊滑塊的伸縮量 $$aa = \\sqrt{(a_{2x}-a_{1x})&#94;2-(a_{2y}-a_{1y})&#94;2}$$ $$ha = \\sqrt{(l_{a})&#94;2-(aa)&#94;2}$$ $$a_{2z} = tz + to +ha $$ 後面再把圖補上 更新了新的界面負責把值傳到vrep裡面,目前已經把gcode解出來,也把逆向運動學推導完成","url":"http://project.mde.tw/blog/pyquino-ri-zhi-1060313.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/03/12","text":"Pyslvs 開發進度： 三角求解器模組 Pyslvs 開發進度 三角求解器模組 寫了一個小模組求解，還未連接使用者界面。 主要功能是傳入一個 list（包含大量題目）並解題。不過 class 裡的函式可以單獨使用。 from math import * ##Directions: ##[{'p1':Point1, 'p2':Point2, 'len1':Line1, ('len2':Line2, 'angle':angle)}, ...] class solver(): def __init__(self, Directions=list()): #Cosine Theorem self.CosineTheoremAngle = lambda a, b, c: acos((b**2+c**2-a**2)/(2*b*c)) self.CosineTheoremSide = lambda alpha, b, c: b**2+c**2-2*b*c*cos(alpha) self.Directions = Directions def set(self, Directions): self.Directions = Directions def answer(self): answer = self.Iterator() if self.Parser() else None self.Directions.clear() return answer def Parser(self): for e in self.Directions: pos = self.Directions.index(e) if e.get('p1', False) is False: return False if e.get('p2', False) is False: return False if e.get('len1', False) is False: return False if e.get('len2', False) is False and e.get('angle', False) is False: return False if e.get('len2', False) is False: self.Directions[pos]['Type'] = 'PLAP' elif e.get('angle', False) is False: self.Directions[pos]['Type'] = 'PLLP' return True def Iterator(self): results = list() for e in self.Directions: p1 = results[e['p1']] if type(e['p1'])==int else e['p1'] p2 = results[e['p2']] if type(e['p2'])==int else e['p2'] #Direction of the point other = e.get('other', False) ##True: angle1-angle2 ##False: angle1+angle2 if e['Type']=='PLAP': results.append(self.PLAP(p1, e['len1'], e['angle'], p2, other)) elif e['Type']=='PLLP': results.append(self.PLLP(p1, e['len1'], e['len2'], p2, other)) return results def PLAP(self, p1, line1, angle, p2, other=False): x1 = p1[0] y1 = p1[1] len1 = float(line1) angle2 = radians(float(angle)) angle1 = self.m(p1, p2) if other: cx = x1+len1*cos(angle1-angle2) cy = y1+len1*sin(angle1-angle2) else: cx = x1+len1*cos(angle1+angle2) cy = y1+len1*sin(angle1+angle2) return cx, cy def PLLP(self, p1, line1, line2, p2, other=False): x1 = p1[0] y1 = p1[1] x2 = p2[0] y2 = p2[1] len1 = float(line1) len2 = float(line2) d = sqrt((x1-x2)**2+(y2-y1)**2) angle1 = self.m(p1, p2) angle2 = self.CosineTheoremAngle(len2, d, len1) if other: cx = x1+len1*cos(angle1-angle2) cy = y1+len1*sin(angle1-angle2) else: cx = x1+len1*cos(angle1+angle2) cy = y1+len1*sin(angle1+angle2) return cx, cy def m(self, p1, p2): x1 = p1[0] y1 = p1[1] x2 = p2[0] y2 = p2[1] x = x2-x1 y = y2-y1 d = sqrt(x**2+y**2) return self.CosineTheoremAngle(y, x, d)*(-1 if y<0 else 1)*(-1 if x<0 else 1) if __name__=='__main__': #Test s = solver([ {'p1':(-60, 0), 'p2':(0, 0), 'len1':30, 'angle':50}, #C {'p1':0, 'p2':(0, 0), 'len1':50, 'len2':60}, #D {'p1':0, 'p2':1, 'len1':50, 'len2':50}, #E ]) print(\"C={}\\nD={}\\nE={}\".format(*s.answer())) ##cx= -40.716371709403816 cy= 22.98133329356934 ##dx= -6.698073034033397 dy= 59.62495968661744 ##ex= -55.44153371488418 ey= 70.76385733649067 解題方向指定 p1、p2、len1、angle 或 len2，Parser 會檢查填入項的完整性；Iterator 會自動判斷輸入內容選擇解題。 而 p1 與 p2 的座標是使用 list 或 tuple 型態給兩個座標軸（取 [0]、[1]），或是引用上一個解（之後會增加順序檢查機制）。其他數據皆為 float 型態。 角度方面使用 degree，不過 Python 的 math 模組是用 radian，途中會進行轉換。 原理都是先求 AB 與水平夾的角度（angle1），最後將 CAB 夾角（angle2）加上 angle1 求 AC 與水平夾的角度，最後求出 C 點座標。 之中為了方便，將餘弦定理做成 lambda 使用。 程式可能還有一些漏洞，接上 Gui 之前會再檢查一遍。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060312.html"},{"tags":"2016g1","title":"Pyquino 日誌 - 106/03/11","text":"開發日誌 製作gcode解析器 目標 製作了Gcode解析器,可以將檔案轉換成（Ⅹ Y Z)的位置和傳出來給Vrep的列印機使用,目前單純就列表在圖框中,接下來會結合pyqtgraphy進行3d的模型繪製 製作方法為分析每行G指令在運作的方式","url":"http://project.mde.tw/blog/pyquino-ri-zhi-1060311.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/03/11","text":"Pyslvs 開發進度： 捲動區塊 PLAP 和 PLLP 的求解 - 計畫 QGraphicsView 畫布 - 計畫 Pyslvs 開發進度 捲動區塊 面板區由於低解析度的螢幕會塞不進空間，改用捲動方式呈現。 面板的按鈕也重新歸類命名。 反合成四連桿系統由視窗改成面板，運算時會凍結自己的 Tab，主畫面的其他功能能夠照常運作。 PLAP 和 PLLP 的求解 - 計畫 打算開一個新面板（歸類在四連桿尺寸合成系統中），讓使用者能 混用 兩種方式堆疊三角形求解，並有連續迭代求解的功能。 獨立 Kernel 連接 Gui 操縱。 參數可以使用現成實體位置或長度。 理論上支援無限迭代。 運算結果後，使用者可以選擇 生成實體合併進畫布 、 全部清除 或是 修改參數 。 這個 project 應該是 0.6 版的主要更新項目，會盡量快點完成。 QGraphicsView 畫布 - 計畫 更有效率、採用局部更新的畫布。 不過 Qt 當初設計上比較偏向多媒體，所以許多功能偏向動畫方面。 看完 Python CAD（Qt4）的 QGraphicsView 部份，操縱上不太像 Free CAD 靈活（模仿其他大型商業軟體）。 目前想先弄好滑鼠中鍵拖移瀏覽的部份（目前還有諸多問題），可能得搞懂 QTransform 的設定。 新的畫布使用 -t 參數啟動，舊的畫布仍能正常運作。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060311.html"},{"tags":"2016bg2","title":"Python Parser for command-line options","text":"Python 的命令列參數管理 argparse 模組 部署說明資訊 參數類型 Python 的命令列參數管理 當使用 sys 模組下的 argv，可以觀看當前的參數內容。 參數在 sys.argv 下是成 string 型態儲存，但是 list 成次序排列，且只會儲存當前輸入項目，因此在調用上十分不方便。 Python 的 argparse 模組是一個不錯的選擇（3.2 版加入），可以用簡單的設定設置參數名稱和類型，並自動生成類 Unix OS 的 help 選項供調用。 argparse 模組 簡單列出常用的選項。 參考資料： https://docs.python.org/3/library/argparse.html http://stackoverflow.com/questions/5262702/argparse-module-how-to-add-option-without-any-argument Python 函式庫語法範例字典： http://www.books.com.tw/products/0010726838 部署說明資訊 在腳本中設定： import argparse parser = argparse.ArgumentParser( prog='prog.py', #程式名稱，預設 sys.argv[0] usage='%(prog)s [options]', #自訂使用方法外觀，預設由參數產生 description='程式說明', #頂端程式說明，預設 None epilog='程式說明2', #底端程式說明，預設 None prefix_chars='-', #參數起始字串，預設 '-' add_help=False, #是否開啟 Help 選項，預設 True ) parser.add_argument('integers', metavar='N', type=int, nargs='+', help='an integer for the accumulator') #第一個參數 parser.add_argument('--sum', dest='accumulate', action='store_const', const=sum, default=max, help='sum the integers (default: find the max)') #第二個參數 args = parser.parse_args() #解析 如果有啟用 add_help 選項，模組產出的 Help 說明如下： $ python3 prog.py -h usage: prog.py [options] 程式說明 positional arguments: N an integer for the accumulator optional arguments: -h, --help show this help message and exit --sum sum the integers (default: find the max) 程式說明2 參數類型 add_argument() 方法中可使用的選項。 name or flags 名稱或標籤，看之前設置的 prefix_chars 決定，名稱只能為一個，標籤表示法可以有多個。 action 傳入參數的動作，預設為 'store' 。 'store' ：儲存，啟用此標籤時會存入後方跟著的項目，按照 type 選項儲存輸入值。 'store_const' ：儲存為常數，啟用此標籤時會存入一個定值，這時必須設定 const 選項。 'store_true' 和 'store_false' ：儲存為 True 或 False，啟用此標籤時會存入 True 或 False。 'append' ：產生一個 list，啟用此標籤時會將後方跟著的項目，按照 type 選項儲存到 list 中。 'append_const' ：產生一個 list，啟用此標籤時會將 const 選項的類型存入 list 中。 'count' ：紀錄這個標籤出現的次數，如 -v 選項輸入成 -vvv 時會回傳 3。 'help' ：預設已經加入，此時若是自行設置會導致衝突。 'version' ：顯示版本而不啟動程式，這時必須設定 version 選項。 argparse.Action 類型：繼承後，透過修改 call 和 init 方法來達成額外的條件。 nargs 決定多個參數傳入時的處理方式，預設由 action 選項決定。 'N' ：迭代，使用一個 list 包裝此標籤後的參數。 '?' ：單一，一次只能傳入一個參數，後方的項目會被視為其他標籤。 '*' ：不限，使用一個 list 包裝此標籤後的參數，多餘的參數會自動歸類到此標籤下。 '+' ：至少一個，類似 '*' ，但是在此標籤沒有任何參數時會跳出錯誤訊息。 argparse.REMAINDER 物件：存為 list，使用一個 list 包裝此標籤和其參數。 const 根據 action 和 nargs 選項決定的定值。 default 未輸入時的預設值，不受 type 選項的轉換。 argparse.SUPPRESS 物件：若此選項沒有任何參數，不會建立這個選項。 type 轉換輸入值的類型，支援任何可呼叫(callable)的類型，預設為 string。 open ：這個類型可以開啟純文字格式的檔案。 argparse.FileType('w') ：argparse 也提供讀寫檔案的選項，作用同上。 choices 選項會在 type 選項轉換完畢後才比對。 choices 比對輸入值的項目是否符合，可接受 list 與 generator，若否則跳出錯誤。 required 是否為必要標籤，預設為 False。若要啟用，將其設為 True 即可，Help 項目中會歸類成必要標籤。 help 當顯示 Help 項目時的說明文字，預設為空字串。 '%(arg)s' ：說明文字中可以引用其他選項，如 %(default)s 、 %(type)s 等，若要使用 % 符號，可以用 %% 表示。 argparse.SUPPRESS 物件：這個標籤不會顯示在 Help 項目中。","url":"http://project.mde.tw/blog/python-parser-for-command-line-options.html"},{"tags":"2016g3","title":"40323203&05&06日誌 - Measuring distance","text":"辨識圖片中兩物體的實際距離 Measuring distance between objects in an image ★範例所使用的圖檔下載位置 http://imgur.com/pSaQUS0 ★程式範例執行 #以圖片最左矩形寬作為依據的距離測量 from scipy.spatial import distance as dist from imutils import perspective from imutils import contours import numpy as np import argparse import imutils import cv2 def midpoint(ptA, ptB): return ((ptA[0] + ptB[0]) * 0.5, (ptA[1] + ptB[1]) * 0.5) ap = argparse.ArgumentParser() #讓圖檔於開啟指令執行時輸入最左端的矩形寬度 #cmd進入py檔和圖檔所在資料夾後，輸入python 1117_distance.py --width 寬度(inch) 開啟 #寬度可直接輸入數字 ap.add_argument(\"-w\", \"--width\", type=float, required=True) args = vars(ap.parse_args()) #讀取圖檔→灰階→模糊 #cv2.GaussianBlur模糊程度可以用3x3, 5x5, 7x7 img = cv2.imread(\"gear4.png\", 1) Gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) gray = cv2.GaussianBlur(Gray, (3, 3), 0) #輪廓描邊→補空&侵蝕 edged = cv2.Canny(gray, 50, 100) edged = cv2.dilate(edged, None, iterations=1) edged = cv2.erode(edged, None, iterations=1) #進行偵測 cnts = cv2.findContours(edged.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) cnts = cnts[0] if imutils.is_cv2() else cnts[1] #以最左矩形四點&中心為基準到其他物品的距離標示線顏色 (cnts, _) = contours.sort_contours(cnts) colors = ((0, 0, 255), (240, 0, 159), (0, 165, 255), (255, 255, 0), (255, 0, 255)) refObj = None #進行一連串的輪廓校準 for c in cnts: # 忽略過小的輪廓 (限定輪廓描繪範圍) if cv2.contourArea(c) < 1500: continue # 計算輪廓旋轉邊界 gear4 = cv2.minAreaRect(c) gear4 = cv2.cv.BoxPoints(gear4) if imutils.is_cv2() else cv2.boxPoints(gear4) gear4 = np.array(gear4, dtype=\"int\") # 重新設定邊界角落座標的順序, 由左上 右上 右下 左下, 順時針方向繞 gear4 = perspective.order_points(gear4) # 計算物體的中心 cX = np.average(gear4[:, 0]) cY = np.average(gear4[:, 1]) # 以左邊邊界輪廓當基準, 當參考對象 if refObj is None: # 計算物品左右邊界的中點 (tl, tr, br, bl) = gear4 (tlblX, tlblY) = midpoint(tl, bl) (trbrX, trbrY) = midpoint(tr, br) # 用座標法計算兩物體中心距離 D = dist.euclidean((tlblX, tlblY), (trbrX, trbrY)) refObj = (gear4, (cX, cY), D / args[\"width\"]) continue # 輪廓描繪 orig = img.copy() cv2.drawContours(orig, [gear4.astype(\"int\")], -1, (0, 255, 0), 2) # 其餘物品的輪廓描繪 cv2.drawContours(orig, [refObj[0].astype(\"int\")], -1, (0, 255, 0), 2) # 最左邊物品的輪廓描繪 # refObj[0] = 最左邊物品輪廓邊緣的左上 # refObj[1] = 物品中心 # refCoords為基準物, objCoords為測量物 refCoords = np.vstack([refObj[0], refObj[1]]) objCoords = np.vstack([gear4, (cX, cY)]) for ((xA, yA), (xB, yB), color) in zip(refCoords, objCoords, colors): # 基準物的四個角&中心點 測量物的四個角&中心點 點到點的距離 cv2.circle(orig, (int(xA), int(yA)), 5, color, -1) cv2.circle(orig, (int(xB), int(yB)), 5, color, -1) cv2.line(orig, (int(xA), int(yA)), (int(xB), int(yB)), color, 2) #用座標距離法算出圖中的座標距離，並和實際的距離做比值，求出待測實際距離 D = dist.euclidean((xA, yA), (xB, yB)) / refObj[2] (mX, mY) = midpoint((xA, yA), (xB, yB)) cv2.putText(orig, \"{:.1f}in\".format(D), (int(mX), int(mY - 10)), cv2.FONT_HERSHEY_SIMPLEX, 0.55, color, 2) # \"{:.1f}in\" 取到小數點第一位 cv2.imshow(\"Image\", orig) cv2.waitKey(0) ★範例執行結果 ★Numpy & Scipy 運用的主要數學計算 用numpy找出物體的中心 用scipy進行距離計算，計算的方式是用座標法： ◎計算過程 1.以一開始輸入的基準物(最左的物體)實際寬度和用座標法在圖片中算出的寬度做比值 2.分別假設基準物和待測物的座標為(X1,Y1)和(X2,Y2)帶入座標法計算出圖片中的距離 3.把第二步驟求出的距離帶入第一步驟求出的比值，算出待測物的實際距離 ★細部程式介紹 【cv2.GaussianBlur】圖像模糊 ◎使用格式： ◎範例程式 import cv2 img = cv2.imread('gear4.png') # cv2.GaussianBlur模糊程度可以用3x3, 5x5, 7x7 # cv2.blur指令: blur = cv2.blur(img, (5,5)) # 相較於 cv2.blur, cv2.GaussianBlur多一個參數color σ（顏色空間的標準差），此數值越大使得模糊效果更明顯 blur = cv2.GaussianBlur(img, (5,5), 0) cv2.imshow(\"Image\", blur) cv2.waitKey(0) ◎結果： 【cv2.Canny & cv2.dilate & cv2.erode】描繪輪廓→擴張輪廓→修邊侵蝕 ◎使用格式： ◎範例程式 import cv2 img = cv2.imread('gear4.png',0) edges = cv2.Canny(img,10,50) edged = cv2.dilate(edges, None, iterations=1) erosion = cv2.erode(edged,None,iterations = 1) cv2.imshow(\"Image1\", edges) cv2.imshow(\"Image2\", edged) cv2.imshow(\"Image3\", erosion) cv2.waitKey(0) ◎結果：","url":"http://project.mde.tw/blog/403232030506ri-zhi-measuring-distance.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/03/05","text":"Leo editor 報告樣板 Leo editor 報告樣板 統整了一下之前在 Pyslvs 手冊的紀錄，將 Pandoc 和 Reveal.js 的整合放在 Github 倉儲。 倉儲位址： https://github.com/KmolYuan/Leo-editor-report-template PDF 按鈕在儲存 Markdown 後使用，會存成一份內含英文目錄的 PDF 在 pdf 資料夾中。 Reveal.js 按鈕會將文章處理後存到 html 的節點去，所以轉換完後要再存一次檔，才會寫入 html 中。 相關設定皆可到個別 Cloned node 中修改。 之後研究看看 pelican 或 Sphinx 輸出成說明網頁。 接下來會參照學長的論文格式寫關於「電腦輔助設計（CAD）應用程式框架」、「平面機構解題」、「四連桿尺寸合成系統」的 paper。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060305.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/03/04","text":"Pyslvs 開發進度： Release version 0.5 Pyslvs 開發進度 Release version 0.5 釋出 Pyslvs version 0.5 穩定版。 新功能： 使用者介面改善。 滑塊、伸縮桿表格功能。 參數表格功能，能夠在節點、連桿、呆鍊表格中使用參數。 大部分的表格都有復原與重做功能。 輸出草圖或模型為 DXF 和 Solvespace 格式。 在 Github 上附有 Windows 平台 64 位元的自解壓縮包供下載（83.1 MB）。 接下來 dev 的分支會先保留，供之後紀錄。 Version 0.5 作為第一個穩定版（之前的版本沒除太多錯），撰寫報告會以這個版本為主。 之後會將 Markdown 用 Pandoc 與 Leo Editor 轉檔的模板整理後放在公開倉儲。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060304.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/03/01","text":"Pyslvs 開發進度： DXF 輸出 - 2D 模型 Pyslvs 開發進度 DXF 輸出 - 2D 模型 新增這個功能匯出 2D 圖檔，可作為雷射切割使用。 可用參數基本和 slvs 格式差不多，亦可自訂每個元件的間隙。 這樣大量的 2D 圖形需要轉出時就很方便了。 有稍微花時間研究這個 DXF write 模組，似乎也能支援畫出 3D 的模型，可能是一個匯入 V-rep 的途徑？ 這週末整理好功能後會釋出 Version 0.5，包含在寒假進行的大量更動，比 Version 0.4 更穩定。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060301.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/28","text":"Pyslvs 開發進度： 介面改進 Pyslvs 開發進度 介面改進 增加轉出格式的預覽圖。 另外縮減了程式碼和修改 import PyQt5 模組的方式。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060228.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/27","text":"Pyslvs 開發進度： slvs 格式 - 組立 Pyslvs 開發進度 由於發現 Ubuntu 上的 Solvespace 是 whitequark 倉儲編的非穩定版，嘗試之後似乎有一些 3D 約束會閃退的狀況，之後再重裝 2016 年底的穩定版看看。 所以先在 Windows 的舊版 Solvespace 上組合。 slvs 格式 - 組立 在 Windows 版的 Pyslvs 轉檔。 之前以為 Linux 檔案結構的 / 和 Windows 的反斜線會衝突，但是實際測試後發現 Python 的 os 模組和 Qt 的 QFileInfo 會按平台轉換，所以輸出沒問題。 輸出後得到組合架構圖和連桿、呆鍊的 slvs 檔。 首先將這些檔案一一點開重新存檔。 舊版的 Solvespace 有跳出提示說這是新版格式的訊息，不過不影響解題。 接著開啟組合架構圖，選擇 New Group > Import \\ Assemble，匯入其他 slvs 檔。 這時就可以利用 Constrain point to point、Parallel、Constrain point to plane 約束將匯入文件的草圖和底層的草圖相接。而將側邊點約束到草圖平面上可以防止零件滾動。 一般來說，一個零件只要上述 3 個約束就能完全固定了。 組立完成後，就能拉動驅動軸的連桿帶動全體了。 下圖是組合完後的比對。 由於上面那張圖是第一次測試品，之後又組一隻腳的範例。 這次有開中間軸選項（直徑為 2 單位）。 整個流程慢慢組的話不到 10 分鐘可以完成。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060227.html"},{"tags":"2016g1","title":"Pyquino 日誌 - 106/02/26","text":"開發日誌 Vrep連動控制 新增remoteAPI到pyqruino裡面 使用remoteAPI來控制Vrep內步的馬達旋轉，目前還沒製做把值存進去的功能，還在思考要如何內外同動，包括訊號傳輸，有想過直接使用之前做的可變電阻的方式，利用Arduino直接使用lua收值把外部的狀況輸入到內部裡面，這部分還在思考要怎麼製做比較盡善盡美。 增加檔案 新增了core裡面的涵式庫，將RemoteAPI的dll包到裡面，目前.so的部分還沒做，要等換到linux系統的時候在製做兩個不一樣版本的差異。 程式部分 在思考要不要額外把串列通訊的部分拉成獨立的控制，不然要一個使用者，在使用串列通訊的功能的時候安裝opengl或者pyqtgraphy之類的模組，感覺有些不適當，除非說變成將得到的值畫成圖表之類的可能比較好。 RemoteAPI在連線部分，不太確定支援的式點對點的控制還是說連線是走同一條線路，這部分要再看資料的規定才會理解他的運作方法，現在的寫法是每按一個按鈕就連線一次，不太確定這樣會不會有問題發生，這可能要看技術手冊或者使用後才會知道。","url":"http://project.mde.tw/blog/pyquino-ri-zhi-1060226.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/26","text":"Pyslvs 開發進度： slvs 格式 - 命名規則 參數式設計 新增一些範例 Pyslvs 開發進度 slvs 格式 - 命名規則 將命名的選項調整完善，如下圖把尺寸資訊編入檔名裡。 再加上幾個測試應該就能使用全部的自訂選項了。 另外還把組合圖第一層的草圖函式獨立出來，另外有選項可以單獨生成 2D slvs 檔案。 參數式設計 之前荒廢有點久的參數功能，因為表格統整等等項目還沒做好，所以都沒維護相關區域。 後來寫好 QUndoCommand 後，統整好表格增刪功能，幾個函式的適應力更為活用，稍微增加判斷式就能接手 Parameter 的增删功能。 所以現在 Parameter 表格也支援復原重做功能了。 新增一個 n0 參數。 新增一個點，座標打上 (n0, 0.0)。 如下圖，點座標會自己對應到 (70.0, 0.0) 的位置。 原理是更新數據（將表格內容轉為 list 與 dict 儲存）時，會偵測 n 開頭的字元，並自動對應到 Parameter 的字典裡找尋。表格上的樣子是紀錄對應到哪個參數。 若是使用該參數，並在之後刪除它，程式會在刪除前將該參數的代號換回它代表的數據。 以上的流程都能任意復原重做，Parameter 的功能支援在節點、連桿、呆鍊的尺寸中使用。 另外可能還有一些問題待處理，會再檢查一下。 新增一些範例 新增了一個滑塊的範例。 另外還把葛式四連桿的路徑重 load 過，參考 PMKS 的範例。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060226.html"},{"tags":"2016g1","title":"Pyquino 日誌 - 106/02/25","text":"開發日誌 機器繪製完成 匯入Vrep內部 利用熟悉的繪圖軟體先將圖趕出來了，也已經匯入到Vrep內部，內部控制我可能先做單純讓兩顆馬達旋轉，先不設定這個複雜的仿生機構，先將控制介面包到Pyquino的分支裡面使用，依靠之前使用RemoAPI來控制Vrep馬達。 實體部分規畫 -馬達 MG996R(360度連續型) -板件，使用雷射切割壓克力來製做 -連接件 螺絲，最長桿還在思考 -控制板 Arduino uno -電源供應，電池盒 可以的話先設計好介面進行控制真的Arduino和內部的馬達，都先不要進行機構上的運行。","url":"http://project.mde.tw/blog/pyquino-ri-zhi-1060225.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/25","text":"Pyslvs 開發進度： slvs 格式 Pyslvs 開發進度 slvs 格式 更新組合圖的輸出。 使用一隻仿生獸的腳來當範例。 輸出選項新增了「建立資料夾」的選項，不用再預先新增資料夾了。預設是工作簿的名稱。 接著會分別輸出零件檔（目前只有連桿和呆練）。若有勾選，會產生組合圖的檔案。 在 Solvespace 開啟的組合檔，第一個線架構圖層已經生成了，可以使用滑鼠拉動，但是若是包含滑塊或伸縮桿，並不會有這兩者的約束。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060225.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/22","text":"Pyslvs 開發進度： slvs 格式調整 Pyslvs 開發進度 在 16.04 上編譯了新版的 Solvespace，除了一些如 zlib1-dev 和 libpng-dev 之類的舊套件無法安裝外，編譯過程順利。安裝在 /usr/share/ 中。 slvs 格式調整 之前只有試驗性地做出連桿的檔案，所以補上了呆鍊的部份。 呆鍊有兩種樣式，分為整塊的 Sheet 板與 Form 支梁。 下圖為支梁樣式在 Solvespace 中的樣子。 Pyslvs 上的尺寸設定，有圓角直徑、厚度、孔徑、軸徑可調整。 另還會有「產生組合圖」的選項，不過因為技術問題，沒法直接匯進其他零件。 因此先暫時產生線架構的草圖，額外手動組裝。這部份最近幾天會開始做。 還有必須注意零件檔是沒有 Surface 數據的， 手動組裝時必須先用 Solvespace 開啟後再存檔一次 ，才會產生數據。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060222.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/21","text":"Pyslvs 開發進度： 面板調整 伸縮桿面板 Pyslvs 開發進度 面板調整 所有面板做了以下調整： 由於一次只啟用 1個驅動軸 Shaft0，所以驅動軸面板將只支援控制 Shaft0 而已。 所有面板改成當修改或刪除任何表格時強制關閉，新增則不受影響。 使用者拉動滑桿調整展示角度或位置時，每改變一次位置，就會設置一個復原點。 伸縮桿面板 類似活塞的功能（滑塊加上距離約束），通過這個面板可以調整滑動的位置。 另外還有自訂距離範圍的功能，按下旁邊的 Reset 鈕可以重置上限和當前位置。 顯示方面也做了一些改變，當有啟用「顯示標註」功能時，驅動軸和伸縮桿會顯示當前距離或角度。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060221.html"},{"tags":"2016g1","title":"Pyquino 日誌 - 106/02/19","text":"開發日誌 更換github名字 release version beta0.1 更新部分Ui *PyQtgraphy 開發日誌 [倉儲位置][https://github.com/kmolLin/Pyquino/tree/master] ，已經更新名字和release測試版，目前實測是可以使用控制機器 製作了launch.py來執行程式 python3 launchPyquino.py","url":"http://project.mde.tw/blog/pyquino-ri-zhi-1060219.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/18","text":"Pyslvs 開發進度： 介面小改進 Pyslvs 開發進度 由於今天剛回學校，忙準備一些事，所以做的比較少。 介面小改進 一些介面上的小更動。 右鍵選單歸類。 編輯任何表格後都會關閉面板分頁，以免誤觸失去條件的面板。 表格在新增後會自動捲到底，捲動方式從 每格(ScrollPerItem) 改成 每像素(ScrollPerPixel) 。 批次移動和路徑追蹤的表單新增「加入全部」和「移除全部」鈕，樣式為雙箭頭 >> 。 範例選單的狀態列會顯示範例編號。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060218.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/17","text":"Pyslvs 開發進度： 批次移動 Pyslvs 開發進度 批次移動 將所選的節點群平移（原點不可選）。 移動後採用「批次移動」命令包裝，內含這些點的修改指令。 命令文字提示如下： Batch move {Point1, Point2, Point3, Point4, Point5} - Moved (+0.00, -50.00) 有了移動功能後，管理點座標會更為容易。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060217.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/16","text":"Pyslvs 開發進度： 節點關聯查詢 取代點 複製點 Pyslvs 開發進度 從 Leo Editor 借鑒一些功能。 節點關聯查詢 新增一個面板，會顯示與個別節點相關的連桿、呆鍊等等。 因為在刪除該節點時會把相關項目移掉免得出錯，所以就增加這個功能方便使用者檢視它們的關係。 複製點 在滑鼠右鍵選單中增加複製點的功能。 會新增一個與目標數據一樣的節點，初始顏色是橘色。 取代點 類似一般 IDE 的搜尋取代，可以把一個節點的所有關聯 完全轉移 到另一個點上，但是如果發生約束衝突會導致解決失敗。 這個功能也支援復原。 準備再新增批次移動的功能供使用者調整選取的節點，可以將這些點平移到指定的增量。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060216.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/15","text":"Pyslvs 開發進度： 復原與重做功能 - 支援項目 新增「歷史紀錄」分頁 Pyslvs 開發進度 復原與重做功能 - 支援項目 現在 Pyslvs 支援復原的命令如下： 全部表格的新增、編輯、刪除功能 驅動軸的切換功能 路徑追蹤的更新、清除功能 路徑解題會以逐項添加實體的方式呈現 另外還有一些較細節的命令在製作中。 新增「歷史紀錄」分頁 這個分頁中有命令紀錄的表單，包含開啟檔案時讀取的動作。 使用滑鼠點擊清單上的命令即可回溯，對開發設計很有幫助。 影片展示 ：","url":"http://project.mde.tw/blog/40323230ri-zhi-1060215.html"},{"tags":"2016bg2","title":"Arguments and Keywords in Python Function","text":"Python 函式的引數與關鍵字 函式基本用法 引數與關鍵字 Python 函式的引數與關鍵字 函式基本用法 一般的 Python 函式如下： def AFunction(x, y, z): print(x, y, z) a = 10 b = 20 c = 30 AFunction(a, b, c) #10 20 30 函式接收名稱（name），以在函式中利用之。 另一種指定 name 的用法如下： def AFunction(x=0, y=0, z=0): print(x, y, z) a = 10 b = 20 AFunction(a, z=b) #10 0 20 規則： 指定預設數值的項目必須置於尾端。 未指定的項目會依順序代入。 若是接收數目與輸入不同，會 Raise 出 TypeError。 引數與關鍵字 Python 提供了使用 tuple、list、dict 來輸入函式，樣式和使用上與 C 語言類似，不過並不是代表指標（Pointer）的意思。 有序排列的 tuple 和 list 使用星號 * 代表，稱為「引數（Arguments, args）」，會依序輸入或接收進函式。 純輸入 ：接收端數量不對等會回傳錯誤。 def AFunction(x, y, z): print(x, y, z) aList = [10, 20, 30] AFunction(*aList) #10 20 30 純接收 ：型態為 tuple。 def AFunction(*aList): print(aList) AFunction(10, 20, 30) #(10, 20, 30) 輸入 + 接收 ：數量必須調整與對應適當。 def AFunction(a, b, c, *aList): print(aList) #前三項不會顯示 AFunction(10, 20, *[30, 40, 50, 60]) #(40, 50, 60) 使用索引的 dict 使用雙星號 ** 代表，稱為「關鍵字（Keywords, kwargs）」，會依名稱填入函式。名稱的部份 規定必須使用 string 表示 。 純輸入 ：接收端名稱不同、未指定預設值的項目沒輸入，皆會回傳錯誤。 def AFunction(x, y, z): print(x) aList = {'x':10, 'y':20, 'z':30} AFunction(**aList) #10 純接收 ：型態為 dict。注意 輸入端都需要給名稱 。 def AFunction(**aList): print(aList) AFunction(c=10, a=20, b=30) #{'a': 20, 'c': 10, 'b': 30} 輸入 + 接收 ：名稱必須調整與對應適當。 def AFunction(missed, **aList): print(aList) #不會列出 missed AFunction(a=10, b=20, **{'c':30, 'missed':40, 'd':50}) #{'a': 10, 'c': 30, 'b': 20, 'd': 50} 引數與關鍵字是可以混合用的，不過兩者必須擺在接收端和輸入端的最後項。 此時函式會照位置依序對應，再照引數依序對應，有名稱的項目最後才根據關鍵字對應。 def AFunction(x, y, *aList, **bList): print(aList) print(bList) AFunction(0, u=10, y=20, *[30, 40], **{'z':50, 'w':60}) #TypeError: AFunction() got multiple values for argument 'y' 以上錯誤就是因為第一個 0 和 [30, 40] 的 list 已經帶入 x 和 y，並且多出一個 40，而之後又追加一個 y 的名稱所致。 善用這個功能，可以創造多變的輸入函式，應用到迴圈處理（如新增許多不同欄數的表格內容），不用再個別撰寫類似的函式流程。","url":"http://project.mde.tw/blog/arguments-and-keywords-in-python-function.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/13","text":"Qt 的復原與重做功能： 基本功能 QUndoStack 巨集 Pyslvs 開發進度： 復原與重做功能 Qt 的復原與重做功能 由於之前 Ubuntu 14.04 更新了 LiberOffice，沒想到 LiberOffice 的 Python 3.5 程式庫被 PyInstaller 錯認，導致在 Ubuntu 14.04 無法編譯出執行檔。 於是最近幾天裝了第三個系統 Ubuntu 16.04 來編譯，並且整理合併了原本雜亂的 Table Widget 管理用函式，為復原與重做功能。 參考資料： http://doc.qt.io/qt-5/qundostack.html 基本功能 在 Qt 的程式中，使用下列類型管理指令以供復原。 QUndoGroup 統整不同區域，如個別視窗、Widget。每個區域用 QUndoStack 紀錄。 QUndoStack 統整不同的指令紀錄，如新增、刪除、編輯。每個指令用 QUndoCommand 紀錄。 QUndoCommand 代表想要復原的指令，指令中可以包含其他 QUndoCommand。每個指令都要有下列方法。 Redo - QUndoCommand.redo() 重做，可視為正指令，第一次呼叫會執行。 Undo - QUndoCommand.undo() 復原，做出動作達成與 Redo 相反的狀態。 由於 QUndoCommand 在 QUndoStack 必須順序執行，因此在指定位置上用當前的位置考慮就好。 如新增「最後一項」，Undo 時刪掉最後一項就好，不用擔心之後的指令造成這個項目不再是最後一項。 至於編輯和刪除， 要先紀錄刪除前的狀態（儲存到子項目），才能在 Undo 時加回來。 寫在 self.__init__() 即可，會比 Redo 早執行。 呼叫 QUndoStack.push( QUndoCommand() ) 方法來執行 QUndoCommand 的 Redo 項目，同時將 QUndoCommand 加入紀錄中。 呼叫 QUndoStack.redo() 和 QUndoStack.undo() 方法來操作 QUndoCommand 的復原與重做。 要用 GUI 的方式查看並控制 QUndoStack，可以使用 QUndoView 這個 Widget。下面是一個只有 QUndoView 的 QDialog 懸浮窗，輸入對應的 stack 後，直接用滑鼠點擊可以馬上回到該階段。 class commandWindow(QDialog): def __init__(self, stack, parent=None): super(commandWindow, self).__init__(parent) undoView = QUndoView(stack) undoView.setEmptyLabel(\"Start.\") undoView.setAttribute(Qt.WA_QuitOnClose, False) layout = QVBoxLayout(self) layout.setContentsMargins(0, 0, 0, 0) layout.addWidget(undoView) self.setWindowTitle(\"Command List\") self.setSizeGripEnabled(False) size = QSize(250, 200) self.setMinimumSize(size) self.setMaximumSize(size) QUndoStack 巨集 QUndoStack 的巨集功能幫開發者可以錄製多個 QUndoCommand 組成的指令。 原理就是建立一個空的 QUndoCommand，再將輸入的 QUndoCommand 建到這個指令下，在使用 count() 方法回傳命令數時，這種巨集只算 1 個指令。 使用 beginMacro() 方法時，該 QUndoStack 所有項目都會凍結，包含 undo() 都會無法使用，直到使用 endMacro()。 使用方式： stack.beginMacro(\"複合指令\") #開始錄製 stack.push(AFunction()) #紀錄第一個 QUndoCommand print(\"複合指令執行中\") #一般程式不會影響 stack.push(BFunction()) #紀錄第二個 QUndoCommand stack.endMacro() #結束錄製 這樣下 undo() 方法就會一次倒敘 AFunction() 和 BFunction() 回去。 Pyslvs 開發進度 復原與重做功能 參照一些簡單的範例達成了復原功能，並且在 Command line 上的 print 字樣也有所標示。 不過還沒把一些更新功能轉成 QUndoCommand，所以暫時無法使用懸浮窗控制，全都加入後會預設啟用懸浮窗。 下圖是載入檔案後編輯連桿的長度。 使用 Ctrl + Z 復原。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060213.html"},{"tags":"2016g1","title":"Pyquino 日誌 - 106/02/12","text":"開發日誌 修理部分Bug opengl 機器設計 *規劃部分 開發日誌 部分Bug 在送值到機器，會因為機器收值的方式不同，導致如取值不像同。舉例來說在不同胞率得到的值會不相同，因此最好的辦法是送16進位的編碼給機器最好(hex)\u0006，在win遇到Big5編碼以及Utf8兩個編碼影響，目前還沒有測試在linux部分的編碼問題，現在一律採用Utf-8的編碼來解決這部分的問題。 OpenGL 這部分還在詳閱相關的開發手冊，還沒真正將Stl匯入到平台裡面，要整合Vrep的話，因為還沒回學校，沒辦法上Service.mde.tw，可能要等回去學校才開始進行開發。 *整理code部分 這部分還沒開始整理，下個禮拜會慢慢的把code整理以及加上註解，讓所有人都可以知道如何使用這部分的程式來和機器溝通，Vrep的介面會根據老師想要模擬的部分來進行設計，可能就是包括機器的移動和Gcode模擬，這部分會和老師在討論。 機器設計 我先設計了一台小三軸來進行輔助控制和設計，如果直接動到真正3D列印機上面可能會有非預期的整合問題出現，打算先用自己設計的機器和韌體進行控制。 規劃 -使用控制板Arduino Mega2560 + ramps1.4(擴充版) -馬達(42步進馬達) -皮帶(GT2) -部分零組件(3D列印) -板件設計(雷射切割) -power supply使用12V輸出 -上銀滑軌(MGW9C) 採取工具機的控制方式G碼來進行控制，使用Arduino EEPROM的方式把文件存取到Arduinio的記憶體裡，這部分韌體我再來進行開發和控制，要先把成品做完才有辦法寫控制，除非利用Vrep等模擬軟體，輔助開發韌體，我想要同時兩邊一起跑來驗證，設計出來的機台在運作上沒有問題，也可以當個範本來輔助機台設計上使用。 二年級協同的部分可以使用我們開發出來的工具，來進行機器的設計，像是仿生獸的範例是非常不錯的，可以先引導他們使用Pyslvs的部分來繪製連桿機構，在使用Vrep來進行模擬，實體可能會做不到，他們在使用Pyslvs應該會花上許多時間可能兩週可能三週，模擬組裝就可以花上到期中的時間，在操作Vrep中remote_API一定會花上更多的時間，Pyqtuino的Vrep部分可能會趕不上讓學員使用，那邊開發需要花上一點時間研究API的部分，可能先請他們可以用Scite啟動python程式讓機器運動，並控制馬達的轉速，利用command line輸入的方式進行控制，將會提升他們對於程式語言的設計能力。 4042的學員，已經有交代他們先研究我們之前所做的教學以及Pyslvs的使用，實際上讀取到多少，我也不確定，要等開學再看看每個學員讀到多少。","url":"http://project.mde.tw/blog/pyquino-ri-zhi-1060212.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/10","text":"Pyslvs 開發進度： Slider 功能修正 容量縮減 防呆措施 轉出 3D 模型 Pyslvs 開發進度 Slider 功能修正 將滑塊功能從 1 連桿上的 1 點改成 2 點間的 1 點定義。 只是 Solvespace kernel 處理上仍有些不妥，若是如上圖旋轉中心與這 2 點共線， 會讓 Point3 在一定距離內被鎖到旋轉中心上，因為這樣也符合條件。 容量縮減 讓許多對話方塊共用同 ui，如一般的新增／編輯視窗共用。 所有的警告視窗都刪除，替代成防呆措施或 QMessageBox（如：未存檔警告）。 Windows 編譯時複製的 kernel 也改成只複製 py35w 的，不過減量效果較有限，從 386 MB 縮減到 377 MB。 防呆措施 實體和模擬的警告視窗都移除了，改成符合條件才會允許建立或修改這些約束。 例如下圖中的新增視窗 start 和 end 選到了相同的節點，OK 鈕就會變成 Disable 狀態。 轉出 3D 模型 由於目前暫時沒有 Solvespace Surface 功能的程式庫，最近會先嘗試做出 OBJ 的轉檔功能。 Solvespace 格式 import 只支援自己的 *.slvs 檔比較可惜，必要的話得看一下原始碼的內容作編譯。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060210.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/09","text":"關於 Solvespace 的 3D 格式 關於 Solvespace 的 3D 格式 這幾天研究了 fourbarlinkage 和 jasen_8link 的檔案。 使用純「拉伸」群組的檔案結構如下： 「組合圖」的檔案結構如下： 這兩個 project 的組立都是將零件匯入，並約束到「組合圖」的草圖中。 若是只改動連桿的長度，該零件 .slvs 格式的變動如下： 雖然其中包含一些 20 位小數造成的誤差，但是主要的內容都是紀錄運算結果。 也因為如此，就算其中有缺損，Solvespace 仍能依據主要實體重新算好結果，存檔時重新存入檔案中。 這些運算結果也包含拉伸出的表面，尤其是弧線的分段計算，每個 1/2 圓弧都會分為 4 等分計算，所以一個完整圓會有 8 段 Curve（平面的 4 等分座標都在一直線上），這些數據就是分段點的當前座標。 不過這些算好的數據並不是給當前檔案看的，而是拿來 匯入 用的，倘若缺少這些數據，使用它們的「組合圖」就會發生缺損，而且回溯結構時會變紅字。 而「組合圖」也會將子項目的數據複製一份存起來，給更大的「組合圖」使用。 然而，「組合圖」要讀取的這些數據不能有錯誤的答案（因為本身沒有該實體），否則該曲線關聯的 Surface 會消失變成破面。 Python-solvespace 的模組沒有加入 Surface 的相關功能，所以沒辦法求出結果。 目前的進度為可以透過 GUI 用迴圈導出 *.slvs 的零件檔案，但是因為上述問題，無法做成組合圖。 不知是否需要加入 Solvespace Surface 的相關功能還是找其他格式（如 OBJ file）解決。 已測試可以在 V-rep 中使用 blender 匯出的模型。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060209.html"},{"tags":"2016g1","title":"Pyquino 日誌 - 106/02/09","text":"開發日誌 pyqtgraphy mointor opengl 分頁更新 開發日誌 pyqtgraphy + pyqtgraph 安裝 + pyqtgraph install 使用的版本為 0.10.0版本 + pyqtgraph documentation Api文件相關說明 mointor新增opengl的分頁 -新增一頁負責開啟Gui的部分，以便讓使用者看檔案的3D樣子 OpenGL -目前只顯示範例教學的部分，將平台搬進去使用，接下來會對這個對話方框新增開啟檔案、stl顯示等功能。 -區隔兩邊功能，分為操控以及預覽圖檔的部分。 分頁更新 新增了兩個對話框，一個對Vrep、一個對Gcode解析、在考慮要不要新增stl預覽的部分，這幾個部分都使用pyqtgraphy來預覽，目前都還沒加入解析的部分，pyqtgraphy的部分還需要研讀，目前還沒看完相關文件。","url":"http://project.mde.tw/blog/pyquino-ri-zhi-1060209.html"},{"tags":"2016g1","title":"Pyquino 日誌 - 106/02/08","text":"開發日誌 Digital Lcd Move locate 可以選擇步數移動 Menu bar更新Help 測試部分 開發日誌 Digital Lcd -使用者可以知道目前機器的位置和點座標，會根據使用者下的指令來更新點座標，也可以讓使用者決定要移動多少mm # step is mm #step由使用者決定 serial.send(str('G90'+'x'+step)) Move locate -根據 Grbl Gcode 的protocol設定，有增量移動這個指令，單純想依靠這G90來跟機器溝通，不去記憶相關位置，而是直接藉著增量位置的值來確定目前機器移動的位置並顯示到LCD上面。 step步數決定 -製作了讓人決定每按一次按鈕要走幾步的選項，可以根據使用者需求自行增加或減少步數設定 Menu bar更新Help -目前help裡面尚未新增資料，未來會參考其他應用程式放入使用教學、關於等相關資料。 測試影片 OpenGL 目前偏向這個倉儲所展示的Gcode viewer + yagv","url":"http://project.mde.tw/blog/pyquino-ri-zhi-1060208.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/07","text":"Leo Editor - 簡單的節點控制 簡述 Leo Editor 的 @button 節點運用。 Generators Position Getters Pyslvs 手冊應用 Pyslvs 目標 - 模型銜接 V-rep Leo Editor - 簡單的節點控制 參考資料： http://leoeditor.com/cheatsheet.html 注：一些方法（method）可以利用 Leo 的自動完成功能（ Alt + 1 ）尋找。 Generators 一些常用的 generator。 Python 的 generator 使用方式： pList = [e.copy() for e in c.all_positions()] 上一篇文章 提到了不要直接使用 generator 來下指令，否則會出現 <pos 139770197424392 [0] None> 回傳值為 None 的情形。 在一般情形下，@button 中的 p 為「當前節點」而非「該 @button 節點」的 position，應當特別注意。 c.all_positions() 依序回傳大綱所有節點的 position，包含的子項目會跟在父節點之後。 c.all_unique_positions() 依序回傳大綱所有節點的 position，包含的子項目會跟在父節點之後，但是分身節點只會回傳一次。 p.children() 依序回傳該 position 子節點的 position。 p.parents() 依序（由底開始）回傳該 position 父節點的 position。 p.self_and_parents() 依序（由底開始）回傳該 position 父節點的 position，第一次會回傳自身。 p.self_and_siblings() 依序回傳該 position 同層級節點的 position。 p.following_siblings() 依序回傳該 position 下方同層級節點的 position。 p.subtree() 依序回傳該 position 子孫節點的 position，包含的子孫項目會跟在父節點之後。 p.self_and_subtree() 依序回傳該 position 子孫節點的 position，包含的子孫項目會跟在父節點之後，第一次會回傳自身。 Position Getters 一些常用的 Getter。 這些方法回傳 position 的週邊資訊，上面提過的 Generator 將不再說明 。 Python 的方法可以使用多層（只要確定非空值）： B = p.next().firstChild().b p.back() 回傳該 position 上方一個節點的 position。 p.next() 回傳該 position 下方一個節點的 position。 p.firstChild() 回傳該 position 第一個子節點的 position。 p.lastChild() 回傳該 position 最後一個子節點的 position。 p.parent() 回傳該 position 第一個父節點的 position。 p.level() 回傳該 position 的層級整數（int）。 至於 position 的新增、移動、刪除方法使用後會如同修改 vnode，發生大綱樹不會即時更新的情形（無法選擇更新後節點、不會提醒儲存以及存檔後不會編輯檔案節點），必須重新存檔才能更新大綱樹。也因為如此不符合 @button 的功能需求，因此就不介紹了。 Pyslvs 手冊應用 縮減了原先的語法，使用 Leo 提供的 generator，變得更易懂。 pList = [e.copy() for e in c.all_positions()] #節點參照 hList = [e.h for e in c.all_positions()] #索引 MD = pList[hList.index(\"@clean {}.md\".format(filename))] #找到 Markdown file pos = hList.index(\"{} Target node\".format(filename)) #目標 B = [e.b for e in MD.self_and_subtree()] B = ''.join(B).replace(\"%\", \"##\").replace(\"\\n@language md\", '').replace(\"\\n@others\", '').replace(\"*@fig:\", '').split(\"\\n\\n\\\\newpage\") head = \"\"\" \"\"\" tail = \"\"\" \"\"\" B = [head+e+tail for e in B] pList[pos].b = removeParentheses(\"@language html\\n\"+'\\n'.join(B)) g.es(\"{} HTML 簡報轉換完畢\".format(filename)) Pyslvs 目標 - 模型銜接 V-rep 為了達成 Pyslvs 的「2D 線條」轉成 V-rep 能用的「3D 支架」（或是連桿之類的），要在接下來的版本做出這個功能。 由於 STL 是三角形接合的立體物件，要憑空畫出 3D 支架的組合圖，想知道這方面的資料。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060207.html"},{"tags":"2016g1","title":"Pyquino 日誌 - 106/02/07","text":"Pyquino develope 開發進度 整體 開發功能 *開發疑惑 今日開發進度 新增了一個分頁(tab)來進行按鈕下指令進行控制機器的部分 以及新增未來要加入Vrep控制的menu bar 整體 -現在還有許多地方需要優化和簡化程式，現在整個程式註解太多以及擁有許多無意義片段的程式碼，並不易閱讀，目前打算先將主功能開發完成再來進行優化的部分，目前還有許多功能未加入(數字顯示器、預覽gcode的opengl...等，這部分後面加入後會再進行優化。 -在看程式碼的部分也需要優化和設定資料夾將他們拆開，而不是全部變成一包，非常凌亂無法協同開發，這部分會等到主功能開發完成再進行。 開發功能 -今日主要優化界面，以及設計出了人機介面，來和機器進行溝通，目前的按鈕已經可以正常發送G指令給機器，包括home unlock的部分，功能都已經開發完成，目前測試的方式單純和Arduino溝通，並沒有實際的列印機可以進行測試，等回到學校再進行測試。部分使用上邏輯的問題，會再思考方法避免發生或者警告使用者使用上的缺失。 -接下來會優先開發讀取gcode並自動發送到機器裡面，並且使用open file的方式，新開一個視窗來額外處理讀取文件和送文件。 開發疑惑 -是否真的可以使用OpenGl來讀取gcode將3D模型變成線架構的模型讓人看 -Opengl with PyQt5 的資料幾乎都找不到，幾乎都是顯示Pyopengl，這部分不太理解他的意義。","url":"http://project.mde.tw/blog/pyquino-ri-zhi-1060207.html"},{"tags":"2016g1","title":"PyQt5 serial port","text":"Serial tools develope tools開發 Arduino_grbl PyQt5 Pyserial GUI 串列通訊工具開發 相關資料連結: PyQt5-pyserial-tools Arduino-grbl Qt API Pyserial 先備知識 在做通訊相關的程式需要了解的部分 receive & send -理解目前的通訊協定(RS232 RS485...) -理解訊息傳送的方法 -以及對方解讀的方法 目前開發進度 這次開發的主畫面(開發版)，基本和Arduino進行溝通已經可以進行回傳和送值的工作。 溝通對象(Arduino in grbl) Grbl -為目前世界開源CNC的控制韌體排名前幾名，許多的數值工具機都可以利用他所開發的韌體進行控制，包括我們常常使用的Ramps1.4控制卡，也可以使用他的arduino程式進行控制。 -操作的方法，和使用一般CNC相同，可以下達Gcode & M command，可自行進行編碼和控制機台(F600、G01 X10 ....等) Pyserial -python模組，目前已經支援python3，可以省去處理許多非常細節關於串列通訊的部分，像是(記憶體位置，如何存取) Gui開發 -目前開發到手動進行機器的溝通，基本的傳輸指令到控制卡裡面 -接下來要開發模擬的部分，可以在內外同時進行溝通，目前不知道內部的模擬器要用什麼做，也許考慮vrep(?)。 -要處理gcode的檔案，現在單純可以送指定到機器並回傳狀態到指令列，後面還需要優化界面才行。 -開發環境目前選定win，我的linux系統崩毀，礙於網路速度太慢，就先從ana_2017進行開發","url":"http://project.mde.tw/blog/pyqt5-serial-port.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/04","text":"Leo Editor - 簡單的節點控制 簡述 Leo Editor 的 @button 節點運用。 預先定義名稱：c、g、p Vnode Position Generator 使用 @button 複製節點正文 Pyslvs 手冊應用 Leo Editor - 簡單的節點控制 參考資料： http://leoeditor.com/tutorial-scripting.html http://leoeditor.com/scripting.html 預先定義名稱：c、g 和 p 在可執行腳本中預先定義的符號 c、g 和 p。 c 為包含腳本大綱的 commander 。 Commander 為指令類別的實體（instance），在 leoCommands.py 文件中定義。 Commander 提供了所有大綱資料與 Leo 原始碼的權限。 g 為 Leo 的 leo.core.leoGlobals 模組。 這個模組包含許多實用的函式，如 g.es 。 p 是當前選擇節點的 position 。 position 為位置類別的實體，在 leoNodes.py 文件中定義。 位置類型提供安全、方便的方式來存取與修改大綱節點。 對於任何位置的 p ， p.v 是一個 vnode 物件。 vnode 包含所有在 Leo 大綱的永久資料。 Vnode vnode 為 vnode 類別的實體，在 leoNodes.py 文件中定義。每個 vnode 代表關聯著一個大綱節點的 所有 資訊，包含著 專用 數據帶有它的大鋼結構。 v.b 是（大綱）節點的正文（body text）。 v.h 是節點的標題（headline）。 v.u 是節點的 使用者資訊 。 所有分身節點共用同一個 vnode。 反之，每個 vnode 表示出所有分身相應的節點。 由於 單一個 vnode 可以代表 多個 大綱節點，直接使用 vnode 會變得較尷尬。這就是為何出現 position： position 簡化對 vnode 的存取。 Position 一個 position 代表一個具體的大綱節點在大綱一個精確的位置上，position 為位置類別的實體，在 leoNodes.py 文件中定義。 在位置 p 上的 vnode 就是 p.v 。 由於所有分身共用一樣的 vnode，多個 position 可能會擁有一樣的 p.v 內容。 p.b 、 p.h 、 p.u 代表著 p.v.b 、 p.v.h 、 p.v.u 。 對於任何一個 Commander c ， c.p 為當前選擇的節點。 position 常因為大綱結構改變而變成無效。 腳本應當只在確保大綱結構不會發生任何改變時儲存位置以供稍後使用。 c.positionExists(p) 會在 c.p 仍為有效值時回傳 True。 Generator Leo 的 Generator 即為 Python generator，這些 generator 追蹤（逐漸地）Leo 大綱的一個個節點： Leo generators yield 出一個位置序列。 命令（commander）和位置類別定義了數個 generator， c.all_positions() 隨著大綱順序追蹤大綱。下面的程式 print 出正確縮排的標題清單。 for p in c.all_positions(): print(' '*p.level()+p.h) Leo generator yield （回傳一個環節）出 position。它們 不會 回傳一個實際的 list；這為大型的大綱節省了不少空間。事實上，這個位置序列其實是一個 單一 、 不斷變化位置 的序列。這是一個非常重要的空間優化。 當一個 generator 已經回傳完成，這個單一位置變成了一個 空的 position 。 p.v 會在空的 position 為 None。這裡有正確及錯誤的方式測試空的 position。 if not p: # Right if not p.v: # Right if p is None: # Wrong! 為了避免上述情形，應當使用 copy() 方法複製 vnode 與 position 類型的物件，再予以修改。 使用 @button 複製節點正文 自己做了一個按鈕程式來應用 Leo editor 的腳本功能。 目標 ：將 I 節點下的 Hellow World! 文章改名複製到 J 節點下。 由於還不太熟悉 Leo 的 generator，先用比較生疏的方式指定目標。 複製節點文章程式： pList = [e.copy() for e in c.all_positions()] nList = [e.h for e in c.all_nodes()] bList = [e.b for e in c.all_nodes()] Istart = nList.index(\"I\")+1 Iend = nList.index(\"i-c\")+1 Jstart = nList.index(\"J\")+1 Jend = nList.index(\"j-c\")+1 B = bList[Istart:Iend] P = pList[Jstart:Jend] B = [e.replace('i', 'j') for e in B] for e in range(len(P)): P[e].b = B[e] g.es('Copied!') 清空節點文章程式： pList = [e.copy() for e in c.all_positions()] nList = [e.h for e in c.all_nodes()] Jstart = nList.index(\"J\")+1 Jend = nList.index(\"j-c\")+1 P = pList[Jstart:Jend] for e in range(len(P)): P[e].b = '' g.es('Cleaned!') 列出 position 和 vnode 程式： pList = [str(e.copy()) for e in c.all_positions()] nList = [str(e.copy()) for e in c.all_nodes()] g.es('\\n'.join(pList)) g.es('\\n'.join(nList)) Pyslvs 手冊應用 使用 Leo editor 的腳本功能達成轉換 Pandoc 特殊語法。 目前功能： 及時裁切處理 Markdown 文件，輸出 Reveal.js 的 Markdown + html 語法到指定節點（Target node）。 切開 \\newpage 記號成水平投影片。 圖片參照記號移除，但是內文的還未解決。 其他皆按照 data-markdown 的功能排版。 程式還有些雜亂，之後會整修一下。 轉換程式： pList = [e.copy() for e in c.all_positions()] nList = [e.h for e in c.all_nodes()] bList = [e.b for e in c.all_nodes()] Istart = nList.index(\"@clean {}.md\".format(filename)) Iend = nList.index(\"@clean reveal.js/{}.html\".format(filename)) pos = nList.index(\"{} Target node\".format(filename)) B = bList[Istart:Iend] P = pList[pos] B[0] = B[0].replace(\"%\", \"##\")+\"\\n\\\\newpage\" B = ''.join(B).replace(\"\\n@language md\", '').replace(\"\\n@others\", '').split(\"\\n\\n\\\\newpage\") head = \"\"\" \"\"\" tail = \"\"\" \"\"\" B = [head+e+tail for e in B] P.b = removeParentheses(\"@language html\\n\"+'\\n'.join(B)) g.es(\"{} HTML 簡報轉換完畢\".format(filename)) 移除圖片參照專用函式 removeParentheses() ： def removeParentheses(content): while content.find(\"{\")!=-1: start = content.find(\"{\") end = content.find(\"}\")+1 result = content[start:end] content = content.replace(result, '') return content 轉換過程不會用到外部程式，三份 html 文件都是共用同一份 js 檔案。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060204.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/03","text":"Leo Editor - Pyslvs 手冊 - Reveal.js 兩種方式轉成 Reveal.js 樣板： Leo Editor Cloned Node Pandoc - Template Pelican 的 Pandoc Plugin Leo Editor - Pyslvs 手冊 - Reveal.js 為了達成使用相同內容達成一樣的效果，所以找了兩種方法，目前各有優缺，暫時都保留。 Leo Editor Cloned Node 使用 Leo Editor 的分身節點套用相同的內容，並用 data-markdown 讀取；原始碼中會包含為轉換的 Markdown 語法。 不過這種方式無法分章節（水平投影片），因此每個章節都需要分身，否則會讀取到 LaTex 的換頁標記。 優點 是可以自由裁切投影片長度（使用自訂記號），而且完全不會影響 Pandoc 的讀取。 缺點 是不能使用使用圖片參照，可能還要另外想辦法或是捨棄這種用法。 還有一個較小的 缺點 是使用記號裁切後，分開的超連結內容會被脫離，必須在裁切前補上註釋，而 Pandoc 可能也會警告重複轉換的內容。 Pandoc - Template 在 Github 上找到有人寫的 Template 檔，讓 Pandoc 直接轉好 index.html，而且認得圖片參照與特殊用法。 倉儲位址： https://gist.github.com/aaronwolen/5017084 使用的指令： $pandoc -t html5 --template=template-revealjs.html \\ --standalone --section-divs \\ --variable transition=\"linear\" \\ example.md -o example.html 主要使用 --section-divs 配上 -t html5 並套用 Reveal.js 的套件轉出。 轉出來的樣式如下： 缺點 明顯就是「小節」會依附在「章」中，每一頁都會有「章」的開頭文字擋住。 Pelican 的 Pandoc Plugin Pelican 部分有找到相關的擴充套件 pandoc_reader。 倉儲位址： https://github.com/liob/pandoc_reader 還沒測試過效果，不過會使用到 command line 的 Pandoc，應該能套用原本的 Markdown 文件。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060203.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/02/02","text":"Leo Editor - Pyslvs 手冊 Pandoc - PDF Reveal.js - HTML 簡報 Leo Editor - Pyslvs 手冊 目前以 Leo Editor 編輯 Markdown 檔案，為了讓章節更分明，用 node 的方式統整內容。 匯出的 PDF 輸出在 /PDF 資料夾內，而 Reveal.js 則是放在 /reveal.js 資料夾內。 至於 Pelican 的部份還沒研究樣板的關係，暫時未加入。 Pandoc - PDF 這部份使用 Pandoc 的命令匯出，在語法上會用到擴展的功能，Pelican 和 Reveal.js 可能不會支援。 在 Leo Editor 中設計了 3 個按鈕轉檔，Python code 判斷平台與字型，Windows 採用 標楷體 ；Ubuntu 後來由 文泉驛微米黑 改成 教育部標準楷書 。 Python code 使用 Clone node 的方式，使三本手冊套用一樣的設定輸出。 import os, platform if platform.system().lower()==\"linux\": font = \"教育部標準楷書\" elif platform.system().lower()==\"windows\": font = \"DFKai-SB\" else: font = \"Arial\" fontsize = \"12\" margin = \"1in\" settingFlag = \"--latex-engine=xelatex --toc --filter pandoc-fignos --template=template.tex -V \\\"mainfont:{0}\\\" -V fontsize={1}pt -V geometry:margin={2}\".format(font, fontsize, margin) os.system(\"pandoc {0}.md -o PDF/{0}.pdf {1}\".format(filename, settingFlag)) g.es(\"{} PDF 轉換完畢\".format(filename)) 只有名稱 filename 使用不同字串而已。 Reveal.js - HTML 簡報 Reveal.js 若是要使用 Markdown 語法，必須先將 markdown plugin 加回來。 啟動時使用： Reveal.initialize({ dependencies: [ { src: 'plugin/markdown/marked.js' }, { src: 'plugin/markdown/markdown.js' }, { src: 'plugin/notes/notes.js', async: true }, { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } } ] }); 並且從 官方倉儲 載回 lib 資料夾。 編寫 index.html 時使用下面的語法： Markdown 文字 並利用 Clone node 與原文件同步。 使用後的樣式如下： 另外還有需要換頁的問題，官方提供的語法可以自動分行、輸入現成 md 檔等等。 不過遇到 Pandoc 語法（如圖片參照）就沒辦法使用了。而針對換頁，可能還需要斟酌嵌入方式，或是在原文件中加入特殊 html 註解換頁。 至於 Pelican 的 Markdown 應該也和 Reveal.js 一樣，只是不需要分頁。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060202.html"},{"tags":"2016g1","title":"fix qt5 designer","text":"無法啟動qtdesigner的問題 要做圖形化設計的時候，除了憑空想像物件的形狀和位置，也可以利用一些輔助工具，像是QT designer，進行先調整繪畫的地方和使用方法。 底下為老師ana2017_lite的win的部分 在cmd裡面更新pip 接著安裝pip install pyqt5-tools 安裝完成後可以在dist-package裡面看到QT designer了 打開eric6裡面的 QT tools設定檔裡面加上位置就可以了 Y:\\Anaconda3\\Lib\\site-packages\\pyqt5-tools\\designer 圖片後面補上(家裡網路太慢了)","url":"http://project.mde.tw/blog/fix-qt5-designer.html"},{"tags":"2016bg2","title":"Qt5 - Ubuntu switch Fcitx input method","text":"解決 Ubuntu 平台無法在 Qt5 切換 Fcitx 輸入法的問題 解決 Ubuntu 平台無法在 Qt5 切換 Fcitx 輸入法的問題 參考資料： http://www.cnblogs.com/cposture/p/5397694.html 使用 Python 3 啟動 Leo editor、QtCreator，甚至是自己的 PyQt 專案時，會發生無法在視窗內使用英文以外的輸入法。 在 Qt4 時，這個功能可以直接在 Qt Setting 中選擇。Qt5 則是依賴「fcitx-qt5」這個套件，使用 apt 檢查時，會顯示已經安裝並為最新版。 但是安裝 Qt 時的 fcitx-qt5 套件沒有對應到作業系統的 Fcitx 版本時，就要手動 make 了。 在編譯 fcitx-qt5 前，先確認已經安裝最新的 CMake。 示範的 Qt 安裝位置為 /opt/Qt/ ，版本為 5.6，請根據自身版本做調整。 這些流程在 14.04 和 16.04 中是大同小異的，並沒有太大分別。 編譯 fcitx-qt5 從官方倉儲下載 fcitx-qt5，進入該資料夾中： $git clone https://github.com/fcitx/fcitx-qt5 $cd fcitx-qt5 接著準備編譯 fcitx-qt5。 $cmake . $make $sudo make install 在使用 CMake 時會發生如下問題。 extra-cmake-modules 錯誤訊息： CMake Error at CMakeLists.txt:8 (find_package): Could not find a package configuration file provided by \"ECM\" (requested version 1.4.0) with any of the following names: ECMConfig.cmake ecm-config.cmake Add the installation prefix of \"ECM\" to CMAKE_PREFIX_PATH or set \"ECM_DIR\" to a directory containing one of the above files. If \"ECM\" provides a separate development package or SDK, be sure it has been installed. -- Configuring incomplete, errors occurred! 到下面網址下載 CMake 額外模組： https://launchpad.net/ubuntu/+source/extra-cmake-modules/1.4.0-0ubuntu1 解壓縮進入，編譯並安裝模組。編譯前必須指定 CMAKE_PREFIX_PATH 位置到 Qt GCC 的 CMake 上。 $export CMAKE_PREFIX_PATH=\"/opt/Qt/5.6/gcc_64/lib/cmake/\" $cmake . $make $sudo make install xkbcommon 錯誤訊息： -- Found PkgConfig: /usr/bin/pkg-config (found version \"0.26\") -- Could NOT find XKBCommon_XKBCommon (missing: XKBCommon_XKBCommon_LIBRARY XKBCommon_XKBCommon_INCLUDE_DIR) CMake Error at /usr/share/cmake-2.8/Modules/FindPackageHandleStandardArgs.cmake:108 (message): Could NOT find XKBCommon (missing: XKBCommon_LIBRARIES XKBCommon) (Required is at least version \"0.5.0\") 到 http://xkbcommon.org/ 下載最新的穩定版本。 解壓縮後進入資料夾，安裝時需要用到 bison 套件。 $sudo apt-get install bison $./configure --prefix=/usr --libdir=/usr/lib/x86_64-linux-gnu --disable-x11 $make $sudo make install 安裝 fcitx-qt5 若順利執行 CMake 並成功編譯，會在 platforminputcontext 出現 fcitx-qt5 的程式庫，名為 libfcitxplatforminputcontextplugin.so 。 接著刪除 Qt 內的 fcitx-qt5 套件： $sudo rm -f /opt/Qt/5.6/gcc_64/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so $sudo rm -f /opt/Qt/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/libfcitxplatforminputcontextplugin.so 然後進入 platforminputcontext 資料夾，先讓該程式庫「可執行化」後再複製。 $sudo chmod +x libfcitxplatforminputcontextplugin.so $sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt/5.6/gcc_64/plugins/platforminputcontexts/ $sudo cp libfcitxplatforminputcontextplugin.so /opt/Qt/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts/ 然後設定 Qt5 的預設輸入法為 Fcitx。 直接執行下面這兩個命令，若是登出或重新開機失效，則要到 .bashrc 文件中加入。 $export XMODIFIERS=@im=fcitx $export QT_IM_MODULE=fcitx 重新啟動 Qt 相關的程式，便能使用 Fcitx 切換其他輸入法了。","url":"http://project.mde.tw/blog/qt5-ubuntu-switch-fcitx-input-method.html"},{"tags":"2016bg2","title":"Pelican - Windows Python Error","text":"解決 ValueError: embedded null byte 錯誤 解決 ValueError: embedded null byte 錯誤 一直以來，某些使用 Python 3.5（無論 Anaconda 與否）的 Windows 電腦會無法使用 Pelican 轉換網誌。 於是加入 --debug 指令檢查。 ... File \"c:\\users\\...\\pelican\\utils.py\", line 101, in strftime return super(SafeDatetime, self).strftime(fmt) ValueError: embedded null byte 重新搜尋了這個問題，找到了一篇新的文章： http://xingjian.me/how-to-fix-value-error-embedded-null-byte-error.html 於是到 cmd 的 Python 直譯器打入下列指令檢查： import locale, time locale.setlocale(locale.LC_ALL, 'ko') time.strftime('%a') Python Rise 了相同的錯誤如下： 解決方式就是重新設定 local 的設定。 到 Anaconda 的資料夾中找到 pelican，編輯其 utils.py 檔案（如： Anaconda3\\Lib\\site-packages\\pelican ）。 搜尋 def strftime(date, date_format) 這個函式。 在函式這片註解後加入 locale.setlocale(locale.LC_ALL, 'en') 指令，如下： def strftime(date, date_format): ''' Replacement for built-in strftime ... This works by 'grabbing' possible format strings (those starting with %), formatting them with the date, (if necessary) decoding the output and replacing formatted output back. ''' locale.setlocale(locale.LC_ALL, 'en') 之後存檔關閉即可。 接著就能使用 Pelican 的功能了。","url":"http://project.mde.tw/blog/pelican-windows-python-error.html"},{"tags":"2016g3","title":"40323214日誌- Install Scipy  on windows","text":"一.Scipy基本介紹 SciPy是一個開源的Python演算法庫和數學工具包。 SciPy包含的模組有最佳化、線性代數、積分、插值、特殊函式、快速傅立葉變換、訊號處理和圖像處理、常微分方程求解和其他科學與工程中常用的計算。與其功能相類似的軟體還有MATLAB、GNU Octave和Scilab。 二.安裝過程 1.首先到http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy 網址中下載對應python(3.4.4)版本的whl檔案。Numpy這個函式庫也可以在這邊下載http://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy。 2.接著利用系統管理員找到載好檔案的路徑。 3.再來打上對應python版本資料夾的路徑，進到scripts中，打上pip install \"載好檔案的名稱前兩個英文字再按tab鍵\"也就是\"sc然後按tab或是nu再按tab\"按下enter後就會開始下載了。 4.最後在python的互動端中，使用Import測試是否有安裝成功。 三.安裝原因 1.在Opencv執行範例時需要使用。 2.由於直接使用pip install scipy無法正常下載，所以上網找了其他的安裝方法。 四.參考的網頁資料 1.維基百科:https://zh.wikipedia.org/zh-tw/SciPy 2.whl檔載點:http://www.lfd.uci.edu/~gohlke/pythonlibs/#scipy 3.下載步驟參考影片:https://www.youtube.com/watch?v=jnpC_Ib_lbc","url":"http://project.mde.tw/blog/40323214ri-zhi-install-scipy-on-windows.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/01/20","text":"Pyslvs version 0.4 Relese Pyslvs version 0.4 Relese 最終在轉動軸的設定中加入修正選項，並優化 csv 的儲存格式。 v0.4 版的功能如下： 包含完整編譯流程的 Makefile。 加入演算法，讓使用者可以依據路徑需求生成四連桿的結果。 之後會開始完成技術文件和在 v0.5 版中補完之前的目標。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060120.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/01/19","text":"Pyslvs 編譯進度： 平行軸 Bug Pyslvs 編譯進度 平行軸 Bug Version 0.4 準備收工，最近陸陸續續修正了一些界面的合理性問題，並且測試了一下目前的範本運作情形。 除了之前提到演算法可能出現結果錯誤之外，在葛式四連桿的範例中找到一直沒解決的問題。 「平行四邊形」的連桿範例為機架、三根連桿長皆相等的模型，如下圖： 在理想狀況下，兩個從動節點的路徑應為兩個半徑相等的正圓。 不過 Solvespace 的 kernel 卻會造成下面的情況（單純用滑鼠繞行）： 花了一些時間，寫了一小串校正函式，但是會造成其他範例出現不應該出現的反轉。 下圖是 Pyslvs 出現相同的狀況： 預計在 Shaft 加入最後一個功能，「平行機件」的選項，可以讓對稱的範例順利執行。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060119.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/01/16","text":"Pyslvs 編譯進度： 拖放檔案開啟功能 反轉 Y 軸初始位置功能 Pyslvs 編譯進度 拖放檔案開啟功能 參考資料： http://doc.qt.io/qt-5/dnd.html 可以透過 Qt 的拉入事件「dragEnterEvent」和拖放事件「dropEvent」達成。 這次只有讓外部資訊拖入，若要讓內部資訊脫出需要其他設置，不過這個功能或許會應用到其他部份，所以先作筆記。 當 QWidget 設定允許拖放動作 setAcceptDrops(true) 後，就能使用滑鼠攜帶資訊，滑鼠游標會變成拖放樣式而非禁止符號。 透過拉入事件「dragEnterEvent」可以允許「哪些資訊」可以被拖入，如字串、圖片、網址和檔案位址。 拖放事件「dropEvent」可以設定拖入後要執行的動作。 def dragEnterEvent(self, event): mimeData = event.mimeData() if mimeData.hasUrls(): for url in mimeData.urls(): FilePath = url.toLocalFile() if QFileInfo(FilePath).suffix()==\"csv\": event.acceptProposedAction() def dropEvent(self, event): FilePath = event.mimeData().urls()[-1].toLocalFile() self.checkChange(FilePath, [], \"Loaded drag-in file:\\n\"+FilePath) event.acceptProposedAction() 上面的 dragEnterEvent 先判斷 QEvent 的攜帶資訊 mimeData 是否為副檔名「csv」的 URL，接著才會通過檢查（ acceptProposedAction() ）。 後面的 dropEvent 則是取出想要的檔案位址並開啟，若是一次選取多個檔案則只開啟最後一個。 反轉 Y 軸初始位置功能 在選定的連桿上按下滑鼠右鍵可以根據固定軸反轉 Y 軸座標的初始位置，若是沒有固定軸，就反轉終點的。 以下是反轉之後重繪的路徑圖。 透過這個功能能夠手動修正初始位置，不過若是能夠自動檢查並修正會比較好。 過幾天應該能開始寫開發手冊。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060116.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/01/15","text":"Pyslvs 編譯進度： 路徑演算法功能 Pyslvs 編譯進度 路徑演算法功能 Pyslvs 生成曲柄搖桿的步驟： 演算法算出的結果有兩種形式： 一個呆鍊的方向朝上，主動軸（短軸）在左方，為學長論文中的模型。 另一個呆鍊的端點朝下，主動軸在右方，剛好跟上述的情況相反。 雖在轉換式中做了些修正，但是有時仍然會發生 Solvespace kernel 解決失敗的情況。 大約原因應該是初始位置帶來的困擾。由於是讀取 C++ 程式庫的問題，若是學 C 語言即時運算會造成 QPainter 畫布閃爍問題（不過還不知道 QGraphicsView 的效果），之後想在發布 Version 0.4 前做一個理想化初始位置的功能。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060115.html"},{"tags":"2016g1","title":"自動控制(Record)","text":"關於這門課用到的技術 選用的控制版子 Arduino + Ramps 1.4 + power supply pin mapping Onshape 主體設計 設計圖 這個再設計上有許多先天上的失誤，請不要直接使用，再傳動的部份需要額外思考，這一個月會再畫一個可以正常工作的三軸機器。 程式碼設計的部份 幾個要注意的地方 1.A4988控制晶片的方法 2.步進馬達的使用 3.對於控制版的腳位要查表 4.對於電路有基本的理解 A4988 & 步進馬達 會需要控制step以及dir的腳位，dir的腳位決定正轉反轉假設輸入high為正轉那low就是反轉。 step腳位決定這個馬達要走幾步，譬如說我配的皮帶輪齒數是20齒的，我步進馬達轉一圈假設是3200步，我的一齒可以帶動皮帶移動1mm，寫個簡單的數學式子就會變成底下這樣。 $$\\theta_T = cos&#94;{-1}(\\frac{x&#94;2+y&#94;2-L1&#94;2-L2&#94;2}{2\\times L1\\times L2})$$ $$\\frac{20}{3200}=\\frac{1}{x}$$ $$x=\\frac{3200}{20}\\times 1mm$$ $$x=160step$$ 我要移動1mm需要多少步數 這對後面機器的校正也會用到，假設說讓機器移動10mm可是卻只移動一半，表示step少一半，再補正回去就可以讓機器正常運轉。 控制版腳位 這塊版子再當初設計的時候加入了許多可以讓使用者字定義的部份，預留了analogread 以及digital output再aux的部份，讓使用者自行對他定義和使用，我們這次有使用到一顆Servo來夾取一枝筆，當作Z軸使用，再查詢腳位花了一些時間，直到後來才發現左下角，作者有預留給大家使用，分別式D4、D5、D6、D11這4個腳位使用，切忌物將地線和火線接相反。 程式碼的倉儲 腳位的部份我都已經定義好了，可以直接使用。 後面想要加的東西 想要做一個端口，將可以利用python做介面來進行裡面和外面同時可以控制，內部可以先模擬完外面再進行執行。機構再從新想一個，這個問題有點多沒有考慮到。","url":"http://project.mde.tw/blog/zi-dong-kong-zhi-record.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/01/14","text":"Pyslvs 編譯進度： 程式 - 求解轉換函式 界面 - 演算法結果說明文字 Pyslvs 編譯進度 程式 - 求解轉換函式 利用演算法得出的解需要經過 Solvespace kernel 的轉換才能得到點座標，不過之前的函式沒經過考慮，會重複許多流程，因此將函式合併，當提供相應值時會回傳需要的解。 pathTrackProcess = not angle==None staticProcess = not table_point==None generateConversionProcess = not generateResult==None ... if pathTrackProcess: try: return x, y except: return 0, 0 elif staticProcess: try: return resultList, sys.dof, script except: return list(), -1, str() elif generateConversionProcess: try: return resultList except: return list() 另外編出 Python Script 的部份縮減很多，只會提供表格的點座標和約束讓使用者利用。 界面 - 演算法結果說明文字 由於做出預覽會造成 QPaint 畫布需要處理很多項目，所以未來使用 QGraphicsView 畫布時再補回去。 當 Path Solving 面板算出結果後會將資料存入待審清單中，滑鼠移上去時可以看到使用演算法、AD點座標、運算時間等等數據。 剩下上述的轉換函式、點擊 Merge 鈕加入表單的功能。 完成並驗證演算法流程後，即會發布 Version 0.4。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060114.html"},{"tags":"Misc","title":"Blue Workforce 併購 V-rep 公司","text":"丹麥的 Blue Workforce 公司與瑞士的 Coppelia Robotics 公司已經在 2016 年 12 月 28 日合併了. 主要目標在開發更普及 (Accessible), 合用 (Applicable) 與平價 (Affordable) 的機器人系統 Coppelia Robotics 就是開發 V-REP (Virtual Robot Experimentation Platform, 虛擬機器人實驗平台) 的公司. 最早是在 2010 年 3 月以 V-REP V2.4.2 版本公開, 直到 2013 年 1 月起釋出 V-REP V3.0.0 版本的原始碼. 由於 V-REP 除了開放原始碼之外, 還提供俱備完整功能的免費教育版本. 因此非常適合在非營利的教育單位中納入課程教學. 在這項虛實機器人開發公司間的合併, 也能看到未來在各層級機器人自動化系統的整合, 將會是機電資 (InfoRmechAtronics) 三種機械、電機與資訊科技領域高度密合時代的來臨. 尤其在產品開發的前端大量使用異地同步串聯虛擬與實體即時整合的專案, 也將會日漸普及. 換言之, 未來機械產品設計最佳化的範圍, 除了必須將納入電機與資訊元件範疇之外, 各項容錯與更強健的製造管理系統規劃, 也將成為重點.","url":"http://project.mde.tw/blog/blue-workforce-bing-gou-v-rep-gong-si.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/01/05","text":"Pyslvs 編譯進度： 界面調整 - 面板 編譯 - Makefile Pyslvs 編譯進度 界面調整 - 面板 當初構想的清單原本也是置頂的視窗，但是後來發現在 Windows 中開啟會導致清單視窗 crash，所以將一些額外的面板合併到點座標的分頁去。 不過這些面板插入分頁後排版不太人性化，之後還會再修正。 編譯 - Makefile 最後還是統一兩個版本都使用 Makefile 來編譯，方便 Windows 可攜的版本下指令，只要使用下列語句即可分辨平台： ifeq ($(OS),Windows_NT) #執行 Windows 編譯 else #執行 Linux 編譯 endif 另外在 Readme 上也有做修正。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060105.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/01/04","text":"Pyslvs 編譯進度 - 演算法 - Windows 版編譯： 演算法函式庫除錯 編譯方法 Pyslvs 編譯進度 - 演算法 - Windows 版編譯 演算法函式庫除錯 之前嘗試過在 Widows 平台編譯學長的 Cython 函式庫，但是使用 MinGW 和 VS 都出錯，於是上網了解一下關鍵原因。 在官方說明中提到，目前尚未支援 Windows 的 64 位元 GNU，而使用 MinGW32 的話，會造成 64 位元的 Python 無法輸入或讀取任何資訊（進位制不同）。 https://github.com/cython/cython/wiki/CythonExtensionsOnWindows#less-useful-information 因此在 Windows 平台中只能使用微軟提供的 SDK 協助編譯了。 使用 Visual Studio Community 客戶端安裝 Windows SDK 即可，若是 Python 認不得 2012 以上的版本，必須編輯 Anaconda 的 Lib\\distutils\\ 資料夾中的 cygwinccompiler.py ，在大約 85 行的位置插入以下程式碼： elif msc_ver == '1700': # Visual Studio 2012 / Visual C++ 11.0 return ['msvcr110'] elif msc_ver == '1800': # Visual Studio 2013 / Visual C++ 12.0 return ['msvcr120'] elif msc_ver == '1900': # Visual Studio 2015 / Visual C++ 14.0 return ['vcruntime140'] Cython 在編譯時才會找到 SDK 的工具。 編譯後，執行 test.py 時出現了類似 IndexError: index 250 is out of bounds for axis 0... 的訊息，顯示某個 List 超出可讀取範圍。 在不斷測試與檢查之後發現是 Cython 從 C 語言 import 的 random 函數有問題。 from libc.stdlib cimport rand, RAND_MAX, srand cdef double randV(): return rand()*1.0 / RAND_MAX 這個是產生亂數用的 function，在 Windows 下，回傳值某些時候會大於 1，這就導致長度 250 的 list 出現 [250] 的選項。 為了避免這個狀況發生，改寫上面的函式成下面的樣子： cdef double randV(): randomNum = rand()*1.0 / RAND_MAX if randomNum>=1: randomNum -= 0.1 return randomNum 這裡使用迭代運算而非重新指定值，速度會比較快一點。 需要修改的檔案為 rga.pyx 和 de.pyx ，其他函式庫都沒問題。 但是因為 Windows 平台多加了判斷式，還有其他因素，運算時間慢上 1 倍（中間的螢火蟲演算法完全相同）。以下是相同題目的運算結果： 編譯方法 由於加入了 Cython 的程式庫，原本的編譯方式又沒辦法使用了，會出現「pythoncom」匯入的錯誤。 用兩種方式重新編譯後，發現在 PyInstaller 的資料夾（dist）中執行它的主程式，會顯示找不到 py35w 的核心。 於是就將 cxFreeze 的 core 資料夾複製到 PyInstaller 的資料夾中，再啟動主程式就可以使用了，也不會出現任何錯誤。 此方法已經套用到 winBuild.bat 中。 目前暫時將 PyInstaller 的 -w 參數拿掉，方便在 Windows 平台查看 console 資訊。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060104.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/01/02","text":"Pyslvs 編譯進度 - 演算法： 介面 程式 Pyslvs 編譯進度 - 演算法 介面 稍微改寫介面： 加入可以控制部份限制值的功能，並做好回傳結果的 dictionary 分類。 考慮之後，最後還是拿回進度條，做成流動的樣式（最大最小值設為 0 即可）。 除了現在的視窗外，之後還會加入第二個較小的清單窗格供使用者挑選，切換清單選擇項目時即可預覽，點選「合併」按鈕即可合併至畫布。 程式 測試不同組座標放入，發現超過當初預設的數目時，kernel 會報錯。 p = len(path) upperVal = Limits[0]+[360.0]*p lowerVal = Limits[1]+[0.0]*p Parm_num = p+9 這裡 p 代表座標的數量，upperVal 和 lowerVal 是限制值的組合（共 9 項）加上後面點座標的轉動可能性。 Parm_num 會帶入三種演算法的 nParm、D 位置，必須等於 upperVal 和 lowerVal 的長度。 比較好奇的是最後回傳的 fitnessParameter 長度會剛好等於 Parm_num，而且前 9 項是 Ax、Ay、Dx、Dy、L0、L1、L2、L3、L4 的答案，後面都是超過範圍的 float 數值，不知道代表含意。 預覽的部份比較複雜，因為當前的 Solvespace 解題 function 是針對左邊的表單寫的，若是拿來運算 3 個未知點的圖形，必須改寫帶入參數。 單機演算法解題的部份預計寒假初完成，釋出 Version 0.4.0，寒假進行中會加入平行運算，並同時完成其他項目。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060102.html"},{"tags":"2016bg2","title":"40323230日誌 - 106/01/01","text":"Pyslvs 編譯進度 - 演算法： 程式 Pyslvs 編譯進度 - 演算法 程式 將編譯好的 so 函式庫放到 kernel 資料夾的 pyslvs_generate 資料夾中，一樣是分開版本。 跟 Path track 與普通解題函式一起放在 calculation.py 中。 載入選擇： if platform.system().lower()==\"linux\": if py_nm==\"3.4\": from ..kernel.pyslvs_generate.py34 import tinycadlib from ..kernel.pyslvs_generate.py34.planarlinkage import build_planar from ..kernel.pyslvs_generate.py34.rga import Genetic from ..kernel.pyslvs_generate.py34.firefly import Firefly from ..kernel.pyslvs_generate.py34.de import DiffertialEvolution if py_nm==\"3.5\": from ..kernel.pyslvs_generate.py35 import tinycadlib from ..kernel.pyslvs_generate.py35.planarlinkage import build_planar from ..kernel.pyslvs_generate.py35.rga import Genetic from ..kernel.pyslvs_generate.py35.firefly import Firefly from ..kernel.pyslvs_generate.py35.de import DiffertialEvolution 這裡必須額外載入 tinycadlib 函式庫。 在同層目錄下，planarlinkage 函式庫可以搜尋到 tinycadlib 函式庫，但是當用外部位置載入時，被包起來的 so 檔會找不到原本存在的名稱，所以額外載入 tinycadlib 供其使用。 當使用 Path solving panel 後可以回傳數據，但是無法回傳進度，要有這個功能可能得改寫演算法。 選擇演算方法的部份是切換式的，一次只能儲存一組解。如果空間允許，可能建一個清單儲存結果。 至於 Windows 方面則完全封鎖功能，編譯時會跳過整個 Path solving 的相關函式。","url":"http://project.mde.tw/blog/40323230ri-zhi-1060101.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/12/29","text":"Pyslvs 編譯進度 - 演算法： 編譯 Pyslvs 編譯進度 - 演算法 編譯 倉儲： https://github.com/40323230/pyslvs_generate-1 將演算法的原始碼統整，並為其 Makefile 添加 clean 指令。 接著就 test.py 範例檔研究了一下，將原本回傳的字串全部改成 float 型態的 list，並且調整了一些顯示方式。 將結果轉換為浮點數： a = [k for k in map(lambda x: [float(i) for i in x.split(',')[1::]],[e for e in time_and_fitness.split(';')[0:-1]])] b = [float(e) for e in fitnessParameter.split(',')] print(a) print(b) X 和 Y 座標的部份之後再做處理，可以確保的是能夠從整個字串中取回數值，回傳至 Pyslvs 時再做篩選。 目前在 14.04 和 16.04 的 Python 3.4 和 3.5 測試都運作良好，Windows 還沒試過。 Linux 編譯流程： 進入 Tinycad_package 目錄下。 1 2 $sudo pip3 install Cython $make 在該目錄下會編譯出可用的動態連結庫，將其移出就能讓 Python 程式碼使用。 接著就要讓 Pyslvs 使用演算法解題。 目前測試解題速度平均 25 秒左右，舊電腦 35 秒左右。 會試圖研究 Windows 版的編譯方式，最後會像 Python Solvespace 的 kernel 一樣偵測平台和 Python 版本作切換。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051229.html"},{"tags":"Tutorial","title":"機械設計工程系網路講座(四)","text":"在這個講座文章中, 我們將以機械設計專題室的純 IPv6 網路連線設定為例, 說明機械設計工程系中的任一用戶, 若想透過設定連線上網, 應該要如何做? 好了, 您作為機械設計工程系的一員, 電腦網路線接到系上的主幹, 而電腦的使用時機除了在實體電腦硬體之前上網之外, 也經常利用校外的光世代連線遠端登入此系上的電腦進行 remote 操作, 那麼該如何設定純 IPv6 協定上網, 無需耗用任何 IPv4 的固定位址? 所有的電腦都直接連線到主幹 首先, 必須要確定您的電腦確實直接連線到系上主幹, 假如您所處的研究室或實驗室, 是以 NAT 轉換位址連線到系上主幹, 這個時候, 應該是考慮拿掉 IPv4 的 NAT, 換成 Gigabit Switch, 讓所有 client 或 servers 直接連線到系上主幹, 而且只有必須充當 IPv4/IPv6 雙支援代理主機 (Proxy Server) 的電腦需要 IPv4 網址, 其他單純上網的電腦, 只需要設定為純 IPv6 協定, 並透過雙協定支援的代理主機上網即可. 利用網卡 MAC 換算 IPv6 網址 假如您使用 Windows 操作系統, 進入網路介面卡設定時, 在網路連線視窗中的\"詳細資料\", 可以查詢該網路卡的\"實體位址\"(也就是 MAC address), 然後利用 MAC 轉 IPv6 位址服務 , 將 48bit MAC 轉為 64bit Host ID (也就是所謂 EUI-64 Global identifier 位址), 然後再前置機械設計系的前段網址: 2001:288:6004:17, 就可得到該電腦的 IPv6 網址. 例如: MAC address 為 00-11-22-33-44-55 的網路卡, 其對應的 EUI-64 Global identifier 位址經過轉換, 得到 ::211:22ff:fe33:4455, 因此該網路卡就可以將 IPv6 網址設為: 2001:288:6004:17:211:22ff:fe33:4455, 並將子網路首碼長度設為 64, 預設閘道設為 2001:288:6004:17::254, DNS 伺服器則分別設為 2001:288:6004:1::2 (虎科大) 與 2001:b000:168::1 (中華電信), 並且不用勾選\"網際網路通訊協定第 4 版\" (也就是無需使用 IPv4 協定). 如下圖所示: 設定完成後, 應該就可以直接連線到 Google 與 Youtube 等支援 IPv6 協定的網站, 但是若要連線到 IPv4 相容的網站, 則必須透過雙支援的 Proxy Server. 建立 Proxy Server 建立使用 Ubuntu 操作系統安裝 Squid proxy server, 請參考 安裝設定流程 . 從光世代遠端登入 請參考 Mechanical Designer and IPV6 中的說明, 若在 Ubuntu 則以 Remmina Remote Desktop Client, 以 RDP 協定進行連線, 前題是必須申請 光世代 IPV6 服務 , 然後在主機中執行 sudo pon dsl-provider 進行 IPv6 撥號連線後執行遠端登入.","url":"http://project.mde.tw/blog/ji-jie-she-ji-gong-cheng-xi-wang-lu-jiang-zuo-si.html"},{"tags":"2016g1","title":"RSA 模組","text":"再看完資料後就整理出來的部份 16版本沒有python2的工具包 因此先不考慮使用16版本的ubuntu Ode--13版本的binding已經改成python3的版本了，改法如下 setup.py裡面有一個解的地方再18行後面加上讓他去解碼的時候用utf8 try: ode_cflags = [x.decode(\"utf-8\") for x in ode_cflags] ode_libs = [x.decode(\"utf-8\") for x in ode_libs] except: pass 這樣就可以執行他的demo tutorial的範例程式碼 不過這邊只包含open dynamic engine 的引擎部份已經改成python可以控控制他了 這邊要補充一點，因為是compolier C++成so故只要串口做好，就不用在從新make 和install 接下來處理VTK的部份，這部份官網有相關的技術手冊，需要自己cmake所以相對麻煩 中途需要安裝opengl以及ccmake來指定路徑 (教學)[http://ghoshbishakh.github.io/blog/blogpost/2016/07/13/building-vtk-with-python3-wrappers.html] ARS模組的部份 只需要把幾個模組的部份改成python3的版本就可以使用了，例如exception , e: 改成exception as e還有print的部份要加括號大致上就這樣，已經修改完成了。 今天卡在VTK的部份，最近幾天再把他解出來就可以使用了 這次改這個open dynamic system改的很快，原因是因為許多問題都是以前已經碰過的，一下就知道如何解題目了，只剩下這個難搞的VTK部份，主要是作者把VTK綁在他自己的模組裡面，像from ars import app就可以呼叫他自己用的模組，這部份我可能再找時間把他做完，剩沒幾步路了。GO","url":"http://project.mde.tw/blog/rsa-mo-zu.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/12/26","text":"Pyslvs 編譯進度： 基因演算法 - 反解機構流程 復原重做功能計畫構思 Solvespace 格式 Pyslvs 圖示 Pyslvs 編譯進度 基因演算法 - 反解機構流程 做好第二個需要運算用的 panel，不過還沒套入基因演算法的 function 和 kernel，所以目前是存一個必經點的 list 給 QThread 在背景運算（或有其他可變項目），算完後預計用淺色的機構圖形展示結果，使用者可以決定是否需要合併到畫布上，亦或清除後重新計算一個結果。 Path Solving 這個面板是置頂的，會紀錄一個需要經過點的 list，關閉視窗後還在，除非重新啟動主程式；會考慮是否將「設計中」項目一起存進檔案中。 當面板開啟後，畫布的右鍵選單就能加入路徑點（不過還沒做出路徑點的顯示），或是自定座標。 按下 Generate button 就會開始計算，回傳機構數據，並預覽在畫布上。 合併的功能還需要想一下，畢竟 Solvespace 還需要初始座標，如果定的不好又會產生問題，所以必須稍微想一下。 Solvespace 格式 之前一直放置的原因就是因為 Qt 表格的字串沒有轉換格式，現在因為有分門別類的 list 儲存實體和約束，所以會比較好設計。 最近有空會試試看重寫一下 Solvespace 的格式，讓 Pyslvs 可以完美支援輸出回 Solvespace 做參照。 復原重做功能計畫構思 使用 Qt 的 undo 功能的話就得做多種「命令」格式，如果加入「命令」的時機太過底層，就會被非預期的命令呼叫到，例如讀檔和手動加入點座標是使用同一個 function。 所以盡量使用比較簡潔的命令。 表格處理方面：增、刪、編輯、上下移、修改 point style。 面板方面：路徑追蹤功能、驅動軸改的 demo angle、未來的 Path Solving。 另外有機會的話考慮做視窗的 undo list。 Pyslvs 圖示 稍微設計了 Pyslvs 的圖示，對應 Python 的顏色風格。 Windows 方面有 256 x 256 大小的 ico 檔案可以使用。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051226.html"},{"tags":"2016g1","title":"ARS 模組","text":"再看完資料後就整理出來的部份 官方技術手冊 使用方法(這邊先講python2的方法) 第一步 先把四樣工具找齊 Python-related packages numpy cython (這邊用到的模組python) VTK (GUI) Open Dynamics Engine (ODE) 這一個要自己build出來 以下式我測試成功的版本 明天會再用虛擬機跑看看不一樣版本的問題是否有衝突 apt-get install python python-dev python-support apt-get install python-numpy cython apt-get install libvtk5.8 python-vtk Download the ode-0.12.tar.gz and unpacking cd ode-0.12 ./configure --enable-double-precision --with-trimesh=opcode --enable-new-trimesh --enable-shared make make install 5.因為ODE裡面有python wrapper 要安裝他的binding到自己的python/distage cd bindings/python/ python setup.py install 安裝的部份就是這些工具了 可能要轉成python3的部份 VTK(如果要沿用的話) numpy cython (這部份可以沿用) VTK (要看官方是否有更新或改成OpenGl) Open Dynamics Engine (ODE) C++那部份不用動，要動的部份會是在bindings/wrapper 還有ARS模組的python程式碼 這部份是DEMO用的 要做的部份 接下來要做的部份就是把他改成python3 我應該會優先改wrapper再改RSA模組，並且測試和新版的ODE-13符不符合使用上的問題，使用虛擬機測試。 Wrapper可以優先測試import Ode，我會再測試。","url":"http://project.mde.tw/blog/ars-mo-zu.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/12/22","text":"Pyslvs 編譯進度： 移除需求提示視窗 雙平台編譯流程 Pyslvs 編譯進度 移除需求提示視窗 將大量當前不可用的命令 Disable，取代之前跳出的「不符合要求」提示視窗。 例如建立一個三角呆鍊需要 3 個連接點，如果點的表單沒有 3 個以上的點，會以紅字顯示需要的項目。 而編輯、刪除、上下移、轉換等等功能，雖然沒有說明，但是也必須符合條件時才會顯示或啟用。 至於路徑規劃、驅動軸等等面板，也都有相應的需求才能使用按鈕。 這個顯示的偵測是每次修改表格時，比以往按下產生一個新的對話視窗省資源。 雙平台編譯流程 Version 0.4 在 Github 的 Readme 中，寫上了 Linux 和 Windows 平台編譯出 Pyslvs 可執行檔的說明。 Linux 可以用 PyInstaller 或 cxFreeze 的 CLI（cxFreeze 不支援 Windows）直接編譯（擇一即可）。 而 Windows 方面寫了一個批次檔（名為 winBuild.bat ），可以編好兩個工具生成的檔案後合併，並已經指定好程式的圖示檔；有安裝必須工具的情況下能直接點兩下執行，在可攜環境必須用 command line 執行。 不過 Windows 版執行檔無法觀看文字回應（不會有 print），不過可以用參數命令正常開啟檔案、使用 Fusion 介面。 有試過工具安裝本機的情況下編譯 Windows 版本，但是仍不能只用單一工具，可能是 PyInstaller 和 cxFreeze 互有優缺吧。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051222.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/12/21","text":"Pyslvs v0.4 預計目標 Pyslvs 緊急修正 Pyslvs v0.4 預計目標 於分支 dev0.4 中開發 釋出 version 0.3 後，整個軟體大致的雛型已經出現了，不過在範例和轉檔部分仍然需要改進。 而另外需要進行的重大改進，包含以下目標： 可互動物件的畫布 這部分可能需要為「需要顯示」的項目歸類，包含： 點（特殊標示：固定軸／滑塊） 連桿（特殊標示：驅動軸／滑塊軌道） 呆鍊 路徑點（特殊標示：作用中路徑） 這些物件可能要分別做不同的類型，並且要擁有現在 QPainter 的特性（例如更換顏色），需要協同的需求性滿高的。 復原重做功能 這個部分正在著手製作，在部屬上較麻煩而已。 分為下列幾個功能： 表格新增復原（所有表格） 表格刪除復原（所有表格） 表格調整次序復原（驅動軸） 物件外觀復原（必須配合新的畫布做調整） Undo 與 Redo 功能是每個有存檔需求的軟體都必須要的項目，未來可能其他 project 可能也會應用到，所以會優先完成，並會把 Qt 的概念和使用方式做一篇整理。 基因演算法 - 反解機構 Github 倉儲： https://github.com/kmollee/django-project-template 這個部分使用之前學長的基因演算法，和 Solvespace 的 Kernel 一樣掛在軟體中。 不過目前遇到的問題點是這個 Kernel 是在 Linux 開發的，要給 Windows 平台使用的話就要重新編譯。 另外演算法的部分還要審查一下，以確定四連桿呆鍊的方向。 Pyslvs 緊急修正 由於之前將模組放在 __init__.py 檔的行為在 PyInstaller 和 cxFreeze 會被識別為掛在資料夾下，因此將模組修正到新的 modules.py 檔下避免誤判。 更新在分支 master 中。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051221.html"},{"tags":"2016bg2","title":"Python Copy Module","text":"Python 的記憶體管理 Copy Module Python 的記憶體管理 參考資料： http://billy3321.blogspot.tw/2009/01/python.html http://www.python-course.eu/deep_copy.php 相對於 C 語言而論，Python 的層級較為高階，為了展現可讀性以及易於管理，有自動調整的功能。 按常理而言，所有的記憶體位址是不能任意更動儲存值類型的。對 Python 而言，不同類型的值進行運算時都會進行轉換，重新分配後才會寫入新的位址中，也造成執行效率沒有 C 語言來的迅速。 Python 另一個特色是 list 類型，可以存入任何類型的值，並且能自由修改與增刪。 這是因為 Python 大部分的情況下都是以「記憶體位址」來存取（可以使用 id() 函式查詢），相當於 C 語言的指標，共用指標的物件就是同一個物件，其中一項值改變時，就會一起更改。 如以下範例： def changeLastOne(list1): list1[-1] = \"c\" list1.append(\"d\") b = [1, 2, 3] changeLastOne(b) print(b) #[1, 2, \"c\", \"d\"] 上述 changeLastOne 的 function 中，「list1」存取了「b」的記憶體位址（相當於下了 list1 = b 的指令），改變「list1」的值時，「b」的值也會改變。 這種基本的參照位址不僅限於兩個變數，可以同時參照給很多對象。 a = 0 b = 0 print(a is b) #True a = 0 b = 0 a += 1 print(a is b) #False a = 1, b = 0 c = 1 print(a is c) #True 在這個例子中，Python 會將還未拿來處理的記憶體共用位址，節省空間，改變時才會複製出來修改，存入其他位址。 a = [0, 1, 2, 3, 4] b = a[:] #使用了分割器，但是不分割 b[1] = 'x' print(b) #[0, 'x', 2, 3, 4] print(a) #[0, 1, 2, 3, 4] 上述的例子拿 list a 做了分割動作給 b，不過取出了完整值，導致 Python 認為這是個「處理」動作，於是將新的記憶體位址分配給它。 a = [0, 1, 2, 3, [0, 1, 2]] b = a[:] #使用了分割器，但是不分割 b[1] = 'x' b[4][2] = 'x' print(b) #[0, 'x', 2, 3, [0, 1, 'x']] print(a) #[0, 1, 2, 3, [0, 1, 'x']] 然而對於父類型儲存的記憶體位址，Python 也會一併複製，導致兩個父類型，雖然數據不同，卻會共用同一個子類型。 Copy Module 參考資料： https://docs.python.org/3.5/library/copy.html 不過這樣就會產生複製資料的問題，如果使用 a = b ，一律都是複製位址，無法做出一個一模一樣的資料分開修改，因此就必須匯入 Python 內建的 copy 模組。 import copy a = [0, 1, 2, 3, [0, 1, 2]] shallowCopy = copy.copy(a) deepCopy = copy.deepcopy(a) Copy 模組中包含兩種複製方式，名為「淺層複製」和「深層複製」，可以重新命令 Python 的參照方式。 淺層複製 shallowCopy[1] = 'x' shallowCopy[4][2] = 'x' print(shallowCopy) #[0, 'x', 2, 3, [0, 1, 'x']] print(a) #[0, 1, 2, 3, [0, 1, 'x']] 相當於一般 Python 的複製方式（如同上述的分割器），底層的物件仍然是共用記憶體位址的。 深層複製 deepCopy[1] = 'x' deepCopy[4][2] = 'x' print(deepCopy) #[0, 'x', 2, 3, [0, 1, 'x']] print(a) #[0, 1, 2, 3, [0, 1, 2]] 完全的複製資料，會透過紀錄位址盡可能的將目標值搜尋回來，建立在新的記憶區中，複製出來的項目已經和原本的資料完全不一樣了。 自訂 class 的比較 from copy import copy, deepcopy class foo(): def __init__(self, mylist): self.list = mylist listA = [0, 1, 2, 3] originData = foo(listA) shallowCopy = copy(originData) deepCopy = deepcopy(originData) listA.append(\"g\") #listA = [0, 1, 2, 3, \"g\"] print(shallowCopy.list) #[0, 1, 2, 3, \"g\"] print(deepCopy.list) #[0, 1, 2, 3] 不過進行「深層複製」會較「淺層複製」耗時間，如果想要取的值沒有子項目的話，使用「淺層複製」就不用去尋找是否有記憶體位址。 這部份紀錄是為了接下來做 Undo 與 Redo 功能，Qt 的 QUndoCommand 必須存入物件關聯，以及複製出當前的值做參考，所以必須瞭解 Python 的記憶區管理方式。","url":"http://project.mde.tw/blog/python-copy-module.html"},{"tags":"Misc","title":"CADLAB 舊電腦的處理","text":"2016 年暑假從 CADLAB 汰換下來的舊電腦, CPU 型號為 Intel E5200 , 因為並不支援 Intel 虛擬化技術, 因此建議直接安裝 Ubuntu 16.04.1 + ubuntu-desktop, 當作實體的 Server 使用. 安裝 LTS Server 與 ubuntu-desktop 處理的步驟為: 移除 PCI 插槽上的還原卡與主機版上的電池, 以便清除 BIOS 上原有的保護設定. 裝回電池後, 將記憶體從原先的 4GB 增為 8GB, 硬碟從原先 500 GB, 加掛至兩個 500 GB (RAM 與硬碟可以從其他舊電腦取用, 每兩台舊電腦拼成一台伺服器使用). 啟動時按下 del 鍵, 進入 BIOS 設定, 移除機殼開啟警示設定, 並確定斷電回復後電腦會主動開機. 利用其他電腦下載 Ubuntu 16.04.1 Server 程式, 燒錄成啟動光碟. 安裝過程無需上網, 安裝完成後依照 參考說明 、 IPV6 網址分配 與 網路導引 設定 IPv6 網路, 並且安裝 ubuntu-desktop 套件. /etc/network/interfaces 參考設定: auto lo iface lo inet loopback auto eth0 iface eth0 inet6 static address 2001:288:6004:17::XX netmask 64 gateway 2001:288:6004:17::254 dns-nameservers 2001:288:6004:1::2 2001:b000:168::1 安裝 squid 代理主機伺服程式 查驗電腦的記憶體, 確定至少有 8GB. grep MemTotal /proc/meminfo to check Ram size 接著安裝設定 squid: sudo apt install squid sudo gedit /etc/squid/squid.conf sudo service squid restart squid.conf 參考設定: acl cad_lab src 140.130.17.0/24 acl cad_lab src 2001:288:6004:17::/64 acl SSL_ports port 443 acl Safe_ports port 80 # http acl Safe_ports port 88 #acl Safe_ports port 21 # ftp acl SSL_ports port 8443 acl Safe_ports port 8443 acl SSL_ports port 9443 acl Safe_ports port 9443 acl SSL_ports port 22 acl Safe_ports port 22 acl Safe_ports port 443 # https acl Safe_ports port 1025-65535 # unregistered ports acl Safe_ports port 280 # http-mgmt acl Safe_ports port 488 # gss-http acl Safe_ports port 591 # filemaker acl Safe_ports port 777 # multiling http acl CONNECT method CONNECT # Deny requests to certain unsafe ports http_access deny !Safe_ports # Deny CONNECT to other than secure SSL ports http_access deny CONNECT !SSL_ports http_access allow cad_lab http_access deny all # Only allow cachemgr access from localhost http_access allow localhost manager http_access deny manager #http_access allow localnet http_access allow localhost # And finally deny all other access to this proxy http_access deny all # Squid normally listens to port 3128 http_port 3128 #cache_dir ufs /var/spool/squid 100 16 256 icp_port 3130 icp_access allow all cache_dir ufs /var/spool/squid 2000 16 256 cache_peer 140.130.17.2 sibling 3128 3130 # # Add any of your own refresh_pattern entries above these. # refresh_pattern &#94;ftp: 1440 20% 10080 refresh_pattern &#94;gopher: 1440 0% 1440 refresh_pattern -i (/cgi-bin/|\\?) 0 0% 0 refresh_pattern (Release|Packages(.gz)*)$ 0 20% 2880 refresh_pattern . 0 20% 4320 配置 nginx 與 uwsgi 伺服環境 接下來就可以安裝並配置 Python3 的網際程式伺服環境. sudo apt install python3-pip sudo pip3 install Flask sudo apt install build-essential python3-dev sudo pip3 install uwsgi sudo apt install nginx uwsgi-plugin-python3 /etc/nginx/sites-availables/default 設定檔: server { listen 80 default_server; #listen [::]:80 default_server ipv6only=on; listen 443 ssl; #listen [::]:443 ssl ipv6only=on; location /static { alias /home/cadlab/cmsimfly/static/; } location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8080; } server_name localhost; #ssl on; ssl_certificate /etc/nginx/ssl/nginx.crt; ssl_certificate_key /etc/nginx/ssl/nginx.key; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers \"HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES\"; ssl_prefer_server_ciphers on; try_files $uri $uri/ =404; } server { listen 88 default_server; #listen [::]:88 default_server ipv6only=on; listen 8443 ssl; #listen [::]:8443 ssl ipv6only=on; location /static { alias /home/cadlab/cmsimfly2/static/; } location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8081; } server_name localhost; #ssl on; ssl_certificate /etc/nginx/ssl/nginx.crt; ssl_certificate_key /etc/nginx/ssl/nginx.key; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers \"HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES\"; ssl_prefer_server_ciphers on; try_files $uri $uri/ =404; } 利用 /etc/rc.local 開機時啟動所有 uwsgi 程式: exec uwsgi_python35 --uid cadlab --gid cadlab --emperor /home/cadlab/uwsgi_ini /home/cadlab/uwsgi_ini/uwsgi.ini 設定檔案內容: [uwsgi] socket = 127.0.0.1:8080 plugins-dir = /usr/lib/uwsgi/plugins/ plugin = python3 processes = 4 threads = 2 chdir = /home/cadlab/cmsimfly wsgi-file = /home/cadlab/cmsimfly/wsgi.py /home/cadlab/uwsgi_ini/uwsgi2.ini 設定檔案內容: [uwsgi] socket = 127.0.0.1:8081 plugins-dir = /usr/lib/uwsgi/plugins/ plugin = python3 processes = 4 threads = 2 chdir = /home/cadlab/cmsimfly2 wsgi-file = /home/cadlab/cmsimfly2/wsgi.py","url":"http://project.mde.tw/blog/cadlab-jiu-dian-nao-de-chu-li.html"},{"tags":"2017","title":"轉換基準的 Pull Requests","text":"在 \"以 Pull Requests 參與網誌編輯\" 文章中, scrum-1 學員已經成功利用 pull requests 機制參與機械設計專題網誌的編寫. 此一利用 pull requests 參與倉儲改版的流程為: 登入 scrum-1 帳號, fork project_site 倉儲 git clone scrum-1 帳號下的 project_site 倉儲至近端 在近端以 git checkout gh-pages, 將工作目錄指向 gh-pages 分支 在近端的 project_site 倉儲中進行改版後, 新增提交並推送至 github 在 github 平台上送出 pull requests project_site 倉儲管理者設法合併 scrum-1 送出的 pull requests scrum-1 所增加的網誌內容將可呈現在機械設計專題網頁上 接下來當原始的 project_site 倉儲持續改版後, 位於 scrum-1 帳號下的 project_site 倉儲將會與原始的倉儲產生差異, 假如 scrum-1 希望先前所 fork 下來的 project_site 倉儲更新到原始倉儲的最新版本, 就是使用\"轉換基準 Pull Requests\"(switching base Pull Requests)的時機. 建立\"轉換基準 Pull Requests\", 是由 scrum-1 帳號提出, 基本流程與前述提出改版 Pull Requests 要求類似, 唯一的差別就是\"改版基準\"的互換, 以遠端的原始倉儲 gh-pages 分支為新版, \"要求\"將原始倉儲的版本合併至 scrum-1 帳號下的 project_site 倉儲. 由於此一轉換基準的改版倉儲位於 scrum-1 帳號下, 因此 scrum-1 具有合併此一自我提出要求的權限, 如下圖所示, 在沒有衝突的情況下, 可以直接在線上完成合併. scrum-1 用戶可以利用\"switching base\"連結, 要求建立\"轉換基準\"的 Pull Requests: 根據下圖, 轉換基準的合併要求可以直接在線上進行, 不會產生衝突: 最後, 如下圖所示, scrum-1 具有同意此一\"轉換基準版本合併請求\"的權限:","url":"http://project.mde.tw/blog/zhuan-huan-ji-zhun-de-pull-requests.html"},{"tags":"Misc","title":"處理學員 pull requests","text":"因為之前處理 scrum-1 pull requests 的合併, 直接在 github 網站上執行, 只是 scrum-1 所提交的版本為近端網誌版本, 因此這裡必須 git pull 後, 進行改版, 並且檢查無誤後, 改提交遠端版本. 直接合併 首先在近端新增目前這篇網誌 .md 檔案, 利用 local-pelican 與 https-server 在近端檢查網誌內容. 檢查無誤後, 利用 gh-pages-pelican 按鈕轉為遠端網誌格式之後, 提交推送. 無法直接合併 當 scrum-1 所送出的 pull requests 無法直接在線上合併時, github 建議: git checkout -b scrum-1-gh-pages gh-pages git pull https://github.com/scrum-1/project_site.git gh-pages 表示要將目前倉儲中的 gh-pages 簽出到 scrum-1-gh-pages 分支後, 拉回 scrum-1 目前的版本. 接著則改版目前這篇網誌內容, 並且利用近端 local-pelican 按鈕轉檔後檢視. 確定沒有問題之後, 改用 gh-pages-pelican 按鈕轉為遠端格式. 至於版本的提交推送, github 建議: git checkout gh-pages git merge --no-ff scrum-1-gh-pages git push origin gh-pages 表示要將近端倉儲的分支簽回 gh-pages, 然後合併 scrum-1-gh-pages 分支, 且以 no fast-forward 的方式進行合併. 最後再將近端 gh-pages 分支版本提交推送到遠端. 但是當我們操作 git merge --no-ff scrum-1-gh-pages 指令時, git 無法自動合併許多有差異的 html 檔案, 這時就必須再利用近端與遠端轉檔按鈕進行內容轉檔與查驗之後, 就可以: git add -A git commit -m \"try to add all changes on scrum-1-gh-pages branch\" 請注意, 這時的分支仍位於 scrum-1-gh-pages, 之後再執行: git checkout gh-pages git merge --no-ff scrum-1-gh-pages 表示要簽出 gh-pages 分支版本, 然後與 scrum-1-gh-pages 分支版本進行 no fast-forward 合併. 完成後, 再進行最後的近端轉檔查驗, 以及遠端的轉檔後, 就可將 gh-pages 分支版本提交推送.","url":"http://project.mde.tw/blog/chu-li-xue-yuan-pull-requests.html"},{"tags":"2017","title":"以 Pull Requests 參與網誌編輯","text":"Pull Requests 是一種間接 git 倉儲改版的模式. 在此展示如何利用 github 的拉回請求, 以及 Leo Editor 專案檔案的建立, 對機械設計專題網誌新增文章. Fork 倉儲 希望使用 Github 的 Pull Requests 功能, 必須在 github 系統中, 先登記用戶帳號, 啟用帳號後登入, 然後以瀏覽器連線到希望 Pull Requests 的倉儲網址, 利用 fork 功能, 將該倉儲\"互刻\"(所謂互刻, 就是一種互相具有連結關係的倉儲複刻) 到所登錄的 github 帳號下. 接下來則建議對於該 forked (互刻) 的倉儲, 儘量 git clone 到近端改版之外, 並且每間隔一段時間, 利用 github 所提供的\"反向 pull requests\", 保持與原始倉儲版本的同步, 避免因版本差異過大的情況下, 提出 Pull Requests, 而提高合併衝突的困難度. 如前所述, 這篇網誌是由 github 帳號 scrum-1 所建立, 截至目前, scrum-1 用戶已經完成 fork project_site 倉儲的動作, 而且以 git clone 將機械設計專題複製到近端改版. 而改版前的第一要務就是確認近端倉儲所在的分支. 切換分支 因 project_site 在 github 上的 default branch 為 master, 因此 git clone 到近端之後, 必須利用 git checkout gh-pages 切換到 gh-pages 分之後, 才能在正確的工作目錄中進行改版, 之後提交推送, 也必須注意, 一定要指定 gh-pages 分支, 才能正確對 github pages 網誌內容改版. 其次, 因為 scrum-1 用戶代表 2017 年學號以 4042 開頭的學員, 因此先在 clone 下來的倉儲中, 利用 git checkout gh-pages 將工作目錄轉到 gh-pages 分之後, 新增 users/4042 與 content/4042 目錄, 並將其個人用戶所屬的 .leo 檔案存為 users/4042/scrum1.leo, 並且利用 Leo Editor 的節點指令 @path 與 @edit, 將個人所屬的 .md 檔案, 存在 content/4042 目錄中, 例如: 目前這篇網誌的 .md 檔案為 content/4042/scrum1_20161215.md 因為同屬 4042 專題學員的 .md 檔案都規劃存在 content/4042 目錄中, 因此要求各用戶將各自所寫的 .md 檔案名稱中冠上 github 帳號, 除了避免彼此覆蓋內容外, 也可以明確找出不同用戶所寫的網誌 .md 檔案. 圖檔管理 在 Pelican 網誌系統中管理文章中所引用的圖檔, 是一項大工程, 假如文章內容與所引用的圖檔都要全部納入分散式版本管理的架構, 方法之一是將專門存放圖檔的 project_site_files 倉儲 gh-page 分支設為 project_site gh-pages 分支的子模組, 然後兩個倉儲分別改版 (也就是不要在 project_site 的改版過程中企圖修改 project_site_files 子模組對應目錄下的檔案). 但是在兩個倉儲利用 pull requests 或者 git submodule update 的過程並非同步時, 近端無法即時看到納入 project_site_files 倉儲中的圖檔. 另外一個比較建議採用的方式則是兩個倉儲分開維護, 若參與協同的學員擁有 project_site_files 倉儲的管理權限 ,就必須先將近端引用的圖檔先推送到 project_site_files 的 gh-pages 分支, 然後在 .md 文章中, 直接引用圖檔的絕對目錄, 例如下圖: 以下的三個圖檔, 也是先放到 scrum-1 近端的 project_site_files gh-pages 分支工作目錄中之後 ,以 git add -A git commit -m \"add scrum1 20161215 picture files\" git push origin gh-pages 提交推送到 scrum-1 帳號所屬的 project_site_files 倉儲之後, 再建立 pull requests, 然後由 project_site_files 倉儲的管理者接受後合併版本 ,就可以直接以圖檔案的絕對 URL 引用如下: 網誌提交推送 一旦 scrum-1 學員完成 .md 的文章原始檔案編輯, 且透過近端 local-pelican 按鈕轉為 pelican 網誌 html 系統之後, 可以利用支援 IPv4 的 https-server 按鈕或支援 IPv6 的 ipv6-https-server 按鈕, 在近端以 https 檢視網誌後, 直接提交推送到 scrum-1 的 project_site 倉儲後進行 pull requests, 由於拉回請求的過程, 管理者除了必須納入 scrum-1 所新增的 .md 檔案外, 其餘都必須先在近端用 local-pelican 按鈕轉檔檢驗, 因此 scrum-1 無需在 pull requests 的流程中提交 gh-pages-pelican 按鈕所產生的遠端格式版本(多了 disqus 留言系統), 可以直接提交近端版本即可. 但是負責審核 pull requests 的管理學員, 除了在近端檢查機械設計專題的網誌改版內容之外, 必須記得在提交推送到 project_site 倉儲 gh-pages 分支之前, 利用 gh-pages-pelican 按鈕, 將 .md 檔案轉為遠端網誌格式, 否則 disqus 留言系統將無法正確呈現. 最後, scrum-1 學員一旦完成互刻 project_site 倉儲 gh-pages 分支的提交推送後, 即可針對 gh-pages 分支, 新增 pull requests, 接下來就是 project_site 倉儲管理端審核請求, 以及納入改版內容的流程.","url":"http://project.mde.tw/blog/yi-pull-requests-can-yu-wang-zhi-bian-ji.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/12/14","text":"Pyslvs 編譯進度： 路徑追蹤 - 驅動軸 大二專題網站 Pyslvs 編譯進度 路徑追蹤 - 驅動軸 路徑追蹤功能已經可以將所有驅動軸旋轉的座標路徑一齊算出。 之後會再修正畫面的呈現，因為還沒有類似遮罩的功能，無法分辨對應的驅動軸。 預計將 Shaft0 的路徑彩色顯示（對應機構點的顏色），其他驅動的路徑以灰色顯示；而且外觀會隨著上移和下移驅動軸表格而變。 至於 QGraphicsView 畫布的測試仍須一段時間，找不太到可互動的畫布範例，PyQt 的範例也更少；而 Python CAD 的物件類型分滿細的，在繼承方面比較難找些。 大二專題網站 今天讓學弟建了倉儲來存放未來網誌的文章，並稍微講解 Python 程式常用規則，想請教老師下學期專題網站的建立。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051214.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/12/13","text":"Pyslvs 編譯進度： 捷徑功能 驅動軸相關 Kernel 其他修正 Pyslvs 編譯進度 捷徑功能 現在所有表格在項目上雙擊滑鼠左鍵，可以編輯該項目內容。 而在衝突導致解題失敗時，DOF 的欄位會顯示 \"Failed\" 字樣，標籤也會改成粗體紅字。 之後會再審視不方便的操作方式以改進。 驅動軸相關 改善關於驅動軸相關的功能，並且改成只能驅動 DOF 為 1 的機構。 目前畫面上顯示的解為 Shaft0 的 Demo Angle 的解，而要切換驅動軸，可以右鍵選單中的上移與下移功能，移到 Shaft0 位置的就會套用 Demo Angle 的約束；目前只剩驅動軸和參數表格有上移與下移的選項。 另外驅動軸面板的切換選單可以暫時套用選定軸的 Demo Angle 約束，關閉面板後會切回 Shaft0 的約束。 在 Path Track 功能中，用了一組選擇驅動軸的介面，不過還沒連接 function，在預設的選項中只有 Shaft0，調成 All 後將會解出所有驅動軸帶動的路徑。 設計好驅動軸的功能後，大致上就能解所有 DOF 為 1 的純連桿機構路徑了；而驅動滑塊的功能還待加入。 Kernel 其他修正 Grashof chain 範例已經全數加入，不過因為 Kernel 問題，某些範例的路徑追蹤點必須重新繪製。 與驅動軸旋轉點相依的其他點，初始值也必須做修正，不然在轉到 180 度之後，會造成其他點因為旋轉點初始位置修正，造成機構反折的狀況。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051213.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/12/12","text":"Pyslvs 編譯進度： 諸多錯誤修正 葛氏運動鍊：Kernel 校正 復原重做功能 Pyslvs 編譯進度 諸多錯誤修正 之前留下一些大大小小的 Bug，會造成程式在讀取檔案或是新增資料時因錯誤而關閉。 花了一些時間測試功能，確定已完成的功能運作流暢。 另外還修整了一下界面，避免在 Windows 和 Ubuntu 切換之間發生 Layout 空間延展的問題。 葛氏運動鍊：Kernel 校正 Example 項目中多出了一個 \"Grashof chain\" 類別，預計加入所有葛氏運動鍊的四連桿範例。 也因為當時寫的校正座標指令是以原點為中心點，造成其他象限的中心軸轉動時，旋轉點出現怪異的運算結果。 校正繞行圓心時造成中心與旋轉點的位置差，目前座標位置如果比中心還高，基本運行就會流暢，不過如果初始低於圓心，還要加上其他判斷才能修正。 提前測試一下學長論文中的近似直線範例： 復原重做功能 這個部份快要整備好了，但是不知道運作效能如何，也還沒部屬必須紀錄的步驟。 仿照 Qt 的方式寫了一個相似的類型（因為 Qt 必須部屬在所有指令上，而且還要另外寫反向命令），並在需要時存入重要資訊，一定的步驟內可還原上次的表格內容。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051212.html"},{"tags":"2016g1","title":"四連桿合成編譯","text":"平面四連桿尺寸合成研讀 已經將學長的code看完RGA(基因演算法)的部分 學長是使用cython來寫演算法的部分，python主要是程式架構而已，要啟動他必須藉著python找答案 GA演算法大致上的作法 1.Cp(複製) 2.crossower(交配) 3.mutate(突變) 4.fitness(適應值) 5.report(回報) 6.getParamValue 設定邊界(Ax,Ay) (Dx,Dy) 是兩個fix的座標點的上下界 Max upper AX AY DX DY L0 L1 L2 L3 L4 Min lower AX AY DX DY L0 L1 L2 L3 L4 目標點給的點數，學長的論文裡面是(0,0)到(10,10)的點 target path [(x,y)(x1,y1)()()()()()()] all Expression 這項我不懂 A,L0,a0,D,B,B,L1,L2,D,C,B,L3,L4,C,E Driving A 驅動桿 Follower D 被動桿 Link L0 L1 L2 L3 L4 連接桿 connect L1 連接桿 nParm 19 這樣不懂 nPop 250 這樣不懂 pCross 0.95 交配率 pMute 0.05 突變率 pWin 0.05 勝率 bDelta 5 突變參數 maxGen 1500 最大子代 report 100 回報週期 我目前是在linux上面做，先將cython編譯成so來做連接庫 python3 setup.py ext_build 做成連結庫，這部分有個問題，我有辦法做成在linux電腦上面都能用的連結庫嗎? 底下是我的倉儲 pyslvs_generate 以及我解出來的答案，會有19組 ，我當時猜想會不會是取前9組答案就好，因為後面那些答案我不知道是要做什麼的 -29.8262,26.5961,-36.8366,3.3764,4.2368,29.9217,9.2923,36.5820,39.4538,59.0497,4 1.7408,50.1189,34.8905,30.3267,77.2301,85.4167,102.6586,68.3543,94.1729 這些答案排版起來就是(Ax,Ay) (Dx,Dy) L0 L1 L2 L3 L4 (Ax,Ay) (-29.8262,26.5961) (Dx,Dy) (-36.8366,3.3764) L0 4.2368 L1 29.9217 L2 9.2923 L3 36.5820 L4 39.4538 第10項以後我就不知道要做什麼了，回傳的答案給的，這個是通過 (1 ,1),(2 ,2),(3 ,3),(4 ,4),(5 ,5),(6 ,6),(7 ,7),(8 ,8),(9 ,9),(10,10) 這些點座標的連桿","url":"http://project.mde.tw/blog/si-lian-gan-he-cheng-bian-yi.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/12/09","text":"Pyslvs 編譯進度： 背景資料名稱 修改畫布 Pyslvs 編譯進度 背景資料名稱 之前為了不讓格式混亂，使用一個函式來轉換所有表格的字串成為數據，但是因為只單純用到清單的功能，分不出來項次代表的內容。 後來成功改成鍵值的方式存取，在辨識上會更容易。 這部份希望改成修改時同步清單，而非使用時才轉換。 修改畫布 由於當前的畫布互動功能只侷限於觀看的部份，在編修上還是得頻繁地去側邊的表格調整，所以必須針對這個部份改強。 參考 Python CAD（GPL 2.0）的方式，使用 QGraphicsView 和 QGraphicsScene 來建立畫布，以方便管理。 另外 QGraphicsView 和 QGraphicsScene 的顯示功能也比單純的 QPainter 強大，節省了不少功能。 不過這種方式修改的部份滿多的，也要重新建立迴圈來畫圖，所以可能會用上一段時間，先從範例的部份開始練習。 如果瞭解QGraphicsView 和 QGraphicsScene 的流程後，也會把教學寫在網誌上。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051209.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/12/08","text":"Pyslvs 編譯進度： Bug 修正 檔案格式檢查 __init__.py 利用 反解連桿尺寸 & 多個驅動軸 技術手冊 Pyslvs 編譯進度 Bug 修正 檢查了一下之前的 code，將兩個地方修正。 一個是開新檔案的 function 填錯 table 位置所以刪錯項目；另一個是一段時間前將 function 歸類時，造成填寫路徑清單的視窗 function 名稱寫錯。 另外將清單處理的 list_process.py 更名為 listProcess.py ，並從 calculation 資料夾轉到 io 底下。這裡的函式經過歸類後，比較像讀寫功能；而非計算功能。 檔案格式檢查 做了一個小型的檔案格式檢查函式，讀取 csv 的三個標籤（ _info_ 、 _table_ 、 _path_ ）數量來檢查。 不過就算如此，其中寫入錯誤訊息，還是會導致程式錯誤而關閉，應該改寫成跳出回報錯誤的視窗拒讀，避免造成如 Solvespace 閃退的困擾。 而之後可能會移除非必要的項目減少 csv 檔案體積和利於程式檢查。 __init__.py 利用 為了讓 main.py 起始的標頭不要都是 import 的項目，將所有的 import 項目放到 core 資料夾的 __init__.py 中（跟 main.py 同層級）。 這樣 main.py 可以向 __init__.py 借入資料，節省主程式的空間。 反解連桿尺寸 & 多個驅動軸 預計加入過去學長使用的演算法，使用者指定路徑後，以四連桿的方式反推，「設計」出近似使用者指定路徑的四連桿。 這個演算法可能會變成類似解路徑的彈出功能，會在介面上規劃空間給它使用，並將解出的第一組解填入表單讓 Solvespace kernel 運算顯示，使用者亦能在產生滿意解之後，另行編修。 原本的路徑功能也是想支援多個驅動軸的功能，由於當時不太了解 Python 的功能，並沒有做出。不過當初資料格式是有支援寫入多個驅動軸運行的結果，應該較容易相容。 技術手冊 由於後輩的加入，開發人員的技術手冊應該要在下學期開始前盡快完成，期末前會再審查一次原始碼，歸類好後 Relese v0.4.0 或更新版本以給技術手冊介紹使用。 之後範例檔案都會存在 core/io/example.py，用 function 回傳 data 值讓程式讀取，若有改版也會附上檔案格式修改的提醒。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051208.html"},{"tags":"2016g1","title":"四連桿合成","text":"平面四連桿尺寸合成研讀 學長的論文裡面包含了許多範例和數學方程式，也有看到可以加到我們的Pyslvs裡面，說不定接下來就可以只靠路徑就把四連桿的樣子做出來。 找不到學長當時論文的電子檔 分析連桿的位置 兩點一線一夾角 圖形後面再補上，還在研究latex畫圖 對四連桿機構進行分析 學長著重在RRRR連桿組的設計 接下來對演算法進行分析 GA(基因演算法) DE(差分演算法) FA(螢火蟲演算法) 問題點 學長裡面用到的方程式不太理解他的意思 $$Fit_{min} = \\sum_{i=0}&#94;{n}\\sqrt{(O_{x,i}-N_{x,i})&#94;2+(O_{y,i}-N_{y,i})&#94;2}$$ 這個式子不太理解他在求什麼東西 O和N的代表意義","url":"http://project.mde.tw/blog/si-lian-gan-he-cheng.html"},{"tags":"Misc","title":"Windows 環境下的可攜 Eric6 IDE","text":"從 KMOL 的程式開發環境 , 可知在 2016 年是以 Ubuntu 16.04 操作系統為主, 但是為了在課程中推廣 Python3 與 PyQt5 的應用, 因此特別打造 64 位元 Windows 環境下的 Eric6 可攜程式開發環境. 先安裝 mingw 與 msys, 之後再安裝 sip-4.18.1 、PyQt5_gpl-5.7 與 QScintilla2, eric6, peewee, dxfwrite 等模組, 即可以 eric6 開啟 eric6 開發套件. 基本安裝步驟如下: 從 https://sourceforge.net/projects/mingw-w64/files/latest/download?source=files 下載 mingw-w64-install.exe 安裝後 ,配合其擷取 gcc.exe 路徑, 設為可攜. msys 則取用先前可攜舊版本, 放至 y:\\msys, 且 make.exe 位於 y:\\msys\\bin 目錄中. 從 Anaconda3 目錄中複製 python35.dll 並使用 mingw32\\bin 目錄中的 gendef.exe 以 gendef python35.dll 建立 python35.def 並以 dlltool --dllname python35.dll --def python35.def --output-lib libpython35.a 建立編譯 sip 所需的 libpython35.a 將 libpython35.a 複製到 Anaconda3\\libs 目錄中 下載 sip-4.18.1 原始碼 , 進入目錄中後以 python configure.py --platform win32-g++ configure 後 ,以 make 完成 sip.exe 以及 sip.pyd 建立. 將 sip.exe 複製到 y:\\Anaconda3 目錄中 將 sip.pyd 複製到 y:\\Anaconda3\\Lib\\site-packages\\ 目錄中 將 siplib\\sip.h 複製到 y:\\Anaconda3\\include\\ 目錄中 將 sip.pyi , sipconfig.py, sipdistutils.py, siputils.py 等檔案, 複製到 y:\\Anaconda3\\Lib\\site-packages\\ 目錄中 利用 pip install PyQt5 安裝 PyQt5 , 利用 pip install QScintilla 安裝 QScintilla2 下載 Eric6 原始碼, 進入目錄後利用 python install.py 完成 Eric6 安裝, 之後可使用 eric6 啟動 利用 conda 安裝 peewee ORM 模組 conda install -c conda-forge peewee=2.8.1 利用 pip install dxfwrite 安裝模組 上述步驟所完成的 Eric6 可攜整合程式開發環境位於 https://service.mde.tw:8443/downloads/kmol/ , 僅支援授權用戶下載. 接下來, 為了打包 Python3 與 PyQt5 所建立的程式套件, 利用 conda 安裝 pyinstaller. conda install -c acellera pyinstaller=3.2.3 並且利用 pip install cx_freeze 安裝 cx_freeze. 打包過程共有兩個步驟: pyinstaller -w --onedir launch_pyslvs.py -w 表示要建立 gui 程式套件. 所產生的包裝程式位於 dist 目錄中 python setup.py build setup.py 內容: from cx_Freeze import setup, Executable import sys build_exe_options = {\"packages\": [\"os\"], \"includes\": [\"PyQt5\"], \"excludes\": [\"tkinter\"]} base = None if sys.platform == \"win32\": base = \"Win32GUI\" setup( name = 'solvespack', version = '1', description = '.', executables=[Executable('launch_pyslvs.py', base=base)], options={\"build_exe\":build_exe_options}, ) 所產生的包裝程式位於 build 目錄中. 最後, 合併兩個套件所建立的包裝檔案, 並以 Pyinstaller 所產生的 .exe 為主體, 啟動 PyQt5 視窗程式.","url":"http://project.mde.tw/blog/windows-huan-jing-xia-de-ke-xi-eric6-ide.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/12/07","text":"PyInstaller 編譯問題 PyInstaller 編譯問題 將目前原始碼轉為執行檔的測試。由於之前只有成功編譯小型的 PyQt5 介面，所以嘗試看看在比較大的架構下，所有分支模組中是否會有導入問題。 Pyslvs 程式碼整理 將程式碼整理了一下，避免發生一些狀況。 移除了讀取 git 資訊的功能，因為這個資訊會讀取 .git 資料夾內的內容。 後來將 PyQt4 的導入去除，實際上也沒有用到 PyQt4 的框架。 Solvespace 函式庫問題 出現了一個重大的問題，在編譯後會找不到函式庫的名稱。 ImportError: No module named 'core.kernel.py35w._slvs' ... ImportError: DLL load failed: The specified module could not be found. 參閱 PyInstaller 的技術文件後，瞭解到如果使用的 DLL 類函式庫名稱不在程式碼中的話，必須手動加入 Spec 文件中。 https://pyinstaller.readthedocs.io/en/stable/spec-files.html Spec 文件是 PyInstaller 的執行腳本，若沒有指定的話會自己生產一個預設設定的 Spec 文件。 Spec 文件的 Analysis 中包含四個項目： scripts ：當作主程式啟動的腳本（就是指令中 input 的檔案，只有一個）。 pure ：所需的 Python 模組（通常會直接參照 import 的項目搜尋到，所以不用填）。 binaries ：所需的非 Python 模組。 datas ：其他所需的非二進制文件（如圖片或是音訊檔）。 不過在 binaries 清單中的示範是填入函式庫中的連結名稱，不知道如果是 DLL 或 SO 的話要如何辨識名稱；直接寫上 _slvs.pyd 或是 libslvs.so 的位址也不能解決問題。 Ubuntu 編譯成功 在一台 16.04 的實體機中，使用 PyInstaller 直接用預設設定編譯，能成功編譯出 Pyslvs 的 Linux 版可執行檔。 Linux 平台的 SO 函式庫似乎不用特別指定也能找到 _slvs.so 和 libslvs.so 的內容；Windows 的 DLL 就得看當初連結庫的名稱是什麼了。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051207.html"},{"tags":"2016g1","title":"寫字機","text":"起源 一般寫字機，都是用最基本的XYZ型式做的，因為在thingverse上面找到相關的機器，想說就來做做看。 thingverse 在機構方面看到許多相關資料，想試試看不一樣的機構製做這個平台，因此搜尋了CoreXY這種結構的皮帶運動，看他的介紹是可以在高速運動下使用的機構，因為手邊也有3D列印機，就把他列印出來試試看可不可行。 電機相關 在機構處理完就開始找電控的板子，因為這台機台和CNC的控制方式類似，同樣都擁有XY兩軸，在加上手邊只有arduino ，就嘗試性的google了一下:\"Arduino CNC\"，結果就找到了這塊版子 這塊版子在大量生產下的原因，價錢也非常的平價，加上也是開源系統，全部控制加一加，1000元以內有找，加上這塊板子也是用A4988這塊驅動晶片，和大部分3D列印機的驅動晶片相同，因為有四組，可以控制四顆馬達。 在晶片上面可以看到有個可以旋轉的螺絲頭，他是負責調電壓，扭力要大一點就把電壓開大一點(千萬不要開太大會超燙)，大約就調到0.37V就已經很夠了，因為不是重負荷，調整的方法就是，使用三用電錶，一端放在螺絲上，一端在地線，就可以測得他的電壓，切記小心，不小心短路就沒了。 接下來就開始往韌體方向尋找相關方法，還在想說可能要自己寫控制器，算數學的時候，發現到一套從以前就已經開源的CNC韌體Grbl，在裡面的程式碼可以學習相關的控制器撰寫， grbl 控制方面 在一般傳統CNC，都會有sensor，知道目前刀軸現在的位置，程式會判斷是否要補正，但是這些感測器的價錢都不便宜，就我們學生而言，這已經不是負荷的起的價錢，Grbl利用一些方法來防止步數少的問題， EX:梯形速度規畫 遇到圓角切削，如果按照剛剛看到的梯形會變成非常多小段進行控制，運轉會有問題 他的解法就變成了這樣Vjunction，主要是用在兩條線夾角趨近於180度，那就有可能是高密度曲線 可是一但遇到夾角為90度，那代表他會變成往反方向移動，那就要確實減速 1.Ventry 是第一條線的速度向量 2.Vexit 是第二條線的速度向量 3.Ventry和Vexit的夾角 θ 4.綠色線 δ 為一常數 5.R 為圓的半徑 式子(1)：基本 sin 函數, θ, δ, Ventry 邊組成的三角形來計算 式子(2)(3)：把它左右搬移一下, 得到求 R 的算式 由於式子 (3) 可以用其下方的算式替換, 結果就是我們只要運用兩次開根號就求得解 雖然我們畫圖可以很清楚知道 θ 的角度, 但是 CNC 機器只收到該往哪裡移動 它並沒法知道夾角, 而求這夾角需要頭痛的 acos 來先找到 θ 值 但是對於8bit的 MCU這會是運算負擔，在Grbl裡面的planner.c 的 plan_buffer_line 他的韌體有許多可以用到的數學，值得一一解開看他的控制器，可惜的是目前的專業知識不夠讓我完全了解他的程式在訴說的事情，雖然都有註解可以查，可能會慢慢的解開一包包在寫的東西。","url":"http://project.mde.tw/blog/xie-zi-ji.html"},{"tags":"Misc","title":"Leo Editor 專案的 https 按鈕","text":"隨著機械設計專題在 近端與遠端分散式版次管理的需求 , 我們增加在純 IPv6 模式下啟動近端 https 伺服器的按鈕. IPv4 https 近端伺服器按鈕程式碼: import os import subprocess import threading import http.server, ssl def domake(): # build directory os.chdir(\"./../\") server_address = ('localhost', 5443) httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler) httpd.socket = ssl.wrap_socket(httpd.socket, server_side=True, certfile='localhost.crt', keyfile='localhost.key', ssl_version=ssl.PROTOCOL_TLSv1) print(\"5443 https server started\") httpd.serve_forever() # 利用執行緒執行 https 伺服器 make = threading.Thread(target=domake) make.start() IPv6 https 近端伺服器按鈕程式碼: import os import subprocess import threading import socket import http.server, ssl class HTTPServerV6(http.server.HTTPServer): address_family = socket.AF_INET6 def domake(): # build directory os.chdir(\"./../\") ipv6_address = '::1' server_address = (ipv6_address, 6443) #httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler) httpd = HTTPServerV6(server_address, http.server.SimpleHTTPRequestHandler) httpd.socket = ssl.wrap_socket(httpd.socket, server_side=True, certfile='localhost.crt', keyfile='localhost.key', ssl_version=ssl.PROTOCOL_TLSv1) print(\"6443 https server started\") httpd.serve_forever() # 利用執行緒執行 https 伺服器 make = threading.Thread(target=domake) make.start() 另外, 為了配合近端與遠端全面支援雙網路協定伺服器, 所有 Pelican template 連結, 也都從 http 改為 https 連結.","url":"http://project.mde.tw/blog/leo-editor-zhuan-an-de-https-an-niu.html"},{"tags":"Tutorial","title":"何謂機械設計?","text":"所謂機械設計, 就是歷經詳細思慮考量, 完成互動元件間之精巧配置, 使其展現特定功能之具體規劃表達. 其中, 詳細思慮考量, 就是\"計\"的字義, 而精巧配置互動元件, 就是\"機\"的字義, 展現特定功能, 就是\"械\"的字義, 最後, 必須完成具體規劃表達則是\"設\"的字義. 因此機械設計共包含下列要件: 經過詳細思慮考量過程 (計) 結果為互動元件間之精巧配置 (機) 配置可展現特定功能, 用於解決所面臨問題 (械) 必須明確表達結果之具體規劃 (設) 而一般工程表達的方法, 包括口語表達, 文字表達, 2D 表達, 3D 表達, 理論解析(定性定量)表達, 實體表達等. 且上述各類表達, 會因時間、地點、參與者、團隊組織的遷流變化而衍生出各式版本, 機械產品的協同設計, 便在各式表達的版本中, 尋求各互動元件組成的可用性外, 也期望透過相同功能的不同供應者, 作為精巧配置的選項, 以降低風險. 至於機械設計的所謂互動元件, 包括固體、流體與軟體, 隨著全球化數位經濟的蓬勃發展, 直接利用雲端統合機械協同設計過程中的所有內容, 已然成為可行方案之一. 當然, 隨著 Onshape 雲端設計表達工具的出現, 各公司目前將所有資料集中在雲端, 統一由一組團隊控管的模式, 未來勢必要納入如 Git 分散式版次管理的模式, 讓資料擁有者可以在無網路支援的單機狀態也能改版, 畢竟, 雲端 CAD/CAE/CAM, 充其量, 只不過是機械設計工程表達的方式之一而已.","url":"http://project.mde.tw/blog/he-wei-ji-jie-she-ji.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/12/06","text":"Windows 環境 Pyslvs 編譯進度 Windows 版進度 因為其他作業需求必須編譯 Windows 版的 Python 執行檔，所以順便弄了一下編譯環境。 在 Windows 架好了撰寫 Pyslvs 所必須的工具： Anaconda Python 3.5.4（執行檔安裝） Qt 5.7（官方執行檔安裝） pip 套件（下載 get-pip.py 執行） 更新 SIP（conda install 更新） PyQt 5.7（pip 安裝） QScintilla（pip 安裝） Eric6（Python 執行 install.py ） PyInstaller（pip 安裝） 現在的 PyInstaller 已經不能跨平台編譯了，只能在相應的平台編出可執行檔，而且有 32 和 64 位元的差異。 Pyslvs 編譯進度 將範例檔直接放入程式中而不會不小心覆蓋到原始檔。 另外還將存檔功能歸類了一下，避免搞亂原本的範例。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051206.html"},{"tags":"2016g1","title":"機台控制","text":"已經可以使用python進行控制了,只是目前gui還在實做當中,或許再一陣子就可以做出gui了,目前單獨用讀檔案的方式在送值到機器裡面。","url":"http://project.mde.tw/blog/ji-tai-kong-zhi.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/11/27","text":"關於 Pyslvs 格式整合的計畫 2D 格式 目前只能畫出支架的圖形，所以要盡快弄出完整樣式。 使用 dxfwrite（授權類型：MIT）畫出基本連桿（或滑塊）的圖形，也許可以給幾種款式選擇。 匯出後（到其他 CAD 軟體上），不同件使用不同圖塊，方便使用者分開更改或直接長出建模。 這方面參照一下 dxfwrite 寫入的方式，放到 Free CAD 或 Autodesk 產品中能夠編修就沒問題了。 3D 格式 使用 python-stl （授權類型：MIT）畫出立體的模型，符合結構強度的外觀。 這部份可以盡量少讓使用者修改，或變成組合圖的形式（需要調整重疊順序）。 轉成 3D 的功能主要是讓 V-rep 可以馬上導入做模擬，可以做一個「生成關節轉軸」的選項。 不過對寫入 STL 文件沒什麼經驗，可能要稍微比對其他 3D 模型。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051127.html"},{"tags":"2016g3","title":"40323214日誌-齒輪計算","text":"一.齒輪的公式轉換 執行程式 import math import sympy from sympy import pi #a=壓力角 #算節圓直徑 def tes1(m,t): d=m*t return(d) #有效齒深 def tes2(m): h=2*m return(h) #算模數 d1=外徑 def tes3(d1): m=d1/(t+2) return(m) #基圓直徑 def tes4(d,a): dg=d *math.cos(a) return(dg) #周節 def tes5(m): t0=pi.evalf()*m return(t0) 二.執行後心得 以上程式是關於計算正齒輪的數值，在小組做出辨識齒輪的外徑以及尺數之後，導入上述程式可以求得齒輪其他的數值，例如模數、節圓直徑...等。 而辨識出壓力角之後，就可以再計算更多關於齒輪的數值。 三.執行後問題 在寫完這些程式之後，發現 sympy函式庫出現問題\"No module named 'sympy'\"，而原因是導入pi這個函式需要使用到sympy，所以自己在網路上找了解答，發現原來是環境裡面並沒有這個函式庫，於是我從\"https://pypi.python.org/pypi/sympy\"網址中下載了安裝檔，並且把所需的資料拉進環境路徑裡面，就能夠正常執行計算式子。 五.參考的網頁資料 1.齒輪計算公式:http://coccad.com/subject/about/2427.html 2.Sympy安裝網頁:https://pypi.python.org/pypi/sympy","url":"http://project.mde.tw/blog/40323214ri-zhi-chi-lun-ji-suan.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/11/20","text":"Pyslvs 編譯進度 Pyslvs 編譯進度 佈署單元測試函式（unittest） 建構了需要測試的項目，會提取主程式的函式測試回傳值。 也因為測試需求，把主程式 main.py 單獨留在 core 資料夾中，其他程式都歸類進資料夾中，方便之後測試函式呼叫。 不過目前的項目只有 Kernel 解題，之後會增加測試單元。 執行頂層目錄的 launch_test.py 來啟動單元測試。 清單處理格式轉移 處理表格及算點的程式都放到 calculation 資料夾中。 原本都是讀取 Qt 的 Table Widget 來取得點座標，但是這樣處理太過混亂（因為回傳值是字串而非數字），也會降低執行效率，所以打算更改。 原先處理表格的 list_process.py 劃分出不同表格的 class，它們的函式也重新命名過，更能知道用途。 1 2 3 4 5 6 Points (style) Lines Chains Shafts Sliders Rods 下一步是在 init 初始化函式中建立空的 list（每筆資料型態都是鍵值），和 Qt 的 Table Widget 同時紀錄資料（格式對應），取資料時不再於 Table Widget 抓資料，而是呼叫所屬 class 的 list，不用轉換格式。 至於還有一些名稱太冗長的程式碼，可能會用 class 歸類，更容易瞭解用途。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051120.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/11/19","text":"Pyslvs 編譯進度 Pyslvs 編譯進度 視角拖曳 做出與 AutoCAD 相似的檢視方式，單靠按住滑鼠滾輪即可自由移動圖形而不會一直鎖定在畫面上。 過去按住 Ctrl 鍵的功能仍會保留。由於必須按住鍵盤，不至於會與主要檢視方式衝突。 技術手冊 1 2 3 User Manual Developer Manual Application Examples 技術手冊採用 Markdown 的方式寫成。 在系統裝上 Pandoc 與 TeX Live 可以轉成其他純文字格式或 PDF。 接下來會先大約在 Developer Manual 簡介原始碼，細部內容會一邊開發一邊補齊。 User Manual 的部份則是做所有功能的介紹，不過預計會附上程式的圖片（改版時若是動到界面就比較麻煩），解釋操作各項功能的方式。 這三個手冊目前是使用中文說明。 v0.3.0 核心改動 最近參考大量 Java Script 的程式架構後，覺得以鍵值管理變數的方式比較容易分清用途，解說上也較好管理。 不過相對於 Java Script，Python 的物件得先建立 class，定義上比較繁瑣，所以就使用 Dictionary 來存取變數，雖然使用上比 Java Script 麻煩許多。 目前畫布 canvas.py 中的變數已經分類得差不多了，計算那塊由於關聯太多物件，修改需要花一段時間，亦或使用 Python 原本的 class 建構？","url":"http://project.mde.tw/blog/40323230ri-zhi-1051119.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/11/18","text":"Pyslvs v0.2.0 Release & informations Pyslvs v0.2.0 Release 包含功能 儲存時紀錄路徑（存檔格式改變） 多種輔助與控制面板 授權聲明 問題 暫停進階選項的開發，將階段放在解題異常的問題上。 目前已知問題是在解題時，運算某些位置會發生錯誤，必須修正此問題。 而 v0.3.0 的目標就是解決死點問題，而滑塊功能仍會繼續測試。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051118.html"},{"tags":"2016g3","title":"40323205日誌 - OpenCV (繪圖函式)","text":"繪圖函式 - cv2.line, cv2.circle, cv2.rectangle, cv2.ellipse 目前電腦都可畫出線、矩形、圓、橢圓，並更改黑色背景大小。 【畫線】 【畫線-程式範例執行】 import numpy as np import cv2 # 建立一個黑色背景 img = np.zeros((512,512,3), np.uint8) # 以寬度 5 px 畫一條藍色的對角線 img = cv2.line(img,(0,0),(511,511),(255,0,0),5) # 呈現此影像 cv2.imshow('image',img) cv2.waitKey(0) cv2.destroyAllWindows() 【畫矩形】 【畫矩形-程式範例執行】 import numpy as np import cv2 # 建立一個黑色背景 img = np.zeros((200,200,3), np.uint8) # 以寬度 5 px 畫一條藍色的對角線 img = cv2.rectangle(img,(10,10),(100,150),(0,255,0),10) # 呈現此影像 cv2.imshow('image',img) cv2.waitKey(0) cv2.destroyAllWindows() 【畫圓】 【畫圓-程式範例執行】 import numpy as np import cv2 # 建立一個黑色背景 img = np.zeros((300,300,3), np.uint8) # 以寬度 5 px 畫一條藍色的對角線 img = cv2.circle(img,(100,150), 100, (0,0,255), -1) # 呈現此影像 cv2.imshow('image',img) cv2.waitKey(0) cv2.destroyAllWindows() 【畫橢圓】 【畫橢圓-程式範例執行】 import numpy as np import cv2 # 建立一個黑色背景 img = np.zeros((450,450,3), np.uint8) # 以寬度 5 px 畫一條藍色的對角線 img = cv2.ellipse(img,(256,256),(100,50),20,150,360, (255,0,255),3) # 呈現此影像 cv2.imshow('image',img) cv2.waitKey(0) cv2.destroyAllWindows() 後記 - 目前正在研究其他OpenCV程式，在這裡先呈現最基礎的繪圖函式。","url":"http://project.mde.tw/blog/40323205ri-zhi-opencv-hui-tu-han-shi.html"},{"tags":"2016g3","title":"40323203日誌 - OpenCV(載入圖像)","text":"載入圖片及影像--cv2.imread,cv2.VideoCapture 載入圖片程式 import numpy as np import cv2 #載入jpg圖檔 #imread:讀取圖片，並將資料寫入Mat/flags:影像標誌 #IMREAD_COLOR:彩色模式可用1表示 #IMREAD_GRAYSCALE:灰度圖可用0表示 #IMREAD_UNCHANGED:透明度可用-1表示 image = cv2.imread(\"DSC00040.jpg\", flags=cv2.IMREAD_COLOR) #WINDOW_NORMAL:調節窗口大小 #WINDOW_AUTOSIZE:固定窗口大小 cv2.namedWindow('image',cv2.WINDOW_NORMAL) cv2.imshow('image',image) cv2.waitKey(0) cv2.destroyAllWindows() 顯示圖片結果可為彩色及黑白: 載入影片程式 import numpy as np import cv2 #Capture:拍攝,紀錄 cap = cv2.VideoCapture('00007.avi') while(cap.isOpened()): ret, frame = cap.read() #cvtColor：轉換影像色域，程式以轉換RGB到gray為例 gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) cv2.imshow('frame',gray) if cv2.waitKey(6) & 0xFF == ord('q'): break cap.release() cv2.destroyAllWindows()","url":"http://project.mde.tw/blog/40323203ri-zhi-opencvzai-ru-tu-xiang.html"},{"tags":"2016g3","title":"40323206日誌 - OpenCV (Dots)","text":"物體角落(點)的辨識 --- cv2.cornerHarris & cv2.dilate ★cv2.cornerHarris的使用&格式 ★範例所使用的圖檔下載位置 http://imgur.com/F05kwRB ★程式範例執行 import cv2 import numpy as np filename = 'chessboard.png' img = cv2.imread(filename) gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) gray = np.float32(gray) dst = cv2.cornerHarris(gray,2,3,0.04) #result is dilated for marking the corners, not important dst = cv2.dilate(dst,None) # Threshold for an optimal value, it may vary depending on the image. img[dst>0.01*dst.max()]=[0,0,255] cv2.imshow('dst',img) if cv2.waitKey(0) & 0xff == 27: cv2.destroyAllWindows() ★範例執行(已灰階)前後之比較 ★套用於齒輪辨識 有包含圓和圓心的辨識&單獨作角落抓點 import numpy as np import cv2 from matplotlib import pyplot as plt img = cv2.imread(\"gear2.png\", 1) imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) cv2.imwrite('graygear.png', imgGray) # 抓點 gray = np.float32(imgGray) dst = cv2.cornerHarris(gray,2,3,0.04) # result is dilated for marking the corners, not important dst = cv2.dilate(dst,None) # Threshold for an optimal value, it may vary depending on the image. img[dst>0.01*dst.max()]=[0,0,255] cv2.imshow('dst',img) # 抓圓 circles = cv2.HoughCircles(imgGray,cv2.HOUGH_GRADIENT,1,20, param1=60,param2=50,minRadius=0,maxRadius=60) circles = np.uint16(np.around(circles)) for i in circles[0,:]: # draw the outer circle cv2.circle(img,(i[0],i[1]),i[2],(255,0,255),2) # draw the center of the circle cv2.circle(img,(i[0],i[1]),2,(0,0,255),3) cv2.imshow('detected circles',img) cv2.waitKey(0) cv2.destroyAllWindows() ★齒輪辨識目的 配合之前的圓心可以初步抓出齒輪的外徑、內徑，方便之後直行計算相關程式的條件。 ★齒輪辨識結果","url":"http://project.mde.tw/blog/40323206ri-zhi-opencv-dots.html"},{"tags":"2016g3","title":"40323206日誌 - OpenCV (Circles)","text":"圓形的辨識 --- cv2.HoughCircles ★cv2.HoughCircles的使用&格式 ★範例所使用的圖檔下載位置 http://imgur.com/EyLp3Qx ★程式範例執行 import cv2 import numpy as np img = cv2.imread('opencv_logo.png',0) img = cv2.medianBlur(img,5) cimg = cv2.cvtColor(img,cv2.COLOR_GRAY2BGR) circles = cv2.HoughCircles(img,cv2.HOUGH_GRADIENT, 1,20, param1=50, param2=40, minRadius=0, maxRadius=0) circles = np.uint16(np.around(circles)) for i in circles[0,:]: # draw the outer circle cv2.circle(cimg,(i[0],i[1]),i[2],(0,255,0),3) # draw the center of the circle cv2.circle(cimg,(i[0],i[1]),2,(0,0,255),3) cv2.imshow('detected circles',cimg) cv2.waitKey(0) cv2.destroyAllWindows() ★範例執行前後之比較 ★套用於齒輪辨識 import numpy as np import cv2 from matplotlib import pyplot as plt # 讀取圖檔 img = cv2.imread(\"gear1.png\", 1) # 圖檔轉灰階 imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 灰階後進行存檔 cv2.imwrite('graygear.png', imgGray) # 使用灰階圖抓圓 circles = cv2.HoughCircles(imgGray,cv2.HOUGH_GRADIENT, 1,20, param1=60, param2=50, minRadius=0, maxRadius=60) circles = np.uint16(np.around(circles)) for i in circles[0,:]: # 圓形的繪製 cv2.circle(img,(i[0],i[1]),i[2],(255,0,255),2) # 圓心的繪製 cv2.circle(img,(i[0],i[1]),2,(0,0,255),3) cv2.imshow('detected circles',img) cv2.waitKey(0) ★齒輪辨識目的 找出齒輪的圓心位置，方便之後直行計算相關程式的條件。 ★齒輪辨識結果","url":"http://project.mde.tw/blog/40323206ri-zhi-opencv-circles.html"},{"tags":"Tutorial","title":"數學有何用?","text":"簡單的算術, 在日常生活購物流程, 隨時都會用到. 至於各種數學範疇的研究, 也都與工程應用的發展息息相關, 數學有何用? 請參考以下的說明. 微積分的用途 微積分起源於 17 世紀, 是用來研究特定內容\"變化\"的數學. 當機構運動時, 各零件的位置與速度, 都將發生\"變化\". 因此研究機構的運動, 需要運用微積分. 當熱量傳遞時, 不同位置的溫度與材料特性, 都將發生\"變化\". 因此研究熱量與流體的運動特性時, 需要運用微積分. 再者, 當材料加工時, 不同的施作方式, 也會讓不同部位的組成, 發生\"變化\". 因此研究材料加工過程時的各項性質, 需要運用微積分. 如眾所週知, 工程是一門運用自然科學與數學知識, 進行特定項目的研究、累積經驗, 並期以最佳方式解決人所面臨問題的科學. 而所謂的最佳方式, 可能是最省成本、最省時間、最輕量化、達到最長生命週期或全面最佳解決方式. 而工程師通常直接或間接在工作流程中使用數學. 以直接套用微積分解題而言, 工程師可以利用微積分計算平面特殊造型材料的面積, 用來決定零件的摩擦力. 也可以利用微積分計算三度空間特殊造型材料的表面積與體積, 算出表面積後, 可用來計算塗層所需用料多寡, 至於體積則可以用來計算材料密度, 或配合其他材料特性, 計算零件施力後可達到的運動速度, 或經由摩擦力與流體阻力大小, 估算達到一定操作速度時, 所需施力大小. 工程師間接套用微積分解題, 則通常使用電腦軟體作為工具解決問題, 而這些軟體的解題流程套用微積分, 例如: 利用系統模擬過程中的系統方程式微分來求取極值, 以最佳化該系統特定值. 為何數學對工程師非常重要? 數學是讓人理解設計的表達工具 - 因為許多自然界的規律已經被發現, 且能用數學模式加以表達, 意即數學是物理科學與工程的重要表達工具 (另外五種表達工具分別為: 口語、文字、2D、3D 與實體, 並且各表達工具彼此互相組成配合, 以完成設計或製造流程之充分表達) , 自然規律以數學模式表達者, 例如: 牛頓運動定律、熱力學定律、電磁學的麥斯威爾方程式、電路分析的克希荷夫規則等. 數學可用來作為培育人才的訓練工具 - 數學除了可以用來表達設計理念之外, 還能用來訓練工程師的邏輯與數值分析能力. 數學有實際解題的應用功能 - 電腦的發展主要從數位邏輯出發, 結合各種數值分析與數學演算法, 發展出各式應用, 工程師為了更進一步應用電腦解題, 就必須熟悉各種數值分析方法與數學演算法. 而機械工程需要用到的數學, 通常包括代數 (Algebra)、幾何 (Geometry)、三角函數 (Trigonometry)、微積分 (Calculus)、微分方程 (Differential Equations) 與統計 (Statistics) 等.","url":"http://project.mde.tw/blog/shu-xue-you-he-yong.html"},{"tags":"Tutorial","title":"機械設計工程系網路講座(三)","text":"執行機械設計專題的過程, 經常需要在不同操作系統與網路位置使用不同的軟硬體, 以 CADLab 電腦硬體 為例, 連同實體操作系統, 總共可以開啟三台虛擬主機, 其中實體操作系統安裝 Ubuntu 16.04 伺服器加上 ubuntu-desktop, 而虛擬主機則分別安裝 Ubuntu 16.04 伺服器加上 ubuntu-desktop, Windows 10 64 位元 Professional 與 Windows 7 64 位元 Professional 版本. 除了當作 Squid Proxy 主機的 Ubuntu 16.04 虛擬主機需要使用 IPv4 與 IPv6 網路協定位址外, 其餘的 Windows 10 與 Windows 7 虛擬主機都僅使用 IPv6 網路協定, 然後透過 Proxy Server 使用各種網路服務. 這樣的配置有幾項好處: 四台主機只需要使用一個 IPv4 網路位址, 也就是負責支援 Proxy 伺服的 Ubuntu 16.04 虛擬機, 且此一固定的 IPv4 網路位址, 可以在 Windows 10 與 Windows 7 操作系統執行授權認證時, 臨時派上用場, 因為目前多數的微軟認證主機只支援 IPv4 網路協定. 實體主機無需認証, 且生命週期可達五年, Ubuntu 16.04 虛擬主機上的 Squid Proxy Server 使用靈活, 可以隨時配合需要更動設定. Windows 10 與 Windows 7 虛擬主機可以在跨操作系統的 Virtualbox 應用程式架構下, 跨主機配置, 且可隨時在一定的軟硬體配置下增減各項設定或軟體套件, 使用限制較低. 從其他主機連線到實體主機, 可以使用純 IPv6 網路協定, 比較不會受到 IPv4 網路協定的干擾. 跨網域管理實體主機, 可以採用 Putty 加上 X-Windows, 若在 Windows 環境則使用 Xming . 跨網域管理 Windows 10 與 Windows 7 則使用 Remote Desktop 協定, 若在 Ubuntu 環境則使用內建的 Remmina 自 Virtualbox 5.0 之後, 可以在虛擬主機中, 再配置 32 位元的虛擬主機, 當作測試使用.","url":"http://project.mde.tw/blog/ji-jie-she-ji-gong-cheng-xi-wang-lu-jiang-zuo-san.html"},{"tags":"Tutorial","title":"機械設計工程網站的短網址","text":"機械設計工程的英文為 Mechanical Design Engineering, 簡稱為 MDE, 有很長一段時間, 機械設計工程系的網路符號名稱為 mde.nfu.edu.tw, 但是在 DNS 上下綁定經常出現問題之後, 權宜之計採用 mde.tw 作為 domain name, 現在可以透過 http://mde.tw , 連結到相關網站. 簡短有意義的網路符號名稱在 Google 搜索引擎撲天蓋地提供完善服務之後, 好像變得不很重要, 但是隨著 IPv6 網址的逐漸普及, 若覺得每一種伺服器都帶著長位址, 使用非常不方便時, 透過雙協定支援的 DNS 伺服器, 所完成的簡短網站符號名稱就會愈來愈重要. 要設定位於 Github Pages 的 http://mdecourse.github.io 成為 http://mde.tw , 共有兩個步驟: 登入 mdecourse.github.io 對應的倉儲, 設定 domain name 為 mde.tw 進入 mde.tw DNS 管理設定, 根據 https://help.github.com/articles/setting-up-an-apex-domain/ 中的說明, 建立兩筆 A 設定 (也就是 mde.tw Internet Address 的綁定), 分別指向 192.30.252.153 與 192.30.252.154 就算完成.","url":"http://project.mde.tw/blog/ji-jie-she-ji-gong-cheng-wang-zhan-de-duan-wang-zhi.html"},{"tags":"Tutorial","title":"機械設計工程系網路講座(二)","text":"因為 IPv4 與 IPv6 是兩種彼此不相容的網路協定, IPv4 採 32 位元定址, 而 IPv6 則為 128 位元定址. 因此, 採用純 IPv6 網路協定設置的連網裝置, 無法與純 IPv4 網路協定設置的連網裝置進行連線, 反之亦然, 也就是採用純 IPv4 網路協定設置的連網裝置, 無法與純 IPv6 網路協定設置的連網裝置進行連線. 假如您使用中華電信的光世代, 而且使用 VDSL2 P883 路由器, 根據 https://chiamingyen.github.io/kmolab/blog/mechanical-designer-and-ipv6.html 流程設定後, 使用 sudo pon dsl-provider 進行撥號後, 出現 Plugin rp-pppoe.so loaded, 表示已經取得 IPv6 協定上網, 就可以透過瀏覽器連線到 http://[2001:288:6004:17::17] , 其中 IPv6 位址與埠號結合的寫法為 [2001:288:6004:17::17]:3128, 假如要利用網路位址設定代理主機就必須採用 IPv6 的格式. 因為機械設計工程系所分配到的 IPv6 網址為 2001:288:6004:17::/64, 表示前面 64 bits 的網址已經指定, 因此 subnet 設為 /64. 至於點對點的連線則建議設為 /127, 理由是可以避開子網路中許多未啟用的位址搜尋, 以免拖累路由器的速度. 在 IPv6 協定中, 每一個網路卡除了所設定使用的網路位址外, 還配置了一個所謂的 link-local address (本地連結位址). 而且 link-local addresses 一定位於 fe80::/10 區段. 至於在區域網路中各裝置的網路卡所使用的本地連結位址則會加上網卡代號存在路由表中. 例如, fe80::1:2:3:4%eth0 機械設計工程系區域網路中的電腦使用 IPv6 協定上網, 共有以下四種方法取得 IPv6 網路位址: 採用 EUI-64 Global identifier 位址, 利用網路卡的 MAC address 進行 換算 . 例如, 若 MAC 網路編號為 00-11-22-33-44-55, 則換算後使用 2001:288:6004:17:211:22FF:FE33:4455 作為 IPv6 網路位址. 個別伺服器則設定固定 IPv6 網址, 並且將設定登錄到 DNS 伺服器中, 由於單一網路卡可以與多個 IPv6 位址綁定, 因此可以就個別服務設定不同的 IPv6 位址. 如此就可以在不同的伺服器硬體中搬遷各種不同服務. 以機械設計工程系網段中, 必須固定設置 IPv6 網址的建議是由目前所使用的 140.130.17.XXX 自行轉換為 2001:288:6004: 17::XXX, 至於採用網路卡 MAC 位址運算得到的 EUI-64 網址, 則不可任意搬遷. 在 Windows 7 或 10 操作系統中直接關閉 IPv4 協定, 採用純 IPv6 協定, 並且透過 DHCPv6 取得 IPv6 網路位址, 只要設定 DNS 為 2001:288:6004:1::2 與 2001:b000:168::1, 並採用 [2001:288:6004:17::17]:3128 或 proxy.mde.tw:3128 作為 proxy, 就可以連線上網. 使用電腦自行亂數設定位於 fe80::/10 區段的 IPv6 本地連結網址上網, 假如要連結到廣域網路, 則使用橫跨內外網段的代理主機上網.","url":"http://project.mde.tw/blog/ji-jie-she-ji-gong-cheng-xi-wang-lu-jiang-zuo-er.html"},{"tags":"Misc","title":"現代機器人學-力學、規劃與控制","text":"身為現代機械設計專題成員, 只要有網路連線, 俱備英文閱讀能力, 就能夠同步檢視美國電腦系排名第1的 Carnegie Mellon University, 2016 年秋季班 Mechanics of Manipulation 課程內容. 從中還能得知, 目前編寫接近完成, 用於韓國首爾大學與美國西北大學相關課程的 教材 pdf 與 軟體 , 也已經同步 釋出 . 這本 電子書 , 標題是: INTRODUCTION TO MODERN ROBOTICS - MECHANICS, PLANNING, AND CONTROL, 主題是現代機器人學有關的力學、規劃與控制. 而課程中的 軟體 , 分別採用 Matlab、Mathematica 與 Python 編寫, 其中只有 Python 是泛用型開放源程式語言, 可見 Python 在機器人學課程的教學中已經逐步深化, 且是學生可以自由帶出學校進入業界使用的重要工具之一. 我們相信, 接下來與類似課程相關的軟體應用, 一定會逐步搬到 Jupyterhub 相關的網際平台上, 屆時若能再將分析結果與 three.js 作動的各式機械手臂及機構模擬結合, 並且將分析完成的各式零組件以 OnShape 完成, 那就真的太棒了.","url":"http://project.mde.tw/blog/xian-dai-ji-qi-ren-xue-li-xue-gui-hua-yu-kong-zhi.html"},{"tags":"Tutorial","title":"機械設計工程系網路講座(一)","text":"過去在 IPV4 的網路環境中, 經常需要利用各種網路管理軟硬體, 進行用戶對於網路頻寬使用的限制或者綁定, 轉換到 IPV6 網路環境之後, 儘管可能無法直接擷取目前仍使用純 IPV4 協定的網路服務, 但是透過代理主機, 不但不會影響各用戶的權益, 反而因為 IPV6 協定的寬廣位址, 而過得海闊天空, 自由自在. 數量眾多的 IPV6 網址 從 機械設計工程系 IPV6 網址分配 文章中, 大家就可以了解, IPV6 網路位址雖然不是無限, 但是數量眾多, 絕對可以滿足多元使用的需求. 因此各機械設計工程系的教學與研究團隊, 在決定使用 IPV6 網路協定之後, 第1件事就是要確定各用戶是否透過 gigabit switch, 讓所有電腦都直接連線到系上的廣域網路. 假如您之前只是使用電腦的瀏覽器上網, 而且使用系上分配的 IPV4 固定網址, 那麼您可以準備將這個 IPV4 的固定網址交回管理室, 因為在從 IPV4 網路環境轉進到 IPV6 的過程中, 只有雙支援需求的 Proxy Server 需要使用 IPV4 固定網址, 一般用戶只要使用各自所在樓層與所分配的 IPV6 固定網址, 就可以上網. 使用固定 IPV4 網址的轉換 在此以綜一館八樓實驗室編號尾碼為 8768 的用戶為例, 因為所分配的 IPV6 網址範圍為2001:288:6004:17:8F:8768:0000:0000 ~ 2001:288:6004:17:8F:8768:FFFF:FFFF, 意思就是這個實驗室有 16 的 8 次方個 IPV6 網路位址可以使用, 其下可以再透過使用者的身分證字號最後四碼 (例如為 1234), 使用 2001:288:6004:17:8F:8768:1234:0000 ~ 2001:288:6004:17:8F:8768:1234:FFFF 的網段. 假如該名用戶採用 Windows 操作系統, 只要進入控制台的網路卡設定, 將 IPV4 協定勾選去除, 只留下 IPV6 網路協定, 然後自行設定網路位址為 2001:288:6004:17:8F:8768:1234:1, 子網路首碼長度設為 64, 預設閘道設為 2001:288:6004:17::254 (請注意, 因為 17 到 254 中間有三個位址段皆為 0000 而省略, 因此要使用 \"::\"), DNS 伺服器設為 2001:288:6004:1::2 (學校 DNS) 與 2001:b000:168::1 (中華電信 DNS) 即可. 接下來只要將瀏覽器的代理主機設為 proxy.mde.tw:3128 即可連線上網. 使用 NAT 轉址的用戶轉換 假如您目前是透過 NAT 從 IPV4 的內部網路轉換為外部網路上網, 只需要將 NAT 移除, 換成 Gigabit 交換器, 就可以利用上一節中的說明, 轉換到固定的 IPV6 網址設定上網. 也就是說, 只要使用該電腦所分配到的 IPV6 網址, 並去除 IPV4 網路協定, 就可以透過代理主機 proxy.mde.tw:3128 連線上網. 網路認証授權主機的轉換 當各用戶從 IPV4 網路協定轉而使用純 IPV6 協定上網之後, 若先前使用 SolidWorks、Matlab、Creo Parametric、Ansys 與 Comsol 等套件的網路授權, 也必須確定各授權主機啟用 IPV6 的協定, 有關這點, 我們極力推廣各系要自行管理各自的 DNS 伺服器, 如此一來, 無論使用者採用 IPV4 或 IPV6 協定要求認証 ,都只要將認証主機設為 solidworks.mde.nfu.edu.tw:埠號, mat.mde.nfu.edu.tw:埠號, creo.mde.nfu.edu.tw:埠號, ansys.mde.nfu.edu.tw:埠號與 comsol.mde.nfu.edu.tw:埠號即可, 無需使用 IPV6 或 IPV4 的網址要求認証, 因為這些主機可能因為各種原因進行硬體搬遷或固定網址而變換, 各管理者只要從各系的 DNS 伺服器中因應調整, 完全不需要更動認証客戶端的伺服器 IP 設定. 結論 從上述說明可以了解, IPV6 的網路架構就在我們的身旁, 只要各用戶依據 機械設計工程系 IPV6 網址分配 使用, 就可以全面改善目前爭搶 IPV4 網路位址的情形, 也無需將個人電腦的 MAC 卡號交由電算中心綁定, 或者區分教師與學生網段, 只要讓管理室可以回收部份 IPV4 網址, 增加雙網路協定支援的代理主機, 並且推廣伺服主機也採用純 IPV6 設定, 就能逐步從舊 IPV4 進入新 IPV6 世代, 享受新協定所帶來的便利.","url":"http://project.mde.tw/blog/ji-jie-she-ji-gong-cheng-xi-wang-lu-jiang-zuo-yi.html"},{"tags":"Misc","title":"yen - 雲端上的機械設計專題","text":"OnShape 正式推出全面的免費帳號還不滿一年, 在 Google 搜尋結果已經突破百萬, 在這段期間, Windows 10 大小更新不斷, 從推出至今一直給系統管理人員帶來困擾, 面對無需使用 SolidWorks 的機械設計專題, Windows 10 的可有可無, 已經確定. 儘管趨勢如此, 雲端上的機械設計專題團隊, 仍然必須正視目前多數課程仍然使用 Windows 操作系統的現況, 推廣將 Windows 10 塞進虛擬環境, 並且儘量用可攜的程式環境, 以便有朝一日能在真正自由開放的環境中, 執行新產品設計. 推廣脫離 Windows 10 約束困擾的第一步, 就是設法讓正版 CAD/CAE/CAM 套件容易使用, 讓系統管理者與用戶能夠在虛擬環境中執行約束最高的 Windows 10, 讓使用者可以在多套, 不同安裝內容的虛擬 Windows 10 環境中執行各式套件. 為了驗證並推廣此一構想, 接下來就是利用一台電腦輔助設計室的 電腦 , 移除硬碟保護卡, 在實體安裝 Ubuntu 16.04 Server + ubuntu-desktop, 之後再用另外一套虛擬的 Ubuntu 16.04 充當網際伺服主機, 以 uwsgi 執行 nginx 與內容管理程式, 完成 http://service.mde.tw 服務網站的建構, 而此一網站不僅有開放的 Debian 核心, 有方便的 uwsgi 多緒多工執行環境, 而且整體服務只用到 Python3 與 C 程式套件模組, 並且以 Virtualbox 的 vdi 檔案存在實體 Ubuntu 16.04 操作系統中, 任何團隊都可以直接以下載 vdi 檔案 (約 13GB) 後, 自行搭建相同的服務, 沒有約束, 無需認証, 使用者可以全盤掌握流程中的所有細節. 之後, 在虛擬的 Ubuntu 16.04 或 Windows 10 環境中, 機械設計專題人員可以大膽地測試各種程式開發環境, 可以按照自己的需求重新編譯 Ubuntu 系統核心碼, 自行客製化所使用的工具, 也能從中開發出自己的工具套件. 機械設計專題成員利用虛擬的 Ubuntu 16.04 伺服器搭建出來的網際內容管理服務系統, http://service.mde.tw : 機械設計專題成員可以直接在虛擬的 Ubuntu 操作系統中, 利用 g++, CMake 編譯 Linux 與 Windows 64 位元都能執行的 Solvespace 參數繪圖程式: 機械設計專題成員也可以延續 Python2 中使用 SWIG 整合 Solvespace 程式庫的 舊專案 , 擴充為 Python3 Solvespace 應用程式庫 外, 並完成以 PyQt5+Python3 編寫的的 平面機構模擬套件 : 最後, 假如要測試上述各項跨平台的工具在 Windows 10 執行的情形, 也是可以:","url":"http://project.mde.tw/blog/yen-yun-duan-shang-de-ji-jie-she-ji-zhuan-ti.html"},{"tags":"Misc","title":"yen - 機械設計專題的近端與遠端","text":"機械設計專門研究如何利用機巧的配置來解決問題, 所謂機巧的配置不限固體、流體或是軟體, 隨著網路數位科技的不斷精進, 機械設計工程師也必須熟練網際協同環境中近端與遠端的搭配使用. 以下有一個例子, 可以用來展示機械設計專題如何在近端與遠端中執行設計工作. 所謂近端, 指的是機械設計工程師身旁所使用的電腦, 可以是在實體操作系統或者是虛擬操作系統, 可以連上廣域網路, 也可以暫時從網路連線中斷線, 以便專心在近端的工作目錄中工作. 所謂遠端, 指的是位於廣域網路上的電腦, 通常是雲端伺服器, 至少提供全球資訊網伺服與 Git 伺服. 遠端主機的功能主要讓身處各地的工程師, 可以透過網路連線, 以 Git 分散式版次管理系統進行產品設計協同. 前面提到機械設計事涉機巧的配置, 因此我們在近端工作時, 會希望能夠得到與遠端伺服器相同的結果, 其中若以網際協同的架構來說, 代表在近端的文字資料, 當使用者在編寫時, 能夠採用 Markdown 格式, 然後再經由程式方法轉換為 html, 至於關鍵字的搜尋也希望兩端相同, 都採 Javascript 完成. 這時, 假如近端有廣域網路連線, 則協同資料中可以使用 cdn 來簡化工作, 否則一律採用相對目錄擷取所需要的 Javascript 程式庫. 剩下的工作就是在近端, 啟動一個專門測試用的 https 伺服器, 讓之後在遠端工作時欲呈現的結果, 預先在近端進行 Debug. 因為整個 KMOL 團隊都是採用 Leo Editor 進行協同工作, 並且所有遠端的資料伺服都採用 https, 因此只要使用下列的多執行緒按鈕, 就可以在近端啟動一個或多個 https 伺服器. 首先, 利用: sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt 建立所需的 localhost.key 與 localhost.crt 然後配合更動各 https 伺服器的埠號, 每按下一次按鈕, 就會配合各 .leo 專案, 產生對應 https 伺服. import os import subprocess import threading import http.server, ssl def domake(): # build directory os.chdir(\"./../\") server_address = ('localhost', 9443) httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler) httpd.socket = ssl.wrap_socket(httpd.socket, server_side=True, certfile='localhost.crt', keyfile='localhost.key', ssl_version=ssl.PROTOCOL_TLSv1) print(\"9443 https server started\") httpd.serve_forever() # 利用執行緒執行 https 伺服器 make = threading.Thread(target=domake) make.start() 這個按鈕的實際應用請參考: 2016fall 電腦輔助設計實習課程分班網誌 與 2016fall 計算機程式分班課程網誌","url":"http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-de-jin-duan-yu-yuan-duan.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/10/17","text":"Kernel 編譯 Pyslvs 編譯進度 Kernel 編譯 位於 python-solvespace 倉儲的程式庫文件因應 Pyslvs 的自動切換功能，編譯後不會放在 Ubuntu 或是 Windows 資料夾中了，而是採用 Pyslvs 的顯示方式。 這個改變儲存在 configure.py 文件中，生成後的 Makefile 將會鎖定在一個編譯者的 Python 版本上，使用其他 Python 編譯的話，要重新用 configure.py 生成。 而這個 configure.py 的功能之後可能會變成 Leo Editor 的按鈕。 目前為止還沒測試 Windows 的編譯，也許試過之後會嘗試改用 MinGW，讓 Ubuntu 平台的協同者能為 Windows 編譯。 Pyslvs 編譯進度 增加參數控制功能，使用 Python 內建的 sys.argv 清單判定。 $python3 launch_pyslvs.py [arg1] [arg2] ... 可能包裝成執行檔後用終端機呼叫才會出現。 目前大約做了如下幾個基本的參數。 Git 資訊 -g / --git 使用後啟動時的標題會讀取目前版次的代碼，不過軟體若是沒帶有 Git 的資訊就會無法顯示。 開啟檔案 -o 在這個參數上直接接上 CSV 檔案的名稱，可以在開啟 Pyslvs 時馬上載入這個檔案。 不過如果副檔名不是 CSV 的話就不會讀取。 基本資訊 -h / --help -v / --version 使用這兩個參數後將不會開啟 Pyslvs 本體，只會顯示其資訊，偵測的優先權最高。 若是使用 -v / --version ，只會列出 Pyslvs 和 Python 的版本。 其他待加入功能 預計加入檢查程式庫和整個 GUI 的 Debug 功能，不過還要研究 Python 的 unit test。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051017.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/10/16","text":"Pyslvs 編譯進度 Putty 連線 Pyslvs 編譯進度 顯示資訊 啟動時顯示的資訊加上 commit 編號和平台類型。 自動選擇平台版本 現在程式庫改移到 kernel 資料夾中，Pyslvs 會讀取平台資訊和 Python 版本來選擇 import 的程式庫。 名稱為不同版本的 Python 名稱，如 py35。後方加上「w」為 Windows 平台的版本。 不過若是如此，當 Python Solvespace kernel 更新時，要為所有平台搬運進倉儲。 設定檔 GUI 的設定檔存放在主目錄，名為 Pyslvs_Settings.ini ，還未開始連結設定功能。 這個檔案並不會被 git 上傳。 License 加入了 GPL 3 的授權檔案。 另外，在 main.py 程式碼中加入了簡短宣告條文（參考自 Gimp）。 Putty 連線 在研究室用 Putty 實測了虛擬機連線的部份，同為 Linux 平台中就沒出現跨平台的錯誤，所以在跨平台撰寫後，測試時可能就得注意了。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051016.html"},{"tags":"Misc","title":"yen - 電腦輔助設計室電腦配置","text":"2016 年暑假機械設計工程系八樓的電腦輔助設計室更換了 54 台四年保固的華碩 Skylake MD790/I7-6700, 這一批 Intel 第六代 Core i7/3.4GHz/8M 電腦, 採用 Intel Q170 晶片組, 搭載 16GB DDR4/2133/288 Pin 記憶體 (8 GBx2), 2 TB-SATA3 硬碟, Asus MINI-GTX950-2G 顯示卡 (支援 PCIE 3.0, OpenGL 4.5, 768 個CUDA 核心數), 500瓦電源供應器, USB 3.1x2 (10GB/s) , USB 3.0x6 (5GB/s), USB 2.0x2 (480MB/s), 以及 群準 的 EVOsys PRO/SATA 還原卡, 可同時支援 D-sub、HDMI 及 DisplayPort 三台獨立顯示器多工作業. 當我們為了機械設計專題, 在這台電腦實體安裝 Ubuntu 16.04 LTS Server 加上 ubuntu-desktop 之後, 發現 UEFI secure boot 必須要關閉, 才能配合 VT-x 功能的啟用, 避開無法載入 Kernel Module 的 錯誤 , 正確安裝 64 位元的 Virtualbox 套件. 要關閉華碩 Skylake MD790/I7-6700 UEFI secure boot 功能, 共有 兩個步驟 , 先將 Secure Boot 裡的 OS Type 設為 Other OS 之後, 然後將 CSM 中的 Launch CSM 設為 Enabled 即可. 之所以選擇在電腦實體安裝 Ubuntu 16.04 LTS 操作系統, 加上 Ubuntu Desktop 的原因是, 其生命週期長達 5 年, 能夠涵蓋電腦硬體四年保固的範圍, 也能利用虛擬的 Windows 10 64位元操作系統, 進行最有效率的配置使用. 此外, 這台華碩 Skylake MD790/I7-6700 電腦主機板, 內建 Intel I219LM 與 Intel I211 Gigabit 網卡外, 另外又加裝了一片 Realtech Gigabit 網卡, 可以利用三條 Cat. 6 網路線, 透過三台虛擬 Ubuntu 16.04 LTS 中的 Squid , 作為 IPV4/IPV6 雙支援代理伺服器. 並且配合不同課程的需求, 配置各式套件組合的 Windows 10 Pro 虛擬主機群, 而無需將所有的 CAD/CAE/CAM、自動控制與各式程式開發環境, 混雜在同一個開機磁區. MD790 電腦機殼: 電腦正面支援兩個 USB 3.0 與兩個 USB 2.0 插槽: 電腦正面支援兩個 USB 3.1 與兩個 USB 3.0 插槽: 用來取代傳統 BIOS 的 UEFI , 目前只能先關閉 ,等待各種軟體套件的支援: Asus MINI-GTX950-2G 顯示卡:","url":"http://project.mde.tw/blog/yen-dian-nao-fu-zhu-she-ji-shi-dian-nao-pei-zhi.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/10/13","text":"Asus 開機選項（UEFI） Qt 升級 個人網頁創建 Asus BIOS 一些新版的 BIOS 採用 UEFI 模式讀取開機硬體，會有以光碟開機後產生光碟錯誤的提示（甚至讀不到鍵盤無法選擇）；或是選單黑屏卡死。 學校的新電腦 BIOS 必須啟用相容模式（預設是自動，要強制啟動）才能讀取安裝光碟或隨身碟。 啟用後重新開機，按 F8 叫出開機選單，選擇沒有「UEFI」字樣的選項，才能用一般的選項載入。 之前發現第一台測試機的顯示卡不太好，跑 QPainter 的快速 Render 時會滿 lag 的（拖動滑桿控制轉軸時），所以想用新電腦的配備處理看看。 Qt 和 PyQt 升級 安裝 Qt 後會多出 Qt Maintanance Tool 的捷徑，使用其可以額外安裝、升級、移除現有的 Qt 程式庫。 不過若要升級，必須每個新版本慢慢升上去，有點花時間就是。 至於 PyQt 的部份，由於 apt-get 的 python3-pyqt5 16.04 只支援到 5.5，而且 16.10 也只支援到 5.6，所以看似只能使用 pip3 安裝，不過還沒測試是否會衝突。 個人網頁 複製了 project site 網站的倉儲建了一個副本，準備改成自己的個人網頁，目前只有存自己的文章。 https://40323230.github.io/YuanBlog/blog/ 之後會在 About 加入簡介和心智圖，並整理 Tags。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051013.html"},{"tags":"Tutorial","title":"yen - 機械設計課程對應網頁","text":"今年機械設計專題的任務之一, 就是希望每一位學員都能各自維護一份自己的網頁, 修課的網頁以及分組的網頁, 過去我們選擇在 OpenShift 進行, 現在 Github Pages 應該是最佳選擇. 首先, 必須要知道 Github 帳號啟用後, 可以 更改對應的 email , 必須在學校 email 面臨被取消之前, 轉換到其他生命週期較長的電子郵箱. 根據課程的規劃, 2016Fall 的計算機程式對應網站位於 https://mdecourse.github.io/2016fallcpa , 而 2016Fall 的電腦輔助設計實習課程則位於 https://mdecourse.github.io/2016fallcadpa , 在課程進行期間, 兩班將使用相同的 reveal.js 投影片, 但各自擁有一份 pelican 靜態網誌, 等到課程結束, 將會合併到年度的課程投影片與網誌中. 上述課程網頁的基本架構與過去幾年所使用的大致相同, 最大的區別在於, 各倉儲都只關注 gh-pages 分支, 且從班上的網頁到各組的網頁, 一直下達各學員的網際內容, 都透過 git submodule 綁定與時間對應的版本, 各組與各學員在規定檢核內容的時限之後, 仍可持續改版, 不致影響自評與互評的版本內容. 此外, 各倉儲中除了影片檔案, 必須放在 Vimeo 與 Youtube 外, 其他的相關檔案都建議存在各自對應的倉儲中, 並且以相對目錄設定, 如此, 一旦課程結束後, 班級課程倉儲就可以被 git clone 到近端繼續使用, 唯一必須處理的就是將各頁面所使用的 cdn 或統一的 Github Pages 對應 Javascripts, 以近端的程式庫取代, 並且使用各學年規劃下的版本.","url":"http://project.mde.tw/blog/yen-ji-jie-she-ji-ke-cheng-dui-ying-wang-ye.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/10/11","text":"Kubuntu 16.04 一些瑣事 Python Solvespace Makefile 配置 倉儲 python-solvespace 已更新 Kubuntu 16.04 安裝 Eric6 成功之後，又安裝了 Leo Editor（使用 git clone 後直接 launch 的方式），在 Python 3.5 + PyQt 5.5 的情形下沒有遇到無法切換輸入法的問題，所以就可以用這台電腦寫網誌了。 升級之後有類似 Windows 的不定期更新，不過是非強制的，可以不用理它。 另外新版的 Plasma 將帳戶和即時通綁在一起，所以通知列一直會有即時通的圖示關不掉，不過不妨礙工作。 資源使用量： 另外比較奇怪的一點是 Eric6 偵測相關工具時發現了 Pyside（不過 Python 3 無法 import；Python 2 可以）；卻找不到 PyQt（但是可以 import），可能是路徑問題。 Python Solvespace Makefile 配置 撰寫了 configure.py 來幫忙生成 Makefile，放在 exposed 資料夾裡。 不過目前只能支援 Ubuntu（測試成功），Windows 的部份因為有可攜環境的關係，需要知道各種工具的位置，必須另外做調整。 也因為如此，目前 Windows 的部份是原本 W: 槽的設定，之後會改用 Windows 7 測試新的可攜 Solvespace 編譯環境，還有如果本機直接安裝相關工具的環境。 能夠自動偵測環境編譯後，在想是否需要重新規劃 Submodule 的父子關係，因為 Pyslvs GUI 無法直接切換對應 Python 版本的 Kernal 來用，只會拿到上個使用者的核心來使用，有很大的機率會出問題。 因此當其他協同者下載 Pyslvs 後，可能需要重新編譯 Kernal 來用，之後放入專案中（或許 Makefile 可以協助），協同 GUI 時就不用理會核心版本不同了。 至於之後是否會在 16.04 升級 Qt 或 PyQt，可能得尋找其他方法，目前是不會更改內建的程式庫。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051011.html"},{"tags":"Tutorial","title":"yen - KMOL 的程式開發環境","text":"當 Ubuntu 在年初推出 16.04 版本時, 因為許多舊型的 AMD 電腦顯示卡無法內建支援, 因此仍然停留在 Ubuntu 14.04 LTS 的使用, 但是隨著 Solvespace 與 PyQt5 相關應用程式的開發需要, Python 3.4 與 PyQt4 已經不敷使用, 因此從今天開始, 利用實體或虛擬安裝的方式, 將 KMOL 機械設計專題的主要程式開發系統, 定調採用 Ubuntu 16.04 版本. 基本程式開發策略 在 OnShape 推出之前, KMOL 機械設計專題為了在 FreeCAD 與 Solvespace 之外, 能夠採用 PTC Creo 與 Solidworks, 因此除了在 Ubuntu 建構程式開發系統之外, 還利用 NetBeans 與 MinGW, 在 Windows 7 與 Windows 10 64 位元環境中建立可攜的程式開發系統, 但是隨著 Windows 10 越發強勢地主導自動更新, KMOL 機械設計專題決定要在 Ubuntu 環境中, 以 cmake 及 mingw-w64 開發 Windows 10 適用的套件, 換言之, 從今以後, Windows 操作系統只是 KMOL 機械設計專題的執行平台而非開發平台. 理想的程式開發環境 假如實體主機無法直接安裝 Ubuntu 16.04, 建議仍安裝 Ubuntu 14.04 與 Virtualbox, 並且在 Virtualbox 中配置 64 位元的虛擬 Ubuntu 16.04 或 Windows 10 執行環境. 有鑑於一台實體主機將經常要開啟一個實體的 Ubuntu 14.04 與兩個虛擬操作系統, 因此除了要俱備 Vti 相關虛擬技術的支援外, 記憶體必須 12GB 以上, 而硬碟則是 1TB 以上較佳. 當然, 因為這一台主機仍必須執行至少一套虛擬 Windows 10 64 位元操作系統, 因此必須購買相應合法的 Windows 操作系統使用授權. Ubuntu 14.04 主機的安裝 當實體主機進行 Ubuntu 14.04 Server 操作系統安裝時, 僅需選擇安裝 OpenSSH server 加上 ubuntu-desktop 即可, 之後可以安裝 gcin 中文輸入系統、git、pip3、PyQt4、pelican、Markdown 以及 Leo Editor 等模組, 目的在於可以處理與 Github 相關倉儲的資料更新. 基本步驟如下: sudo apt-get install gcin git python3-pip python-pyqt4 git clone https://github.com/leo-editor/leo-editor.git 將 leo-editor 目錄下的 leo 檔案複製到 /usr/local/lib/python3.4/dist-packages 目錄下 利用 python3 launchLeo.py 啟動 Leo Editor sudo pip3 install pelican Markdown 因為 gcin 在 Ubuntu 14.04 操作系統環境下, 可以直接支援 PyQt4 程式的中文輸入, 因此只要選用 gcin 後重新開機即可. Ubuntu 16.04 實體或虛擬主機安裝 Ubuntu 16.04 Server 操作系統的安裝, 雖然步驟與 14.04 大致相同, 但是因為要作為 CMake 與 PyQt5 程式開發之用, 因此除了必要的程式模組採 apt 安裝外, 其他的 Qt5、sip、PyQt5、qscintilla2 與 eric6 等, 都直接從原始碼編譯連結後進行安裝. 首先, 利用 apt purge 徹底移除 Ubuntu 16.04 內建的 sip 4.17.1 舊版本: sudo apt purge python3-sip python3-sip-dev 移除 sip 前後, 可以利用 sip -V 確認版次. 接著安裝, Solvespace 與程式庫開發所需的各種套件: apt-get install libpng-dev libjson-c-dev libfreetype6-dev \\ libfontconfig1-dev libgtkmm-2.4-dev libpangomm-1.4-dev \\ libcairo2-dev libgl-dev libglu-dev cmake swig \\ python3-dev python3-pip pyqt5-dev mingw-w64 然後安裝 Pyslvs-PyQt5 所需要的 peewee ORM 模組, 以及產生靜態網誌所需的 pelican 與 Markdown: sudo pip3 install peewee pelican Markdown 接著下載 http://download.qt.io/official_releases/qt/5.7/5.7.0/qt-opensource-linux-x64-5.7.0.run , 安裝 Qt5.7: 然後利用 gedit ~/.bashrc, 編輯 .bashrc, 加入: 1 2 3 export QTDIR=/opt/Qt5.7.0/5.7/gcc_64/ export LD_LIBRARY_PATH= ${ LD_LIBRARY_PATH } : ${ QTDIR } /lib export PATH= ${ QTDIR } /bin: ${ PATH } 然後以 source ~/.bashrc 讓設定生效. 要確認 Qt 版次, 使用: qmake -v 接下來下載 http://www.riverbankcomputing.com/software/sip/download , 然後以下列指令安裝 sip 4.18.1: 1 2 3 python3 configure.py make sudo make install 如同前面移除 sip 4.17.1 時相同, 利用 sip -V 確認系統中 sip 的版本, 假如要確認 Python3 導入時使用的 sip 版本, 利用下列程式碼檢查: 1 2 import sip print ( sip , sip . SIP_VERSION_STR ) PyQt5 的安裝步驟與 sip 相同, 從 http://www.riverbankcomputing.com/software/pyqt/download5 下載原始碼之後: 1 2 3 python3 configure.py make sudo make install 至於 qscintilla 的安裝, 牽涉3個步驟, 首先從 http://www.riverbankcomputing.com/software/qscintilla/download 下載原始碼: 步驟一: 1 2 3 4 cd Qt4Qt5 qmake qscintilla.pro make sudo make install 步驟二: 1 2 3 4 cd ../designer-Qt4Qt5 qmake designer.pro make sudo make install 步驟三: 1 2 3 4 cd ../Python python3 configure.py --pyqt=PyQt5 make sudo make install 接下來則安裝 eric6, 從 http://eric-ide.python-projects.org/eric-download.html 下載原始碼後, 以 sudo python3 install.py 進行安裝, 並以 eric6 開啟. 安裝 Leo Editor 因為前面已經安裝 PyQt5, 因此只要從 https://github.com/leo-editor/leo-editor.git 取得 Leo Editor 的原始碼, 並將 leo 目錄複製到 /usr/local/lib/python3.5/dist-packages 目錄中即完成安裝, 啟動 Leo Editor, 則以 python3 launchLeo.py, 或者將 python3 launchLeo.py 放入可執行的 leo 檔案中, 以 ./leo& 啟動. 安裝 fcitx 中文輸入 由於目前 gcin 對於 PyQt5 的支援較不完全, 因此在 Ubuntu 16.04 操作系統中, 採用 fcitx 作為中文輸入的套件: sudo apt install fcitx fcitx-chewing 表示將採用 fcitx 中文輸入法中的酷音輸入套件. 酷音輸入法的使用牽涉3個步驟, 第1步驟就是上方的套件安裝, 而第2步驟就是進入系統設定中的 language support, 將原先內建的 ibus 改為 fcitx, 而第3步驟則是在輸入 configure 時, 加入 chewing 中文輸入法, 並且將原先的切換鍵 space 改為 ctrl+space. 完成上述步驟的安裝與設定後, 就可以利用 Leo Editor 及 eric6 來開發 Solvespace 與 api 應用, 包含所有相關系統原始碼的倉儲位於 https://github.com/mdecourse/solvespack , 以 submodule 設定的相同倉儲則位於: https://github.com/mdecourse/solvk .","url":"http://project.mde.tw/blog/yen-kmol-de-cheng-shi-kai-fa-huan-jing.html"},{"tags":"2016bg2","title":"40323230日誌 - Kubuntu 16.04","text":"：：Kubuntu 16.04 資訊紀錄：： Kubuntu 16.04 系統資訊 Ubuntu: 16.04 KDE Plasma: 5.5.5 Qt: 5.5.1 核心：3.13.0-36-generic (x64) 由於研究室有空閒的兩台電腦效能不佳，只有 4GB 的記憶體，且無法模擬 x64 作業系統的能力，所以就配合使用 16.04 版本的測試。 用 Kubuntu 升級成實體機測試後，其中一台較沒問題，另一台雙系統的電腦反而效能不彰。 Kubuntu 是使用 muon 系統更新來升級的（但是 16.04 中名稱變為「軟體更新 Update Manager」），若是更新選項調成 LTS 穩定版，就會偵測到 16.04，接受後就會升級。 升級時所有內建軟體（包括終端機 Konsole）都會凍結，設定功能也會停用，整個過程大約 1 小時左右。升級時建議不要開外部程式以免造成中斷。 而自己的電腦仍在 14.04 開發。 升級後問題 主要最大的部份是改用 Python 3.5 與內建 Qt / PyQt 5.5.1 。因此在升級時 Python 3.4 和它相關的所有套件都會被移除。（Python 2.7 也因為比 16.04 舊的關係，一樣會被移除） 新工具：由於官方套件供應者變成 Xenial，所有套件都已經捨棄舊版（如不再提供 GNU 4），而且內建更多工具（如 CMake、Python-dev）。 新驅動：內建非穩定版 Ubuntu 15 的 Kernel，支援以往 14.04 沒支援的驅動，要注意是否有新的驅動選項要勾選（如測試電腦中有主機板驅動的選項，預設是未啟用）。 KDE 界面變動：需要稍微習慣和重新設定新的圖形界面，例如滑鼠點兩下的設定放在「滑鼠」中而非檔案總管。 Pidgin 移除：通訊程式 Pidgin 不再於新的 KDE 支援了，若不想在更新程式捷徑時出現錯誤，必須在軟體中心移除它。 Python 3.5 套件：安裝 pip 與 QScintilla、QtSQL、QtSVG 時要使用 apt-get，不然自行下載的版本會無法認得內建的 Qt 5。 安裝 QMake：內建的 Qt 沒有附上 QMake，使用 apt-get 下載 qt5-qmake 安裝它。 安裝 Eric 6 IDE 以下為項目的安裝方式： Qt5（內建 5.5，目前與 Pyslvs 並沒有相容問題） SIP（重新安裝） PyQt5（內建） QScintilla2（用 apt-get 安裝，名稱 python3-pyqt5.qsci ） QtSQL（Eric 6 需求，用 apt-get 安裝，名稱 python3-pyqt5.qtsql ） QtSVG（Eric 6 需求，用 apt-get 安裝，名稱 python3-pyqt5.qtsvg ） Eric 6（正常安裝） Python Solvespace 核心 遇到 Python dev Kernel 不相容的問題，因為之前是使用 Python 3.4。意味著必須重編一個 Python Solvespace 的核心給使用 Python 3.5 的 16.04。 不過新工具跟自己電腦的 14.04 一樣，只要一個新的 Makefile 就行了。 Python Solvespace 或其 GUI 的編譯是否需要加入 CMake 或 QMake？因為以前不熟悉的關係只能手寫 Makefile，如果能因應未來版本的相關 lib，會比較符合升級的概念。","url":"http://project.mde.tw/blog/40323230ri-zhi-kubuntu-1604.html"},{"tags":"2016bg2","title":"40323230日誌 - 影音","text":"：：影片作業環境（Ubuntu）：： Kazam Ubuntu 平台的錄製軟體，為 KDE 系列的附屬程式，因此安裝 Kubuntu 時就內建了。 FFmpeg 從官方網站下載 .tar.bz2 壓縮檔解開並進入資料夾。 $./configure --disable-yasm #若是不支援某些項目會提醒停用參數 $make $sudo make install 最後檢查一下是否安裝： $ffmpeg -h SRT 字幕 以前自己載過 Youtube 的字幕練習英文，所以不算陌生。 未來做 introduction video 應該能好好發揮。","url":"http://project.mde.tw/blog/40323230ri-zhi-ying-yin.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/10/05","text":"Ubuntu MinGW Ubuntu 16.04 與 Windows 10 Leo Editor IDE Ubuntu MinGW 用 apt-get 安裝 MinGW，以在 Ubuntu 編譯 Windows 的可執行檔 .exe 。 $sudo apt-get install mingw-w64 編譯時使用下列指令（相當於 GNU 工具）： $x86_64-w64-mingw32-gcc $x86_64-w64-mingw32-g++ 不過若要使用在 Pyslvs，Qt 方面仍要做相應的調整。 Ubuntu 16.04 與 Windows 10 目前研究室沒有實體機使用這兩個系統，所以打算使用一台學校的電腦安裝 Virtualbox，模擬兩個系統的環境。 該電腦由於安裝雙系統，Ubuntu 不使用時 Virtualbox 不會佔用 Windows 7 的記憶體，所以應該能提供較流暢的模擬環境。 明天早上會裝好 Virtualbox 的設定。 Leo Editor IDE 目前觀察利用 Python 3 的程式碼編譯 Solvespace 是沒有問題的，不過在 14.04 與 16.04 的 Python 3.4 和 3.5 之間需要切換 Makefile。不然會沒有 include 或 lib 位置。 slvs_wrap.cxx:14:23: fatal error: Python.h: 沒有此一檔案或目錄 而若是編譯給 Windows 使用，也是要改一些設定。 除了之前無法輸入中文的問題以外，測試執行 Button 的 Script 是沒問題。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051005.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/10/04","text":"Pyslvs 編譯進度 Pyslvs 編譯進度 DXF 輸出 使用 dxfwrite 模組進行建檔，成功轉出 DXF 檔，可以在其他 CAD 軟體使用。 dxfwrite 可以使用 pip 安裝。 不過這個模組的讀取功能似乎不太能支援直接取得 DXF 的數據。 dxfwrite documentation: http://pythonhosted.org/dxfwrite/ 設定功能 規劃了一些自訂功能，想使用 QSettings 功能製作使用者的偏好選項。 預計會有面板位置、顏色等等選項可以調整。 不過還在研究 QSettings，可能屬於次要項目。 SLVS 輸出 將 .slvs 輸出功能分離出來做調整，希望以後可以單獨使用。 類似一般撰寫的功能，輸入點或線後可以寫成 .slvs 檔。 不過還有一些問題待調整，仍要測試一些項目。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051004.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/10/02","text":"Pyslvs 編譯進度 OCE Kernel Pyslvs 編譯進度 Log： 圖片格式選擇 按照機構寬度或高度縮放視角功能 表格提示文字 表格右鍵複製數據 遮罩修正 OCE Kernel Open CASCADE Community Edition: https://github.com/tpaviot/oce pythonocc: https://github.com/tpaviot/pythonocc-core 找到官方 Open CASCADE 的 C++ 核心，還有 Python 的接口 pythonocc。 另外 pythonocc 有一個附加模組 aocxchange 可以幫忙轉換 3D 檔案格式。 預想在 Pyslvs 設計草圖後，可以利用模組轉出簡單的 3D 零件樣式（例如連桿），供 3D CAD 軟體編修。","url":"http://project.mde.tw/blog/40323230ri-zhi-1051002.html"},{"tags":"2016g1","title":"automatic control","text":"自動控制系統中理解的部份筆記 相關名詞： 1.控制器 2.pole 3.古典控制 4.現代控制 5.後現代控制 6.拉普拉斯變換 7.回授(sensor) 大致上是這些相關名詞真的要使用的話看是要用現代的理論(數值的方法讓他學習),或者利用古典的方式推出數學方程式,利用laplace的方法,將T domain 轉到S domain將解解出來後,再進行調值和使用讓(kp ki kd )利用pid的方式進行控制相關的物理量。 才看一部分的自動控制,感覺還有一大部分會不了解,光是這樣我就決的自動控制在機械裡面是不可或缺的,只要他要動,就可以設計一套控制器來控制他,無論是在簡單的馬達控制或者是大型的機台控制,這些理論一定會實際的應用在這些控制器裡面。","url":"http://project.mde.tw/blog/automatic-control.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/30","text":"Pyslvs 編譯進度 Pyslvs 編譯進度 Log： 格式加入路徑儲存功能 原點初始值改變 驅動軸面板輸入精確角度 重置顯示區按鈕 滑塊計算功能（未驗證） 滑塊路徑追蹤功能（未驗證）","url":"http://project.mde.tw/blog/40323230ri-zhi-1050930.html"},{"tags":"2016g1","title":"python3 control","text":"安裝與使用教學 可以使用pip3 install的方式進行安裝 1.要先安裝Slycot Slycot 可以使用pip進行安裝 2.再來需要安裝一些工具 numpy matplotlib 3.接者才能進行安裝python-control pip install control 如果是python3版本的話,他有相對應的版本,會自動選擇,前提是要使用pip3 安裝完以後就可以跑模擬和使用他的模組了","url":"http://project.mde.tw/blog/python3-control.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/28","text":"Pyslvs 編譯進度 Pyslvs 編譯進度 輔助線面板 增加標示極限功能，開啟顯示標註的話，會顯示極限的數值（最大 6 位小數）。 這個面板在關閉後仍會保留上次的資料（歸類在畫布的參數中），不過切換到其他機構點時就會清掉極限紀錄。 模擬面板改進 這次調整過模擬功能的面板，更明確易懂。 另外新增開關路徑圖的功能，之前要刪掉才會消失。 路徑圖最後會加入存檔中，這部份功能會之後做。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050928.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/27","text":"Release v0.1.0 Pyslvs 編譯進度 Release v0.1.0 穩定版本釋出，開發中的功能有標示「Alpha」的字樣，未做出的功能鈕已經 disable。 目前更動的部份都是 GUI 相關，動態模擬的部份可能會整合進圖形界面。 之後的編譯進度更新的是第二版號，第三版號是單純修正 bug，第一版號是大功能的整合。 Pyslvs 編譯進度 輔助線 新增輔助線面板，可以觀察機構點的水平或垂直位置，之後會加入最大最小位置紀錄的功能。 主動軸標示 圖中會標示主動軸的相對點連線，使用橘色虛線表示，之後自訂功能做好後就能改別的顏色了。 今天花時間在輔助線的功能上，還沒做滑塊的計算。 滑塊可能會和主動軸分開面板控制。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050927.html"},{"tags":"2016bg2","title":"WebGL_three.js","text":"研究WebGL的框架three.js ,嘗試建立和Onshape同性質的網頁繪圖系統 經過討論後 ,我比較想要嘗試網頁方面的繪圖 ,然後上網找到了一些對岸製作的有關於WebGL、three.js的介紹 WebGL中文网 因為之前也沒有很深入的了解 ,所以可能要接觸一些範例來加深印象 ,假如可行 便能加入30號同學的核心進行2D線上繪圖 ,這樣資源也會更加豐富","url":"http://project.mde.tw/blog/webgl_threejs.html"},{"tags":"2016g1","title":"dynamic engine with python3","text":"今天在找相關開源的運算引擎找到的資料 pybox2d 今天找到一篇看似可以使用的開源運動模擬,範例裡面是使用pygame來顯示運動模擬,而且是符合python3 版本的,可能先從這邊下手,或者有找到更好的大型模擬引擎,已經有先build成so 和swig寫的啟動檔,執行他的範例是使用自由落體當範例,看起來是可以使用的,但是裡面的物理引擎沒有大型的這麼強大（bullet newton ),因為編成so和swig,就可以和pyslvs一樣做成可攜系統,直接包在裡面使用,而部用綁系統。 open dynamic engine 還沒真的深入下去看資料和相關python的部份,昨天作的bullet再python2的部份,確定真的可以使用,有一個範例是作自由落體的部份看值大致上是差不多相等的。 這次使用的pybox2d我也有作一個自由落體的範例程式,利用pygame呈現結果,詳細要使用還要看參考說明書來使用函式庫。","url":"http://project.mde.tw/blog/dynamic-engine-with-python3.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/24","text":"安裝 bullet-2.81 程式庫 安裝 bullet 程式庫 Bullet 其中一個用途為 Blender 的物理運算。 由於找到了一些 Python 相關的端口，所以想先安裝來讓 Python 使用。 ＊先確認已安裝 OpenCL。 從官方網站下載 Bullet Physics Library。 http://bulletphysics.org/Bullet/phpBB3/viewtopic.php?t=8490 載點為 bullet-2.81-rev2613.tgz： https://code.google.com/archive/p/bullet/downloads 使用 CMake 設定系統參數，並安裝： $cmake . -G \"Unix Makefiles\" -DBUILD_SHARED_LIBS=ON $sudo make $sudo make install 預設會安裝於 /usr/loca/lib/ 中。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050924.html"},{"tags":"2016g1","title":"bullet dynamic engine","text":"目前唯一可惜的部份是只能用在python2.7上面 今天將v-rep裡面的運動引擎,找了許多資料其中有 bullet dynamic (blender) newton ODE (opensource dynamic engine) 再找了許多資料後,發現現在這些引擎都幾乎和python掛不著邊,資料相當稀少,目前已經將bullet的部份轉成可以用python去調度裡面的運算模擬,例如碰撞 慣性等,但是目前有個極大的問題,swap的部份部是我寫的,當時他是使用python2.7,已經沒有開發成python3以上的版本,但是我不知道如何去撰寫關於這個swap的部份,可能要請老師教我們如何撰寫。 https://github.com/20tab/pybulletphysics.git","url":"http://project.mde.tw/blog/bullet-dynamic-engine.html"},{"tags":"2016g1","title":"Pyslvs 學習","text":"本篇關於開發的分配 參考範例所延伸的心得 這次開發繼續將手上的工具solvespace轉成自己手上的工具,本次開發會往以下幾個方向同時進行 網路的部份 相關技術Juypter hub的平行運算使用帶入解方程式 dynamic 相關技術再vrep裡面應該可以找到 系統控制的部份 modidied 這幾個方案可能會接下去進行開發,主要我想作的部份可能是運動那一篇,今天已經學到大致上的畫點劃線等的參數位置,相關函數大致上了解,可能朝著working model的方式進行開發,讓大致上的運動的方式,可以做成實作的方案,驗證的部份將vrep拿出來驗證,解出來的解是否正確,大致上就是進去幫忙開發延伸的功能,這次這個開發案會套用submodule的方式進行開發,可以再主倉儲看到目前已經有許多的子倉儲建立出來, 底下是今天學習的筆記 今天學習的部份先部探討如何去make那些so檔和c++部份的東西,今天只探討如何使用,大致上使用上的方法可以分成幾項來講,動態的部份部確定是要朝向vrep還是要往哪部份走,,有點忘記老師講的工具是哪一套,因為講的有點多. 定義系統 System(500) 初始3d的原點 Point3d(p0, p1, p2) 做一條XY軸的法線 Slvs_MakeQuaternion 畫一個工作平面 Workplane 畫一個2d的點約束再3d的點上 dragged 接著開始進行製作點座標 約束 將線畫出來 設定角度 解題會得掉回傳值再決定狀態 Q: 目前遇到的問題是來自於這些物理引擎不知道可以如何作接口到python上","url":"http://project.mde.tw/blog/pyslvs-xue-xi.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/21","text":".slvs 格式 速度計算 .slvs 格式 簡述進度： 輸出功能做了之後就測試 Pyslvs 產生的檔案是否能給 Solvespace 讀取，但是發現其實 16 進位編號是有順序的，如果跳號或對錯位就會導致閃退。 測試之後，目前基本的點輸入一切正常，但是當有連接線時就會產生錯誤，可能是數值對錯位，轉檔紀錄時應該必須和現在的算點功能分離。 目前轉出點成功： 速度計算功能 想做一個有關速度計算的功能，從轉的角度轉換距離，用自訂 RPM 速度轉換當前線速度。 可能會結合路徑追蹤使用。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050921.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/19","text":".slvs 格式 3D Printer 模擬 .slvs 格式 其實 .slvs 格式只是將 Solvespace 的暫存數據記錄下來，若有缺失就會使用預設數據，存檔時會刷新而非只修改部份。 參考的部份是空白文件的數據（包含預設平面、向量、原點等等），當有增加實體時就會追加內容。 特別注意的是這些代碼皆為 16 進位， True 的部份用 1 表示， False 則用 0 表示。 總共分為 5 個部份： 群組：群組，類似圖層的概念。 參數：之後會用到的幾何數據，會用編號歸納關係，基本上無法共用。 回應：圖形化界面的回應，包含滑鼠能點擊到的所有物件。 實體：點線的構成，包含實體建構時的參考副本，例如 point[0] 到 point[1] 的內容會被歸納到線條的從屬下。 未閉合的端點會有重複的紀錄，不過實驗過刪除多餘的紀錄仍可正常開啟。 不同實體有不同屬性可調整。 約束：用來約束實體，不同約束有不同屬性可調整。 參照下列格式： 辨識標頭（使用 ISO-8859-15）： ±²³SolveSpaceREVa 參考群組（00000001）： Group.h.v=00000001 Group.type=5000 Group.name=#references ... AddGroup 加入群組： Group.h.v=00000002 Group.type=5001 Group.order=1 Group.name=sketch-in-plane ... AddGroup 參考參數（00010010~00030023）： Param.h.v.=00010010 AddParam 加入參數：00030020 Param.h.v.=00040010 Param.val=40.00000000000000000000 AddParam 參考回應（00000001~00000003）： Request.h.v=00000001 Request.type=100 Request.group.v=00000001 Request.construction=0 AddRequest 加入回應： Request.h.v=00000004 Request.type=101 Request.workplane.v=80020000 Request.group.v=00000002 Request.construction=0 AddRequest 參考實體（00010000~00030020）： Entity.h.v=00010000 Entity.type=10000 Entity.construction=0 Entity.point[0].v=00010001 Entity.normal.v=00010020 Entity.actVisible=1 AddEntity 加入實體： Entity.h.v=00040000 Entity.type=2001 Entity.construction=0 Entity.workplane.v=80020000 Entity.actPoint.x=40.00000000000000000000 Entity.actPoint.y=30.00000000000000000000 Entity.actVisible=1 AddEntity 複製項（80020000~80020002）： Entity.h.v=80020000 Entity.type=10000 Entity.construction=0 Entity.point[0].v=80020002 Entity.normal.v=80020001 Entity.actVisible=1 AddEntity 加入約束： Constraint.h.v=00000001 Constraint.type=30 Constraint.group.v=00000002 Constraint.workplane.v=80020000 Constraint.valA=50.00000000000000000000 Constraint.ptA.v=00040000 Constraint.ptB.v=80020002 Constraint.other=0 Constraint.other2=0 Constraint.reference=0 AddConstraint 研究花了一些時間，可能得後天才能加入匯出功能。 Pyslvs 的群組應該只會有一個，用點之間的線架構就好了。 應該只有 3D Mode 才有 STL 支援的功能。 剩下 3D Mode 將 2D 的功能加過去，另外新增線條鉛錘與水平的約束、應該就能結束了。 3D Printer 模擬 關於 3D Printer 模擬的部份，可能必須寫一個新的軟體來應對。 因為一些定義如果直接套用目前的範本，可能會無法模擬。 畫了個模型，之後套範本應該比較快。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050919.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/17","text":"Pyslvs 編譯進度 PyOpenGL Pyslvs 界面 3D 模式 在另一個分頁新增相同的面板，不過拿掉了呆鍊約束。 新的 Widget 名稱都改成 _3d 字尾以供辨識。 不過上方的 QMenuBar 必須應對這個改變，估計製作 3D 的 QAction 後，會根據當前頁籤隱藏另一邊的 QAction。 記憶體釋放 由於初學時的寫法沒優化觀念，Qt 的視窗物件必須用 setAttribute() 設定屬性，其中的 Qt.WA_DeleteOnClose 會在關閉後刪除物件，以免開過太多視窗會導致速度降低。 .slvs 格式 今天還是沒時間研究詳細的用法，但是可以確定 2D 圖面的初步內容（基準面之類的），用 Python 程式碼存成 .slvs 附檔名的 ISO-8859-15 編碼文字檔。 with open(fileName, 'w', encoding=\"iso-8859-15\", newline=\"\") as f: f.write(self.Slvs_Script) print(\"Successful Save: \"+fileName) PyOpenGL 找了一下之前為何無法使用 OpenGL 範例的原因，似乎是因為那些範例無法支援新的 OpenGL 了。 http://stackoverflow.com/questions/38645674/issues-with-pyqt5s-opengl-module-and-versioning-calls-for-incorrect-qopenglfu 所以按照建議，安裝了 PyOpenGL（License: BSD） ，不過它的開發期較長。 http://pyopengl.sourceforge.net/documentation/installation.html 執行過上面文章的範例，可以成功使用（不過那個範例 code 忘記匯入 sys 和 math）。 明天可能會利用時間放圖片。 Mark Down 圖片的語法（其實和超連結很像）： ![替代文字](近端或遠端連結\"滑鼠提示文字\") 只是無法調整圖片大小。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050917.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/15","text":"現時 Ubuntu 版 Solvespace 安裝 .slvs 檔案格式 Pyslvs 3D 模式 Solvespace 編譯 確保下列事項： GNU 5.3 以上 CMake 3.0 以上 下載後進入資料夾。 $git submodule update --init extlib/libdxfrw $mkdir build $cd build $cmake .. -DENABLE_TESTS=OFF 若出現 GCC 5.0+ is required 問題，請使用下列指令更改優先權： $sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 1 $sudo update-alternatives --config gcc 替代項目 gcc（提供 /usr/bin/gcc）有 2 個選擇。 選項 路徑 優先權 狀態 ------------------------------------------------------------ * 0 /usr/bin/gcc-4.8 48 自動模式 1 /usr/bin/gcc-4.8 48 手動模式 2 /usr/bin/gcc-5 1 手動模式 按 [enter] 保留目前選項 [*]，或輸入選項編號：2 update-alternatives: 以 /usr/bin/gcc-5 提供 手動模式 中的 /usr/bin/gcc (gcc) 若出現這個警告： The CMAKE_CXX_COMPILER: /usr/bin/c++ is not a full path to an existing compiler tool. 請更改 CMake List 的參數（注意不要指到軟連結，必須是執行檔本體）： $sudo cmake -D CMAKE_C_COMPILER=\"/usr/bin/gcc-5\" -D CMAKE_CXX_COMPILER=\"/usr/bin/g++-5\" ../CMakeLists.txt 最後 build 檔案出來後，使用下列指令： $cd .. $sudo make 編譯完畢後，可以在 src 資料夾中找到 solvespace 執行檔，點兩下就能執行了。 .slvs 檔案格式 為了瞭解 Solvespace 的運作流程，也以便之後跟它溝通，想知道 .slvs 的儲存方式。 觀察檔案格式，用文字編輯軟體開啟之前存的範例。 Solvespace 是用西歐語系 ISO-8859-15 編碼儲存圖檔的，以這點來說，Python 要輸出成 .slvs 應該是輕而易舉。 之後觀察一下每種圖形的變化式，應該就能理解如何將 Pyslvs 的表格 Output 給 Solvespace 開啟了。 Pyslvs 3D 模式 在想 Pyslvs 之後會加入 3D 模式，採用 Qt OpenGL 繪圖（可以控制鏡頭），且和 2D 模式並存，參考這裡的文章： http://doc.qt.io/qt-5/topics-graphics.html#2d-graphics-with-qpainter 之前好像看過 QPainter 和 QOpenglWidgets 重疊渲染錯誤的問題，不過只要分開 Widget，應該是不會造成太大衝突。 而 2D 和 3D 共存不知道是否會吃太多資源，還有待觀察。 另外在成功大學的文件裡找到關於 STL 格式的說明： http://vr.me.ncku.edu.tw/courses/cg99/Download/STL.pdf 想要大約瞭解一下，畢竟大部分的 3D CAD 軟體應該都支援 STL 檔。 亦找到一篇 C++ 讀取 STL 並用 OpenGL 顯示的範例 code，值得研究一下。 http://www.cnblogs.com/xds1224/p/3565280.html","url":"http://project.mde.tw/blog/40323230ri-zhi-1050915.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/14","text":"Qt OpenGL 教學資料 PySide 2 安裝問題 Qt OpenGL Qt 的官方頁面還沒有撰寫說明，只看函式與格式不太能了解其用途。 所以去找其他 QtOpenGLWidgets 的教學，找到滿多資料的。 http://blog.csdn.net/cly116/article/details/47184729 PyQt 的詳細說明比較少，不過找到幾篇範例後，可以對照著看。由於是高階語言，Python 使用 C++ 函式滿容易的，省略不少步驟。 PySide 2 安裝問題 今天將 Qt 版本改成 5.6，並重新下載官方倉儲安裝。 https://github.com/PySide/pyside2-setup 使用的參數： $sudo python3 setup.py install --qmake=/usr/bin/qmake --cmake=/usr/bin/cmake 剛開始遇到 Makelist 找不到指定檔案的問題，如下圖： 必須安裝以下套件： $sudo apt-get install libqt5xmlpatterns5-dev 不過接下來遇到編譯 shiboken 的問題，編到一半就中斷了。 上網查了下結果，是因為函式未回傳值，可是不知道什麼原因。 到官方的倉儲找 Issue，不過好像都沒遇到這種情況。 所以另外從非官方倉儲下載 wheel 來用。 https://github.com/fredrikaverpil/pyside2-wheels 下載了編譯完成的 wheel (Python 3.4) 後，按照下方 Readme 的說明安裝。 這個套件提供者是將 Qt 版本分開裝的，所以會和 PyQt 使用的資料庫不一樣。 不過不須擔心這個問題，因為包好的 wheel 會直接讀安裝的 Qt 資料庫，可以不用裝說明裡的套件。 以下連結有 4 個平台的 PySide 2 載點，只需使用 pip install 或 pip3 install 就能裝成功。 https://bintray.com/fredrikaverpil/pyside2-wheels/pyside2/2.0.0.dev0#files/","url":"http://project.mde.tw/blog/40323230ri-zhi-1050914.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/13","text":"Pyslvs 版本子倉儲 PySide 2 一些資料 子倉儲 將資料夾重新命名後，建立新的倉儲，將 Pyslvs 的程式碼放入。 再用指令將子倉儲嵌入 Python-solvespace 的倉儲： git submodule add https://github.com/40323230/Pyslvs-PyQt5 Pyslvs-PyQt5 重新 push 一次，這樣就將子倉儲放在主倉儲中了。 而 .gitmodules 檔案中也會紀錄子倉儲的文件。 只是在切換分支時要特別小心，以免造成衝突。 參考的是 Git 官方英文網站的說明，不過這裡有中文版的： https://git-scm.com/book/zh-tw/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E7%B5%84-Submodules PySide 2 找了 PySide 的相關資料，發現目前支援 Qt5 的是 PySide 2，是去年開始開發的，仍在努力追上 PyQt 的腳步。 https://wiki.qt.io/PySide2 在開發紀錄中提到還在克服 Qt 5.7 中 shiboken 失去 C++ 11 的支援，所以暫不支援 Qt 5.7。 也因為如此，今天試圖 build 出 PySide 2 的安裝檔時發生 shiboken 的錯誤，應該就是這個問題，明天會將 Qt 改成 5.6，以裝上 PySide 2。 另外也先預習 PyQt 轉 PySide 時需要注意的事項，不過目前看下來頂多是信號槽的名稱需要去掉 pyqt 的字頭。 其他因為是用 Python 3 開發的關係，內建標準的 String 與 List 格式，不須煩憂 QString 或 QList 的問題。 而還有用 Super 繼承的問題，在 PySide 中也有 Qt Designer， .ui 轉換 .py 上使用 PySide 的程式（或是 Eric 可以自己應變）就行了。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050913.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/12","text":"Pyslvs 編譯進度 第二對連桿腳 Pyslvs 界面 參數式界面 大部分的界面都統整好了，剩下遮罩沒設定。 這些參數確定可用，不過角度格式還不支援。 滑鼠加入點 在畫布上使用滑鼠右鍵選單就可以在該位置加入座標。 加入後會出現在左側的表格裡，亦可供編輯。 連桿組範例 用新的繪圖系統加入了第二組連桿腳。 模擬了一下動作，效果還不錯。 之後會改試試 OpenGL 的模組功能，之前執行範例時會出錯，要找辦法解決。 另外在 imgur.com 的圖片載了一個副本下來，找時間會移到倉儲上。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050912.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/11","text":"Pyslvs 編譯進度 - 參數式架構核心完成 倉儲 python-solvespace 已更新 Pyslvs 界面 簡略 log： 大改核心，寫了一條函式將表格轉為 list 型態，並自動儲存成相應的類型。 整修後的計算式乾淨多了，沒有型態問題，從對應 list 取出來就行。 這次大改是因應新的參數表加入，圖中的項目配置方便使用者直接選取後打入新數值。 而 Commit 的部份沒多加限制，點擊兩下就能修改。 執行全部功能正常。 不過輸入界面部份還沒做轉換，Point 的加入可能會出問題，所以目前是讀範例做測試。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050911.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/10","text":"Pyslvs 編譯進度 參數式架構 測試影片 Pyslvs 界面 今天將所有的視窗都用圖層或 Widget 固定化，免得編譯後位置出現落差。 不過也花了許多時間，之後主要是為參數式編輯做架構。 最後決定使用單行文字框做輸入。 未來的輸入界面大約像這樣： 參數式界面改良 在點座標分頁中新增參數表，使用右鍵可以新增或刪除項目，點擊兩下就能編輯數據與註解。 而下方加入點的欄位中，可以打入新增的代碼。 雖然整體改換還需要段時間，但是重要的功能已經有雛型了。 輸入遮罩 遮罩設定存於主視窗中，對話方塊生成時會複製內容，給其所有需要的單行文字框。 有了這個設定，就能避免使用者亂輸入文字了，基本概念如下： X_coordinate = QLineEdit() X_coordinate.setValidator(QRegExpValidator(QRegExp(mask))) 其中 mask 是字串，也是篩選的條件。 基本規則如下： [ 任何文字 ]{ 必要出現次數 , 在接下來的長度內 } 中括弧中是打允許使用者的字元。 如 [a] ，使用者必須打入 1 個小寫的 a 才能再繼續之後的規則，可以使用 [0-9] 表示 0 至 9 的數字， [a-z] 表示小寫的 26 個英文字母等等。 大括弧是篩選條件，默認是 {1, 1} ，第一項是必須打的數量，第二項是這個規則最大的數量。 小括弧是邏輯順序，跟其他程式語言差不多，如 ([a] | [b]{3, 5}) 就是在這個位置可以選擇打入 1 個 a，或是 3 個到 5 個 b。 至於 &#94; 和 $ 則是標示貼緊字頭與字尾的符號，能夠比較明確，但是要注意是否會導致字頭設下太多規則，而讓使用者打不了半個字。 基本規則容易搞混的話，可以使用簡語，如 ? 符號代表 {0, 1} ，就是能選擇要不要輸入的意思，可以省略它打入下個規則的字串。 其他簡語可以參考 官方網站 的說明。 以下是 Pyslvs的遮罩： #超過10個參數 param_10 = '[1-'+str(int(self.Parameter_list.rowCount()/10))+']?' if self.Parameter_list.rowCount()>=10 else '' #有參數 param_use = '(&#94;[n]'+param_10+'[0-'+str(int(self.Parameter_list.rowCount())-1)+']$|' if self.Parameter_list.rowCount()>=1 else '' #最小值 -9999.9999 最大值 9999.9999 的數字 mask = param_use+'&#94;[-]?([1-9][0-9]{1,2})?[0-9][.][0-9]{1,4}$' if param_use: mask += ')' self.Mask = QRegExpValidator(QRegExp(mask)) self.X_coordinate.setValidator(self.Mask) self.Y_coordinate.setValidator(self.Mask) 如果參數表長度超過 1，只要開頭打入 n 這個字母，就會啟用參數規則，而且只能打入目前長度設入的參數代號。 如果沒有設定參數，文字欄內只能填入最大 9999.9999 的數字。 因為要讀表的長度，上述設定在參數表新增或移除項目時就會更新。 另一方面，因為變成了文字欄，為了偵測是否為空值，做了一些小篩選： x = self.X_coordinate.text() if not self.X_coordinate.text()==\"\" else self.X_coordinate.placeholderText() y = self.Y_coordinate.text() if not self.Y_coordinate.text()==\"\" else self.Y_coordinate.placeholderText() 至於空的欄位上的淡色文字（Place Holder Text）部份地方只是寫好看的，之後可能就直接讀淡色文字來用。例如編輯視窗中只需要改動 X 軸座標，不小心動到 Y 軸座標時直接刪成空欄位，系統可以填回原本的數值。 測試影片 錄製一段粗糙的影片展示目前基本功能。 之後會找一個比較好的軟體剪接。 路徑追蹤 程式碼和路徑座標展示 動態模擬 距離量測 Pyslvs preview from Union000 on Vimeo .","url":"http://project.mde.tw/blog/40323230ri-zhi-1050910.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/09","text":"Pyslvs 編譯進度 近似直線機構問題 活塞 → 動力源而非被動元件 參數式設計？ 測量能力待加強 Pyslvs 界面 Fusion 主題 使用 QApplication 的主題選擇功能指定主題。 這樣在 Ubuntu 執行時會強制使用該元件外觀，而非之前節圖的鐵灰色。 QApplication.setStyle(\"fusion\") app = QApplication(argv) run = MainWindow() run.show() exit(app.exec()) Qt 的說明文件提及，雖然 Qt 程式庫擁有 5 種主題，但是所有平台共通的是 fusion 和 windows （傳統佈景）主題。 只在有在特定平台才能正常顯示特定主題，如在麥金塔上使用 macintosh ，Windows XP 上使用 windowsxp ，Windows Vista 以上的作業系統使用 windowsvista 。 編輯視窗提取舊資料 編輯視窗會在下拉選單變更對象時提取該項目資料，以供參考。 使用右鍵選單時，亦會嘗試讀取選中的欄位，自動選到該項目。 刪除功能的右鍵選單也會將選中的欄位對應下拉式選單。 移除驅動軸面板的暫停功能 由於暫停的功能也不算是非常必須，所以將停止的功能拿掉。 若要中止動畫，直接將面板關掉就好了。 直線機構問題 今天嘗試了 Peaucellier 直線機構的模擬，但是在輸入軸轉動的時候碰到一些障礙。 直線機構無法立即得知其極限，而之前做的路徑追蹤功能只支援 知道範圍 的圓周運動。 不過按理說頂多會回傳約束錯誤的訊息，但是沒想到連一度都無法搖擺，不知道是機構卡死還是什麼問題。 所以想正視這個情況，讓直線機構也可以在 Pyslvs 上模擬。 應該做一個能夠解極限的功能。 活塞動力源 由於程式庫的技術問題，可能無法計算可以改變長度的被動元件，所以將活塞功能改成直線驅動的連桿，可以嘗試讓一活動點進行固定直線運動。 構成是由節點、兩固定點構成的直線上作動，跟滑塊不同的是，這個項目是無極限的主動元件，利用增量進行移動（使用者可設定範圍），遇到約束衝突會強制結束。 預計這個功能要加入驅動面板中，讓這個面板能管理主動軸與活塞動力。 參數式設計 想讓 Pyslvs 加入新的參數設計表，紀錄所有使用者使用的參數，支援使用者自行註解、在表內進行交叉運算。 這樣修改更快，達成機械設計的目的，跟上大部分 CAD 軟體一樣的功能。 表格會跟點座標和連桿約束等等的項目存入 Data Sheet 中。 不過這樣所有新增和編輯界面就得做調整。 測量能力 測量面板目前只有計算點之間的距離，無法測量角度之類，有些不方便。 有大量現成的數學公式求解，拿來用在點座標結果上是再好不過了。 預計之後測量、驅動面板會增強許多，上面提到的解極限的功能或許也會歸類在面板類。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050909.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/08","text":"Pyslvs 編譯進度 倉儲 python-solvespace 已更新 Pyslvs Demo 功能介紹 錄影準備中 Pyslvs 界面 模擬功能按鈕調整 路徑追蹤功能區隔出來，其他兩個面板類的歸在下方。 面板同時只能開啟一個，必須關掉前一個才能切換。 而開啟新檔時會自動關閉已開啟的面板。 路徑座標輸出 路徑追蹤功能啟動時做一些小改變，會自動開啟顯示標註。 現在會將運算後的路徑保留，會顯示在畫面上，使用者可以決定其去留，若是沒刪除，再次執行追蹤功能時結果將覆蓋當前數據。 因應新增兩個按鈕，分別為清除鈕和結果預覽。 座標表格亦可匯出成 CSV 表格。 而不同點的路徑現在會用不同顏色呈現了。 點外觀的分頁中可以調整路徑粗細。 量測面板 量測面板可以計算機構任意兩點間的距離，並且顯示滑鼠座標位置，以供滑鼠附近點的座標參考，座標單位已經為縮放調整了。 面板開啟時會自動開啟顯示標註。 驅動軸面板 這個面板可以選擇任意設定好的主動軸調整角度，並且還有慢速播放的功能，不過暫停後等待延遲的缺陷還在找方法修正。 影片簡介 當初預想的功能大部分都快完成了，剩下一些輸出和防呆的細節處理。 之後想錄製一點說明影片，介紹基本功能之類的，算是專題資料的一部分。 而如果找不到輸出給其他 CAD 軟體的方式的話，網頁版可能得沿用目前 Data Sheet 的儲存方式。 網頁版在這學期學習 Java Script 之後，配合專題所學得的技能，應該有能力做一個圖形化界面出來。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050908.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/07","text":"路徑計算解決 程式碼功能簡介 PyQt5 線程 QThread 教學 PyQt5 信號槽教學 PyQt5 進度條教學 倉儲 python-solvespace 已更新 書籤： PyQt 線程 PyQt 信號槽 PyQt 進度條 路徑計算解決 煩惱多日的路徑問題解決了，是靠觀察程式碼產生結果觀察出判斷式有問題。 在 Qt 表格的回傳值中 不可以這樣用 ，因為永遠不會發生： if table_point.item(i, 3).checkState()==True: ... 必須這樣用： if table_point.item(i, 3).checkState(): ... Pyslvs 界面 程式碼 Demo 這個程式碼使用 matplotlib 繪出圖形，最上端可以設定運算的對象。 按下「Copy」鈕可以複製到剪貼簿，「Help」鈕會連到之前寫的程式庫網頁。 PyQt 的剪貼簿用法很簡單： clipboard = QApplication.clipboard() clipboard.setText(self.script.toPlainText()) 「Save」可以存成 Python 程式碼，執行過確認沒問題。 路徑追蹤 追加解析度功能，預設 5 度，最大 45 度，最小到 0.5 度。 表單也經過篩選，不會加入固定點了。 按下「Apply」鈕後會開始執行運算，而且進度條會顯示運算進度（進度無誤）。 中途隨時可以停止執行，只是一旦停止就會關閉小視窗且刪除暫存資料，要重新計算。 執行完畢後，就會自動關閉視窗，呈現路徑圖。 接著就能調整畫布，用內建的存檔功能存成圖片！ 關於路徑追蹤的視窗，其實花了不少功夫研究 Qt 的功能，將 Python 的教學寫在下面。 PyQt 線程 需要執行序的原因是，程式語言通常會將複雜運算的程序優先度提高，相對畫面的處理較簡單，因此會將「複雜運算」處理完後才會更新畫面顯示。 若是不想讓視窗凍結，使用排程功能就十分重要，提醒使用者正在運算，亦可以避免輸入過多指令時，因為正在處理「複雜運算」，而無法理會使用者的呼叫。 線程功能並非平行運算，而是拖慢所有進度，在執行序之間來回處理，以因應多方面需求。 Python3 雖然有內建 threading 和 _thread 的模組，但是還滿難使用與管理的，所以利用 Qt 的功能來替代之。 可以想像成 QThread 是另一個元件，也是使用 class的方式繼承，基本架構如下： class WorkerThread(QThread): #這裡是信號（括弧中填入傳出參數類型，沒有就不用） #必須擺外面 done = pyqtSignal(list) #初始化 def __init__(self, parent = None): QThread.__init__(self, parent) self.stoped = False self.mutex = QMutex() #執行序（可以很多個） def run(self): ... #完成，發出信號（帶一個 list 參數） self.done.emit(nPath) #中止序 def stop(self): with QMutexLocker(self.mutex): self.stoped = True QThread 跟外界溝通的方式是靠信號跟從外部定值（這樣可以從 self 直接讀值）。 Window 或 Widget 可以如下使用： class Path_Track_show(QDialog, Ui_Dialog): def __init__(self, parent=None): super(Path_Track_show, self).__init__(parent) ... #定義線程 self.work = WorkerThread() #連接啟動信號 self.buttonBox.button(QDialogButtonBox.Apply).clicked.connect(self.start) #連接強制結束訊號 self.buttonBox.button(QDialogButtonBox.Cancel).clicked.connect(self.stop) #連接完成信號 self.work.done.connect(self.finish) #啟動 def start(self): #傳入值（或任何前置作業） self.work.Run_list = self.Run_list ... #啟動 self.work.start() #關閉按鈕（有關GUI項目） #會同時執行work和之後的項目 self.buttonBox.button(QDialogButtonBox.Apply).setEnabled(False) ... #強制結束 def stop(self): self.work.stop() #完成 #信號槽接收值（帶一個 list 參數） @pyqtSlot(list) def finish(self, Path): self.Path_data = Path #接收後關閉 self.accept() PyQt 信號槽 信號是 Qt 元件用來溝通的方式，通常是「函式」使用「信號物件」發送訊息給連結的「信號槽」，而配戴此信號槽的函式就會在接收訊息的時候開始執行。 特別注意 PyQt4 和 PyQt5 的信號連接方式有所不同。 在一個 class 配置「信號物件」： class a(parentA): done = pyqtSignal() 這個物件必須擺在 class 中，不過不行在任何函式裡（包括初始化函式 __init__ ）。 呼叫方式是跟其他同 class 底下的函式同個位階（如 self . done 或 a . done ）。 接著在一個函式配置一個信號槽： class b(parentB): @pyqtSlot() def b_1(self): ... 然後在需要連接的時段連結它們（亦可以在時機內斷開連結），例如 class b 的初始化： class b(parentB): def __init__(self, parent=None): ... self.Come_from_A = a() self.Come_from_A.done.connect(self.b_1) 最後就是發送信號的時機，剛才的信號物件是 class a 內的函式都可調用的： class a(parentA): def a_1(self): ... self.done.emit() 這樣 class b 內的 b_1 就會執行了。 這些括弧內都是可以帶入參數的，由於 Qt 是 C++ 寫成的， @pyqtSlot() 的括弧中是填參數類型。 PyQt 進度條 知道線程和信號槽的利用後，處理時控制進度條物件就易如反掌了。 首先在執行前算一下進度條跑滿後的格數（若是迴圈，會在執行一次時加 1，加到滿）： self.progressBar.setRange(0, limit) 接著在線程的初始化中設置一個整數 progress_Signal ，從零開始。 self.progress = 0 執行時的迴圈，用另一個函式發送訊息與增加進度值： def run(self): for i in range(_range_): self.progress_going() def progress_going(self): self.progress = self.progress+1 self.progress_Signal.emit(self.progress) 接收端函式（也許是另一個 class）： @pyqtSlot(int) def progressbar_change(self, val): self.progressBar.setValue(val) 連接（在初始化就可以了）： self.work = WorkerThread() self.work.progress_Signal.connect(self.progressbar_change) 最重要的功能做完了，最終也學會了難懂的信號槽（以前都是編譯器幫忙產生的），剩下的功能應該也能順利做完。 雖然最終沒有在暑假內完成專題的項目，但是也學會許東西，培養出快速統整資料並架構化的能力。 覺得自己需要多練習語言表達的部份，因為可能統整資料十分明瞭，在口語上卻節奏太快，順著聽者的思路呈現才是最重要的方向。 P.S Roger 用 wordpress 架了一個存文章的網站： http://roger-blog.tk/","url":"http://project.mde.tw/blog/40323230ri-zhi-1050907.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/06","text":"表格管理與程式碼 路徑計算問題 Pyslvs 界面 表格管理 新增調整連桿和呆鍊順序的功能。 但是 slvs 程式庫處理的結果似乎和約束順序無關。 不論是調整表格順序，還是調動範例 code 裡的順序，結果都一樣。 點座標的表格現在多了當前座標欄位，和初始座標區隔開。 運算時是使用初始座標，當前座標是繪圖用的。 這樣按理說產生的點座標和約束條件就和範例一樣了，但是仍然沒解決。 程式碼輸出 將字串和文字區塊作合併，存成一個 object，但是還未回傳主程式。 以下是加入點座標的範例。 Script = \"\" #初始化 Script += \"\"\" sys = System(1000) p0 = sys.add_param(0.0) p1 = sys.add_param(0.0) p2 = sys.add_param(0.0) Point0 = Point3d(p0, p1, p2) qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0) p3 = sys.add_param(qw) p4 = sys.add_param(qx) p5 = sys.add_param(qy) p6 = sys.add_param(qz) Normal1 = Normal3d(p3, p4, p5, p6) Workplane1 = Workplane(Point0, Normal1) p7 = sys.add_param(0.0) p8 = sys.add_param(0.0) Point1 = Point2d(Workplane1, p7, p8) Constraint.dragged(Workplane1, Point1) \"\"\" ... #加入點 Script += \"\"\"p\"\"\"+str(i+7)+\"\"\" = sys.add_param(\"\"\"+str(float(table_point.item(i, 1).text()))+\"\"\") p\"\"\"+str(i+8)+\"\"\" = sys.add_param(\"\"\"+str(float(table_point.item(i, 2).text()))+\"\"\") Point\"\"\"+str(i+1)+\"\"\" = Point2d(Workplane1, p\"\"\"+str(i+8)+\"\"\", p\"\"\"+str(i+9)+\"\"\") \"\"\" #如果點固定 Script += \"\"\"Constraint.dragged(Workplane1, Point\"\"\"+str(i+1)+\"\"\") \"\"\" 路徑計算 今天嘗試過許多方法，但是未能讓路徑運算功能的結果與 Python 3 執行範例的結果一樣。 逐步將其他功能做起來，也許能幫助檢查為何無法算出正確的結果。 以下是直接將執行範例的結果畫在圖層上，違和感滿大的。 接著會先著重於程式碼輸出的部份，拿來和範例比對，希望能找出錯誤。 如果必要的話，也許有些複雜的能會暫時移除。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050906.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/05","text":"小細節修正 程式碼顯示功能 路徑計算問題 Pyslvs 界面 繪圖選項 新增顯示尺度和反黑背景的選項。 佈署面板 由於碰到一些小障礙，所以就先作模擬面板的部份。 之所以使用嵌入的 Widget，是因為必須一面看著畫布作調整，所以都放在主視窗作業會比較好。 不過之間的傳輸功能還在研究，和視窗設定的形式不一樣，不能在關閉的瞬間偵測。 右鍵選單 由於發現會受表格標頭欄厚度的影響，微調了一下右鍵選單的位置，不過這些定值會因為字體大小而改變。 拆開滑鼠游標的 X Y 位置作像素調整： def on_point_context_menu(self, point): pos = QPoint(point.x()+43, point.y()+23) action = self.popMenu_point.exec_(self.Entiteis_Point.mapToGlobal(pos)) ... 以及偵測加入項目後出現欄的寬度： def on_link_context_menu(self, point): if self.Entiteis_Link.rowCount()==0: pos = QPoint(point.x()+3, point.y()+23) else: pos = QPoint(point.x()+15, point.y()+23) 存檔提示 視窗標題會在修改後，未存檔時多出星號。 讀檔、開新檔案、存檔後星號會消失。 在沒有星號的情形下，關閉程式時不會提示是否存檔。 圖形顏色對應 利用 Python 的 dict 鍵值功能作顏色對應表，基本概念如下： dict = {key1 : value1, key2 : value2} dict[key1] 得 value1 dict[key2] 得 value2 可以使用 zip 來將兩個 list 縫合，顏色代碼對應 Qt 的 Name space。 self.Color = dict(zip(self.re_Color, val_Color)) 這樣就可得（無定義則用綠色）： try: pen.setColor(self.Color[self.table_style.item(i, 1).text()]) except KeyError: pen.setColor(Qt.green) 以下是目前支援的顏色表： Print 程式碼 新增一個功能，會在監視窗中 Print 所有迴圈呈現的程式碼。 這個功能目前僅只於 print，之後會做成顯示在視窗中、存成文字的功能。 路徑計算問題 將約束帶入後似乎出現了問題，還在研究如何解決。 路徑計算功能能夠畫出指定點（可複數）的移動軌跡，設定視窗中使用兩個表單達成這個功能。 結果計算後變成 180° 之後的軌跡出現錯亂。 下圖繪製 Point2 和 Point3 的軌跡，Point3 的圓周運動是一切正常，但是 Point2 在繞回來時運算不知道為何出了嚴重的錯誤，畫在不可能出現的位置。 由於這部份功能的程式滿大的，也是用自己的邏輯手寫的，可能會漏一些沒注意的地方，檢查費了不少功夫。 原理是用一整個 list object 傳送座標群的，包含選擇的點，從 start angle 到 end angle 的範圍，理論上是三維的。 不過迴圈迭代時有點小毛病，所以改成 object[0] 是第一個點的 X 軸，object[1] 是 Y 軸，object[2] 是第二個點的 X 軸，以此類推。 #取值用的迴圈 for i in range(0, len(self.Path), 2): X_path = self.Path[i] Y_path = self.Path[i+1] 可能是 slvs 程式庫的約束處理問題，因為我是先將「呆鍊」組成三角形後才約束「連桿」接起，因而動到主動軸的點，產生了這個問題。 相反地，「客製化」零件的約束順序採用最保險的方式，所以沒有這個問題。 歸納幾個解決方式，是製作以下功能（都會加入）： 調整表格順序的功能（決定優先權，比較好知道原因）。 優先偵測主動軸的參照點，優先定義與其相關的連桿約束。 之前提到的，因為這部份程式碼滿大的，跨了3個檔案，所以可能要一些時間處理。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050905.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/03","text":"QPaint 繪圖 模擬功能-目標 QPaint 其實 QPaint 繪圖就跟 slvs 程式庫滿像的，只需要擔心順序（圖層）問題。 用 QPaint 繪圖的話，想辦法將最新的座標 copy 進去就行了。 把繪圖的 Widget 和處理 list 的副程式獨立出來，名為 canvas.py 和 list_process ，沒什麼影響，讓主程式不會太雜亂。 Class 中宣告一個名為 update_figure 的函式，主程式要刷新時就會呼叫，並填進主程式的表單，這個函式就會將所有表單填進 self 的 object 裡，讓 paintEvent 函式讀取。 def update_figure(self, table_point, table_line, table_chain, table_shaft, table_slider, table_rod, table_style, zoom_rate): self.Xval = [] self.Yval = [] zoom = float(zoom_rate.replace(\"%\", \"\"))/100 self.table_point = table_point ... self.update() 之所以這樣寫，是因為 paintEvent 函式和所有 Qt 的 Event 函式都不能輸入 event 以外的參數。 而且 Qt 有規定 QPainter 只能畫在 paintEvent 函式中，不然會出錯。而這個函式也同時決定重新繪製的時機（視窗縮放，改變大小時）。 若想手動刷新，對 Widget 物件下 self.update() 或 self.repaint() （不建議，閃爍頻率高）就行了。 而 event 參數是專門傳入事件發生相關的數據，如滑鼠座標： def mouseMoveEvent(self, event): if self.drag: self.origin_x = event.x() self.origin_y = event.y() self.update() 能夠繪圖後，必須校正視圖的大小和位置，由於大小要看這個機構的基本尺寸是多少，所以給使用者自己調整是最好的方法了。 預設是將座標尺度放大兩倍後定義為畫布的一倍，所以剛才的 update_figure 中有下列轉換式： for i in range(table_point.rowCount()): self.Xval += [float(table_point.item(i, 1).text())*zoom*rate_all] self.Yval += [float(table_point.item(i, 2).text())*zoom*rate_all*(-1)] Y 軸座標乘上負號是因為不論 Window 和 Widget，兩者都是從「標題欄」往下延伸的，所以向下是負值。 上次更新中加入沒用到的 QSlider 滑桿，這次讓它能夠定義放大的倍率，從 50％ 到 500％，應該都能夠支援幾乎所有尺度的機構了。 另外調整畫布大小可以用 Ctrl + 滑鼠滾輪調整， Ctrl + 左鍵按住拖移或雙擊可以定義原點位置。 這樣設定是讓使用者不會亂拉將圖面移走，也更能知道機構樣貌。 而這次顏色設定暫時只有 R、G、B 三色，其他色碼的加入還要看下說明文件，原本的顏色都偏亮或太黯淡，所以會整合後加入其他顏色。 ＊上次的 mpl 畫布就有加入存成 png 圖片的功能了，想不到現在 QPainter 也能如法炮製。 好像大部分 Widget 都能用這個方式截圖，不過 OpenGL 不知道可不可行。 fileName, sub = QFileDialog.getSaveFileName(self, 'Save file...', '../', 'PNG file(*.png)') if fileName: fileName = fileName.replace(\".png\", \"\") fileName += \".png\" pixmap = self.mplWindow.grab() pixmap.save(fileName) 模擬功能 主要關鍵都在 Drive Shaft （驅動軸）的清單上，太多驅動軸就會有很多組解，可能要慢慢代入；活塞部份還沒想到怎做。 期望模擬的部份有如下效果： 畫出機構運動時指定點（可複數）路徑，路徑可以用線條或打點的方式繪出。 相關動畫的展示。 使用者觀看自訂角度（滑鼠在圖面上拖拉最佳）。 測量工具（指定點距離）。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050903.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/02","text":"改換 Qt 5.7 與 PyQt 5.7 一些操作重點 Qt 5.3 -> 5.7 Qt 5.8 預計今年11月29日釋出穩定版 一些繪圖功能需要較高的 Qt 版本才支援，所以選擇升級了當前的函式庫。 將需要的 Qt 版本載下來，不須舊版的話可以刪掉。 要切換 Qt 的版本，必須修改之前的 .bashrc 的目錄至切換的版本，並重新建立 QMake 的軟連結，這樣就可以了（對 C++ 的使用者來說）。 $sudo rm -f /usr/bin/qmake $sudo ln -s /opt/Qt/5.7/gcc_64/bin/qmake /usr/bin/qmake 但是對其他語言的使用者來說，必須將接口套件的設定一起切換版本，所以得重新安裝 Python 的 PyQt（亦或 PySide）。 使用下列指令刪除 PyQt： $sudo rm -r -f /usr/lib/python3/dist-packages/PyQt5 然後從 官方載點 下載 Linux 版本。 照著之前的範例重新安裝 PyQt、QScintilla2、Eric6，並修改 Eric6 的相關設定。 裝完後，若 Eric 安裝時出現版本過低的狀況，就必須完全刪除 PyQt 再重新安裝。 若是出現缺少一些套件的狀況，請使用 apt-get 下載安裝，相關名稱如下網站所示。 http://packages.ubuntu.com/search?keywords=python3-pyqt5 安裝後檢查 即使安裝完成，都能啟動或匯入相關套件，因為是重新安裝，還是得檢查一下是否載到舊版的檔案。 在 Python3 的直譯器中檢查： >>>from PyQt5.QtCore import qVersion >>>print(\"Qt Version: {0}\".format(qVersion.strip())) #顯示 Qt 版本 >>>from PyQt5.QtCore import PYQT_VERSION_STR as pyqtVersion >>>print(\"PyQt Version:\", pyqtVersion.strip()) #顯示 PyQt 版本 在 Eric6 的 Settings -> Show extermal tools 選項中，載入所有相關的工具版本。 下圖中的 Qt 工具版本均要一致，選擇的部份是 PyQt，非常重要，因為和 Python 中顯示的版本是一樣的。 另一個就是觀察 Qt 附的相關工具，不過只要載對版本應該都是對的，僅供參考。 新版的 Qt 工具也會支援新功能。 稍微看過上次範例倉儲的程式碼，QPainter 是可以和 QOpenGL 的元件組合使用的，不過如果直接插入空的圖形化元件，會造成程式視窗內黑屏，應該要另外設定。 新版的 Qt 支援 OpenGL3D 的嵌入，會找一些範例，作到和之前 bokeh 套件相仿的功能，再把其他運算功能補齊（或許之後會做銜接其他 CAD 軟體的格式），本機解題+繪圖專案就完成了。 專題在 Python Solvespace 的部份在想要如何結構化，因為尚未圖形化的編譯部份比較難呈現，如果將現成的程式理論搬上報告又有點太「資訊系」和發散了些。 預計報告中會包含一部分原版 Solvespace 的解說，還有 SWIG 相關的原始碼呈現。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050902.html"},{"tags":"Misc","title":"yen - Anaconda on Windows 10","text":"在 Windows 10 中的 Anaconda 使用 Python 3.5.2 以及 Pelican, 測試將 .md 檔案轉為 html. 目前所使用的 Python 3.5.2 與 Leo Editor 5.4-devel 配合 Pelican, 以舊有的倉儲架構進行測試. 首先, 因為 Anaconda 中的 Python 沒有 Pelican 模組, 因此利用 conda install pelican 進行安裝 沒有成功, 改用 conda install -c conda-forge pelican=3.6.3 進行安裝 完成後利用按鈕建立 Pelican 網誌. 系統抱怨 no module named markdown, 而且 Pelican 模組沒有 liquid_tags_notebook 先用 conda install markdown 安裝 markdown 模組, 再來處理 Pelican liquid_tags plugin. 安裝 markdown 之後, 發現專案中已經有 liquid_tag plugin, 因此直接利用按鈕, 先在近端產生 html, 沒有問題. 接著利用遠端按鈕產生 html 後將 gh-pages 分支資料提交推送回倉儲.","url":"http://project.mde.tw/blog/yen-anaconda-on-windows-10.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/09/01","text":"Pyslvs 編譯進度 一些 QPainter 及 OpenGL 的資料連結 Pyslvs 界面 今天花時間在整修細節的部份（包括讀寫檔和繪圖時機），所以只有暫時將 matplotlib 的畫布隱藏到參數 -mpl 裡。 想要用 matplotlib 繪圖時要加上上述參數，不然只會使用 QPainter 的 Widget。 不過這個地方還沒做好，還沒研究 QPainter 上的細節。 另外將 crank_rocker 範例存成 Pyslvs 可用的 CSV 表格，可以隨時讀進來 Demo。 至於繪圖時機，採用的是 resizeEvent，當偵測到 Widget 大小改變時會觸發。 原先想使用 paintEvent，但是不知道為何改用在主視窗後就會一直重新整理，很吃資源，所以只好改用相近的 resizeEvent。 QPainter 及 OpenGL 參考資料 官方 Qt 文件： http://doc.qt.io/qt-5/qpainter.html OpenGL 範例： https://github.com/baoboa/pyqt5/tree/master/examples/opengl 還沒深入看過介紹，只看過一些簡單的 QPainter 範例。 另外 PyQt5 的 QOpenGLWidget 要另外安裝： $sudo apt-get install python3-pyqt5.qtopengl $sudo apt-get install libqt5opengl5 不過安裝套件一直有麻煩，已經是最新版可是 import 還是找不到，在想是不是安裝位置問題。 網際應用程式方面只查到 PHP 與 OpenGL 整合的範例，Qt 的部份貌似只能在本機端執行。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050901.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/31","text":"Pyslvs 編譯進度 - 繪圖功能 倉儲 python-solvespace 已更新 畫布嵌入 成功嵌入畫布，使用另一個繼承自 matplotlib . backends . backend_qt5agg . FigureCanvasQTAgg （更名為 FigureCanvas ）的 class 函式 DynamicMplCanvas 來繪製點座標。 這個 class 只包含三個功能，初始化圖形、清除畫布、更新畫布。 而在主視窗的 __init__ 中初始在預設的 Layout 中嵌入一個 Widget（名稱為「mplWindow」），複製 DynamicMplCanvas() 的格式來用。 當初 DynamicMplCanvas() 是參考自網站範例： http://matplotlib.org/examples/user_interfaces/embedding_in_qt4.html 後來改寫成可以匯入表格代參數的功能。 目前畫布只有支援繪製節點、連桿和呆鍊，以下是繪製未約束的呆鍊。 而另外也修正一些程式庫帶入重疊點的問題，會自動增加偏移量。 表格在畫布重新繪製時也會作修改，重新繪製的功能目前是 手動的 ，所以還待改進。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050831.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/30","text":"Pyslvs 編譯進度 倉儲 python-solvespace 已更新 Pyslvs 界面 寫了算點程式（ calculation.py ）的雛型，目前只 print 出來結果，還沒直接寫進表格。 而以後模擬的路徑座標功能會寫在同個檔案裡。 由於 Python 在記憶體中的物件名稱不能撞名，所以如果是用 launch 腳本來帶動整個程式執行的話，若其中有部件互相 import ，會造成暫存檔重疊而無法載入，這種方法只適用啟動一端的腳本。 所以在 class 中寫了一條指令 Reload_Canvas ，讓它將表格物件代入 calculation.py 的 table_process 中，回傳點座標的 list 回來。 Reload_Canvas 打算也會有判斷 Solve 成功或失敗的功能，會跳出警告，亦不會覆寫到原本的表格上。 程式碼大約的樣子： 執行結果（加入 Point2 後回傳第三組點座標）： 目前加入 Link 的表單，約束距離的功能正常。 不過碰到無法對重合點作距離約束的情況，可能要提前作座標修正（增加間隙）。 Reload_Canvas 函式應當是在表格增刪或是編輯後執行，不過如果顯示失敗的話相當麻煩，可能之後會做1步復原功能之類的。 而繪圖功能比較沒那麼繁瑣，會拖比較後面。 隔天要回虎尾搬遷宿舍，所以能利用時間較少，預計下午後做好 table_process 整體功能，包括座標修正的判斷。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050830.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/29","text":"Pyslvs 編譯進度 SQLite 資料 Pyslvs 界面 新增一個類似活塞／彈簧的連結器，可以自訂最大和最小拉伸長度。 造型方面應該只會改線段顏色。 不過不知道程式方面怎寫，因為程式庫中沒有類似約束，可能要寫在外部，帶入最大值／最小值／範圍內（不須約束）的結果。 至於彈簧的彈性效果可能作不太出來，所以目前是朝活塞桿設計。 SQLite 資料庫 上網找了一些有關寫入寫出 Data Base 的範例，主要是 Python 官方的解說。 https://docs.python.org/3.4/library/sqlite3.html http://www.runoob.com/sqlite/sqlite-python.html 不過主要還是研究 peewee 套件的功能。 http://docs.peewee-orm.com/en/latest/peewee/quickstart.html peewee 的用法比較直覺化一些，畢竟不用對 C++ 資料庫下指令。 不過上網找了一下 FreeCAD 的技術文件，沒有提到關於 Data Base 如何匯入 2D 圖形的解說，只有模擬材料表的格式。 http://www.freecadweb.org/wiki/index.php?title=Material","url":"http://project.mde.tw/blog/40323230ri-zhi-1050829.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/28","text":"Pyslvs 編譯進度 測試程式庫能否支援 Python 的 list 型態 Pyslvs 界面 旋轉軸及滑塊清單 和點、連桿、呆鍊一樣都有增刪功能，不過還沒支援右鍵選單。 一些細節也可能還沒做好，需要一些時間修正。 CSV 匯出入功能調整 現在可以支援匯出整個工作簿存檔，並能完整載入所有表格。 意味著可以保留工作階段而不會遺失。 在每個表格間插入的是 Next_table 這個欄位來辨識。 算點程式測試 打算使用 Python 的 list 來存 SLVS 程式庫的 Point 或 Line ，對迴圈的相性比較好。 所以建立了一個清單物件 draw ，來測試看看能不能存入後提出來給約束函式用。 結果是可行的。 上面測試寫法有點累贅，應該直接用 draw += [Point] 加入清單就可以了。 這樣支援迴圈讀取就十分不錯了，只是在 import 的部份還需要另外測試。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050828.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/27","text":"Pyslvs 編譯進度 Linkage 的參考心得 運動約束類型 打算使用主動旋轉軸和滑塊用在繪製動態圖或是移動路徑上。 旋轉軸可以在定義的角度範圍中旋轉，滑塊則是一個被約束在直線上的點（至於滑動範圍不知道程式庫是否能辦得到）。 在模擬選項中可以調整： 靜態移動 - 所有旋轉軸待在某個角度時，整體機構的外觀狀態。 移動路徑 - 指定一點位置，轉動所有旋轉軸（或自訂），畫出移動路徑。 目前旋轉軸和滑塊的新增方式都和其他實體一樣。 字型大小 系統會因為字型大小的問題而跑出外框，只能調整多一點的空間給太大的字。 Linkage 參考了技術手冊的介紹和使用說明，Linkage 有一些滿複雜的功能，也支援彈簧計算之類的。 應該能夠在 Pyslvs 中加入一些值得使用的優點，不過實作性要先評估。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050827.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/26","text":"Pyslvs 編譯進度 一些後續寫法想法 圖層統整 重新編排了圖層，以在縮放視窗時還能對齊調整大小，不過空間判定上還需要調整參數，才能達到理想的結果。 另外有研究下 PyQt 嵌入 matpoltlib 繪圖的資料，大約知道該如何嵌入繪出的結果了。 右鍵選單 嘗試寫了表格的右鍵選單，功能等同於叫出新增、刪除和編輯的對話方塊。 不過位置無法置中，參數可能還要看一下。 從屬項目刪除 刪除點時會將包含這個點的連桿或呆鍊一起刪除。 程式結構 之後大約會將 import 程式庫的程式碼放在 main.py 同層的資料夾下，互相載入。 而 main.py 中會有一個專門的 def 放在主視窗的 class 外，好讓算點的程式可以讀表格的資料。 以下是原始碼結構，括弧中還待建構。 Pyslvs launch_pyslvs.py（啟動檔） icons_rc.py（圖示資源） +icons（讀取用圖示） +core main.py（主程式-待加入） （算點程式.py） slvs.py _slvs.so libslvs.so +draw（繪圖表管理視窗-已完成） +info（提示與說明視窗-待加入） +warning（警告視窗-待加入） +（模擬表管理視窗） +（一些給使用者的設定檔） 今天由於花了些時間更新 Ubuntu 版的顯示卡驅動，所以拖了一些時間。 之後會快點將核心的算點功能做好。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050826.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/24","text":"Pyslvs 編譯進度 倉儲 python-solvespace 已更新 Pyslvs 界面 新增了管理物件（點、連線、呆鍊）的功能。 刪除物件 在選單中選取名稱即可刪除。 不過還沒為刪除點的連帶影響作調整。 編輯物件 可以重新複寫物件的狀態而不用刪除。 包括重新調整點的位置和固定狀態。 點外觀 紀錄點的外觀，包括用環圈起來，並能讓使用者直接調整其大小和顏色。 CSV匯入功能 後來有把匯出功能調整一下，可以用 Fixed 和 noFixed 紀錄點的固定狀態了。 所以在讀值時，可以將每列的物件精準填入點的列表中。 因為要讓其他 .py 檔讀值，又要回傳回 main.py 中，想要可以浮動創造 Point 並新增約束的功能，所以在思考執行的可行性。 有嘗試過兩個檔案互相 import ，不過出錯的機率很大，上網尋找的建議是 import 兩邊的檔名就好，需要該物件才會特別指定。 也就是說直接指定 def 或 class 就會出錯，之後會試試看。 想要找一個比較保險的方式計算，不然只能盡量避開會衝突的地方。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050824.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/23","text":"Pyslvs 編譯進度 倉儲 python-solvespace 已更新 Pyslvs 界面 Pyslvs 的界面大致上完成，表單的增加功能都寫好了。 主界面 右側打算作為繪圖區，只要左邊表單有更動就會更新。 增加線條選單 讀取既有兩點來規定距離，若為重複點或是點的數目不足就會警告。 增加呆鍊選單 只能新增三角形呆鍊，不過以解連桿的工具而言，三角形呆鍊已經夠實用。 同樣會在違反規則時警告。 匯出CSV能力 成功撰寫將點座標匯出成CSV的功能。 在其他工作表軟體的匯入畫面。 以後會在動態模擬那裡針對點座標作相同的功能。 大部分的功能由於都沒接觸過，每換一種元件都要上網搜尋它們取值、設值的用法，Qt 的相關介紹又都是以 C++ 撰寫的，為此研究了一下 Python 物件導向的說明。 由於再過 2 天就要回去家裡了，所以會盡量將需要整合的工作完成，回去後仍會繼續整理資料。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050823.html"},{"tags":"2016g1","title":"40323143 -  機械腳構想","text":"","url":"http://project.mde.tw/blog/40323143-ji-jie-jiao-gou-xiang.html"},{"tags":"2016g1","title":"QT GUI","text":"change the the way to control the arm 今天使用了QT做了介面，接下來會用點座標，將實體所走出去的曲線，再程式裡面也可以畫出相同的曲線，也可以同時把Vrep裡面的模擬出來的曲線，一起畫出來，以此驗證我下的點是正確的曲線，接下來會做新的一頁，畫方程式曲線圖，左邊會變成輸入方程式，右邊就會生成他的圖形。 2Axis 3Axis","url":"http://project.mde.tw/blog/qt-gui.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/21","text":"Pyslvs 編譯進度 Leo editor 輸入法問題 Pyslvs 界面 目前編譯的圖形化界面使用常見的功能表做命令設定。 不過只有外表，實際功能還需要連結。 目前只有控制視窗縮放，結束執行，連結說明網頁的功能。 Leo Editor 自從安裝過新版的 Qt 5.3 和 5.7 後 Leo Editor 就怪怪的，無法切換英文以外的輸入法，啟動時 Leo Editor 是使用 5.3 版。 而使用 Python 2 啟動是使用 Qt 4，所以沒這個問題，但是就無法使用 Pelican。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050821.html"},{"tags":"2016g1","title":"Vrep machine arm","text":"change the the way to control the arm I use the Inverse equation to compute the machine arm need to turn angle of rotation. After we use is to give the angel to control the arm, we can give the (x,y,z)point to control rotate correct angle and catch the bottle. And we will to develope the auto control by use OpenCv to judge when will to catch the printer components. Today had install the PyQt5, we will study the QT tutorial, and develope beautiful interface to control our machine. Vrep in Linux version need to makefile by youself, it have in remoteAPI in the folder, I can control Vrep in my ubuntu computer. The code have update on my Vrep_python3_control repository/mixer_test https://github.com/smpss91341/Vrep_python3_control","url":"http://project.mde.tw/blog/vrep-machine-arm.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/20","text":"安裝 eric 6 成功 圖形介面計畫：Pyslvs Eric 6 透過一些安裝教學的資料，成功將 Eric 6.1.8 安裝於 Ubuntu 上。 http://blog.csdn.net/idber/article/details/40076821 不過由於安裝位置及主程式運作的關係，執行時必須給予 Root 權限。 $sudo eric6 若是沒給予權限，會造成 Eric 顯示一系列錯誤後關閉。 而透過 Eric 建立的目錄，會被轉為 Root 的所有權，所以必須改回給其他使用者使用。 $sudo chmod -c 777 目錄名稱 mode of ‘目錄名稱' changed from 0755 (rwxr-xr-x) to 0777 (rwxrwxrwx) 目前還在摸索 Qt 相關的教學，發現有許多自訂功能，包括圖示界面和呼叫傳輸之類，稍作了解應該就能達成相關效果。 Eric 的語言問題在於外部程式（Qt 設計師之類的），會偵測系統語言作變更，但是主程式卻不會如此，所以本體改成英文後，附屬的程式仍然是繁體中文。 Pyslvs 將圖形化包裝的 Python Solvespace 程式暫定名為 Pyslvs，如果覺得定名不妥就之後再變更。 當界面有基本雛型之後會上傳至倉儲，之後會陸續更新表單按鈕的功能連結。 Pyslvs 目前在 Ubuntu 系統上開發，因為 Ubuntu 目前好像沒有一個如 Linkage 之類的模擬程式，使用 LibreCAD 或是 FreeCAD 又會太佔資源，所以想做這個工具給 Ubuntu 系統用。 剛開始評估的困難點可能是如何呈現 2D 圖形在 Qt 界面上吧。其他如輸出成程式碼之類的應該用普通的 .py 程式就能辦到了。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050820.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/19","text":"紀錄 GCC 和 CMake 在 Ubuntu 上安裝的方式 紀錄 Ubuntu 網誌編譯環境 前言 為推廣學員使用 Ubuntu 作業系統，紀錄一些安裝軟體的方式。 紀錄如何建構 Ubuntu (ezgo) 的作業環境。 官方版本的 Ubuntu 更新較快，已經到了 16.04 ，教育部的 ezgo 使用 Ubuntu 14.04，使用上較多推薦工具，不用再自己尋找，不過也會安裝一些可能不會用到的套件。 目前使用感想是 ezgo 的 KDE 界面還滿方便的，終端機能提供比 Windows 更多的功能，而且硬體支援度非常良好，即使使用非官方驅動程式，運作甚至會比任何版本的 Windows 更加流暢。 GNU 工具 完整版的 ezgo 預設沒有安裝 g++，使用精簡版的 Ubuntu 亦必須自己安裝這兩套編譯工具。 使用下列指令安裝 GCC。 $sudo apt-get install gcc $sudo apt-get install g++ 使用下列指令安裝 CMake，不過由於提供者版本的問題，可以稍候安裝。 $sudo apt-get install cmake 在沒使用其他提供者的情況下，gcc 的最新版本只會到 4.9 ，所以想安裝 gcc 5.0 以上的版本，必須加入信任來源。 同樣地，在沒使用其他提供者的情況下，CMake 的最新版本無法到 3.x ，也要另一個信任來源。 加入信任來源後，使用 apt-get update 指令或是圖形界面的 Ubuntu 管理中心時，就會將你的提供者也加入搜尋。 $sudo add-apt-repository ppa:ubuntu-toolchain-r/test #gcc 的提供者 $sudo add-apt-repository ppa:george-edison55/cmake-3.x #cmake 的提供者 $sudo apt-get update $sudo apt-get install gcc-5 $sudo apt-get install g++-5 $sudo apt-get install cmake 這時只能使用 gcc-5 指令啟動 gcc 5.x，使用一般的 gcc 指令只會啟動最新的 4.x 的版本。 因此必須將指令連結過去。 $alias gcc='gcc-5' $alias g++='g++-5' 下圖是完成畫面，用 gcc --version 指令來檢查編譯器的版本（g++ 的版本應該也會相同）。 附註：想移除提供者也很簡單，只要加上 --remove 參數就行。 $sudo add-apt-repository --remove ppa:提供者來源 Leo Editor 注意：Leo Editor 在 Python 3.5 中的 Pelican 會產生錯誤，所以請使用 Python 3.4 以下的 Python3 版本。 使用下列指令從官方倉儲下載 Leo Editor。 $cd \"安裝位置\" $git clone https://github.com/leo-editor/leo-editor.git 直接使用下列指令啟動 Leo Editor。 啟動後如果關閉這個終端機，將會結束 Leo Editor，請注意是否有存檔。 $cd \"安裝位置\"/leo-editor $python3 launchLeo.py 寫網誌的必要週邊模組： $sudo pip3 install pelican -U $sudo pip3 install markdown -U $sudo pip3 install bs4 -U 圖中是 Leo 5.3 的版本。 未來若有必要軟體的特殊安裝方式，會更新在此。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050819.html"},{"tags":"2016g1","title":"PyQt5 install","text":"install Question 問題： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 作法：http://blog.csdn.net/idber/article/details/40076821 安裝PyQt的圖形化介面的問題 再安裝eric6 的介面時發生的問題 所有工具都裝好了 包括 1.QT 2.PyQt5 3. QScintilla2 就只剩eric6這個圖形化介面裝不進去了 Error: Sorry, please install QScintilla2 and its PyQt5/PyQt4 wrapper. Error: /opt/Qt/5.3/gcc_64/lib/libQt5Gui.so.5: undefined symbol: z_deflateReset","url":"http://project.mde.tw/blog/pyqt5-install.html"},{"tags":"2016g1","title":"Vrep Bug in Linux","text":"無法執行windows的動態連結庫，remoteAPI.dll Vrep haved install in Ubuntu and when we want to use our project control panel,because the RemoteAPI.dll isn't match with the Linux system, so how can we do for the remoteAPI.dll. And why I use the English to write the blog,because my Ubuntu chinese input program didn't work on leo-editor, it can use everywhere but can't use in leo.","url":"http://project.mde.tw/blog/vrep-bug-in-linux.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/18","text":"CentOS 的 Python 3.3 版本 glibc 版本問題 GLIBC 編譯好的 CentOS 版程式庫放入 Openshift 後，回傳了錯誤： libc.so.6: version `GLIBC_2.14' not found 是執行系統的 GLIBC 版本較舊所引起的，最簡單的解決方法是升級執行系統的 GLIBC，但是不知道如何命令 Openshift 的倉儲升級。 用指令檢查了一下虛擬機上的 GLIBC 版本，是 2.17 。 不過 gcc 應該用了 2.14 做編譯，而 Openshift 的版本沒到 2.14 所致。 今天在 python.log 注意到 Openshift 使用的 Python 版本是 3.3.2，所以剛開始懷疑是小版號不合所致，但是並非如此。 從官方的連結下載了 GLIBC 2.14 版： http://ftp.gnu.org/gnu/glibc/ 上網找到的方法大約都是要執行端主機下命令，但是不知道如何對 Openshift 做出要求，所以先在編譯用的虛擬機做調整。 但是不知道如何在同一台電腦上取代或是安裝兩個版本的 GLIBC，而虛擬機的效能還滿不彰的。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050818.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/17","text":"距離約束 Bug 解決 CentOS 的 Python 3.3 版本 倉儲 python-solvespace 已更新 slvs_python.hpp 修改 slvs_python.hpp 標頭檔，讓 value 的值等於 0 時自動轉換成重合約束。 不過點與線的重合約束還沒調整，稍後會做更新。 CentOS 編譯 在 CentOS 上重新編譯 Python 3.3，在執行configure時添加了 --enable-shared 參數，這樣make時會產生可用的共享資料庫 libpython3.3m.so 。 另外還把 Makefile 修正到 Python 3.3 的 include 和共享資料庫的目錄。 執行時會找不到 libpython3.3m.so ，可能是 CentOS 的 Python 3.3 是安裝在自訂的位置，所以環境變數沒對到。 後來想調整，但是虛擬機因為記憶體太少而卡住了，不過 Redhat 的 Python 是原生的，應該是沒問題。 目前還未搬上 Openshift 測試。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050817.html"},{"tags":"2016bg2","title":"SLVS 程式庫函式","text":"slvs 程式庫（ _slvs.pyd 或 _slvs.so ）轉成Python後的內容。 協助Python程式使用指令。 內容待勘誤 08/17 更新-錯誤已解決 快速尋找 簡介 CDemo ｜ 程式庫簡介 使用基礎 實體 點 ｜ 工作平面 ｜ 距離 ｜ 向量法線 線段 ｜ 中心點弧 ｜ 完整圓 ｜ 貝茲曲線 約束 距離 ｜ 線段比值 ｜ 直徑 ｜ 角度 重合 ｜ 相等 ｜ 鎖定位置 ｜ 中點 對稱 ｜ 水平或垂直 ｜ 平行 ｜ 相切 未支援功能 Brief Introduction SLVS 程式庫裡面的名稱結構是使用C語言撰寫，雖然 slvs.py 已經幫忙轉換了裡面的名稱，但是仍有些許函式名稱變化。 所以紀錄一下在Python中如何使用這些功能，預計讓這篇文章達到易使用和易理解的功能。 CDemo SolveSpace 是一款開源的 2D / 3D 電腦輔助設計繪圖軟體，從 2008 年釋出第一個版本，相容於 Windows / Mac / Linux 三個平台。 有著體積小、執行快速、免費，且不用安裝的特性，支援 STEP 或 STL 開啟，或輸出成 DXF 、 PDF 、 SVG 等開放格式，也有自己的文字式格式 *.slvs 。 更新方面，可以在 GitHub 的 官方倉儲 或是 非官方倉儲 中下載最新的原始碼後，直接利用開發者工具（如 GNU）編譯出主程式。 Solvespace 在繪圖程式本身外還附帶一個名為 CDemo 的小執行檔，是利用 Solvespace 的原始碼編譯出來的。 可以利用此外部程式呼叫 Solvespace 的程式庫 libslvs.dll 進行 2D 或是 3D 的解題運算，而無須啟動 Solvespace 。 CDemo 的概念是能夠讓外部程式使用 Solvespace 的功能，無論是利用其解開最大行程、干涉位置，都能讓應用程式免去您需要親自使用 CAD 軟體解題的困擾。 SLVS Library CDemo 為 C 語言編譯而成，使用的 Solvespace 程式庫則是C++編譯的，在運算和使用上固然快速，但活用性較局限。 Python 語言擁有大量自定義模組、易讀的函式，並且在網際執行方面比C語言多一片天，若將 Solvespace 程式庫轉換使用，將會使這些 Python 程式擁有線上解題的能力，在機械設計方面更是方便許多。 在 Python 的連結庫中， *.pyd 和 Windows 中 C 語言的動態載入庫 *.dll 相仿； *.so 則是大部分開放式作業系統（如為人熟知的 Ubuntu）使用的。 *.so 的優點是利於共享資料，執行檔與程式庫分離，更新函式庫更為方便。 Python-Solvespace 的製作概念是利用 SWIG 軟體製作一個 C++ 至 Python 的端口，使任何一個使用 Anaconda 3 (Python 3.5) 的 Python 程式都能夠使用 Solvespace 的函式庫。 當 Solvespace 的函式轉換成 Python 介面時，也希望保持這個語言一貫清爽易懂的名稱，因此特別重新分類了這些指令的名稱及用法。 稱號下方是原始的命令代號，用於程式庫中識別命令的類型。 Starting Draw and Solve 若要使用SLVS程式庫，必須透過 slvs.py 介面來轉換。 在您的Python程式中使用以下指令： #導入slvs.py from slvs import * #導入Solid Python #沒有使用就不需要導入 import solid #創造你的系統，以及支援單位數量 #預設單位數為50 #若是在迴圈中創造系統，將會重新洗掉記錄 sys = System(20) ... 欲執行解題，Python必須使用下列命令： #執行解題 sys.solve() #直接命令 Slvs_Solve(sys, g) #結果回報的值如下 if (sys.result == SLVS_RESULT_OKAY): ... elif (sys.result == SLVS_RESULT_INCONSISTENT): print (\"solve failed\") print (\"SLVS_RESULT_INCONSISTENT\") print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE): print (\"solve failed\") print (\"SLVS_RESULT_DIDNT_CONVERGE\") print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS): print (\"solve failed\") print (\"SLVS_RESULT_TOO_MANY_UNKNOWNS\") print (\"%d DOF\" % sys.dof) 在執行解題程式後，會出現三種結果： 所有約束都能滿足，會回傳 SLVS_RESULT_OKAY ，這時就能檢查您的約束結果，沒有完全約束的項目會被移動至滿足條件的範圍中，不過可能會不符合您的期待。 解題程式證明約束條件互相牴觸，會傳回 SLVS_RESULT_INCONSISTENT 。 解題程式證明約束條件沒有互相牴觸，但定義了一些重複的約束，會傳回 SLVS_RESULT_DIDNT_CONVERGE 。 最後能調用以下值來檢查結果。 #實體結果 #格式為高精度浮點數 sys.get_param(0).val 而過於嚴重的錯誤會回傳 SLVS_RESULT_TOO_MANY_UNKNOWNS ，必須檢查您的 Python 程式庫或是 SLVS 函式庫是否損壞。 Types of Entities SLVS_E 實體的類型，屬於物件的部分，Entity中還有一些子分類。 Point 此物件屬於點。 LineSegment 此物件屬於線段。 Circular 此物件屬於圓弧。 沒有標籤的項目屬於 Entity 旗下的物件。 根據這些關係，在約束時必須判斷其分類以填入。 輸入值後方加入 , sys ，以傳入系統清單 sys 中（也許有 sys2 或 sys3 等等）；亦可用 sys.add_ 加入以下支援的實體，而取出的編號取決於註冊的順序。 1 2 3 4 add_param( ) add_point2d( ) add_point3d( ) add_entity( ) 取出時亦同（函數中加上編號就能指定）： 1 2 3 4 5 6 7 8 9 10 get_Point2d( ) get_Point3d( ) get_LineSegment2d( ) get_LineSegment3d( ) get_Normal3d( ) get_Distance( ) get_Workplane( ) get_Cubic( ) get_Circle( ) get_ArcOfCircle( ) Point SLVS_E_POINT_IN_3D Entity / Point / Point3d 使用指令： Point3d(Param x, Param y, Param z) 代表空間中的點。 SLVS_E_POINT_IN_2D Entity / Point / Point2d 使用指令： Point2d(Workplane workplane, Param u, Param v) 代表工作平面上的點。 Normal SLVS_E_NORMAL_IN_3D Entity / Normal3d 使用指令： Normal3d(Param qw, Param qx, Param qy, Param qz) 代表空間中的一條法線。 SLVS_E_NORMAL_IN_2D Entity / Normal3d / Normal2d 使用指令： Normal3d(Workplane wrkpl) 代表垂直工作平面的一條法線。 在SolveSpace中，法線是由一個3x3的旋轉矩陣從基本的坐標系到一個新的架構，是由單位四元數定義的。 可以想像這個四元數代表一個通過原點的平面。 這個平面跟三個向量相關：基礎向量 U 和 V 在平面上、而法線 N 則垂直它，相當於 [ U V N ]' 。 因此U、N、N都有單位長度，而他們都正交，所以： 1 2 3 U cross V = N V cross N = U N cross U = V 轉換函式 Slvs_Quaternion 提供了在 U 、 V 、 N 和單位四元數之間轉換。 單位四元數只有三個自由度，但是要在四個參數中指定。因此一個額外的約束產生了，就是： w&#94;2 + x&#94;2 + y&#94;2 + z&#94;2 = 1 Make a Quaternion for a Work Plane Tips 要定義一個由 U[1 0 0] 向量（等同X軸）和 V[0 1 0] 向量（等同Y軸）組成的平面，是需要一條3D法線的。 若是不會計算四元數，可以利用下列函式達成： #函式轉換四元數 qw, qx, qy, qz = MakeQuaternion(1, 0, 0, 0, 1, 0) #帶入3D法線的函式中 normal = Normal3d(Param(qw), Param(qx), Param(qy), Param(qz), sys) #做成工作平面 c = Point3d(Param(0.0), Param(0.0), Param(0.0)) plane = Workplane(c, normal) 這個公式在製作2D平面時非常方便。 以下是不同平面參考： 1 2 3 4 5 6 7 8 XY平面：[1 0 0], [0 1 0] MakeQuaternion(1, 0, 0, 0, 1, 0) YZ平面：[0 1 0], [0 0 1] MakeQuaternion(0, 1, 0, 0, 0, 1) XZ平面：[1 0 0], [0 0 1] MakeQuaternion(1, 0, 0, 0, 0, 1) Distance SLVS_E_DISTANCE Entity / Distance 使用指令： Distance(Workplane wrkpl, Param distance) 代表與工作平面平行的距離。 Work Plane Entity / Workplane SLVS_E_WORKPLANE 使用指令： Workplane(Point3d origin, Normal3d normal) 代表通過原點，與法線垂直的工作平面。 Line Segment SLVS_E_LINE_SEGMENT Entity / LineSegment / LineSegment3d 3D 使用指令： LineSegment3d(Point3d a, Point3d b) Entity / LineSegment / LineSegment2d 2D 使用指令： LineSegment2d(Workplane wrkpl, Point2d a, Point2d b) 在兩個 Point2d/3d 之間繪出直線條。 代表兩個點之間的連線。 Cubic SLVS_E_CUBIC Entity / Cubic 3D 使用指令： Cubic(Point3d pt0, Point3d pt1, Point3d pt2, Point3d pt3) 2D 使用指令： Cubic(Workplane wrkpl, Point2d pt0, Point2d pt1, Point2d pt2, Point2d pt3) 四個點構成的貝茲曲線，無論是用2D還是3D建構，都會視為3D物件。 四個點的公式如下： 公式（t從0積分到1） p(t) = P0*(1 - t)&#94;3 + 3*P1*(1 - t)&#94;2*t + 3*P2*(1 - t)*t&#94;2 + P3*t&#94;3 Circle Entity / Circular / Circle SLVS_E_CIRCLE 使用指令： Circle(Workplane wrkpl, Normal3d normal, Point2d center, Distance radius) 與一條 Normal3d 法線垂直，與一個 Workplane 平面平行，由 Point2d 圓心和 Distance 半徑構成的完整圓。 這個圓無法使用相切約束，除非給定切點，並使圓心距離永遠和切線保持半徑長度。 Arc of Circle SLVS_E_ARC_OF_CIRCLE Circular / ArcOfCircle 使用指令： ArcOfCircle(Workplane wrkpl, Normal3d normal, Point2d center, Point2d start, Point2d end) 與一條 Normal3d 法線垂直，與一個 Workplane 平面平行，由 Point2d 圓心和兩個 Point2d 點構成的三點弧。 Types of Constrains SLVS_C 約束的類型，大部分的指令都會自動判斷狀況。 3D 此種約束只能用在3D或投影到平面上。 2D 此種約束只能用在平面上。 Val 此種約束必須設定額外的參考值。 輸入值最後端加入群組編號可以規定群組（預設值 Slvs_hGroup group = USE_DEFAULT_GROUP ）。 約束的直接命令（必須在空白項目中填入 0 ）： Slvs_MakeConstraint(h, group, type, wrkpl, valA, ptA, ptB, entityA, entityB, entityC, entityD, other, other2) Distance Val SLVS_C_PT_PT_DISTANCE 3D 使用指令： Constraint.distance(double value, Point3d p1, Point3d p2) 2D 使用指令： Constraint.distance(double value, Workplane wrkpl, Point p1, Point p2) 約束兩個 Point2d/3d 的距離。 SLVS_C_PROJ_PT_DISTANCE 3D 使用指令： Constraint.distance_proj(double value, Point3d p1, Point3d p2, Workplane wrkpl) 約束兩個 Point3d 的投影到 Workplane 的距離。 SLVS_C_PT_PLANE_DISTANCE 3D 使用指令： Constraint.distance(double value, Workplane wrkpl, Point3d p) 從一個 Point3d 到一個 Workplane 的距離。 距離值的正負會規定點在平面之上或之下。 SLVS_C_PT_LINE_DISTANCE 3D 使用指令： Constraint.distance(double value, Point3d p, LineSegment3d line) 2D 使用指令： Constraint.distance(double value, Workplane wrkpl, Point p, LineSegment2d line) 從一個 Point2d/3d 到一條 LineSegment2d/3d 的距離。 距離值的正負會規定點在線段之上或之下。 On SLVS_C_POINTS_COINCIDENT 3D 使用指令： Constraint.on(Point3d p1, Point3d p2) 2D 使用指令： Constraint.on(Workplane wrkpl, Point p1, Point p2) 兩個 Point2d/3d 的座標相等。 SLVS_C_PT_IN_PLANE 3D 使用指令： Constraint.on(Workplane wrkpl, Point3d p) 一個 Point3d 會被固定在一個 Workplane 上。 SLVS_C_PT_ON_LINE 3D 使用指令： Constraint.on(Point3d p, LineSegment3d line) 2D 使用指令： Constraint.on(Workplane wrkpl, Point p, LineSegment2d line) 一個 Point2d/3d 會被固定在一條 LineSegment2d/3d 上。 注意此約束會在2D時移除一個自由度；而在3D空間時變成兩個。 SLVS_C_PT_ON_CIRCLE 2D 使用指令： Constraint.on(Workplane wrkpl, Point p, Circle circle) 一個 Point2d 會被固定在一個 Circle 上。 Equal SLVS_C_EQUAL_LENGTH_LINES 2D 使用指令： Constraint.equal(Workplane wrkpl, LineSegment2d line1, LineSegment2d line line2) 兩條 LineSegment2d 的長度等長。 SLVS_C_EQ_LEN_PT_LINE_D 2D 使用指令： Constraint.equal(Workplane wrkpl, Point2d p, LineSegment2d line1, LineSegment2d line line2) 第一條 LineSegment2d 長度等於一個 Point2d 到第二條 LineSegment2d 的距離。 SLVS_C_EQ_PT_LN_DISTANCES 2D 使用指令： Constraint.equal_point_line(Workplane wrkpl, Point2d p1, Point2d p2, LineSegment2d line1, LineSegment2d line2) 第一個 Point2d 到第一條 LineSegment2d 的距離等於第二個 Point2d 到第二條 LineSegment2d 的距離。 SLVS_C_EQUAL_ANGLE 2D 使用指令： Constraint.equal_angle(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2, LineSegment2d line3, LineSegment2d line4) 第一條 LineSegment2d 和第二條 LineSegment2d 的夾角等於第三條 LineSegment2d 和第四條 LineSegment2d 的夾角。 SLVS_C_EQUAL_LINE_ARC_LEN 2D 使用指令： Constraint.equal(Workplane wrkpl, LineSegment2d line, Circular c) 一條 LineSegment2d 線段長度和另一段 Circular 長度相等。 SLVS_C_EQUAL_RADIUS 3D 使用指令： Constraint.equal_radius(Workplane wrkpl, Circular c1, Circular c2) 兩條 Circular 的半徑相等。 SLVS_C_SAME_ORIENTATION 3D 使用指令： Constraint.orientation(Normal3d nrml1, Normal3d nrml2) 兩條 Normal3d 法線的方向相等。 Ratio of Length Val SLVS_C_LENGTH_RATIO 2D 使用指令： Constraint.ratio(double value, Workplane wrkpl, LineSegment2d line1, LineSegment2d line2) 第一條 LineSegment2d 長度對上第二條 LineSegment2d 長度的比值。 Symmetric SLVS_C_SYMMETRIC 3D 使用指令： Constraint.symmetric(Workplane wrkpl, Point3d p1, Point3d p2) 2D 使用指令： Constraint.symmetric(Workplane wrkpl, Point2d p1, Point2d p2) 第一個 Point2d/3d 會和第二個 Point2d/3d 對稱於一個工作平面。 意味著兩個點到平面的距離都相等，而兩點的連線可以做為平面的法線。 SLVS_C_SYMMETRIC_HORIZ 2D 使用指令： Constraint.symmetric_H(Workplane wrkpl, Point2d p1, Point2d p2) 兩個 Point2d 會鎖定在相同的水平座標。 SLVS_C_SYMMETRIC_VERT 2D 使用指令： Constraint.symmetric_V(Workplane wrkpl, Point2d p1, Point2d p2) 兩個 Point2d 會鎖定在相同的垂直座標。 SLVS_C_SYMMETRIC_LINE 2D 使用指令： Constraint.symmetric(Workplane wrkpl, Point2d p1, Point2d p2, LineSegment2d line) 規定兩個 Point2d ，對稱 LineSegment2d 。 Middle point SLVS_C_AT_MIDPOINT 3D 使用指令： Constraint.midpoint(Point3d p, LineSegment3d line) 2D 使用指令： Constraint.midpoint(Workplane wrkpl, Point2d p, LineSegment2d line) 讓一個 Point2d/3d 位於一條 LineSegment2d 的中點。 Horizontal & Vertical SLVS_C_HORIZONTAL 2D 使用指令： Constraint.horizontal(Workplane wrkpl, LineSegment2d line) SLVS_C_VERTICAL 2D 使用指令： Constraint.vertical(Workplane wrkpl, LineSegment2d line) 規定一條 LineSegment2d 水平或垂直。 Diameter Val SLVS_C_DIAMETER 2D 使用指令： Constraint.diameter(double diameter, Workplane wrkpl, Circular c) 一段 Circular 的直徑。 Angle Val SLVS_C_ANGLE 2D 使用指令： Constraint.angle(Workplane wrkpl, double value, LineSegment2d line1, LineSegment2d line2, bool other) 兩條 LineSegment2d 的夾角，定義值單位為度。 公式如下（ A 和 B 為兩條線的向量）： (A dot B)/(|A||B|) = cos(valA) 注意這裡的值定義比較不明確，無論正負90度都會是相同的結果。 所以必須使用 other 布林值來判斷正負。 SLVS_C_PERPENDICULAR 2D 使用指令： Constraint.perpendicular(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2, bool other) 源自約束 SLVS_C_ANGLE 。 這個約束是定義角度約束為90度的情況。 Parallel SLVS_C_PARALLEL 3D 使用指令： Constraint.parallel(LineSegment3d line1, LineSegment3d line2) 2D 使用指令： Constraint.parallel(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2) 兩條 LineSegment2d/3d 互相平行。 注意此約束會在投影到一個平面上時移除一個自由度；而在3D空間時變成兩個。 Tangent Val SLVS_C_ARC_LINE_TANGENT 2D 使用指令： Constraint.tangent(ArcOfCircle arc, LineSegment2d line, bool other) 一段 ArcOfCircle 和一條 LineSegment2d 相切。 若布林值是 False ，則圓弧的切點會位於它的起點 s ；反之若為 True ，則會位於它的終點 e 。 SLVS_C_CUBIC_LINE_TANGENT 3D 使用指令： Constraint.tangent(Cubic c, LineSegment3d l, bool other) 一條 Cubic 和一條 LineSegment3d 相切。 若布林值是 False ，則貝茲曲線的切點會位於它的起點 p0 ；反之若為 True ，則會位於它的終點 p3 。 SLVS_C_CURVE_CURVE_TANGENT 3D 使用指令： Constraint.tangent(ArcOfCircle c1, ArcOfCircle c2, bool other, bool other2) Constraint.tangent(Cubic c1, Cubic c2, bool other, bool other2) Constraint.tangent(ArcOfCircle c1, Cubic c2, bool other, bool other2) Constraint.tangent(Cubic c1, ArcOfCircle c2, bool other, bool other2) 兩條曲線的相切組合。 若布林值是 False ，則圓弧的切點會位於它的起點 s ，貝茲曲線的切點會位於它的起點 p0 ；反之若為 True ，則會位於它的終點 e 或 p3 。 Dragged SLVS_C_WHERE_DRAGGED 3D 使用指令： Constraint.dragged(Point3d p) 2D 使用指令： Constraint.dragged(Workplane wrkpl, Point2d p) 永久鎖定這個 Point2d/3d 的座標在目前計算的座標上，再也不會改變。 在2D平面上，會移除兩個自由度；在3D空間中，是三個自由度。 Set Dragged Tips 關於鎖定位置，另一個系統的約束如下： sys.set_dragged(Point p) 是命令約束盡量固定這個 Point2d/3d 點，取而代之的是移動周遭的項目。 這個點被固定後移動量會較小。 Additional Types of Constrains 一些額外的約束條件，目前沒有對應實體項目可用。 Point and Face SLVS_C_PT_FACE_DISTANCE 3D 使用指令： #這個功能尚未建構 Point on Face SLVS_C_PT_ON_FACE 3D 使用指令： #這個功能尚未建構","url":"http://project.mde.tw/blog/slvs-cheng-shi-ku-han-shi.html"},{"tags":"2016bg2","title":"SLVS Library Functions","text":"slvs library（ _slvs.pyd or _slvs.so ）for Python. Retrieve for Python Programing Design. Content to be amended 08/17 Updated Quick Search Brief introduction CDemo ｜ SLVS Library How to start Entities Point ｜ Work Plane ｜ Distance ｜ Normal Line Segment ｜ Arc (have a center) ｜ Circle ｜ Bezier curve Constraints Distance ｜ Ratio of Line Segment ｜ Diameter ｜ Angle Coincide ｜ Equal ｜ Locked position ｜ Middle point Symmetric ｜ Horizontal & Vertical ｜ Parallel ｜ Tangent Functions that not in use Brief Introduction SLVS Library is compose by C language, Although slvs.py was translate to Python interface, but some function names has change. So I record these function, that how to use in Python program. CDemo SolveSpace is an open source 2D / 3D computer-aided design and drafting software, from 2008 released the first version, compatible with Windows / Mac / Linux three platforms. Has a small size, perform fast, free, and no installation features, STEP or STL support open, or exported into DXF, PDF, SVG and other open formats, also has its own text-based format *.slvs . For updating, you can go to GitHub's official storage or unofficial storage to download the latest source code, the direct use of developer tools (such as GNU) compile the main program. Solvespace has another small executable file named CDemo, compiled with source code of Solvespace. You can use this external program call library of Solvespace libslvs.dll be 2D or 3D computing problem-solving, and without startup Solvespace. The concept of CDemo is be able to use an external program to call functions from Solvespace, whether it is using its maximum travel untied, the interference position. You can use this app without need to use CAD software to personally solving problems by you self. SLVS Library CDemo compiled from C language. Solvespace database using the C++ compiler is useful and fast of course, but the utilization of more limited. Python language has a lot of custom modules, easy-reading function, and has another scopes in the Internet than the C language, if Solvespace use database conversion, will make these Python programs have online problem-solving ability, mechanical design in particular it is a lot easier. In Python link library, *.pyd is similar to C language dynamic load library *.dll in Windows; *.so is the most open operating systems (such as Ubuntu) in use. Advantage of *.so is beneficial to share information, perform file and database separation, updated library more convenient. Concept of the production Python-Solvespace is using SWIG to create a C ++ to Python port to make any use of Anaconda 3 (Python 3.5) of Python programs are able to use the library of Solvespace. When Solvespace the function is converted into when Python interface, but also want to keep consistently fresh and understandable names for this language, so I especially reclassified these names and usage instructions. Below the title is original name of the command code, the database using to identify the type of command. Starting Draw and Solve To use SLVS database must be converted through the slvs.py interface. Use the following command in your Python program: #Import \"slvs.py\". from slvs import * #Import Solid Python. #If not using Solid Python, don't need to do this. import solid #Your system, and it's supporting number of params. #Default Units 50 #If your system is in a loop, it's params will be re-clear. sys = System(20) ... For the implementation of problem-solving, Python program must use the following command: #Implementation of problem-solving. sys.solve() #Another command. Slvs_Solve(sys, g) #Return result value as follows. if (sys.result == SLVS_RESULT_OKAY): ... elif (sys.result == SLVS_RESULT_INCONSISTENT): print (\"solve failed\") print (\"SLVS_RESULT_INCONSISTENT\") print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE): print (\"solve failed\") print (\"SLVS_RESULT_DIDNT_CONVERGE\") print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS): print (\"solve failed\") print (\"SLVS_RESULT_TOO_MANY_UNKNOWNS\") print (\"%d DOF\" % sys.dof) After the execution of problem-solving program, there will be three results: All constraints were satisfied to within our numerical tolerance (i.e., success). The result is equal to SLVS_RESULT_OKAY , entities that not fully constrained will be moved to meet the conditions of, but may not meet your expectations. The solver can prove that two constraints are inconsistent (for example, if a line with nonzero length is constrained both horizontal and vertical). The result is equal to SLVS_RESULT_INCONSISTENT . The solver cannot prove that two constraints are inconsistent, but it cannot find a solution. The result is equal to SLVS_RESULT_DIDNT_CONVERGE . Finally, the following function can call to check the results. #Entities result. #Precision floating-point format. sys.get_param(0).val And too serious error will return SLVS_RESULT_TOO_MANY_UNKNOWNS . You must checkout your Python library or SLVS library is damaged or not. Types of Entities SLVS_E Entity type, object parts for problem-solving. Entity has some sub-categories. Point This object belongs to Point. LineSegment This object belongs to Line Segment. Circular This object belongs to Circular. No label items belonging to sub-categories of Entity . According to these relations, in the constraint must determine its classification to fill. When function input \" , sys \" after value, it can record into sys (There maybe exist sys2 or sys3 ). It can also use sys.add_ to input to current system. 1 2 3 4 add_param( ) add_point2d( ) add_point3d( ) add_entity( ) As same as take them out (Add the specified number). 1 2 3 4 5 6 7 8 9 10 get_Point2d( ) get_Point3d( ) get_LineSegment2d( ) get_LineSegment3d( ) get_Normal3d( ) get_Distance( ) get_Workplane( ) get_Cubic( ) get_Circle( ) get_ArcOfCircle( ) Point SLVS_E_POINT_IN_3D Entity / Point / Point3d Use the command: Point3d(Param x, Param y, Param z) Representative of a point in space. SLVS_E_POINT_IN_2D Entity / Point / Point2d Use the command: Point2d(Workplane workplane, Param u, Param v) Representative a point on a work plane. Normal SLVS_E_NORMAL_IN_3D Entity / Normal3d Use the command: Normal3d(Param qw, Param qx, Param qy, Param qz) Representative of a normal in space. SLVS_E_NORMAL_IN_2D Entity / Normal3d / Normal2d Use the command: Normal3d(Workplane wrkpl) Representative of a normal line perpendicular to the work plane. In SolveSpace, \"normals\" represent a 3x3 rotation matrix from our base coordinate system to a new frame. Defined by the unit quaternion w, x, y, z. It is useful to think of this quaternion as representing a plane through the origin. This plane has three associated vectors: basis vectors U, V that lie within the plane, and normal N that is perpendicular to it. This means that 1 [ U V N ]' defines a 3x3 rotation matrix. So U, V, and N all have unit length, and are orthogonal so that 1 2 3 U cross V = N V cross N = U N cross U = V Convenience functions Slvs_Quaternion are provided to convert between this representation as vectors U, V, N and the unit quaternion. A unit quaternion has only 3 degrees of freedom, but is specified in terms of 4 parameters. An extra constraint is therefore generatedimplicitly, that w&#94;2 + x&#94;2 + y&#94;2 + z&#94;2 = 1 Make a Quaternion for a Work Plane Tips To define a plane consisting by the U [1 0 0] vector (equivalent X-axis) and V [0 1 0] vector (equivalent Y axis) need for 3D normals. If you don't know how to calculated quaternion, can be reached using the following functions: #Conversion quaternion qw, qx, qy, qz = MakeQuaternion(1, 0, 0, 0, 1, 0) #Take into the 3D normal function normal = Normal3d(Param(qw), Param(qx), Param(qy), Param(qz), sys) #Make a working plane c = Point3d(Param(0.0), Param(0.0), Param(0.0)) plane = Workplane(c, normal) When creating 2D plane, using this formula is very convenient. The following are the different planes reference: 1 2 3 4 5 6 7 8 XY plane: [1 0 0], [0 1 0] MakeQuaternion(1, 0, 0, 0, 1, 0) YZ plane: [0 1 0], [0 0 1] MakeQuaternion(0, 1, 0, 0, 0, 1) XZ plane: [1 0 0], [0 0 1] MakeQuaternion(1, 0, 0, 0, 0, 1) Distance SLVS_E_DISTANCE Entity / Distance Use the command: Distance(Workplane wrkpl, Param distance) Representative of a distance parallel a work plane. Work Plane Entity / Workplane SLVS_E_WORKPLANE Use the command: Workplane(Point3d origin, Normal3d normal) Representative of a work plane through the origin, perpendicular to a normal. Line Segment SLVS_E_LINE_SEGMENT Entity / LineSegment / LineSegment3d 3D Use the command: LineSegment3d(Point3d a, Point3d b) Entity / LineSegment / LineSegment2d 2D Use the command: LineSegment2d(Workplane wrkpl, Point2d a, Point2d b) Draw a straight line between two Point2d / 3d point. Representative of a connection between two points. Cubic SLVS_E_CUBIC Entity / Cubic 3D Use the command: Cubic(Point3d pt0, Point3d pt1, Point3d pt2, Point3d pt3) 2D Use the command: Cubic(Workplane wrkpl, Point2d pt0, Point2d pt1, Point2d pt2, Point2d pt3) Bezier curve consisting of four points, whether it be 2D or 3D construction, will be treated as 3D objects. Four point formula is as follows: Equation (t from 0 to 1 points) p(t) = P0*(1 - t)&#94;3 + 3*P1*(1 - t)&#94;2*t + 3*P2*(1 - t)*t&#94;2 + P3*t&#94;3 Circle Entity / Circular / Circle SLVS_E_CIRCLE Use the command: Circle(Workplane wrkpl, Normal3d normal, Point2d center, Distance radius) Representative of a circle perpendicular with a Normal3d normal, parallel with a Workplane plane, constitute by a Point2d center and a Distance radius. Arc of Circle SLVS_E_ARC_OF_CIRCLE Circular / ArcOfCircle Use the command: ArcOfCircle(Workplane wrkpl, Normal3d normal, Point2d center, Point2d start, Point2d end) Representative of an arc perpendicular with a Normal3d normal, parallel with a Workplane plane, constitute by a Point2d center, a Point2d start point, and a Point2d endpoint. Types of Constrains SLVS_C Constraints type. Most of the instruction will automatically determine the situation. 3D Such constraints can only be used in 3D or projected onto a plane. 2D Such constraints can only be used in a 2D plane. Val Such constraints must be set additional reference value. Enter the value of the last side to join the group numbers can be specified group (Default Slvs_hGroup group = USE_DEFAULT_GROUP ). Direct command constraint(But you should filled zero in empty entry): Slvs_MakeConstraint(h, group, type, wrkpl, valA, ptA, ptB, entityA, entityB, entityC, entityD, other, other2) Distance Val SLVS_C_PT_PT_DISTANCE 3D Use the command: Constraint.distance(double value, Point3d p1, Point3d p2) 2D Use the command: Constraint.distance(double value, Workplane wrkpl, Point p1, Point p2) Constraints two Point 2d / 3d distance. SLVS_C_PROJ_PT_DISTANCE 3D Use the command: Constraint.distance_proj(double value, Point3d p1, Point3d p2, Workplane wrkpl) Constraints two Point 3d projected to Workplane distance. SLVS_C_PT_PLANE_DISTANCE 3D Use the command: Constraint.distance(double value, Workplane wrkpl, Point3d p) Distance from a Point3d to a Workplane . Positive and negative values will be predetermined distance above or below the plane. SLVS_C_PT_LINE_DISTANCE 3D Use the command: Constraint.distance(double value, Point3d p, LineSegment3d line) 2D Use the command: Constraint.distance(double value, Workplane wrkpl, Point p, LineSegment2d line) Distance from a Point 2d/3d to a LineSegment2d/3d . Positive and negative values will be predetermined distance above or below the line segment. On SLVS_C_POINTS_COINCIDENT 3D Use the command: Constraint.on(Point3d p1, Point3d p2) 2D Use the command: Constraint.on(Workplane wrkpl, Point p1, Point p2) Two Point2d/3d coordinates equal. SLVS_C_PT_IN_PLANE 3D Use the command: Constraint.on(Workplane wrkpl, Point3d p) A Point3d will be fixed on a Workplane . SLVS_C_PT_ON_LINE 3D Use the command: Constraint.on(Point3d p, LineSegment3d line) 2D Use the command: Constraint.on(Workplane wrkpl, Point p, LineSegment2d line) A Point2d/3d will be fixed on a LineSegment2d/3d . Note that this constraint removes one degree of freedom when projected in to the plane, but two degrees of freedom in 3d. SLVS_C_PT_ON_CIRCLE 2D Use the command: Constraint.on(Workplane wrkpl, Point p, Circle circle) A Point2d will be fixed on a Circle . Equal SLVS_C_EQUAL_LENGTH_LINES 2D Use the command: Constraint.equal(Workplane wrkpl, LineSegment2d line1, LineSegment2d line line2) Two length of LineSegment2d will be same. SLVS_C_EQ_LEN_PT_LINE_D 2D Use the command: Constraint.equal(Workplane wrkpl, Point2d p, LineSegment2d line1, LineSegment2d line line2) Length of first LineSegment2d will as same as a distance of a Point2d to second LineSegment2d . SLVS_C_EQ_PT_LN_DISTANCES 2D Use the command: Constraint.equal_point_line(Workplane wrkpl, Point2d p1, Point2d p2, LineSegment2d line1, LineSegment2d line2) Distance of first Point2d to first LineSegment2d will as same as next distance of second Point2d to second LineSegment2d . SLVS_C_EQUAL_ANGLE 2D Use the command: Constraint.equal_angle(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2, LineSegment2d line3, LineSegment2d line4) Angle of first LineSegment2d to second LineSegment2d will as same as next angle of third LineSegment2d to fourth LineSegment2d . SLVS_C_EQUAL_LINE_ARC_LEN 2D Use the command: Constraint.equal(Workplane wrkpl, LineSegment2d line, Circular c) Length of a LineSegment2d and Arc length of a Circular will be same. SLVS_C_EQUAL_RADIUS 3D Use the command: Constraint.equal_radius(Workplane wrkpl, Circular c1, Circular c2) Two radius of Circular will be same. SLVS_C_SAME_ORIENTATION 3D Use the command: Constraint.orientation(Normal3d nrml1, Normal3d nrml2) Two direction of Normal3d will be same. Ratio of Length Val SLVS_C_LENGTH_RATIO 2D Use the command: Constraint.ratio(double value, Workplane wrkpl, LineSegment2d line1, LineSegment2d line2) The ratio of first LineSegment2d to second LineSegment2d . Symmetric SLVS_C_SYMMETRIC 3D Use the command: Constraint.symmetric(Workplane wrkpl, Point3d p1, Point3d p2) 2D Use the command: Constraint.symmetric(Workplane wrkpl, Point2d p1, Point2d p2) Two Point2d/3d will symmetric to a work plane. This means that they are on opposite sides of the plane and at equal distances from the plane, and that the line connecting ptA and ptB is normal to the plane. SLVS_C_SYMMETRIC_HORIZ 2D Use the command: Constraint.symmetric_H(Workplane wrkpl, Point2d p1, Point2d p2) Two Point2d will be locked in the same horizontal coordinate. SLVS_C_SYMMETRIC_VERT 2D Use the command: Constraint.symmetric_V(Workplane wrkpl, Point2d p1, Point2d p2) Two Point2d will be locked in the same vertical coordinate. SLVS_C_SYMMETRIC_LINE 2D Use the command: Constraint.symmetric(Workplane wrkpl, Point2d p1, Point2d p2, LineSegment2d line) Two Point2d will symmetric to the LineSegment2d . Middle point SLVS_C_AT_MIDPOINT 3D Use the command: Constraint.midpoint(Point3d p, LineSegment3d line) 2D Use the command: Constraint.midpoint(Workplane wrkpl, Point2d p, LineSegment2d line) Let a Point2d/3d locate on a middle point of the LineSegment2d . Horizontal & Vertical SLVS_C_HORIZONTAL 2D Use the command: Constraint.horizontal(Workplane wrkpl, LineSegment2d line) SLVS_C_VERTICAL 2D Use the command: Constraint.vertical(Workplane wrkpl, LineSegment2d line) Let a LineSegment2d to horizontal or vertical. Diameter Val SLVS_C_DIAMETER 2D Use the command: Constraint.diameter(double diameter, Workplane wrkpl, Circular c) Diameter of a Circular . Angle Val SLVS_C_ANGLE 2D Use the command: Constraint.angle(Workplane wrkpl, double value, LineSegment2d line1, LineSegment2d line2, bool other) Angle of two LineSegment2d . In degrees. The following formula ( A and B are vector of two lines): (A dot B)/(|A||B|) = cos(valA) where A and B are vectors in the directions of lines A and B. This equation does not specify the angle unambiguously; for example, note that valA = +/- 90 degrees will produce the same equation. If other is true, then the constraint is instead that (A dot B)/(|A||B|) = -cos(valA) SLVS_C_PERPENDICULAR 2D Use the command: Constraint.perpendicular(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2, bool other) From constraint SLVS_C_ANGLE . This constraint is defined angle constraint when it is 90 degrees. Parallel SLVS_C_PARALLEL 3D Use the command: Constraint.parallel(LineSegment3d line1, LineSegment3d line2) 2D Use the command: Constraint.parallel(Workplane wrkpl, LineSegment2d line1, LineSegment2d line2) Two LineSegment2d/3d are parallel each other. Note that this constraint removes one degree of freedom when projected in to the plane, but two degrees of freedom in 3d. Tangent Val SLVS_C_ARC_LINE_TANGENT 2D Use the command: Constraint.tangent(ArcOfCircle arc, LineSegment2d line, bool other) A ArcOfCircle and a LineSegment2d are tangent. If the bool value is False , than it will tangent at its beginning s . If other is True , then the arc is tangent at its end e . SLVS_C_CUBIC_LINE_TANGENT 3D Use the command: Constraint.tangent(Cubic c, LineSegment3d l, bool other) A Cubic and a LineSegment3d are tangent. If the bool value is False , than it will tangent at its beginning p0 . If other is True , then the arc is tangent at its end p3 . SLVS_C_CURVE_CURVE_TANGENT 3D 2D Use the command: Constraint.tangent(ArcOfCircle c1, ArcOfCircle c2, bool other, bool other2) Constraint.tangent(Cubic c1, Cubic c2, bool other, bool other2) Constraint.tangent(ArcOfCircle c1, Cubic c2, bool other, bool other2) Constraint.tangent(Cubic c1, ArcOfCircle c2, bool other, bool other2) Tangent combination of two curves. If the bool value is False , than it will tangent at its beginning s or p0 . If other is True , then the arc is tangent at its end e or p3 . Dragged SLVS_C_WHERE_DRAGGED 3D Use the command: Constraint.dragged(Point3d p) 2D Use the command: Constraint.dragged(Workplane wrkpl, Point2d p) Permanently lock the Point2d/3d point coordinates in the current calculation of the coordinates, never change. This constrains two degrees of freedom in a workplane, and three in free space. Set Dragged Tips About lock the position, another constraint of system as follows: sys.set_dragged(Point p) It is command that try to fix the Point2d/3d , instead to move other entities. This point will get a little of movement. Additional Types of Constrains Some additional constraints, there is no corresponding entity items available for them. Point and Face SLVS_C_PT_FACE_DISTANCE 3D Use the command: #This feature is not Construction Point on Face SLVS_C_PT_ON_FACE 3D Use the command: #This feature is not Construction","url":"http://project.mde.tw/blog/slvs-library-functions.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/16","text":"Jupyterhub 繪圖 - 漸開線範例（已儲存8888.kmol.info） CentOS 安裝 Python 3.3 倉儲 python-solvespace 已更新 漸開線範例 嘗試使用純 slvs 程式庫（而非使用 matlab 的公式）的方式畫出漸開線。 雖然程式庫中有比較弧長和線段長的公式，但是無法因應多圈的狀況，所以使用內建math的 pi 來計算弧長。 越多圈的漸開線計算越久，角度參照是基圓而非漸開線尾。 %matplotlib inline #漸開線解題 #由端點Point3畫出圖形 from slvs import * import matplotlib.pyplot as plt from math import * #參數 r = 10.0#基圓半徑 def Involute(degree): #角度換算：degree去除重複圈數 d = r*(degree*pi/180) n = degree//360 degree -= 360*n #開始繪圖 sys = System(500) g = 1 #3D原點Point0 p0 = sys.add_param(0.0) p1 = sys.add_param(0.0) p2 = sys.add_param(0.0) Point0 = Point3d(p0, p1, p2) #XY法線 qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0) p3 = sys.add_param(qw) p4 = sys.add_param(qx) p5 = sys.add_param(qy) p6 = sys.add_param(qz) Normal1 = Normal3d(p3, p4, p5, p6) #工作平面 Workplane1 = Workplane(Point0, Normal1) #2D原點Point1 p7 = sys.add_param(0.0) p8 = sys.add_param(0.0) Point1 = Point2d(Workplane1, p7, p8) Constraint.dragged(Workplane1, Point1) #Angle約束判斷 if degree >= 180: other = -1 else: other = 1 #Point2繞行圓周，距離r p9 = sys.add_param(0.0) p10 = sys.add_param(10.0*other) Point2 = Point2d(Workplane1, p9, p10) Constraint.distance(r, Workplane1, Point1, Point2) Line1 = LineSegment2d(Workplane1, Point1, Point2) #Point3距離Point2為目前圓周長 #並且連線d會垂直半徑連線r p11 = sys.add_param(10.0*other) p12 = sys.add_param(10.0*other) Point3 = Point2d(Workplane1, p11, p12) if d == 0: Constraint.on(Workplane1, Point2, Point3) else: Line2 = LineSegment2d(Workplane1, Point2, Point3) Constraint.distance(d, Workplane1, Point2, Point3) Constraint.perpendicular(Workplane1, Line1, Line2, False) #輔助基線Line0 p13 = sys.add_param(10.0) p14 = sys.add_param(0.0) Point4 = Point2d(Workplane1, p13, p14) Constraint.dragged(Workplane1, Point4) Line0 = LineSegment2d(Workplane1, Point1, Point4) #約束角度 Constraint.angle(Workplane1, degree, Line1, Line0, False) #以下解題 sys.solve() if (sys.result == SLVS_RESULT_OKAY): #回傳Point7 x = sys.get_param(11).val y = sys.get_param(12).val return x, y elif (sys.result == SLVS_RESULT_INCONSISTENT): print (\"solve failed\") print (\"SLVS_RESULT_INCONSISTENT\") print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE): print (\"solve failed\") print (\"SLVS_RESULT_DIDNT_CONVERGE\") print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS): print (\"solve failed\") print (\"SLVS_RESULT_TOO_MANY_UNKNOWNS\") print (\"%d DOF\" % sys.dof) #主程式 Xval = [] Yval = [] degree = 720 for i in range(0, degree+1, 1): x, y = Involute(i) Xval += [x] Yval += [y] print (\"Solve Completed\") plt.plot(Xval, Yval) plt.xlabel('x coordinate') plt.ylabel('y coordinate') plt.title(\"Involute - \"+str(degree)+\" deg\") plt.show() 由於 Point2 是逆時針旋轉，必須保持 Point3 在它的後方，之間的連線也必須相切基圓，即與其半徑垂直。 然而 slvs 程式庫無法解決距離為 0 的情況，必須自己改成重合約束，目前在程式庫說明中加上註解，不過應該有辦法透過原始碼的標頭檔避開這個問題，晚點會修正這個情況，如果情況順利，明天的網誌中會更新。 結果圖形： Jupyter 運行結果（計算時間較長）： CentOS 7 為虛擬機（研究室的電腦）安裝官方的 Everything 版本（ISO映像檔），但是電腦效能只能同時跑一個程式，所以安裝很緩慢。 最後還是灌好了。 但是安裝完後之前選的 Python 工具包中竟然只有 Python 2.7，所以上網找了一下資料，用手動make的方式安裝 Python 3.3.6。 http://tecadmin.net/install-python-3-4-on-centos-rhel-fedora/ CentOS 相較於 Ubuntu 操作方式不太一樣，而雖然安裝畫面是寫 KDE 圖形介面，但卻是 GNOME 包著 KDE 的附屬程式，而且它們的介面還比 Ubuntu 陽春。 慶幸的是 CentOS 的開發者工具包十分完善，應該是不用 Netbeans 了，可以直接用終端機make。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050816.html"},{"tags":"2016g1","title":"40323143 -  滾珠螺桿減速機構想","text":"利用滾珠作為媒介，在兩個不同節距螺桿間傳遞動力，達到增減速效果。","url":"http://project.mde.tw/blog/40323143-gun-zhu-luo-gan-jian-su-ji-gou-xiang.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/15","text":"Jupyterhub 繪圖 多連桿機構的程式及註解 倉儲 python-solvespace 已更新 Jupyterhub 用學校 Gmail 登入後用 notebook 進行運算，程式碼開頭只要加上 %matplotlib inline 就能使用 matplotlib 了。 不過 notebook 目前是唯獨模式，無法建立檔案或是編輯。 程式碼 這次將畫圖順序統整了一下。 %matplotlib inline #多連桿機構端點（Point7）路徑圖形 #主動軸為［曲柄］Point1-Point2 #圖形將在程式中解釋 from slvs import * import matplotlib.pyplot as plt def Multi_link(degree): #開始繪圖 sys = System(500) g = 1 #3D原點Point0 p0 = sys.add_param(0.0) p1 = sys.add_param(0.0) p2 = sys.add_param(0.0) Point0 = Point3d(p0, p1, p2) #XY法線 qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0) p3 = sys.add_param(qw) p4 = sys.add_param(qx) p5 = sys.add_param(qy) p6 = sys.add_param(qz) Normal1 = Normal3d(p3, p4, p5, p6) #工作平面 Workplane1 = Workplane(Point0, Normal1) #2D原點Point1 p7 = sys.add_param(0.0) p8 = sys.add_param(0.0) Point1 = Point2d(Workplane1, p7, p8) Constraint.dragged(Workplane1, Point1) #Angle約束判斷 if degree >= 180: other = -1 else: other = 1 #［曲柄］Point1-Point2長15mm p9 = sys.add_param(0.0) p10 = sys.add_param(20.0*other) Point2 = Point2d(Workplane1, p9, p10) Constraint.distance(15.0, Workplane1, Point1, Point2) Line1 = LineSegment2d(Workplane1, Point1, Point2) #第一組［呆鍊］Point3-Point4-Point5（Point3固定） #長度41.5-55.8-40.1mm p11 = sys.add_param(-38.0) p12 = sys.add_param(-7.8) Point3 = Point2d(Workplane1, p11, p12) Constraint.dragged(Workplane1, Point3) p13 = sys.add_param(-50.0) p14 = sys.add_param(30.0) Point4 = Point2d(Workplane1, p13, p14) p15 = sys.add_param(-70.0) p16 = sys.add_param(-15.0) Point5 = Point2d(Workplane1, p15, p16) Constraint.distance(41.5, Workplane1, Point3, Point4) Constraint.distance(55.8, Workplane1, Point4, Point5) Constraint.distance(40.1, Workplane1, Point3, Point5) #第二組［呆鍊］Point6-Point7-Point8 #長度65.7-49.0-36.7mm p17 = sys.add_param(-50.0) p18 = sys.add_param(-50.0) Point6 = Point2d(Workplane1, p17, p18) p19 = sys.add_param(-10.0) p20 = sys.add_param(-90.0) Point7 = Point2d(Workplane1, p19, p20) p21 = sys.add_param(-20.0) p22 = sys.add_param(-40.0) Point8 = Point2d(Workplane1, p21, p22) Constraint.distance(65.7, Workplane1, Point6, Point7) Constraint.distance(49.0, Workplane1, Point7, Point8) Constraint.distance(36.7, Workplane1, Point6, Point8) #兩段［呆鍊-呆鍊］連接桿 #Point5-Point6長39.4mm #Point3-Point8長39.3mm Constraint.distance(39.4, Workplane1, Point5, Point6) Constraint.distance(39.3, Workplane1, Point3, Point8) #兩段［區柄-呆鍊］連接桿 #Point2-Point4長50.0mm #Point2-Point8長61.9mm Constraint.distance(50.0, Workplane1, Point2, Point4) Constraint.distance(61.9, Workplane1, Point2, Point8) #水平輔助Line0 p23 = sys.add_param(20.0) p24 = sys.add_param(0.0) Point9 = Point2d(Workplane1, p23, p24) Constraint.dragged(Workplane1, Point9) Line0 = LineSegment2d(Workplane1, Point1, Point9) #區柄角度（手動項目務必放最後） Constraint.angle(Workplane1, degree, Line1, Line0, False) #以下解題 sys.solve() if (sys.result == SLVS_RESULT_OKAY): #回傳Point7 x = sys.get_param(19).val y = sys.get_param(20).val return x, y elif (sys.result == SLVS_RESULT_INCONSISTENT): print (\"solve failed\") print (\"SLVS_RESULT_INCONSISTENT\") print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE): print (\"solve failed\") print (\"SLVS_RESULT_DIDNT_CONVERGE\") print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS): print (\"solve failed\") print (\"SLVS_RESULT_TOO_MANY_UNKNOWNS\") print (\"%d DOF\" % sys.dof) #主程式 Xval = [] Yval = [] for i in range(0, 361, 1): x, y = Multi_link(i) Xval += [x] Yval += [y] print (\"Solve Completed\") plt.plot(Xval, Yval) plt.xlabel('x coordinate') plt.ylabel('y coordinate') plt.show() 因為是變速機構，如果將精度調成5度的話，圖形會比較粗糙，目前用1度的精度會比較平滑，不過相對運算時間會比較久。 執行結果（5度） 執行結果（1度） 經過多次範例，若要使用 slvs 程式庫畫圖，要先看一下機構節點的大約位置，尤其是運動範圍跨象限的主動節點（即參數控制約束的點）。 機構中會360度繞軸旋轉的區柄端點，起始位置要定在90度（輸入值在0～180）或-90度（輸入值在181～359），要用 if 函式判斷。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050815.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/14","text":"使用研究室網路設定 架站問題 Python 3.3 版本製作中 網路設定 由於之前上網是用手機網路，為了取得固定IP，使用的是原本給新電腦用的網路 140.130.17.117 。 Windows 和 Ubuntu 中的設定是一樣的，兩個OS都能連到網際網路。 Oauthenticator 參考 Cadlab 有關 Jupyterhub 的安裝，在 Python 中安裝了 jupyterhub、notebook 和 oauthenticator。 http://cadlab.mde.tw/post/jupyterhub-oauth2-deng-ru-she-ding.html http://cadlab.mde.tw/post/chun-ipv6-huan-jing-xia-an-zhuang-jupyterhub.html 利用指令產生 key 和 crt 兩個憑證檔案。 sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout jupyterhub.key -out jupyterhub.crt 起動指令是： jupyterhub --ip 140.130.17.117 --port 9443 --ssl-key jupyterhub.key --ssl-cert jupyterhub.crt 從 https://github.com/jupyterhub/oauthenticator/tree/master/example 下載了範例資料夾，不過 jupyterhub_config.py 結構跟說明不太一樣，所以把他的指令碼改成 Cadlab 的方式，只是白名單和使用者清單的檔案可能不一樣，改一下資料夾或連結名稱就能對應。 接著進 Github 註冊新的app，取得 Client ID 和 Client Secret，不過不知道網域名稱該填甚麼，只能填上電腦IP名稱。 而 Google 方面也是一樣，但是重新導向 callback 的方面要使用頂層網域，就是包含 .com 或 .org 的名稱，這樣就沒辦法導向給 IP 名稱的網站用了。 另外就是檔案瀏覽器沒有權限在 etc 或 srv 目錄裡編輯或是建立檔案，要自動啟動就必須用終端機設定了。 pyenv 裝了 pyenv 來管理 Python 版本。 安裝時還需要 Mercurial。 Python 3.3 dev 下載和安裝時都比較久，等了一段時間才弄好。 接下來會編譯 3.3 的版本來測試。 由於對網路方面不熟悉，所以可能設定方面有所缺失，還要花一些時間檢查。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050814.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/13","text":"Ubuntu 版本與 Openshift 不合 Openshift 的 cartridge 自訂？ 版本不合 後來發現為何找不到 _slvs.so 的檔案了，因為 .gitignore 中包含了 *.so ，而不會上傳這兩個檔案，註解掉就行了。 但是上傳後仍無法執行，回報的訊息為： Traceback (most recent call last): File \"/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/wsgi.py\", line 5, in import myflaskapp File \"/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/myflaskapp.py\", line 18, in import users.b.g9.bg9_40323230 File \"/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/users/b/g9/bg9_40323230.py\", line 2, in from slvs import * File \"/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/slvs.py\", line 28, in _slvs = swig_import_helper() File \"/var/lib/openshift/57182def7628e1988e00002a/app-root/runtime/repo/slvs.py\", line 24, in swig_import_helper _mod = imp.load_module('_slvs', fp, pathname, description) File \"/opt/rh/python33/root/usr/lib64/python3.3/imp.py\", line 183, in load_module return load_dynamic(name, filename, file) ImportError: libpython3.4m.so.1.0: cannot open shared object file: No such file or directory 看來開發時使用 Python 3.4 dev 會造成 Python 3.3 無法讀取。 Openshift custom cartridge 上網找了一下文章，找到有人問能不能建立其他版本的 cartridge。 http://stackoverflow.com/questions/34073473/openshift-custom-cartridge-with-python-3-4 而回應的是如果使用 s2i-python-container 這個工具，可以建立一個名為 Python 3.3 的其他版本 Python 鏡像檔，甚至有支援 Python 3.5。 https://github.com/sclorg/s2i-python-container 不過這個工具只能給 Fedora 類型的 Linux 作業系統使用，看起來是沒有 Debian 的版本。 要解決 Linux 相容的問題，Ubuntu 上可能要裝 3.3 版本的 Python 了，會先研究看看 Openshift 方可以安裝和執行的指令。 不知道如果其他 Ubuntu 沒安裝 Python-dev（或版本不同）的話能不能執行這些檔案。 Windows 的 Python 連結庫是自己做的，而非安裝 Python-dev，所以沒這個問題。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050813.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/12","text":"Ubuntu 版本編譯完畢 倉儲 python-solvespace 已更新 Ubuntu 執行成功 後來將 slvs_python.hpp 的 __mingw_vasprintf 暫時改為 vasprintf 就沒問題了，不過若要使用MinGW編譯的話要再改回來。 編譯出來的檔案名稱為 _slvs.so ，類型是共享連結庫。 在終端機中使用python3執行所有範例檔都沒問題。 Windows 用的 _slvs.pyd ，在檔案瀏覽器中被視為 Windows 可執行檔，而非共享連結庫。 將 Makefile 存成兩個版本（加上次檔名），不同平台間用 -f 參數切換make就行了。 不過目前手邊沒有虛擬機，所以還沒測試是否所有使用 Python 3.4 的 Ubuntu 都能使用程式庫。 倉儲更新 統一將make完畢的 Library 放在 Windows 和 Ubuntu 資料夾。 將倉儲清理了一下，讓原始碼回到 make clean 狀態。 將原本 Windows 的範例code複製一份到 Ubuntu 資料夾中。 不過將 _slvs.so 和編譯好的附屬文件上傳到 Openshift 後仍然找不到 _slvs 模組。 接著會測試看看小型的pyd能不能用。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050812.html"},{"tags":"2016g1","title":"40323143 -  手臂設計流程","text":"1.定義客觀值 將手臂外既有的空間以數值表現 2.規劃路徑 (1)定義原點 (2)定義夾取點 (3)定義可行路徑範圍 (4)依需求決定路徑 3.決定旋轉軸及旋轉軸安排 此旋轉軸指動力輸入軸 4.推導路徑方程式 依旋轉軸數個三角函數組合成一套路徑方程式 5.決定旋轉軸動力安排 決定旋轉軸動力輸入方式，直接輸入或以連桿等任何方式輸入旋轉軸 6.決定手臂連接桿及組裝配合尺寸","url":"http://project.mde.tw/blog/40323143-shou-bi-she-ji-liu-cheng.html"},{"tags":"2016g1","title":"Vrep手臂逆向","text":"利用tkinter連接給最後的點座標，算出轉軸的角度 因為目前是使用class的方法去繼承function，因此可以用兩個頁面進行控制3DP和手臂的地方，因為把逆向的方程式帶進去了，可以直接給他要到的座標，就可以算出兩個角度的大小，以及範圍。 實驗室近況報告 目前第三組已有部分組員回歸團隊，並著手進行OpenCv的開發，以及讀相關的資料和論文，而另外兩組目前都在著手報告的部分，以及Latex等設定檔和撰寫內容，目前大家進度都卡住，可能最近會有一陣子停頓期，大家的開發能力在七月也用的差不多，像是從0開始的V-rep到現在可以控制整合，動態模擬，Solvespace也改成python3的版本，大家的東西也串流再一起，像是我們手臂的部分，從模擬，推出數學方程式，到solvespace算點座標劃出曲線方程式以及路徑，最後一路的推導方程式，到現在只要給點就可以控制移動的路徑。 下學期的學弟妹應該會有不錯的收穫，除了有老師搬上flask的pygroup，還有新版的solvespace for python3，和最新的Vrep控制、組裝、模擬，這些都可以向下交接了，這些東西都可以結合我們的cad能力，應該是不錯的工具以及多元整合。 可能是我進度壓的緊了點，大家呈現疲倦的樣子，想說讓大家休息一兩周，好好恢復精神，讓大家可以動力繼續往更高的層次邁進，可能這一兩周，進度會比較少，讓大家輕鬆一周。","url":"http://project.mde.tw/blog/vrepshou-bi-ni-xiang.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/11","text":"安裝 Linux 版工具 Ubuntu 版本編譯 工作環境 用以前安裝的雙系統做 Ubuntu 版本的編譯。 作業系統是基於 Ubuntu 14.04 的 ezgo 12，圖形介面為KDE。 原本 ezgo 中的python3版本為 3.4.0，安裝python3.4-dev後升級到最新的3.4.5。 而原版的GNU工具沒有裝入g++，所以就用apt安裝了。 在 Ubuntu 上運行 Netbeans 和 gcc 比 Windows 流暢，make的速度更快。 產生問題 因為作業系統換了環境，所以Makefile的位置研究並調整了一下。 不過在編譯 slvs_python.hpp 時出現 ‘__mingw_vasprintf' was not declared in this scope 的訊息。 這個函式應該是 stdio.h 的，不知道為何無法找到它。 檢查了系統目錄，這個檔案應該都在 include 的範圍內，所以應該是使用GNU和原本MinGW兩種版本gcc的問題。 不過這次並非在虛擬機測試，所以使用上會更小心。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050811.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/10","text":"檢視python.log的錯誤 Python Solvespace 的介紹圖 FileZilla 登入 用FileZilla進入網站查看和下載檔案。 在Openshift的網頁中按下\"Want to log in to your application?\"連結，能取得一個字串，形式如下。 ssh 使用者名稱@主機 將其內容填入FileZilla的站台設定中，協定選擇SFTP，登入形式選擇交談式。 然後連線後，在 /var/lib/openshift/使用者名稱/app-root/logs 資料夾中可以找到python.log，下載後開啟。 最下方是最新的執行紀錄和連線紀錄。 看到問題是錯在模組導入錯誤，雖然訊息跟之前模組匯入的問題一樣，但是造成原因應該不一樣。 不知道是python版本還是openshift不使用anaconda的關係。 slvs.py 無法像先前一般將 _slvs.pyd 的名稱傳給python用。 介紹圖 用免費軟體XMind做兩張Python Solvespace的概念圖。 軟體中不能調整解析度，目前的比例還能符合網頁或文件中的說明。 製作過程 利用規劃 在想是否要將slvs的檔案做成模組的方式裝入Python，再裝到Openshift的python上。 做成模組後用途應該會增加。 近期將整理網誌內容改成書面格式，先存成Markdown檔，再另外參照學長的目錄做分類排序成章節。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050810.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/08","text":"將bokeh繪圖搬入Flask，使用的是上學期的倉儲。 bokeh網頁原始碼 bokeh在使用後，可以不選擇存檔，而是變成網頁原始碼的型態，讓程式利用。 #不使用from bokeh.plotting import figure, output_file, show, save #而導入： from bokeh.plotting import figure from bokeh.resources import CDN from bokeh.embed import file_html #照常畫圖 plot = figure(...) plot.line(...) #最後傳出給outstring outstring = str(file_html(plot, CDN, \"網頁視窗標題\")) 變成這樣的形態後，會先讓SLVS程式庫和bokeh計算完原始碼後才使用，算是靜態結果，這樣會產生一個缺點，稍後會提到。 bokeh也有自己的附加功能\"JavaScript Callbacks\"，屬於動態運算，讓圖形能及時更新，不用重新整理。 參考連結： http://bokeh.pydata.org/en/latest/docs/user_guide/interaction/callbacks.html#customjs-for-widgets 試過了範例Slider的方法（最接近需求：給角度求機構當前狀態），在JavaScript中卻不知所以然，不知道要如何把callback的內容帶入我的函式中。 上網看過別人的範例，不同利用方式都不一樣，但是不知道如何修改JS迴圈中的內容。因為機構的圖形要回傳所有的點，可能要了解一下這些物件的關係。 Flask 和上學期的專案一樣，用 python wsgi.py 啟動後就能呼叫程式並帶入變數求解。 不同的是用到新模組和自己的程式庫。 在自己的檔案中再插入一段 Mango(k) 來嵌入bokeh的圖形，並希望能控制機構的角度狀態。 稍微調整了bokeh的選項，隱藏工具、取消預設工具、不可拖移、放大介面等等。 @bg9_40323230.route('/crank_rock/＜k>') def Mango(k): outstring = \"\" #相關參數 d0 = 90 #基線長度(mm) n1 = 35 #短連桿長度(mm) n2 = 70 #長連桿長度(mm) t1 = 40 #三角形第一邊(mm) t2 = 40 #三角形第二邊(mm) t3 = 70 #三角形第三邊(mm) #迴圈求路徑用 def crank_rock(degree): ... #當前機構狀態用 def crank_rock_M(degree): ... #主程式 X1val = [] Y1val = [] for i in range(0, 361): x, y = crank_rock(i) X1val += [x] Y1val += [y] x1, y1, x2, y2, x3, y3, x4, y4, x5, y5 = crank_rock_M(float(k)) X2val = [x1, x4, x3, x5, x4, x5, x2] Y2val = [y1, y4, y3, y5, y4, y5, y2] X3val = [x1, x2] Y3val = [y1, y2] #bokeh plot = figure(title=\"simple line example\", x_axis_label='x', y_axis_label='y', toolbar_location=None, plot_width=700, plot_height=700) plot.line(X1val, Y1val, legend=\"Path.\", line_width=2, line_color=\"blue\") plot.line(X2val, Y2val, legend=\"Mechanism.\", line_width=4, line_color=\"red\") plot.line(X3val, Y3val, line_width=3, line_dash=[4, 4], line_color=\"orange\") plot.toolbar.active_drag = None outstring = str(file_html(plot, CDN, \"Crank Rocker: \"+str(k)+\" degree\")) return outstring 這樣子程式會計算出HTML的原始碼給網頁，而bokeh的網頁中不會用到python程式。 在這裡 k 是以 字串 的方式帶進來的，所以必須轉成Float才能計算。 但是如果預先設置了 defaults 值時（例如 120 ），這裡的 120 可以代表字串或整數或浮點數，python會搶先認定 defaults 值能用，儘管自訂的 k 值後來轉成浮點數，結果仍然會是 defaults 值。 所以最後不得以把 defaults 值捨棄。 最後結果： 建立了一支Openshift程式，但是上傳後卻無法使用，不知道是Python 3.3還是其他的問題，整個程式都跑不了。 最近因為有點感冒，研究bokeh的互動功能函式滿久的。 嘗試過用3D的方式解手臂極限範圍，但是程式庫有些盲點。 SLVS似乎會認定4個約束在同平面的3D點，他們之間的2條連線如果約束為平行，是重複約束，目前不知道要怎麼辦。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050808.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/05","text":"使用bokeh繪圖 bokeh 由於mpld3沒有支援Python 3.5，測試過執行產生的頁面是空白頁，所以選擇使用bokeh來繪製，但是後者不支援3D繪圖。 使用Anaconda的指令安裝bokeh。 1 ana install bokeh 參照了一下官方的說明頁： http://bokeh.pydata.org/en/latest/docs/installation.html http://bokeh.pydata.org/en/latest/docs/reference/io.html http://bokeh.pydata.org/en/latest/docs/user_guide/notebook.html Exercise 將之前的Crank Rocker改寫一下。 #一三角形呆鍊，由一長一短的連桿固定在水平基線上。 #短連桿鎖固在原點上，長連桿鎖固在距原點90mm處。 #短連桿長度35mm；長連桿長度70mm。 #三角形呆鍊邊長分別為40mm、40mm、70mm from slvs import * from math import * from bokeh.plotting import figure, output_file, show #相關參數 d0 = 90 #基線長度(mm) n1 = 35 #短連桿長度(mm) n2 = 70 #長連桿長度(mm) t1 = 40 #三角形第一邊(mm) t2 = 40 #三角形第二邊(mm) t3 = 70 #三角形第三邊(mm) #開始繪圖 def crank_rock(degree): sys = System(500) g = 1 #原點Point0 p0 = sys.add_param(0.0) p1 = sys.add_param(0.0) p2 = sys.add_param(0.0) Point0 = Point3d(p0, p1, p2) #XY法線 qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0) p3 = sys.add_param(qw) p4 = sys.add_param(qx) p5 = sys.add_param(qy) p6 = sys.add_param(qz) Normal1 = Normal3d(p3, p4, p5, p6) #工作平面 Workplane1 = Workplane(Point0, Normal1) #3D版的Point0=>Point1 p7 = sys.add_param(0.0) p8 = sys.add_param(0.0) Point1 = Point2d(Workplane1, p7, p8) Constraint.dragged(Workplane1, Point1) #長連桿轉軸Point2，還有基線Line0。 p9 = sys.add_param(d0) p10 = sys.add_param(0.0) Point2 = Point2d(Workplane1, p9, p10) Constraint.dragged(Workplane1, Point2) Line0 = LineSegment2d(Workplane1, Point1, Point2) #Angle約束判斷 if degree >= 180: other = -1 else: other = 1 #三角形Point3 / Point4 / Point5 p11 = sys.add_param(20.0) p12 = sys.add_param(20.0) Point3 = Point2d(Workplane1, p11, p12) p13 = sys.add_param(0.0) p14 = sys.add_param(10.0*other) Point4 = Point2d(Workplane1, p13, p14) p15 = sys.add_param(30.0) p16 = sys.add_param(20.0) Point5 = Point2d(Workplane1, p15, p16) Constraint.distance(t1, Workplane1, Point4, Point3) Constraint.distance(t2, Workplane1, Point3, Point5) Constraint.distance(t3, Workplane1, Point4, Point5) #連桿約束 Constraint.distance(n1, Workplane1, Point1, Point4) Constraint.distance(n2, Workplane1, Point2, Point5) Line1 = LineSegment2d(Workplane1, Point1, Point4) #短連桿與水平軸的角度 Constraint.angle(Workplane1, degree, Line1, Line0, False) #以下解題 sys.solve() if (sys.result == SLVS_RESULT_OKAY): x = sys.get_param(11).val y = sys.get_param(12).val return x, y elif (sys.result == SLVS_RESULT_INCONSISTENT): print (\"solve failed\") print (\"SLVS_RESULT_INCONSISTENT\") print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE): print (\"solve failed\") print (\"SLVS_RESULT_DIDNT_CONVERGE\") print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS): print (\"solve failed\") print (\"SLVS_RESULT_TOO_MANY_UNKNOWNS\") print (\"%d DOF\" % sys.dof) #主程式 Xval = [] Yval = [] for i in range(0, 361): x, y = crank_rock(i) Xval += [x] Yval += [y] print (\"Solve Completed\") #bokeh output_file(\"mango.html\") plot = figure(title=\"simple line example\", x_axis_label='x', y_axis_label='y') plot.line(Xval, Yval, legend=\"Temp.\", line_width=2) show(plot) 使用的是簡單的show指令，會產生一個 html 的檔案。 內容是和matplotlib一樣的圖形。 另外bokeh也可以在Jupyter notebook上使用。 from tmp.workplace.exposed.slvs import * from math import * from bokeh.plotting import figure, output_notebook, show d0 = 90 #基線長度(mm) n1 = 35 #短連桿長度(mm) n2 = 70 #長連桿長度(mm) t1 = 40 #三角形第一邊(mm) t2 = 40 #三角形第二邊(mm) t3 = 70 #三角形第三邊(mm) #開始繪圖 def crank_rock(degree): ... #主程式 Xval = [] Yval = [] for i in range(0, 361): x, y = crank_rock(i) Xval += [x] Yval += [y] print (\"Solve Completed\") #bokeh output_notebook() plot = figure(title=\"simple line example\", x_axis_label='x', y_axis_label='y') plot.line(Xval, Yval, legend=\"Temp.\", line_width=2) show(plot) 程式庫名稱必須改為 tmp.workplace.exposed.slvs 執行結果如下： 另一支跑手臂極限範圍的程式： 有找到另一個套件Vispy可以畫3D物件，也可以在Jupyter notebook上執行。 另外Solvespace的運算方面無法同時計算2D和3D的物件，儲存的項目也不一樣。 不知道能不能用球座標系或圓柱坐標系轉換的方式，做一個將3D點鎖定到2D點的功能。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050805.html"},{"tags":"2016g1","title":"手臂逆向控制推導","text":"此篇為使用python3給末端點座標，求轉軸的兩個角度 上一篇推導的補充 由上一篇可以得知手臂的逆向推導公式，可是存在一個問題，並沒有將方程式列出來，最後證明出的面積是由順向方程式的角度去限制角度將每個角度所會經過的路徑會畫出來。 今天從新將方程式從新推導，因為不確定自己推導是否正確，我們幾個人將工具備齊，利用順向法確認算出來的角度是否有包含於在面積裡面，使用Vrep確定轉軸的角度是否正確，前面幾次因為設錯角度，造成轉軸的角度都不是正確的轉軸，後來利用餘弦定理的方法，終於推導出方程式。 接下知道點座標後，就可以利用點得到正確的角度，轉軸轉向正確的角度夾取物件，也可以同時控制V-rep和實體的部分，是否要配合影像辨識取點座標，目前還在考慮當中，還未執行，可能先用Vrep模擬取下列印件的方式為優先，手臂的控制介面目前進度到可以同時在兩個頁面控制printer和手臂。 $$\\theta_T = cos&#94;{-1}(\\frac{x&#94;2+y&#94;2-L1&#94;2-L2&#94;2}{2\\times L1\\times L2})$$ $$\\theta_n = cos&#94;{-1}(\\frac{x}{\\sqrt{x&#94;2+y&#94;2}}))$$ $$\\theta_\\alpha = cos&#94;{-1}(\\frac{x&#94;2+y&#94;2+L1&#94;2-L2&#94;2}{2\\times L1\\times \\sqrt{x&#94;2+y&#94;2}})$$ 大軸旋轉的角度 $$\\theta_2 = 90 - (\\theta_n + \\theta_\\alpha)$$ 小軸旋轉的角度 $$\\theta_3 = \\theta_T - \\theta_2$$ python 方程式推導 import math from math import * L1 = 135.0 L2 = 145.0 #X ,Y= 0,0 x =120.0 y = 10.0 theate = float((x*x+y*y-L1*L1-L2*L2)/(2*L1*L2)) print(theate) rad = math.acos(theate) print(rad) tha = math.degrees(rad) #tha為算出來的角度 print(\"算出來的\",tha) ### ##test================== #thn = arcos(x/(sqrt(x&#94;2+y&#94;2))) #tha = (x&#94;2+y&#94;2+L1&#94;2+L2&#94;2)/(2(sqrt(x&#94;2+y&#94;2)*L1)) theatanr = math.acos(x/(math.sqrt(x*x+y*y))) theatan = math.degrees(theatanr) #theataN的角度 print(\"theatan角度\",theatan) theatalphar = math.acos((x*x+y*y+L1*L1-L2*L2)/(2*math.sqrt(x*x+y*y)*L1)) theatalpha = math.degrees(theatalphar) #theatAlpha的角度 print(\"theatalpha角度\",theatalpha) #theata2 = theatan + theatAlpha #theata2大軸轉的角度 test = theatan+theatalpha theata2 = 90- test print(\"theata2\",theata2) #theata3 = tha - theata2 #theata3小軸轉的角度 theata3 = tha - test print(\"theata3\",theata3)","url":"http://project.mde.tw/blog/shou-bi-ni-xiang-kong-zhi-tui-dao.html"},{"tags":"2016g3","title":"40323214日誌-Opencv範例","text":"一.Windows執行範例程式 1.範例程式 import cv2 import sys cascPath = \"haarcascade_frontalface_default.xml\" faceCascade = cv2.CascadeClassifier(cascPath) video_capture = cv2.VideoCapture(0) while True: # 逐一以影格取像 ret, frame = video_capture.read() gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) faces = faceCascade.detectMultiScale( gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30), flags=cv2.CASCADE_SCALE_IMAGE ) # 在辨識的臉形外圍畫一個矩形 for (x, y, w, h) in faces: cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 0), 2) # 呈現影像 cv2.imshow('Video', frame) if cv2.waitKey(1) & 0xFF == ord('q'): break # 停止執行 video_capture.release() cv2.destroyAllWindows() 2.執行結果 二.網路上的相關範例 import cv2 from webcam_gui import webcam_gui def imgproc(frame): # convert color to gray scale and show it gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) cv2.imshow('gray', gray) blur = cv2.blur(gray, (5,5)) edge = cv2.Canny(blur, 30, 100) edge = cv2.blur(edge, (2,2)) cv2.imshow('blured edge', edge) # convert image to black and white and show it thresh1, thresh = cv2.threshold(edge, 60, 255, cv2.THRESH_BINARY) cv2.imshow('thresh', thresh) # find contours! _,contours, hry = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) # draw all the contours cpframe = frame.copy() cv2.drawContours(cpframe, contours, -1, (0,255,0), 3) cv2.imshow('cpframe', cpframe) # ================== TODO =================== # Modify these code to suit your need contours = [ctr for ctr in contours if cv2.contourArea(ctr) > 100] contours = [cv2.approxPolyDP(ctr, 5 , True) for ctr in contours] contours = [ctr for ctr in contours if cv2.isContourConvex(ctr)] # ============================================ # draw on the frame cv2.drawContours(frame, contours, -1, (0,255,0), 3) return frame if __name__ == \"__main__\": webcam_gui(imgproc, video_src=0) 1.執行結果 三.執行範例後心得 執行老師範例後，配合視訊裝置，可以呼叫出影像，並且進行人臉辨識。另外，我也在網路上查詢了其他相關範例，但程式碼更為複雜難懂，而網路上的範例是使用python2.x版本，所以必須換成python3的版本。 由於剛接觸到程式以及Opencv，所以有很多範例的程式碼是尚未瞭解的。 因此，我從Opencv的基礎語法中開始學習，包含cv2.imread()，cv2.imshow()，cv2.imwrite()等，先從如何呼叫圖片視窗，再到呼叫影片視窗。 四.目前碰到的問題 1.不知道如何學習範例程式中的辨識輪廓部分，以及辨識輪廓的數值是從何處來的。 2.有些程式中會提到Xml檔案，但不知道是如何製作出來。 五.參考的網頁資料 1.拍.電.視.時間Github範例程式:https://github.com/fatcloud/PyCV-time 2.OpenCv基礎語法學習網頁:http://docs.opencv.org/3.0-beta/doc/py_tutorials/py_gui/py_table_of_contents_gui/py_table_of_contents_gui.html 3.大兵萊恩學習OpenCv路程:http://gogoprivateryan.blogspot.tw/2015/09/opencv-3-opencv-python-face-recognition.html 4.Python2 to Python3程式改變部分:https://docs.python.org/2/library/2to3.html","url":"http://project.mde.tw/blog/40323214ri-zhi-opencvfan-li.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/08/03","text":"研究Scoop的使用方式 檢查錯誤 參考資料： http://scoop.readthedocs.io/en/latest/usage.html 啟動Scoop 為了讓自己製作的函式庫能進行分工運算，想要用一些工具讓SLVS Library能夠支援平行運算功能。 用pip安裝scoop。 pip install scoop Scoop的需求： 1 2 3 4 Distribute >= 0.6.2 or setuptools >= 0.7 Greenlet >= 0.3.4 pyzmq >= 13.1.0 and libzmq >= 3.2.0 ssh for remote execution 上述的套件Anaconda都有安裝了，不過在連線方面還不知道如何設定。 用 python -m scoop 啟動後會顯示［WinError 10022］，上網找資料發現是沒有指定特定目標。 Scoop的Help指令。 Scoop函式 啟動後，在python程式中導入scoop。 from scoop import futures, shared def myParallelFunc(inValue): myValue = shared.getConst('myValue') return inValue + myValue if __name__ == '__main__': shared.setConst(myValue=5) print(list(futures.map(myParallelFunc, range(10)))) 或是使用指令執行單一檔案也可以。 python -m scoop --hostfile hosts -vv -n 6 your_program.py [your arguments] Scoop可以分享函式給其他電腦，並在同時間回饋相同訊息。 而每台電腦可以平均分配需要運算的項目，達成多工的目的。 今天花太多時間檢查ZeroMQ (libzmq)的安裝狀態，因為不同語言的需求好像都不一樣，Python已經包含在pyzmq中（Windows版本應該是如此，但是Linux要另外裝和設定lib位置）；而C語言是安裝後從安裝位置include。 而ZeroMQ也能導入Python中，不過Scoop給的指令更方便。 關於Scoop的說明和介紹資料好像滿少的，而網路方面不知道如何架設。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050803.html"},{"tags":"2016bg2","title":"40323231日誌 - 指令(G碼、M碼...)","text":"常用指令與解說 常用指令 G28 : 原點複歸 G29 : 自動校正 G01 X70 Y60 Z5 : 快速定位 X70 Y60 高度5 M104 : 設定噴頭溫度 M105 : 查詢溫度(噴頭和熱床) M106 : 開啟風扇 M107 : 關閉風扇 M114 : 查詢目前位置(例如:X40 Y50 Z5) M119 : 查詢限位開關目前狀態 M500 : 儲存參數 字母定義 G:範例說明 M:範例說明 T:選擇工具，單一噴頭所以無用 S:命令參數，如電壓，控制轉速、溫度等等 P:命令參數，多少毫秒 F:每分鐘進給(毫米) E:擠出材料的長度(毫米) 其他指令說明 G4的：暫停 例如：G4 P200 在這種狀態下暫停200秒不工作。在延時時的機器狀態下(例如:擠出機溫度)仍然會被保留和控制。 G20 設定從現在開始為英寸 G21 設定從現在開始為毫米 G90 從現在開始，所有的座標都是絕對座標 G91 設定現在位置為原點，之後的都為相對座標 M0 停止 M18 禁止所有步進馬達 M20：列出SD卡 M21：初始化SD卡 M22：釋放SD卡 M23：選擇SD文件 M24：啟動/恢復SD列印 M25：暫停SD列印 M26：設置的SD位置 M27：報告SD列印狀態 M28：開始寫入到SD卡 M29：停止向SD卡寫入 M42：用盡材料時停止(XY回歸原點但Z沒有，關閉所有電器和加熱器，要重新開始必須複歸，之後繼續列印) M43: 用盡材料時等待(與M42相似，可是M43還可以下指令如G碼和M碼) M101:正轉啟動擠出馬達 M102:逆向啟動擠出馬達 M109:設定擠出溫度 M112：緊急停止(全部動作停止包括電器關閉) M113：設定擠出機的的PWM，例如:M113 S0.7，設定為擠出機70%速度，未用過猜測與軟體內的流量設定相同功用 M303 S200 C8 : 設定目標溫度200，並做8次震盪 震盪參考","url":"http://project.mde.tw/blog/40323231ri-zhi-zhi-ling-gma-mma.html"},{"tags":"2016bg2","title":"40323250日誌 - v-rep實做心得","text":"V-rep 與 Solvespace的結合應用 最近開了很多V-rep的範例檔來看 ,但都不太有收穫 ,為了避免浪費時間 ,回去找了之前老師提到的solvespace和vrep的共同運用 ,也因為要完成3D - Printer就要先了解基本觀念和用法 ,所以就抓了檔案來測試 (檔案位於solvespace官網的 tutorial : linkages) 壓縮檔載點 由於各零件之軸孔沒有軸連接 ,導致旋轉軸無法放置 ,所以我把軸都畫上去了 ,檔案為g2目錄下的solvespcae_vrep Solvespace的長料與除料功能真的不太習慣 ,很容易造成運算錯誤 軸都放好了 ,只是從屬關係還是不太清楚要如何放置 結果我又弄了一個圖 ,試圖從這邊學習從屬設定 目前只會讓它亂轉 感覺和各個旋轉軸速度也有關係 105 - 07/10更新 現在能夠讓連桿旋轉了 想要測試能否以固定角度來回旋轉 但是要達到這樣的動作需要編寫程式 ,且還在研究script的類別以及revolute的type到底要用哪一種 ,這些花了很多時間... 目前先以控單軸為主 ,但是遇到以下狀況 如果是用左邊的script就不會有simWait的錯誤 ,但是它只會走90度 ,然後simWait就不會動了 參考 : Joint types and operation Child Scripts 105 - 07/11更新 Joint 種類分成以下4種 : 1. 為旋轉軸, 只有一個自由度 (旋轉), 用於一般旋轉軸。 2. 為平移軸, 只有一個自由度 (平移), 物體能沿著軸線做平移。 3. 為旋轉與平移軸的結合, 只有一個自由度, 能夠使物體沿著軸做旋轉移動, 如同螺絲。 4. 為球窩接頭, 有三個自由度, 用於類似關節的地方。 Control the joint : 1.simSetJointPosition : when your joint is not in force/torque mode 2.simSetJointTargetPosition : when your joint is in force/torque mode, its motor enabled and its control loop also enabled 3.simSetJointTargetVelocity : when your joint is in force/torque mode, its motor enabled, and its control loop NOT enabled 今天回去翻老師的信, 才發現裡面有四連桿的範例, 以下為測試: 只要設定一個轉軸, 其他設定好就可以跟著一起做動, 但是在程式部分, if 條件還是不太懂, 很容易出現lua錯誤, 還有很多語法要理解。 105 - 07/12更新 今天拿老師的程式去跑小車子 ,但是joint的角度只要定在360就跟0度一樣 ,要如何才能超過這個範圍還在思考... little_car.ttt 105 - 07/14更新 今天參照了irb360範例, 試著組了printer, 前面還算順利, 在中間的 close chain部分 還要加上重疊的Revolute 來限制移動, 最後再搭上dummy 應該就可以控制了 printer_new.ttt printer_new_2.ttt 105 - 07/15更新 今天開始研究Inverse Kinematic 逆向運動學(IK) ,透過矩正及向量運算 ,就可以得到參數 ,且恰巧有學長論文和此相關 ,從中學到了不少 ,但還沒能弄懂 ,最後要結合進V-rep模擬中 ,腳步要加快了 105 - 07/17更新 Solvespace測試連桿運動方式 旋轉軸定義 子屬關係設定 (測試) ,加上dummy固定 經過一番波折 ,終於和同學弄出來了 ,只要無法封閉的部分利用dummy固定就可以了 ,至於實體轉軸部分要搭接在桿子上才可以 solvespace_successful 105 - 07/18更新 嘗試幫第一組 組裝手臂, 除了夾爪部分外 ,其餘都組裝好了 ,過程發現部分零件拆解後會有座標不對的問題 ,只要將做標調整和world相同就比較容易了 (參照範例: 7 DoF manipulator 設定ik值) 105 - 07/24更新 今天預計要測試馬達控制 ,但是沒有多的12V power supply ,所以先把Onshape ,printer的細部畫一畫 ,現在大概有300個特徵 ,本來可以輕鬆的拉動滑塊 ,現在要用箭頭才能拉動了 ,估計不會畫電路板部分 ,戲偶衣服穿太多了 105 - 07/28更新 暫時利用可變電阻取代步進馬達 ,並加入馬達轉軸 ,控制加熱頭移動 105 - 08/02更新 V-rep定位 在繪圖時 ,需要有一個對稱零件(輔助零件)在vrep內訂定位置 ,在定位之前 ,座標系要先調整 之後將主體設為此零件子屬 定位完之後就可以設為一個群組了","url":"http://project.mde.tw/blog/40323250ri-zhi-v-repshi-zuo-xin-de.html"},{"tags":"2016bg2","title":"40323231日誌 - 105/08/01","text":"網誌更新，列印組合件，觀看新軟體 今天把問題那篇網誌做新增和整理 ，並整理出常用指令一篇。 列印組合件時，孔和外型的公差不太穩定，多次列印出來的公差也都不太一樣，有時會差到20條，還需要做改進和調整。 今天列印需要支撐材的物件時，發現cura會生成很多不必要的支撐材，導致浪費，所以去尋找很多方法，其中有看到新的軟體Meshmixer，它的操作方式很獨特，跟其他3D繪圖軟體不一樣。網路教學讓軟體很多變，像是製作卡扣、拆解物件、填補漏洞、手動生成支撐材......等等，很多好用的功能，可是滿複雜的，還在學習。因為是新的軟體，所以花了比較多時間觀看，明天會把重心拉回來，繼續製作。","url":"http://project.mde.tw/blog/40323231ri-zhi-1050801.html"},{"tags":"2016g1","title":"40323131日誌 105/07/31","text":"手臂的推導角度公式 角度推導公式 先用圖解法解，再來用python-solvespace 來驗證點坐標是否相符 底下是程式碼，可以跑出所有結果 from slvs import * from math import * def arm(degree1, degree2): sys = System(500) g = 1 #原點Point0 p0 = sys.add_param(0.0) p1 = sys.add_param(0.0) p2 = sys.add_param(0.0) Point0 = Point3d(p0, p1, p2) #XY法線 qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0) p3 = sys.add_param(qw) p4 = sys.add_param(qx) p5 = sys.add_param(qy) p6 = sys.add_param(qz) Normal1 = Normal3d(p3, p4, p5, p6) #工作平面 Workplane1 = Workplane(Point0, Normal1) #3D版的Point0=>Point1 p7 = sys.add_param(0.0) p8 = sys.add_param(0.0) Point1 = Point2d(Workplane1, p7, p8) Constraint.dragged(Workplane1, Point1) #Point2 p9 = sys.add_param(10.0) p10 = sys.add_param(10.0) Point2 = Point2d(Workplane1, p9, p10) p11 = sys.add_param(-20.0) p12 = sys.add_param(20.0) Point3 = Point2d(Workplane1, p11, p12) p13 = sys.add_param(-30.0) p14 = sys.add_param(15.0) Point4 = Point2d(Workplane1, p13, p14) p15 = sys.add_param(-40.0) p16 = sys.add_param(10.0) Point5 = Point2d(Workplane1, p15, p16) #基線點 p17 = sys.add_param(10.0) p18 = sys.add_param(0.0) Point6 = Point2d(Workplane1, p17, p18) Constraint.dragged(Workplane1, Point6) Line0 = LineSegment2d(Workplane1, Point1, Point6) Constraint.distance(55, Workplane1, Point1, Point2) Constraint.distance(135, Workplane1, Point2, Point3) Constraint.distance(55, Workplane1, Point3, Point4) Constraint.distance(145, Workplane1, Point4, Point5) Constraint.distance(135, Workplane1, Point4, Point1) Line1 = LineSegment2d(Workplane1, Point1, Point2) Line2 = LineSegment2d(Workplane1, Point3, Point4) Line3 = LineSegment2d(Workplane1, Point1, Point4) Constraint.on(Workplane1, Point5, Line2) Constraint.angle(Workplane1, degree1, Line0, Line3, False) Constraint.angle(Workplane1, degree2, Line0, Line1, False) sys.solve() if (sys.result == SLVS_RESULT_OKAY): print (\"點座標：\") print((\"P5(%.3f %.3f %.3f)\")%(sys.get_param(15).val, sys.get_param(16).val, sys.get_param(2).val)) print((\"P4(%.3f %.3f %.3f)\")%(sys.get_param(13).val, sys.get_param(14).val, sys.get_param(2).val)) #print((\"P3(%.3f %.3f %.3f)\")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val)) #print((\"P2(%.3f %.3f %.3f)\")%(sys.get_param(9).val, sys.get_param(10).val, sys.get_param(2).val)) print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_INCONSISTENT): print (\"solve failed\") print (\"SLVS_RESULT_INCONSISTENT\") print (\"%d DOF\" % sys.dof) for i in range(sys.faileds): print(\" %lu\", sys.failed[i]); elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE): print (\"solve failed\") print (\"SLVS_RESULT_DIDNT_CONVERGE\") print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS): print (\"solve failed\") print (\"SLVS_RESULT_TOO_MANY_UNKNOWNS\") print (\"%d DOF\" % sys.dof) #主程式 #限制範圍內的角度的所有組合 for i in range(90, 151): for j in range(0, 61): print (i,j) arm(i, j) 下圖的連桿是可以跑的最大角度範圍 底下是隨機抓取在限制範圍內的角度 可以從限制範圍的角度裡，去求出點坐標，然後再跑迴圈將所有的點結果列出，然後用matplotlip將路徑畫出來，所以可以求得路徑方程式，然後我是用已知點的坐標，然後去算出 θ2的角度，然後就可以用三角形的關係去求出θ1、θ3。","url":"http://project.mde.tw/blog/40323131ri-zhi-1050731.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/31","text":"新增範例Crank Rocker 倉儲 python-solvespace 已更新 準備整理函式庫內容，再製作英文版副本 Crank Rocker範例 模仿三角形呆鍊的圖形解題。 用迴圈方式旋轉短連桿，讓三角形頂點畫出點座標。 以下程式將輸出每一度畫出的點座標。 #一三角形呆鍊，由一長一短的連桿固定在水平基線上。 #短連桿鎖固在原點上，長連桿鎖固在距原點90mm處。 #短連桿長度35mm；長連桿長度70mm。 #三角形呆鍊邊長分別為40mm、40mm、70mm from slvs import * from math import * import unittest #相關參數 d0 = 90 #基線長度(mm) n1 = 35 #短連桿長度(mm) n2 = 70 #長連桿長度(mm) t1 = 40 #三角形第一邊(mm) t2 = 40 #三角形第二邊(mm) t3 = 70 #三角形第三邊(mm) #開始繪圖 def crank_rock(degree): sys = System(500) g = 1 #原點Point0 p0 = sys.add_param(0.0) p1 = sys.add_param(0.0) p2 = sys.add_param(0.0) Point0 = Point3d(p0, p1, p2) #XY法線 qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0) p3 = sys.add_param(qw) p4 = sys.add_param(qx) p5 = sys.add_param(qy) p6 = sys.add_param(qz) Normal1 = Normal3d(p3, p4, p5, p6) #工作平面 Workplane1 = Workplane(Point0, Normal1) #3D版的Point0=>Point1 p7 = sys.add_param(0.0) p8 = sys.add_param(0.0) Point1 = Point2d(Workplane1, p7, p8) Constraint.dragged(Workplane1, Point1) #長連桿轉軸Point2，還有基線Line0。 p9 = sys.add_param(d0) p10 = sys.add_param(0.0) Point2 = Point2d(Workplane1, p9, p10) Constraint.dragged(Workplane1, Point2) Line0 = LineSegment2d(Workplane1, Point1, Point2) #Angle約束判斷 if degree >= 180: other = -1 else: other = 1 #三角形Point3 / Point4 / Point5 p11 = sys.add_param(20.0) p12 = sys.add_param(20.0) Point3 = Point2d(Workplane1, p11, p12) p13 = sys.add_param(0.0) p14 = sys.add_param(10.0*other) Point4 = Point2d(Workplane1, p13, p14) p15 = sys.add_param(30.0) p16 = sys.add_param(20.0) Point5 = Point2d(Workplane1, p15, p16) Constraint.distance(t1, Workplane1, Point4, Point3) Constraint.distance(t2, Workplane1, Point3, Point5) Constraint.distance(t3, Workplane1, Point4, Point5) #連桿約束 Constraint.distance(n1, Workplane1, Point1, Point4) Constraint.distance(n2, Workplane1, Point2, Point5) Line1 = LineSegment2d(Workplane1, Point1, Point4) #短連桿與水平軸的角度 Constraint.angle(Workplane1, degree, Line1, Line0, False) #以下解題 sys.solve() if (sys.result == SLVS_RESULT_OKAY): print (\"點座標：\") print((\"P3(%.3f %.3f %.3f)\")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val)) print((\"P4(%.3f %.3f %.3f)\")%(sys.get_param(13).val, sys.get_param(14).val, sys.get_param(2).val)) print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_INCONSISTENT): print (\"solve failed\") print (\"SLVS_RESULT_INCONSISTENT\") print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE): print (\"solve failed\") print (\"SLVS_RESULT_DIDNT_CONVERGE\") print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS): print (\"solve failed\") print (\"SLVS_RESULT_TOO_MANY_UNKNOWNS\") print (\"%d DOF\" % sys.dof) #主程式 for i in range(0, 360): print (\"Degree: %3s deg\"%(i)) crank_rock(i) print (\"=======\") print (\"Solve Completed\") 輸出結果圖： 圖解法： 這次旋轉的時候，角度約束似乎無法支援超過180度的角度，而會使用正值，讓原本在第一二象限的點 Point4 座標無法移動至第三四象限。 因此在起始定點時的象限位置非常重要，加入了 if 判斷式讓 Point4 更改初始位置，就解決了這個問題。 只有用來畫線，且線段有約束角度的點座標有限制。 另一個要注意的是，要約束成三角形的三個點不可以共線。 以下是正確值比對： 0° 45° 135° 180° 225° 解了多個圖形題目後，發現之前寫的那篇還滿不容易查詢資料，而且前作者的內容有些錯誤。 由於當初紀錄是靠 DOC.txt 的順序寫的，所以要自己重新閱讀多次，將使用比例分配一下。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050731.html"},{"tags":"2016bg2","title":"40323231 -3DP注意事項","text":"注意事項 一.固件安裝 : 1.鎖固個螺絲時請依循鎖固方向(對角或順逆時鐘)，而且不要一次就鎖緊，分兩次至三次，避免不平或無法微調 2.安裝滑塊時請勿推出滑軌外，避免滑塊內的滾珠掉出 3.鎖固滑塊上用來控制限位的螺絲時，不要鎖太裡面，避免限位開關接收不到訊號，導致撞機，或者校機時無法做調整(圖.A) 4.安裝喉管和噴頭塊以及噴嘴時一定要確定鎖緊，不然可能會有液料或漏料的問題(圖.B) 5.安裝噴頭塊時不要直接接觸噴頭座，避免噴頭座過熱(圖.C) 6.安裝擠出機時不要將料壓得太緊，避免進料不順 7.安裝位於噴頭座上方的鐵氟龍管時，要量測插入的深度，以免列印時喉管堵塞 8.安裝料和鐵氟龍管時可將前端剪成斜狀，方便安裝和進料 9.安裝加熱棒時，請置中洞中，勿太裡面或太外面，以免加熱不確實，或加熱到其他地方(圖.D) 10.安裝皮帶上面的固定鎖時勿一開始就鎖到緊，避免皮帶太鬆時無法做調整(圖.E) (圖.A) (圖.B) (圖.C) (圖.D) (圖.E) 二.配電 : 1.裸露的線要用熱縮管(套到需要的地方後用打火機讓館子收縮即可)或者PVC電氣絕緣膠帶包覆 2.delta機型的噴頭上所有的線用捲束管包覆，避免電線纏繞打結或扯斷 3.鐵氟龍管以及噴頭上方的電線長度要夠長，避免噴頭到最下方時被扯斷或撞機 4.控制板上所有電線都需整線，避免內部過熱燒毀 三.測機 : 切記:如發生意外，請迅速切斷電源，切斷後不要立即開啟電源，請先關閉軟體的訊號，之後再做開電的動作，避免開電後訊號依 舊在，導致機台繼續損壞。 切記:要跑動X、Y方向時噴頭高度不能在最高點，不然機台可能損壞 切記:列印機與電腦操控軟體(如:pronterface)連接後務必G28原點複歸 1.要確定三軸速度不要太高，避免回歸或者移動速度太快 2.確定訊號為多少(250000或其他) 3.確定噴頭高度(程式) 4.不要把列印範圍(平台大小)設最大，因為噴頭座可能會撞到各軸，或跑出外面導致列印品質低 5.要確定限位開關是否有作用 6.要下降Z方向時要注意高度，G1 Z20，避免撞機 7.確定XYZ和擠出軸轉向是否正常 8.跑動X、Y方向時噴頭高度不要靠近熱床，因為跑動時可能是碗公型，可能會撞擊熱床 四.列印 : 1.務必檢查列印成品是否超過列印大小 2.列印前請用口紅膠或特定膠帶弄在熱床上，可避免列印時材料不能貼緊熱床 3.前幾次列印請注意列印狀況以及擠料狀況(跳線、擠不進去等等)","url":"http://project.mde.tw/blog/40323231-3dpzhu-yi-shi-xiang.html"},{"tags":"2016g1","title":"python3 Vrep control","text":"製作控制介面，控制虛擬端的Vrep 使用Tkinter 由4023250做出的控制方法，將他改寫成class呼叫的方法，以便未來的開發方便，接下來會針對，手臂的控制下去寫，opencv部分可能要等第三組，稍微有點進度再開始，目前主要就是使用python3去控制我們的機械手臂，將外部和內部同動，利用自己寫的控制介面，讓未來學弟妹也可以使用。 會將控制手臂的程式和方法放在這個倉儲 https://github.com/smpss91341/Vrep_python3_control import matplotlib matplotlib.use(\"TkAgg\") from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg,NavigationToolbar2TkAgg from matplotlib.figure import Figure import matplotlib.animation as animation from matplotlib import style import numpy as np import tkinter as tk from tkinter import ttk from matplotlib import pyplot, rcParams import serial import sys import vrep LARGE_FONT = (\"Verdana\",12) style.use(\"ggplot\") f = Figure(figsize = (5,5),dpi = 100) a = f.add_subplot(111) #def animate(i): # pullData = open(\"sampleData.txt\",\"r\").read() # dataList = pullData.split('\\n') # xList = [] # yList = [] # for eachLine in dataList: # if len(eachLine)>1: # x, y = eachLine.split(',') # xList.append(int(x)) # yList.append(int(y)) # a.clear() # a.plot(xList,yList) class Seaofbt(tk.Tk): def __init__(self, *args, **kwargs): #程式執行時先預載入的參數或者動作 tk.Tk.__init__(self, *args, **kwargs) # tk.Tk.iconbitmap(self,default = \"client.ico\") 改變左上角的圖示 tk.Tk.wm_title(self,\"My works\") container = tk.Frame(self) container.pack(side=\"top\",fill=\"both\",expand = True) container.grid_rowconfigure(0,weigh=1) container.grid_columnconfigure(0,weigh=1) self.frames = {} for F in (StartPage, PageOne,PageTwo,PageThree): frame = F(container,self) self.frames[F] = frame frame.grid(row=0, column = 0, sticky=\"nsew\") self.show_frame(StartPage) def show_frame(self,cont): frame = self.frames[cont] frame.tkraise() def qf(param): print(param) class StartPage(tk.Frame): def __init__(self,parent,controller): tk.Frame.__init__(self,parent) label = tk.Label(self,text=\"PageOne\",font = LARGE_FONT) label.pack(pady = 10,padx = 10) button1 = ttk.Button(self,text = \"Visit Page 1\", command = lambda: controller.show_frame(PageOne)) button1.pack() button2 = ttk.Button(self,text = \"Visit Page 2\", command = lambda: controller.show_frame(PageTwo)) button2.pack() button3 = ttk.Button(self,text = \"Graph Page\", command = lambda: controller.show_frame(PageThree)) button3.pack() class PageOne(tk.Frame): def __init__(self,parent,controller): tk.Frame.__init__(self,parent) label = tk.Label(self,text=\"Start Page\",font = LARGE_FONT) label.pack(pady = 10,padx = 10) button1 = ttk.Button(self,text = \"Back to Home\", command = lambda: controller.show_frame(StartPage)) button1.pack() button2 = ttk.Button(self,text = \"Visit Page2\", command = lambda: controller.show_frame(PageTwo)) button2.pack() class PageTwo(tk.Frame): def __init__(self, parent,controller): tk.Frame.__init__(self, parent) self.createWidgets() self.getNumber1 = 0 self.getNumber2 = 0 self.getNumber3 = 0 label1 = tk.Label(self,text=\"\").grid(column=0, row=1) label2 = tk.Label(self,text=\"X\").grid(column=0, row=2) label3 = tk.Label(self,text=\"\").grid(column=0, row=3) label4 = tk.Label(self,text=\"Y\").grid(column=0, row=4) label5 = tk.Label(self,text=\"\").grid(column=0, row=5) label6 = tk.Label(self,text=\"Z\").grid(column=0, row=6) button1 = ttk.Button(self,text = \"Back\", command = lambda: controller.show_frame(StartPage)) button1.grid(row = 20,column = 3) button2 = ttk.Button(self, text='Quit', width=5, command=self.quit) button2.grid(row = 20,column = 2) button3 = ttk.Button(self, text='Go', width=5, command =lambda:self.show_entry_fields()) button3.grid(row = 20,column = 1) def createWidgets(self): self.entry1 = tk.Entry(self) self.entry1[\"width\"] = 12 self.entry1.grid(row=2, column=1) self.entry2 = tk.Entry(self) self.entry2[\"width\"] = 12 self.entry2.grid(row=4, column=1) self.entry3 = tk.Entry(self) self.entry3[\"width\"] = 12 self.entry3.grid(row=6, column=1) def show_entry_fields(self): self.getNumber1 = self.entry1.get() self.getNumber2 = self.entry2.get() self.getNumber3 = self.entry3.get() x = self.getNumber1 y = self.getNumber2 z = self.getNumber3 if x =='' or y==''or z =='': x = 0 y = 0 z = 0 print(\"Error\") else: x = float(self.getNumber1) y = float(self.getNumber2) z = float(self.getNumber3) if float(x) >= 100: # set x&y;&z; limit x = 100 if float(y) >= 100: y = 100 if float(z) >= 400: z = 400 if float(x) <= -100: x = -100 if float(y) <= -100: y = -100 if float(z) <= 0: z = 0 e=x/1222 r=y/1222 t=z/889 if t <= 0.11656: t = t+0.11656 vrep.simxFinish(-1) clientID = vrep.simxStart('127.0.0.1', 19999, True, True, 5000, 5) if clientID!= -1: print(\"Connected to remote server\") else: print('Connection not successful') sys.exit('Could not connect') errorCode,plate=vrep.simxGetObjectHandle(clientID,'plate',vrep.simx_opmode_oneshot_wait) if errorCode == -1: print('Can not find left or right motor') sys.exit() errorCode=vrep.simxSetObjectPosition(clientID,plate,-1,[e,r,t], vrep.simx_opmode_oneshot) print(x,y,z) class PageThree(tk.Frame): def __init__(self,parent,controller): tk.Frame.__init__(self,parent) label = tk.Label(self,text=\"Graph Pages\",font = LARGE_FONT) label.pack(pady = 10,padx = 10) button1 = ttk.Button(self,text = \"Back to Home\", command = lambda: controller.show_frame(StartPage)) button1.pack() #f = Figure(figsize = (5,5),dpi = 100) #a = f.add_subplot(111) #a.plot([1,2,3,4,5,6,7,8],[5,6,1,3,8,9,3,5]) canvas = FigureCanvasTkAgg(f,self) canvas.show() canvas.get_tk_widget().pack(side=tk.TOP , fill=tk.BOTH,expand=True) toolbar = NavigationToolbar2TkAgg(canvas,self) toolbar.update() canvas._tkcanvas.pack(side = tk.TOP,fill = tk.BOTH,expand =True) app = Seaofbt() #ani = animation.FuncAnimation(f,animate,interval = 1000) app.mainloop()","url":"http://project.mde.tw/blog/python3-vrep-control.html"},{"tags":"2016bg2","title":"40323250日誌 - V-rep & 3D-Printer","text":"之後的 V-rep模擬Printer都整理於本文章中 透過Tkinter介面及remote api 控制printer參數 程式碼 from tkinter import * import serial import sys import numpy as np from matplotlib import pyplot, rcParams import vrep import math class printer(Frame): def __init__(self, master=None): Frame.__init__(self, master) self.grid() self.createWidgets() def createWidgets(self): Label(pri, text=\"Axis\").grid(column=0, row=0) Label(pri, text=\"\").grid(column=0, row=1) Label(pri, text=\"X\").grid(column=0, row=2) Label(pri, text=\"\").grid(column=0, row=3) Label(pri, text=\"Y\").grid(column=0, row=4) Label(pri, text=\"\").grid(column=0, row=5) Label(pri, text=\"Z\").grid(column=0, row=6) Label(pri, text=\"Position\").grid(column=1, row=0) Label(pri, text=\"-125<=X<=125\").grid(column=1, row=1) Label(pri, text=\"-125<=Y<=125\").grid(column=1, row=3) Label(pri, text=\"0<=Z<=400\").grid(column=1, row=5) a = Entry(pri, width=12, justify=RIGHT) b = Entry(pri, width=12, justify=RIGHT) c = Entry(pri, width=12, justify=RIGHT) #x.delete(0,END) #y.delete(0,END) a.grid(row=2, column=1) b.grid(row=4, column=1) c.grid(row=6, column=1) def show_entry_fields(): deg = math.pi/180 x = a.get() y = b.get() z = c.get() if x =='' or y==''or z =='': x = 0 y = 0 z = 0 print(\"Error\") else: x = float(a.get()) y = float(b.get()) z = float(c.get()) if float(x) >= 125: x = 125 print(\"X_axis is out of range\") if float(y) >= 125: y = 125 print(\"Y_axis is out of range\") if float(z) >= 400: z = 400 print(\"Z_axis is out of range\") if float(x) <= -125: x = -125 print(\"X_axis is out of range\") if float(y) <= -125: y = -125 print(\"Y_axis is out of range\") if float(z) < 0: z = 0 print(\"Z_axis is out of range\") if (float(x) <= -125*math.sin(30*deg)) & (float(y) >= 125*math.cos(30*deg)): x = -125*math.sin(30*deg) y = 125*math.cos(30*deg) if (float(x) <= -125*math.sin(30*deg)) & (float(y) <= -125*math.cos(30*deg)): x = -125*math.sin(30*deg) y = -125*math.cos(30*deg) if (float(x) >= 125*math.sin(30*deg)) & (float(y) >= 125*math.cos(30*deg)): x = 125*math.sin(30*deg) y = 125*math.cos(30*deg) if (float(x) >= -125*math.sin(30*deg)) & (float(y) <= -125*math.cos(30*deg)): x = 125*math.sin(30*deg) y = -125*math.cos(30*deg) e=x/1000 r=y/1000 t=z/889 if t <= 0.11656: t = t+0.11656 vrep.simxFinish(-1) clientID = vrep.simxStart('127.0.0.1', 19999, True, True, 5000, 5) if clientID!= -1: print(\"Connected to remote server\") else: print('Connection not successful') sys.exit('Could not connect') errorCode,plate=vrep.simxGetObjectHandle(clientID,'plate',vrep.simx_opmode_oneshot_wait) if errorCode == -1: print('Can not find left or right motor') sys.exit() errorCode=vrep.simxSetObjectPosition(clientID,plate,-1,[e,r,t], vrep.simx_opmode_oneshot) print(x,y,z) #print(\"%s,%s,%s\" % (x, y, z)) Button(pri, text='Quit', width=5, command=pri.quit).grid(row=8, column=2, sticky=W, pady=4) Button(pri, text='Go', width=5, command=show_entry_fields).grid(row=8, column=0, sticky=W, pady=4) if __name__ == '__main__': pri = Tk() pri.title(\"Printer\") pri.geometry('180x220'); #設定視窗大小 pri.resizable(0, 0) #鎖定視窗大小 app = printer(master=pri) app.mainloop() #print(x,y,z) printer_final.ttt","url":"http://project.mde.tw/blog/40323250ri-zhi-v-rep-3d-printer.html"},{"tags":"2016bg2","title":"40323231日誌 - 105/07/30","text":"3DP維修 今天維修3DP，因為3DP擠出的料變得非常的少，導致成品稀疏和脆弱，而且還發現進料馬達有在旋轉，可是料卻擠不進去。 一開始先加熱之後開始清理喉管，清完後校機重新印製，可是情況還是一樣，再來我改變進料速度(80%.60%)，可是依舊如此。 再來將噴頭座整組拔出，測量鐵氟龍管插入喉管的深度和全新的做比較，發現深度差很多因此用燈照進去，發現有整塊白色的硬塊堵住，所以又加熱再拿尖銳物將裡面清空，並重新測量鐵氟龍管插入深度，確定可以後校機再重新印製，情況還是一樣，之後加熱更換噴頭，弄完校機後再印製，情況有所改善，可是進料有時候料會擠不進去，所以更改進料速度(最新值:65%)，現在情況已經穩定，印出的公差也調整過，公差在+4條。 列印兩次後發現噴頭座有部分地方會有液料情況，重新鎖固鎖緊後就OK。(重組後須檢查是否鎖緊。) 拆卸下來的噴頭需要用0.3大小的鑽頭去清理，還需要討論要怎麼處理噴頭。","url":"http://project.mde.tw/blog/40323231ri-zhi-1050730.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/30","text":"新增範例Nutcraker 倉儲 python-solvespace 已更新 Nutcraker範例 #行程解題解題：兩個長1.5mm、2.3mm的連桿，在一直線上作動。 #原點的基座塊比工作路徑高0.5mm，寬0.75mm（占用0.38mm）。 #底線距離基座面3.25mm。 #2.3mm的連桿寬0.25mm，半圓頭。 #求最小行程（2.3mm的連桿與基座接觸）。 #求最大行程（半圓頭與底線接觸）。 from slvs import * from math import * sys = System(500) g = 1 #相關參數 h0 = 0.5 #基塊高度(mm) b0 = 0.75 #基塊寬度(mm) n1 = 1.5 #後連桿長度(mm) n2 = 2.3 #前連桿長度(mm) R0 = 0.25 #半圓頭半徑(mm) L0 = 3.25 #底線距離(mm) #開始繪圖 #原點Point0 p0 = sys.add_param(0.0) p1 = sys.add_param(0.0) p2 = sys.add_param(0.0) Point0 = Point3d(p0, p1, p2) #XY法線 qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0) p3 = sys.add_param(qw) p4 = sys.add_param(qx) p5 = sys.add_param(qy) p6 = sys.add_param(qz) Normal1 = Normal3d(p3, p4, p5, p6) #工作平面 Workplane1 = Workplane(Point0, Normal1) #3D版的Point0=>Point1 p7 = sys.add_param(0.0) p8 = sys.add_param(0.0) Point1 = Point2d(Workplane1, p7, p8) Constraint.dragged(Workplane1, Point1) #連桿中繼點Point2和行程點Point3 p9 = sys.add_param(2.0) p10 = sys.add_param(2.0) Point2 = Point2d(Workplane1, p9, p10) p11 = sys.add_param(2.0) p12 = sys.add_param(0.0) Point3 = Point2d(Workplane1, p11, p12) Line0 = LineSegment2d(Workplane1, Point1, Point3) Constraint.horizontal(Workplane1, Line0) #前連桿碰到基座 Line1 = LineSegment2d(Workplane1, Point2, Point3) p13 = sys.add_param(b0/2) p14 = sys.add_param(h0) Point4 = Point2d(Workplane1, p13, p14) Constraint.dragged(Workplane1, Point4) #必須鎖住已知點 Constraint.distance(R0, Workplane1, Point4, Line1) Constraint.distance(n1, Workplane1, Point1, Point2) Constraint.distance(n2, Workplane1, Point2, Point3) #以下解題 sys.solve() Ansmin = sys.get_param(11).val - b0/2 Ansmax = L0 - R0 - b0/2 if (sys.result == SLVS_RESULT_OKAY): print (\"點座標：\") print((\"P1(%.3f %.3f %.3f)\")%(sys.get_param(7).val, sys.get_param(8).val, sys.get_param(2).val)) print(\"P1(0.000 0.000 0.000)\") print((\"P2(%.3f %.3f %.3f)\")%(sys.get_param(9).val, sys.get_param(10).val, sys.get_param(2).val)) print(\"P2(-0.400 1.450 0.000)\") print((\"P3(%.3f %.3f %.3f)\")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val)) print(\"P4(1.390 0.000 0.000)\\n\") print(\"Min:\") print((\"(%.3f)\")%(Ansmin)) print(\"Max:\") print((\"(%.3f)\")%(Ansmax)) print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_INCONSISTENT): print (\"solve failed\") print (\"SLVS_RESULT_INCONSISTENT\") print (\"%d DOF\" % sys.dof) for i in range(sys.faileds): print(\" %lu\", sys.failed[i]); elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE): print (\"solve failed\") print (\"SLVS_RESULT_DIDNT_CONVERGE\") print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS): print (\"solve failed\") print (\"SLVS_RESULT_TOO_MANY_UNKNOWNS\") print (\"%d DOF\" % sys.dof) 解題結果： Nutcracker只有單純的連桿，非常簡單。 而之前的題目有相切約束，Solvespace解這種會有極限的約束都十分不便，常常會出現約束衝突或是正負不分的狀況。 目前還不知道如何解決，只能多注意圓弧曲線的地方，可以用距離約束取代的地方就盡量不用額外輔助線。 倉儲中嵌入副模組 在倉儲中加入了BBBSnowball的模組SolidPython，不過不知道怎麼用。 git submodule add https://github.com/BBBSnowball/SolidPython.git solid-python 應該只是單純放著支援功能。 之前\"SLVS資料庫函式\"那篇還需要檢查一下，或是做一個英文版副本連結到倉儲Readme。 雖然轉到Python介面中不只那些指令，但是只靠這些指令就能解題目了。 進階應用如切換群組等，稍微看一下原本的範例code或CDemo的原始碼應該就能瞭解。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050730.html"},{"tags":"2016g1","title":"手臂的順向推導","text":"推導機械手臂的座標方程式 手臂順向方程式 順(正)向運動學 由各軸狀態推導出末端位置。 根據我們使用的手臂，是使用二連桿的X Y，利用Solvespace畫出連桿機構，目前只考慮抓取這個動作的，不考慮左右旋轉。 連桿L1、L2長度為constant L1 = 135 mm L2 = 145 mm θ = 90 - servo1 所輸入的角度 θ3 = servo2 所旋轉的角度 X = L1 * cos(θ) + L2 * cos(θ3) Y = L1 * sin(θ) - L2 * sin(θ3) 可以由我們計算出角度，輸入後得到對應的XY位置，進行夾取的動作 目前自動化這部分的進度 流程入下: 1.上傳檔案 2.進行列印 3.縮時攝影 4.列印完成 5.printer復歸位置 6.另一台控制器影像辨識 7.當判斷成功後，計算出位置，輸入相對應的值控制手臂 8.夾取後，退出機台平台，將料放置指定的盒子 9.發送訊息到客戶端顯示列印完成","url":"http://project.mde.tw/blog/shou-bi-de-shun-xiang-tui-dao.html"},{"tags":"Tutorial","title":"yen - 有關機械設計專題網站內容","text":"本機械設計專題網誌採用 Leo Editor 管理文章內容與設定, 並且透過 Pelican 靜態網誌系統程式, 將各參與協同人員所分別建立的 .md 檔案, 轉為一系列的 html 檔案, 其中包括全文內容的搜尋, 以及網誌分類的架構. 假如您檢視現在這篇文章的 .md 檔案, 在文章最前頭的內容為: Title: yen - 有關機械設計專題網站內容 Date: 2016-07-27 11:29 Category: Tutorial Tags: Pelican, 文章日期 Author: yen 表示這篇文章的標題, 建立日期, 類別, 標籤與作者名稱, 因為我們先前採用的 Pelican 近端與遠端的 DEFAULT_DATE 設定, 將原先的 None, 改為 'fs', 表示若使用者所提供的 Markdown 文章中, 沒有 Date: 時間註記, 那麼系統就會直接採用 file system 的檔案存檔時間作為文章的 Date. 但是就實務應用的觀點, 各用戶一旦 git clone 本倉儲內容, 或者在操作系統中搬動或複製倉儲檔案, 而沒能利用像 cp -p 這種可以保留原始檔案建立時間的指令, 整個倉儲的 .md 檔案就會隨著不同操作流程, 而讓網誌的文章順序變來變去, 從讀者的角度來看, 我們應該要加以解決這個問題. 解決的方法很簡單, 我們仍然保留原先近端與遠端 DEFAULT_DATE = 'fs' 的設定, 也就是若使用者的文章沒有 Date: 註記, 就仍舊採用該 .md 檔案的建立時間作為文章登錄的時間 ,但是若使用者的 .md 檔案提供了 Date: 註記, 那麼就以註記的時間作為文章建立時間. 好了, 接下來就是要求所有參與協同的作者, 在各自的文章標題後面, 加上 Date:, 而格式則是 Date: 2016-07-27 11:29, 一旦所有的文章都各自標註建立的確切時間, 之後所產生的機械設計專題網誌文章順序, 應該就不會再變來變去了. 當然, 我們為了要讓現在這篇文章能夠放在網誌的最上頭幾天, 我們把它註記為三天後的時間.","url":"http://project.mde.tw/blog/yen-you-guan-ji-jie-she-ji-zhuan-ti-wang-zhan-nei-rong.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/29","text":"CDemo資料庫內容補正 倉儲 python-solvespace 已更新 資料庫解題成功 修復內容 使用修復過的資料庫內容解題，新增將近三分之一的對應函式。 這些函式中也包括需要的相切約束。 由於這些函式都未有對應名稱，所以都是自己編名的，例如 equal_angle( ) 。 解題成功 使用的是下列程式碼，在SciTE中解題成功： #鍊條解題：18齒與30齒的鏈條，上下外切線長為200。 #小圓圓心為原點，大圓圓心在X軸上，求四個切點的座標 from slvs import * from math import * sys = System(500) g = 1 #相關參數 n0 = 20 #鍊條長度(mm) n1 = 18 #小輪齒數(t) n2 = 30 #大輪齒數(t) #邊長為a的的正n邊形外接圓半徑為： #R=a/(2*sin(pi/n)) or R=(a/2)*csc(pi/n) R1 = n0/(2*sin(pi/n1)) R2 = n0/(2*sin(pi/n2)) #開始繪圖 #原點Point0 p0 = sys.add_param(0.0) p1 = sys.add_param(0.0) p2 = sys.add_param(0.0) Point0 = Point3d(p0, p1, p2) #XY法線 qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0) p3 = sys.add_param(qw) p4 = sys.add_param(qx) p5 = sys.add_param(qy) p6 = sys.add_param(qz) Normal1 = Normal3d(p3, p4, p5, p6) #工作平面 Workplane1 = Workplane(Point0, Normal1) #3D版的Point0=>Point1 p7 = sys.add_param(0.0) p8 = sys.add_param(0.0) Point1 = Point2d(Workplane1, p7, p8) Constraint.dragged(Workplane1, Point1) #Point2 p9 = sys.add_param(0.0) p10 = sys.add_param(200.0) Point2 = Point2d(Workplane1, p9, p10) #上端外切線的兩個點Point3和Point4 p11 = sys.add_param(0.0) p12 = sys.add_param(500.0) Point3 = Point2d(Workplane1, p11, p12) p13 = sys.add_param(500.0) p14 = sys.add_param(500.0) Point4 = Point2d(Workplane1, p13, p14) #下端外切線的兩個點Point5和Point6 p15 = sys.add_param(0.0) p16 = sys.add_param(-500.0) Point5 = Point2d(Workplane1, p15, p16) p17 = sys.add_param(500.0) p18 = sys.add_param(-500.0) Point6 = Point2d(Workplane1, p17, p18) #外切線 Line1 = LineSegment2d(Workplane1, Point3, Point4) Line2 = LineSegment2d(Workplane1, Point5, Point6) #圓弧 Arc1 = ArcOfCircle(Workplane1, Normal1, Point1, Point3, Point5) Constraint.diameter(R1*2, Workplane1, Arc1) Arc2 = ArcOfCircle(Workplane1, Normal1, Point2, Point6, Point4) Constraint.diameter(R2*2, Workplane1, Arc2) #X軸Line0 Line0 = LineSegment2d(Workplane1, Point1, Point2) Constraint.horizontal(Workplane1, Line0) #約束 Constraint.tangent(Arc1, Line1, False) Constraint.tangent(Arc2, Line1, False) Constraint.tangent(Arc2, Line2, True) Constraint.distance(200.0, Workplane1, Point3, Point4) #以下解題 sys.solve() if (sys.result == SLVS_RESULT_OKAY): print (\"兩點座標：\") print((\"(%.3f %.3f %.3f)\")%(sys.get_param(7).val, sys.get_param(8).val, sys.get_param(2).val)) print((\"(%.3f %.3f %.3f)\\n\")%(sys.get_param(9).val, sys.get_param(10).val, sys.get_param(2).val)) print (\"上切點座標：\") print((\"(%.3f %.3f %.3f)\")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val)) print(\"(-10.770 56.570 0.000)\") print((\"(%.3f %.3f %.3f)\")%(sys.get_param(13).val, sys.get_param(14).val, sys.get_param(2).val)) print(\"(185.700 93.980 0.000)\\n\") print (\"下切點座標：\") print((\"(%.3f %.3f %.3f)\")%(sys.get_param(15).val, sys.get_param(16).val, sys.get_param(2).val)) print(\"(-10.770 -56.570 0.000)\") print((\"(%.3f %.3f %.3f)\")%(sys.get_param(17).val, sys.get_param(18).val, sys.get_param(2).val)) print(\"(185.700 -93.98 0.000)\\n\") print (\"導入函數測試：\") print (\"R1：\") print(R1) print (\"R2：\") print(R2) print (\"pi：\") print(pi) print (\"%d DOF\" % sys.dof) elif (sys.result == SLVS_RESULT_INCONSISTENT): print (\"solve failed\") print (\"SLVS_RESULT_INCONSISTENT\") print (\"%d DOF\" % sys.dof) for i in range(sys.faileds): print(\" %lu\", sys.failed[i]); elif (sys.result == SLVS_RESULT_DIDNT_CONVERGE): print (\"solve failed\") print (\"SLVS_RESULT_DIDNT_CONVERGE\") print (\"%d DOF\" % sys.dof) for i in range(sys.faileds): print(\" %lu\", sys.failed[i]); elif (sys.result == SLVS_RESULT_TOO_MANY_UNKNOWNS): print (\"solve failed\") print (\"SLVS_RESULT_TOO_MANY_UNKNOWNS\") print (\"%d DOF\" % sys.dof) 弧與直線相切的函式只能鎖住一頭（布林值調整鎖住頭或尾），所以要下兩次。 不過由於Solvespace對約束的要求十分嚴謹，所以只要下了衝突約束或是重複約束，前者會顯示 SLVS_RESULT_INCONSISTENT ，後者會顯示 SLVS_RESULT_DIDNT_CONVERGE ，就得重新檢查寫的程式。 以下是圖解法比對（其實已經記錄在上面的程式中供比對），兩者使用的資料庫函式應該是一樣的。 結果是零誤差。 以下是SciTE的顯示結果，較上方的是Python運算的結果。 使用這個函式庫非常簡單，跟在Solvespace上畫圖一樣。 先設定起始值後，利用約束調整這些值（而且可以將固定值鎖住），確定之後就能算出答案。 第一次使用自己寫的介面，由於以熟悉它們的從屬關係和解題公式，所以用起來十分上手。 這個函式庫最大的缺點應該是取值不太方便吧，雖然仍可以使用自己命名或是直接內嵌進函式中，可是取值時是按照註冊順序取的，所以養成輸入值時給編號比較不容易亂掉。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050729.html"},{"tags":"2016g1","title":"machine Arm","text":"今天製作的手臂用到樹莓派加上一塊台灣沒有賣的擴充板，走兩個I2C控制16個PWM訊號，走額外的電源供應器，利用這樣的系統可以使用Raspberry pi 的GPIO控制，控制機械手臂，目前用I2C的方式控制 https://www.adafruit.com/product/2327 目前還在摸索控制方法，希望接下來可以配合影像辨識，將自動下料的部份做好，原本規劃利用Octopi，進行控制，可是就目前進度，我們還沒拆開他的那包，還沒辦法寫自己的功能，現在想要用影像的方式辨認目標，然後夾取。 底下為control的程式 #!/usr/bin/python from Adafruit_PWM_Servo_Driver import PWM import time # Initialise the PWM device using the default address pwm = PWM(0x40) # Note if you'd like more debug output you can instead run: #pwm = PWM(0x40, debug=True) servoMin = 150 # Min pulse length out of 4096 servoMax = 600 # Max pulse length out of 4096 def setServoPulse(channel, pulse): pulseLength = 1000000 # 1,000,000 us per second pulseLength /= 60 # 60 Hz print \"%d us per period\" % pulseLength pulseLength /= 4096 # 12 bits of resolution print \"%d us per bit\" % pulseLength pulse *= 1000 pulse /= pulseLength pwm.setPWM(channel, 0, pulse) pwm.setPWMFreq(60) # Set frequency to 60 Hz while (True): # Change speed of continuous servo on channel O pwm.setPWM(0, 0, servoMin) time.sleep(1) pwm.setPWM(0, 0, servoMax) time.sleep(1)","url":"http://project.mde.tw/blog/machine-arm.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/28","text":"CDemo資料庫內容補正 倉儲 python-solvespace 已更新 未支援項目 ＊某些項目未紀錄於DOC.exe中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 SLVS_C_PT_FACE_DISTANCE SLVS_C_PT_ON_FACE SLVS_C_LENGTH_RATIO SLVS_C_EQ_LEN_PT_LINE_D SLVS_C_EQ_PT_LN_DISTANCES SLVS_C_EQUAL_ANGLE SLVS_C_EQUAL_LINE_ARC_LEN SLVS_C_SYMMETRIC SLVS_C_SYMMETRIC_HORIZ SLVS_C_SYMMETRIC_VERT SLVS_C_SYMMETRIC_LINE SLVS_C_AT_MIDPOINT SLVS_C_SAME_ORIENTATION SLVS_C_ANGLE SLVS_C_PARALLEL SLVS_C_PERPENDICULAR SLVS_C_ARC_LINE_TANGENT SLVS_C_CUBIC_LINE_TANGENT SLVS_C_PROJ_PT_DISTANCE SLVS_C_WHERE_DRAGGED SLVS_C_CURVE_CURVE_TANGENT 今天編譯完 slvs_python.hpp ，並推送至倉儲 python-solvespace 。 因為大部分都是強硬約束的關係，只測試過部分功能。 編譯流程 使用Netbeans編譯 slvs_python.hpp 和 slvs.i ，旁邊的 constrainteq.cpp 供參考函式。 slvs.i class Constraint { Constraint(); public: ... static Constraint some_other_constraint( System* system, int type, Workplane workplane, double value, Point ptA, Point ptB, Entity entityA, Entity entityB, Slvs_hGroup group = USE_DEFAULT_GROUP); 標準的約束條件格式如上，其實所有的約束函式都是透過 slvs_python.hpp 輸入 constrainteq.cpp 的約束做計算。 slvs_python.hpp class Constraint { ... public: static Constraint some_other_constraint( System* system, int type, Workplane workplane, double value, Point ptA, Point ptB, Entity entityA, Entity entityB, Slvs_hGroup group = USE_DEFAULT_GROUP) { return init(system, Slvs_MakeConstraint( 0, group, type, workplane.handle(), value, ptA.handle(), ptB.handle(), entityA.handle(), entityB.handle())); } ... 但是由於約束 SLVS_C_EQUAL_ANGLE 會用到四個Entity，預設只有開啟2個，另外的 EntityC 、 EntityD 沒有開啟，而相切約束需要的布林值 other 和 other2 亦沒有加入。 所以只能從 slvs.h 添加這4個值。 其他項目也要加上4個空位，以免出錯。 對照 constrainteq.cpp 中需要的項目，在 slvs_python.hpp 中填上需要的值的類型，應該就可以運作了。 測試了一些新加入的約束，如果 slvs_python.hpp 中填上的類型正確，就會解題，不過「重複約束」的結果似乎是歸類在「過度約束」裡。 而如果本身類型填錯，就會回傳錯誤碼 -1 。 但是函式庫中只有 SLVS_C_WHERE_DRAGGED 會抓住點（而且還是有移動量），還要研究一下如何鎖住這些點的位置。 今天幫忙編寫CDemo，使其擁有Solvespace全部約束的功能。 會找時間翻修一下之前的紀錄。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050728.html"},{"tags":"Misc","title":"yen - 我們為何要全盤托出研究成果?","text":"不知道您有沒有發現, 您可以在 https://github.com/coursemdetw/project_site 下載本機械設計專題網誌相關的所有資料, 其中包括許多我們竭盡全力悟出的知識與技巧. 我們為何要這樣做? 這種自由開放的研究理念, 源自我們在機械設計工程系開設的課程 (包括計算機程式、網際內容管理、電腦輔助設計實習與協同產品設計實習等) 中所使用的工具, 這些工具包括 Python3, Anaconda, Leo Editor, Pelican, OnShape, Solvespace, V-rep, Jupyter, Ubuntu, Virtualbox, Github, Bitbucket 與 OpenShift 等. 其中 Python3, Leo Editor, Pelican, Solvespace, V-rep, Jupyter 與 Virtualbox 都是自由開放源套件 (註: V-rep 雖然開放源, 但只限非營利教育單位免費使用, 營利單位必須購買後才能使用), 其餘則可以在教育界免費使用. 尤其當 OnShape 將 FeatureScript 整體程式碼開放出來之後, 我們終於發現, 假如連全球的機械設計菁英們, 都願意將價值性如此高的系統給開放出來, 那麼我們這種小團隊, 在受益於這些巨人所推出的系統應用中, 所領悟理解出的一點點小小心得, 就更沒有隱藏與故步自封的必要了.","url":"http://project.mde.tw/blog/yen-wo-men-wei-he-yao-quan-pan-tuo-chu-yan-jiu-cheng-guo.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/27","text":"規劃解題與檢驗函式 檢驗出功能缺損 規劃解題 : 計算題目，並一邊利用SciTE的偵錯窗來檢查之前寫的函式資料。 之前的題目： http://chiamingyen.github.io/kmolab/blog/zi-xing-che-chuan-dong-2d-lian-tiao-hui-tu-er.html 規劃了一支程式來計算鍊輪的點座標（半成品）： #鍊條解題：18齒與30齒的鏈條，上下外切線長為200。 #小圓圓心為原點，大圓圓心在X軸上，求四個切點的座標 from slvs import * from math import * sys = System(500) g = 1 #相關參數 n0 = 20 #鍊條長度(mm) n1 = 18 #小輪齒數(t) n2 = 30 #大輪齒數(t) #邊長為a的的正n邊形外接圓半徑為： #R=a/(2*sin(pi/n)) or R=(a/2)*csc(pi/n) R1 = n0/(2*sin(pi/n1)) R2 = n0/(2*sin(pi/n2)) #開始繪圖 #原點Point0 p0 = sys.add_param(0.0) p1 = sys.add_param(0.0) p2 = sys.add_param(0.0) Point0 = Point3d(p0, p1, p2) #XY法線 qw, qx, qy, qz = Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0) p3 = sys.add_param(qw) p4 = sys.add_param(qx) p5 = sys.add_param(qy) p6 = sys.add_param(qz) Normal1 = Normal3d(p3, p4, p5, p6, sys) #工作平面 Workplane1 = Workplane(Point0, Normal1) #3D版的Point0=>Point1 Point1 = Point2d(Workplane1, p0, p1) #小圓 p7 = sys.add_param(R1) Distance1 = Distance(Workplane1, p7) Circle1 = Circle(Workplane1, Normal1, Point1, Distance1) #Point2 p8 = sys.add_param(500.0) p9 = sys.add_param(0.0) Point2 = Point2d(Workplane1, p7, p8) #大圓 p10 = sys.add_param(R2) Distance2 = Distance(Workplane1, p10) Circle2 = Circle(Workplane1, Normal1, Point2, Distance2) #上端外切線的兩個點Point3和Point4 p11 = sys.add_param(300.0) p12 = sys.add_param(500.0) Point3 = Point2d(Workplane1, p11, p12) p13 = sys.add_param(500.0) p14 = sys.add_param(500.0) Point4 = Point2d(Workplane1, p13, p14) #下端外切線的兩個點Point5和Point6 p15 = sys.add_param(300.0) p16 = sys.add_param(-500.0) Point5 = Point2d(Workplane1, p15, p16) p17 = sys.add_param(500.0) p18 = sys.add_param(-500.0) Point6 = Point2d(Workplane1, p17, p18) ... #以下解題 sys.solve() if (sys.result == SLVS_RESULT_OKAY): print (\"兩點座標：\") print((\"(%.3f %.3f %.3f)\")%(sys.get_param(0).val, sys.get_param(1).val, sys.get_param(2).val)) print((\"(%.3f %.3f %.3f)\\n\")%(sys.get_param(8).val, sys.get_param(9).val, sys.get_param(2).val)) print (\"上切點座標：\") print((\"(%.3f %.3f %.3f)\")%(sys.get_param(11).val, sys.get_param(12).val, sys.get_param(2).val)) print((\"(%.3f %.3f %.3f)\\n\")%(sys.get_param(13).val, sys.get_param(14).val, sys.get_param(2).val)) print (\"下切點座標：\") print((\"(%.3f %.3f %.3f)\")%(sys.get_param(15).val, sys.get_param(16).val, sys.get_param(2).val)) print((\"(%.3f %.3f %.3f)\\n\")%(sys.get_param(17).val, sys.get_param(18).val, sys.get_param(2).val)) print (\"導入函數測試：\") print(pi) print (\"%d DOF\" % sys.dof) else: print (\"solve failed\") 但是在使用畫線並約束與圓相切的指令時，之前臆測的程式碼卻沒有這個功能，於是去倉儲搜尋函式名稱。 發現某些Solvespace的功能並沒有轉給CDemo使用，之前 DOC.txt 簡介只是說明出本體支援的功能。 在 h++ 的標頭檔 slvs_python.hpp 中，有以下項目： class Constraint { ... public: // This constructor can be used to make arbitrary // constraints. It has a very ugly name to discourage // its use. If you need a constraint that the library // doesn't support, you should implement it. //以下是所有約束函式 ... 而那些沒做出的功能都用註解的方式放在這些做好的函式之間，所以看來好像是要自己做了。 目前瞭解需要編寫的檔案為 slvs.i 的Interface檔、 slvs_python.hpp 標頭檔、 constrainteq.cpp 約束方程式的函式。 畢竟是用別人寫好的架構，自己修改應該沒甚麼太大的障礙，以一個Python模組而言，拓展所需才是協同作業重要之處。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050727.html"},{"tags":"2016bg2","title":"40323231日誌 - 105/07/25","text":"3DP問題、測試、解決方法 固件組裝時的問題 : 1.熱床的安裝較不容易，因為它是暗孔所以比較難對齊，鎖固的時間較長，之後有要組一台的話要考慮是否改換成明孔 配電的問題 : 1.限位開關的接法，因為限位開關有分兩種，一種是機械式微動開關，一種是光學限位開關，要怎麼接? 接法和注意事項: a. 機械微動開關接法 機械微動開關只需接2個腳位的：單純使用微動開關當作限位器，那一定要接RAMPS上的 \"S\" 跟 \"-\" 腳位。絕對不要把3個腳位都接了，如果不小心接了3個腳位，那在觸發時會發生火花，會把5V穩壓 IC燒毀。 b. 光學限位開關接法(我們的) 光學限位開關則是需要用到3條線，接到RAMPS上的\"S\"、\"-\"及\"+\" 3個腳位。 c.程式碼也需要改(由於我們的是光學限位所以都改成false) const bool X_MIN_ENDSTOP_INVERTING = false; const bool Y_MIN_ENDSTOP_INVERTING = false; const bool Z_MIN_ENDSTOP_INVERTING = false; 測機問題 : 1.用arduino燒入韌體時會說缺少東西，這時用(u8glib_arduino_v1.16)壓縮檔即可。 操作方法是 : a.先到網站下載u8glib_arduino_v1.16這包壓縮檔 b.點開arduino c.點選Sketch d.點選Include Library e.點選Add .ZIP Library... f.選擇u8glib_arduino_v1.16 g.完成 2.擠出馬達不能運作,其他xyz馬達皆能動 測試方法: a.將擠出馬達的訊號線接到X軸的訊號端(馬達是否正常)，測試馬達正常 b.將擠出軸的訊號線由E0接到E1(測試控制板和韌體是否正常)，測試結果無法作動 c.將電源線和擠出訊號線接到ramps1.4和arduino上(測試控制板是否正常)，測試結果無法作動 解決方法:因為程式碼中有保護措施，保護措施為噴頭溫度要先加熱到指定的溫度後才能啟動，怕擠料不正常。可修改此程式碼define MIN_EXTRUDER_TEMP 170 3.馬達旋轉方向不符 解決方法:調整程式碼 Repetier(0、1為正反轉) #define INVERT_X_DIR 0 #define INVERT_Y_DIR 0 #define INVERT_Z_DIR 0 #define EXT0_INVERSE 0 Marlin(true、false為正反轉) #define INVERT_X_DIR true #define INVERT_Y_DIR true #define INVERT_Z_DIR true #define INVERT_E0_DIR true 4.G28回歸的時候，Z軸不動其他兩軸馬達回歸，導致噴頭座往外跑出 測試方法 : a.打指令M119檢查限位開關是否有開，測試結果有開 b.用手讓限位器偵測是否會感應，測試結果有感應 c.檢查程式碼true/false是否正確，正確(有說明此功能的一篇) 解決方法:更換新的杜邦端子，因為測量多次後發現時好時壞，所以猜測是訊號接收不正常，更換後能夠順利回歸 5.軟體關掉訊號後滑軌依然鎖住 解決方法:關掉訊號後再連接(connect)，之後再斷掉，就可以解鎖了 使用韌體Repetier所碰到的問題 : 1.噴嘴高度不管怎麼改都是319.2mm不知道為什麼? 解決方法(還未真正找到解決方法) a.修改程式碼中噴頭最大高度，可是不管怎麼改依然都是319.2mm b.修改程式碼中噴頭最小高度，可是依然319.2mm c.修改3軸的補正值，依然不變 d.修改xyz軸的最大值，發現xyz軸會超出設定的最大值，發現好像是code燒不進去，而且有看到RAM大小所以猜測是空間不足 e.將空白的arduino燒進控制板後，機器不能運轉表示燒入成功，之後再把修改過的韌體在燒進去，可是依然還是319.2mm f.用軟體Repetier-Host直接修改高度，可是一樣還是319.2mm g.改用韌體Marlin，可是Marlin卻有更多的不穩定 h.用Cura_15.04特別版，才成功修改，並能順利列印 使用韌體Marlin所碰到的問題 : 1.G28回歸後，只能單軸單軸進行復歸補正，導致速度較慢，而且有時候複歸的途中會停下來，之後單軸複歸導致噴頭座跑出機台外。(備註:機台斷電後，軟體也要切斷訊號，不然機台重新開電後還是會繼續執行) 2.執行G28時個軸的速度，寫法與Repetier不太一樣，所以一開始沒注意到，導致速度過快差點撞機。 #define HOMING_FEEDRATE {50 60, 50 60, 50*60, 0} 列印時碰到的問題 : 1.翹邊 解決方法:塗口紅膠在平台上，以及再加熱期間把溢出來的料弄掉，因為溢出來的料會把底層弄掀，導致沒有地基、材料高低不平 2.列印出來的東西很稀疏，而且一捏就碎 解決方法: a.先加熱，之後用細的鐵絲或夾子將堵塞住的料全部清除(清理時要注意不要直接觸摸噴頭組，請用工具夾持，夾持時勿將熱敏電阻和加熱棒弄壞)，清完後用鐵氟龍管測試深度(避免之後再裝鐵氟龍管時無法到達最深部，導致又回流堵料) b.如果上述不行，再清理噴頭，或直接更換，我是清理完喉管後還是不行，直接更換噴頭，之後就改善了 3.擠出馬達持續轉動，料則是斷斷續續的進料，有時甚至完全停止 解決方法: a.進入軟體(cura)的基本 -> 列印材料(Filament) -> 流量(Flow)(%) ->更改此數值(擠料速度會降低) b.還是未改善請依循:列印時碰到的問題2進行改善 4.列印時噴頭和熱床無法同時加熱 還未解決 5.噴頭液料(部位有噴頭、喉管的鎖固部分) 解決方法:重新鎖固，或者鎖緊即可 6.口紅膠的殘留，以及要拿下產品時要用刮刀拆下，導致平板會有刮傷 還未解決，有看到網路上有人是購買專用的膠帶，不知道實不實用 7.馬達很燙 還未解決，有想要在熱床下加裝風扇 8.如何放置料桶 還未解決，想要製作料座，然後用軸承放置兩邊讓他能順利進料 持續更新","url":"http://project.mde.tw/blog/40323231ri-zhi-1050725.html"},{"tags":"2016g1","title":"40323143 -  日誌  105年7月25日","text":"手臂資料 總重量約為0.6kg 夾取重量約為0.15kg 控制手臂可從序列埠輸入數值控制，序列埠輸入數值 為(asin(列印件距離/100)+50)/0.09//10*10)。 最長夾取距離的序列埠輸入值為2060。 最終程式 #include 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 Servo myservo; Servo myservo2; Servo myservo3; Servo myservo4; int Pin = 3; int limt; void setup() { Serial.begin(9600); myservo.attach(9, 500, 2500); // 修正脈衝寬度範圍 myservo2.attach(10, 500, 2500);// 修正脈衝寬度範圍 myservo3.attach(10, 500, 2500); myservo4.attach(10, 500, 2500); pinMode(Pin,INPUT); } void loop() { limt = digitalRead(Pin); myservo.write(0); myservo2.write(0); myservo3.write(0); myservo4.write(0); int d; int e; if(Serial.available()){ d = Serial.parseInt(); Serial.println(d); if(0 <= d && d <= 2500){ delay(3000); for(int i = 500; i <= d; i+=10){ myservo.writeMicroseconds(i); // 直接以脈衝寬度控制 myservo2.writeMicroseconds(i); myservo3.writeMicroseconds(1500); delay(10); } delay(3000); for(int i = 500; i <= 1350 ; i+=10){ myservo4.writeMicroseconds(i); delay(10); delay(1000); for(int i = d; i >= 500; i-=10){ myservo.writeMicroseconds(i); myservo2.writeMicroseconds(i); myservo3.writeMicroseconds(1500); delay(10); } delay(1000); for(int i = 1350 ; i >= 500; i-=10){ myservo4.writeMicroseconds(i); delay(10); } } } } }","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-25ri.html"},{"tags":"2016bg2","title":"40323230紀錄 - Python-Solvespace編譯完畢","text":"Windows執行成功！ Ubuntu執行失敗（需重生 _slvs.so ）。 公開倉儲 python-solvespace 已更新。 編譯結果 : 最後編譯時把 _slvs.so 改成了 _slvs.pyd 就能使用了。 有測試過改成 .dll 的方式，但是反而不能使用，可能是Windows平台Python辨認的問題。 不過由於 _slvs.pyd 是參照 libslvs.so 的內容生成的，所以這四個檔案必須放在同一個資料夾： 1 2 3 4 solvespace/exposed/_slvs.pyd solvespace/exposed/libslvs.so solvespace/exposed/slvs.py solvespace/exposed/Usage.py 倉儲的Readme也做了一下說明。 而 test.py 執行結果中，偵測到 long 還沒定義，所以資料庫還需要修理一下。 搬到新電腦虛擬機的Ubuntu上測試時，使用的是 _slvs.so 的樣式。 會顯示ELF標頭檔錯誤，而無法執行，應該是因為在Windows上生成的關係，重新在Ubuntu上編譯應該就行了。 另外在新電腦虛擬機的Ubuntu上裝了一下Git、Netbeans和GNU工具包，可以正常運作，不過可能是跨系統模擬的關係，反應還滿慢的。 然後Python3不知道怎麼更新，一直在3.4.2沒辦法升上去。","url":"http://project.mde.tw/blog/40323230ji-lu-python-solvespacebian-yi-wan-bi.html"},{"tags":"2016bg2","title":"40323218日誌 - 105/07/23","text":"V-rep printer_control 嘗試組裝3Dprinter 現在已嘗試兩種方式操控 分別是： Printer_position_control.ttt 可以操控position(需用滑鼠移動) Printer_motor_control.ttt 可以操控motor(需用參數移動) 串列通訊：","url":"http://project.mde.tw/blog/40323218ri-zhi-1050723.html"},{"tags":"2016bg2","title":"40323230紀錄 - C語言資料庫格式","text":"關於各平台程式使用之連結庫類型。 Static libraries Shared libraries Dynamically loaded libraries 參考資料來源： http://terrycslife.blogspot.tw/2010/07/so.html https://kaineshu.wordpress.com/2007/05/02/%E8%BD%89%E8%B2%BC%E7%94%A8gcc-%E8%87%AA%E8%A3%BD-library/ http://www.jianshu.com/p/09994c9d8489 Object File : 通常副檔名為 .o 或是 .obj ，後者為Windows使用的格式。 將 .c 或 .cpp 、 .cxx 的C語言程式碼包裝成的物件檔，無法直接使用。 使用編譯工具的\"Link\"功能可以將這些單獨的物件檔合併成連結庫或是可執行檔。 Static libraries - 靜態資料庫 : 通常副檔名為 .a 。 作用方式：將連結庫包入程式中執行，處理效率高，缺點是檔案大且不易更新。 若要建立一個靜態資料庫，可以使用DllTool從 .dll 檔解出或是用GNU的 ar 工具連結物件檔編譯。 ar 的指令中， rcs 或是 -r 後接上輸出的檔案名稱，如下： ar rcs libmylib.a first.o second.o 產生靜態資料庫後，可以使用gcc的 -L 和 -l 指令連結，對象包含程式碼、物件檔和其他靜態資料庫。 Shared libraries - 共用資料庫 : 通常副檔名為 .so ，後面可加掛版本編號。 作用方式：資料庫和執行檔是分離的，剛開始就要載入，並且資料庫必須一直和執行檔待在一起，優點是修改方便。 gcc在產生物件檔時必須加上 -fPIC 參數，紀錄\"position-independent code\"，就是獨立位置碼，以紀錄存取位置的資訊。沒有使用的話只會用相對位置，不利於共享內容。 再來將物件檔合併成資料庫時，加上 -shared 參數，接著要自訂義\"soname\"、\"real name\"、\"linker name\"。 soname是資料庫的名稱，通常以 lib 開頭，包含附檔名和大版號，如 libexample.so.1 。 real name是真正使用程式的資料庫名稱，包含小版號，如 libexample.so.1.0.0 。 linker name是連結時的資料庫名稱，不包含版號，如 libexample.so 。 gcc使用 -Wl 參數向內建的Link工具\"ln\"傳入資訊，如下： gcc -shared -Wl,-soname,libexample.so.1 -o libexample.so.1.0.0 first.o second.o 使用 -Wl,-soname 定義soname；輸出的檔案名稱為real name；使用 -l 或 -l: 連結的名稱為linker name。 尋找了下 維基百科 ，似乎也能使用 -h 和 -soname= 來定義soname的名稱。 資料庫連結時使用 ln 指令連結兩個 .so 檔。使用 -s 參數為軟連結，類似捷徑式的參照；使用 -d 參數為硬連結，類似副本的備份。 最後必須用以下指令為real name創造linker name和soname的檔案（使用 -s 或 -d 就隨喜好了）。 linker name ln -s libexample.so.1.0.0 libexample.so soname ln -s libexample.so.1.0.0 libexample.so.1 之後可以用GNU的另一個工具\"objdump\"檢查連結。 objdump -p libexample.so.1.3 | grep SONAME 產生共用資料庫後，可以像靜態資料庫一樣包裝，也可以用程式呼叫。 連結時有同名資料庫時會以共用資料庫優先，加上 -static 參數可以指定靜態資料庫。 而調用資料庫時是先找soname的檔案，否則會尋找linker name的檔案，可執行檔亦同。 Dynamically loaded libraries - 動態載入庫 : 為Windows中 .dll 檔標準的模式，不過並非所有 .dll 都是如此。 作用方式：使用時才會載入，編譯時不須要相關資料庫檔案，因此常用於附加元件。 使用一套DLL function來處理，標頭檔和編譯的程式碼中都會使用來傳遞訊息。 gcc編譯時要加上 -ldl 參數連結。 後來發現gcc有時編譯「成功」的樣子可能包含著錯誤。 今天測試了一些方法，但是明明CDemo和Python的 .so 都是差不多的參數，編譯出的結果卻不如預期。 libslvs.so g++ -shared -o libslvs.so ../obj/util.obj ... ../obj/w32util.obj _slvs.so g++ -shared -o _slvs.so ../obj/util.obj ... ../obj/slvs_wrap.o -LW:/Anaconda3/libs -lPython35 -L. -l:libslvs.so 如果編譯 _slvs.so 時不加上後面的 -LW:/Anaconda3/libs 、 -lPython35 等等就會因為 slvs_wrap.o 的 slvs_wrap.cxx 出問題，但是沒加上就和 libslvs.so 一樣了。 但是這樣另一個問題就產生了，因為編出來的 _slvs.so 是「可執行檔」，不指定 -o _slvs.so 的話就會編譯成 a.exe ，所以其他Python程式碼都找不到（有搬到虛擬機的Ubuntu測試，也找不到）。 想過學範例用 .c 跳過Object File的階段直接轉成 .so 檔，但是只有 libslvs.so 成功， _slvs.so 反而在系統暫存檔Temp資料夾中找不到Python連結。 之後稍微看了一下SWIG轉出的 slvs.py 結構，呼叫的 .py 檔必須先導入 slvs.py 後， slvs.py 會視Python版本取用 _slvs.so 的內容，再傳給需要的 .py 檔，所以 slvs.py 和 _slvs.so 都必須和撰寫的 .py 檔放在一起。","url":"http://project.mde.tw/blog/40323230ji-lu-cyu-yan-zi-liao-ku-ge-shi.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/22","text":"Python-Solvespace編譯完畢。 進行 _slvs.so 呼叫測試。 公開倉儲 python-solvespace 已推送。 編譯成功 : 上次編譯時一直找不到 Slvs_ 相關名稱的問題。 最後發現編譯 _slvs.so 時加入參照 libslvs.so 資料庫的指令（ -L 和 -l ），就成功編譯了。 結束編譯時，Makefile執行了CDemo.exe證明C語言調用 libslvs.so 是完全沒問題的。 接著要試著執行Python調用 _slvs.so 。 測試test.py和Usage.py : 作者提供了2個範例使用，將它們和 _slvs.so 放在相同目錄中。 Usage.py 是參照Readme的說明，將範例code抓下來存在 exposed 資料夾的程式檔。 然而若直接執行會出下列錯誤： test.py Usage.py 意思是Python無法調用 _slvs 這個模組，大部分的原因是名稱錯誤或是沒有導入。 SWIG手冊的\"Using distutils\"之後的幾章是講導出模組後的應用。 看了一下內容，Python導出後的模組可以作為Python的附加元件、直接呼叫、動態模組、靜態連結之類的。 不過沒有解答一些例外的錯誤。 但是一直找不到 _slvs.so ，不知道是出了甚麼問題，會繼續尋找資料。 公開倉儲 : 把目前進度推到了自己的 python-solvespace 倉儲，在 exposed 資料夾中的Makefile編輯工具位置，就能Make和Clean。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050722.html"},{"tags":"2016g1","title":"40323143 -  日誌  105年7月22日","text":"變更夾爪形狀，並在夾頭下方新增連桿，加大夾持穩定度，開了槽可安裝極限開關，安裝點還沒畫，夾持面向內凹了1mm，夾持件不至於在夾持過程中由夾口脫落。 新增夾頭馬達的控制程式，暫時固定正轉90度，或許會改。 夾爪 整體圖 加上底座馬達控制程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include <Servo.h> Servo myservo ; Servo myservo2 ; Servo myservo3 ; Servo myservo4 ; void setup () { Serial . begin ( 9600 ); myservo . attach ( 9 , 500 , 2500 ); // 修正脈衝寬度範圍 myservo2 . attach ( 10 , 500 , 2500 ); // 修正脈衝寬度範圍 myservo3 . attach ( 10 , 500 , 2400 ); myservo4 . attach ( 10 , 500 , 2500 ); } void loop () { myservo . write ( 0 ); myservo2 . write ( 0 ); myservo3 . write ( 0 ); myservo4 . write ( 0 ); int d ; int e ; if ( Serial . available ()){ d = Serial . parseInt (); Serial . println ( d ); if ( 0 <= d && d <= 2500 ){ delay ( 3000 ); for ( int i = 500 ; i <= d ; i += 10 ){ myservo . writeMicroseconds ( i ); // 直接以脈衝寬度控制 myservo2 . writeMicroseconds ( i ); myservo3 . writeMicroseconds ( 1500 ); delay ( 10 ); } delay ( 3000 ); for ( int i = 500 ; i <= 1500 ; i += 10 ){ //夾爪動作 myservo4 . writeMicroseconds ( i ); delay ( 10 ); } delay ( 1000 ); for ( int i = d ; i >= 500 ; i -= 10 ){ myservo . writeMicroseconds ( i ); myservo2 . writeMicroseconds ( i ); myservo3 . writeMicroseconds ( 1500 ); delay ( 10 ); } delay ( 1000 ); for ( int i = 1500 ; i >= 500 ; i -= 10 ){ //夾爪動作 myservo4 . writeMicroseconds ( i ); delay ( 10 ); } } } } 結語: 手臂剩下列印組裝就可以完成，但以目前馬達的力量沒有熱床八成沒辦法下料。","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-22ri.html"},{"tags":"2016g1","title":"報告的內容3","text":"介紹硬體相關訊息(純文字還沒補照片) 3d printing 3D printing，又稱增量製造、積層製造（Additive Manufacturing，AM），可指任何列印三維物體的過程。3D列印主要是一個不斷添加的過程，在電腦控制下堆疊材料。3D列印的內容可以來源於三維模型，其列印出的三維物體可以擁有任何形狀和幾何特徵。3D列印機屬於工業機器人的一種。 「3D列印」這個詞的原意是指順序地將材料沉積到粉末層噴墨列印頭的過程。最近此詞的含義已經擴大到廣泛包括的各種技術，如擠壓和燒結過程。技術標準一般使用「增量製造」這個術語來表達這個廣泛含義。 我們所選用的方法為FDM(Fused deposition modeling)，先用CAD軟體建構出物體的3D立體模型圖，將物體模型圖輸入到3D printer。列印機的噴嘴就會根據模型的切層檔(G-code)，一層一層移動，同時列印機的加熱頭會擠出PLA材料。材料被加熱到半液體狀態後，在微電腦(Arduino)的控制下，列印機的噴嘴就會沿著模型移動，將熱塑性材料擠壓，在該層中凝固。列印機會根據G-code裡面的設定，分別是構成成品的建模材料和用作支架的支撐材料，透過噴嘴垂直升降，材料層層堆積凝固後，就能由下而上形成一個3D列印模型的實體。列印完成的實體，就能開始進行整理，剝除固定在零件或模型外部的支撐材料，即可使用該零件了。 Raspberrypi3 樹莓派（英語：Raspberry Pi），是一款基於Linux的單板機電腦。它由英國的樹莓派基金會所開發，目的是以低價硬體及自由軟體促進學校的基本電腦科學教育。樹莓派配備一枚博通（Broadcom）出產的ARM架構1.2GHZ，使用SD卡當作儲存媒體，且擁有一個Ethernet、四個USB介面、以及HDMI（支援聲音輸出）和RCA端子輸出支援。樹莓派只有一張信用卡大小，體積大概是一個火柴盒大小，可以進行1080p影片的播放。操作系統採用開源的Linux系統如Debian、ArchLinux，自帶的Iceweasel、KOffice等軟體，能夠滿足基本的網路瀏覽、文字處理以及電腦學習的需要。近年來Maker、以及IOT活動興盛，大家開始往電子電路、機電整合...等方向開發，例如:網路的恆溫器、可以上網的機台...等，而這些機器的原型，很有可能就是利用樹莓派本身具有的GPIO做原型機的樣本，可以利用python+GPIO控制方式，快速的從網路傳回相對應的格式，以便開發後面的電路板。 Arduino Arduino為一套在近年Maker活動興盛的電路板，對於學生來說，價格並不會非常高，是一般學生，或者對電路學習者很好的入門電路板，在這塊版子上，有將每個GPIO腳位拉出來使用，利用官方所寫的C語言方法，就可以很快的知道要如何編寫，也因為它的簡單，所以推廣的快，目前市面上有很多都已經是利用這樣的套件，讓學習者可以快速的開發與學習，以及在去年公開原始碼的Marlin 3d printer ，是利用Arduino Mega2560加上Ramps 1.4(註一)所開發的控制板，可以控制基本的三軸(X Y Z)，因為這樣的開發，讓自製CNC、3D printer、雷射切割機，一一的冒出台面上，讓更多想學習工具機開發，或者基本三軸運動機構的開發，更為快速。 RS-232串列通訊 RS-232是美國電子工業聯盟（EIA）制定的序列資料通訊的介面標準，原始編號全稱是EIA-RS-232（簡稱232，RS232）。它被廣泛用於電腦串列埠外設連線。 RS-232C標準，其中EIA（Electronic Industry Association）代表美國電子工業聯盟,RS（Recommended standard）代表推薦標準，232是標識號，C代表RS232的第三次修改（1969年），在這之前，還有RS232B、RS232A。 它規定連接電纜和機械、電氣特性、訊號功能及傳送過程。其他常用電氣標準還有EIA-RS-422-A、EIA-RS-423A、EIA-RS-485。 目前在IBM PC機上的COM1、COM2介面，就是RS-232C介面。RS-232對電氣特性、邏輯電位和各種訊號線功能都作了規定。 我們的3D列印機是利用RS232的USB通訊傳送G-code指令到3D列印機中進行控制，利用切片軟體計算三角網格曲面(STL)，分出每一層所需要走的路徑，產生出相對應的G指令，接下來利用RS232通訊到控制板中，控制機台的作動。 註一 Ramps 1.4 為目前主要支援3D列印機的擴充版，目的是把腳位從原本的Arduino Mega2560中，變得針對相應的馬達控制以及感測，讓使用者可以輕鬆的安裝以及佈線，不需要額外再拉麵包版，或者控制晶片的腳位，也將額外的12V電源，拉到板子做整合，避免走線導致短路。","url":"http://project.mde.tw/blog/bao-gao-de-nei-rong-3.html"},{"tags":"2016bg2","title":"40323250日誌 - V-rep 功能 (持續更新中)","text":"V-rep 的使用與學習 Onshape繪製V-rep零件 : 在Onshape新增一個零件檔 ,選擇隱私或者公開 ,目前每個人擁有的容量為10mb。 在part studio部分選擇平面當作草圖繪圖 ,功能和大多繪圖軟體相同。 單位設置 : 功能表有一個(x)函數圖示 ,能夠設定變數值 ,方便用於零件設計 ,若新增一個x ,命名為a且值為10的值 ,之後在填入尺寸部分輸入#a ,則該尺寸為10。 零件繪製好之後 ,在Assembly中引入零件。 先按右鍵將底座設定為fix(固定) ,組裝零件須注意 ,因為使用V-rep模擬 ,組裝時零件和零件設定小段距離(offset) ,不要完全貼合(在V-rep較易拆解零件) ,旋轉軸先透過cylindrical_mate和孔配合 ,再利用planar_mate讓軸偏移小段距離。 組合完畢後 ,在Assembly點選右鍵 ,輸出成stl格式檔案。 V-rep 教學 : 導入stl檔案 : 點選左上方工具列File ,import ,mesh ,選取繪製的stl檔案後 ,就可以看到零件了。 調整座標 : 若只看到零件的一部分 ,就是零件倒過來了 ,這時候點選左方零件圖示 ,再選上方工具列 ,將零件座標系設定成V-rep內(World)座標 ,最後點選上方旋轉功能 ,旋轉零件至理想角度。 轉好角度之後 ,點選上方平移功能 ,並調整Z軸高度。 若零件被地板遮住 ,看不到零件 ,可先使用選平移功能 。 拆解零件 : 在V-rep導入的stl檔都會變成一個整體零件 ,而在Onshape先組好是因為零件拆解後較容易定位 ,且座標較容易設定等等。 點選欲拆解之零件後 ,點選工具列 ,編輯 ,Grouping/Merging ,Divide select shapes。 若有照上方Onshape繪製零件方式 ,零件就可以順利拆開。 加入旋轉軸 : 在右側視窗點選右鍵 , Add → Joint → Revolute 新增完成 ,快點兩下圖示 ,可以設定相關性質 橘色框框為旋轉軸長度及直徑 移動旋轉軸至零件主軸 : 先點選欲移動之物件(a.)後 ,按著shift並點選欲移動到的物件(b.) ,之後點選移動調整性質 綠色框框內分別為X、Y、Z重合 ,使旋轉軸與物體在同一軸線上 如果相關參數都設定好了 ,點選右鍵→Edit→使旋轉軸與零件結合成一物件(也可以直接用滑鼠拖曳) 結合後的從屬關係 旋轉軸(馬達)設定 : 先將各部位組立完成 設定底座Dynamic性質 , ( X = 不打勾 ) Body is respondable 指 是否實體化 ,若兩個實體化物件互相碰撞 ,會依照物理設定做相對反應。 設定Revolute_joint(馬達)性質 設定旋轉軸Dynamic性質 ,設為動態物件 設定旋轉桿Dynamic性質 都設定好之後 ,設定旋轉軸(馬達)程式 ,點選左方文件圖示 ,之後在右方Scripts新增一個子程式 在Assciated object選擇STL_Imported_sub(主體) 之後打開左方script ,並加入下面那行程式 設定完之後就可以按start ,跑老師的python範例了 加入攝影機 在物件視窗點選滑鼠右鍵 → add → vision sensor →選擇其中一種類型 vision_sensor類型可分為 : a.為orthographic type 及 b.為perspective type 點兩下圖示設定攝影機性質 ,橘色框框為攝影範圍 , 綠色框框為範圍內的解析度 (2&#94;n ,2~256) ,棕色框框為攝影機大小 將旋轉桿和攝影機結合並設定從屬關係 在物件視窗點選右鍵 ,點選 Remove page ,再次按右鍵新增2個視窗 點選左方第一台預設攝影機後 ,在上方視窗點選右鍵輸入攝影鏡頭 下方視窗則點選新增的攝影機 ,一樣新增攝影鏡頭 下方視窗會是黑色的 ,因為鏡頭所照的地方都是黑色 若將攝影機向下轉 ,就可以照到地板了 ,紅框內是照到旋轉桿 啟動程式來跑看看囉~ dummy ( 虛擬座標 ) : dummy 能夠讓不是從屬性質的物件做相對移動, 常用於close chain, 以irb360範例來說 : a. b.桿為示範物件 將a.及b.桿實體隱藏之後 ,能夠看到從屬於a、b桿下的dummy為重疊狀態 ,並且為互相對應(target) 目的是因為 ,若a桿做出任何動作(移動) ,在它從屬下的dummy會隨著target的dummy做相對運動 ,因此兩桿距離始終會保持固定 零件大小 : size factor 為 目前模型的 比例 ,透過下方 Scaling 可以設定模型倍率 ,若Scaling factor 設為2 ,上方的size factor 會變成2 ,就是原始模型的2倍大 零件座標系 : 導入零件後 ,拆解發現零件的角度與V-rep右下角(World)的座標不同 ,有時對於joint的放置會變得不方便 點選要改變座標的零件後 ,在edit選單下點選Reorient bounding box→with reference frame of world 即可 利用三角建構零件放入joint : 因為手臂有個齒輪 ,且有傾斜角度 ,所以需要透過零件轉換 ,並插入一個圓軸來輔助joint 點選零件後右鍵選取 Edit→Decimate selected shape後 ,選擇三角形數量 (太少圓形會變多角形 ,太多運算會變慢) ,之後點選左方 Toggle shape edit mode 全選所有三角形 ,並點選Extract cylinder後按OK 之後就可以順利放上joint了","url":"http://project.mde.tw/blog/40323250ri-zhi-v-rep-gong-neng-chi-xu-geng-xin-zhong.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/20","text":"gcc的 -M 類型參數問題。 math.h與pyconfig.h衝突修正。 使用libpython35.a解決_wrap.cxx找不到函式的問題。 Solvespace Makefile : 目前發現obj檔案無法辨識的原因是原始Makefile中加上了 -MT 這個參數，然而沒有這個參數，只能改用 -MD 來取代。 直到Link這些obj檔時才發現，這些obj檔竟然是文字文件，而另一個Makefile導出的obj檔都相當正常。 最後決定把Makefile中gcc的參數統一化，剩下才發現 -M 系的參數會輸出信息檔，而不是物件。 但是將obj檔重新連結成 solvespace.exe 時就開始顯示大大小小的錯誤了，而且並非 -W 的普通警告。相反的另一邊exposed資料夾就沒出現過警告。 所以要成功編譯就必須將錯誤修正，看一些關於C++的資料。這些錯誤貌似都是物件繼承、指標項的用法問題。 不過今天專注在如何克服exposed資料夾的錯誤。 MinGW的math.h和Python的pyconfig.h : 上網搜尋了許多文章，大部分的人使用MinGW編譯C轉Python的文件時，同時導入 cmath 和 Python.h 都會遇到這個衝突。 主要原因是＜math.h＞中有一段 _hypot(double _X, double _Y) 的函式，而它的名稱剛好與 pyconfig.h 中的 define hypot _hypot 衝突。 上網搜尋時找到一系列2013年的信件： http://www.vtk.org/pipermail/vtk-developers/2013-March/013475.html 主要是討論如何處理這個問題，信中曾建議在自己的程式碼的 include ＜Python.h＞ 下加上這段： #include ＜cmath＞ #include ＜Python.h＞ #ifdef hypot #undef hypot #endif 但是這樣根本不可行，因為導入 Python.h 時就會同時導入 pyconfig.h ，一旦導入 pyconfig.h 就會產生衝突，後面再undefine也不會有用。 所以根本的問題就是修改 pyconfig.h ，變成這一段： #ifndef _MATH_H_ #define hypot _hypot #endif 讓它只能在沒有 math.h 的時候才能使用。 更改後編譯就沒有問題了。 不過不知道這樣更改會不會讓Anaconda的Python衍生其他狀況。 libpython35.a : 出現了 slvs_wrap.cxx 匯入函式的問題。 slvs_wrap.o: In function `_SWIG_Py_None': slvs_wrap.cxx:1446: undefined reference to `__imp__Py_RefTotal' ... 這些是SWIG自動產生的，interface無法修改。 上網搜尋了一下，應該是軟體位元問題，找到了類似的問題。 http://www.gdomc.com/0423/how-can-i-build-my-c-extensions-with-mingw-w64-in-python/ 接著參考另一篇文章生成 libpython35.a 。 https://github.com/kivy/kivy/wiki/Creating-a-64-bit-development-environment-with-MinGW-on-Windows 首先，將Python的DLL檔複製一份進Python的libs資料夾中。 接著下載 gendef.exe ，它也是MinGW的工具之一，從下列網址下載 gendef-1.0.1346-1-mingw32-bin.tar.lzma ： https://sourceforge.net/projects/mingw/files/MinGW/Extension/gendef/gendef-1.0.1346/ 解壓縮進MinGW的bin資料夾中。 接著用CMD進入Python的libs資料夾中使用以下命令。 gendef python35.dll dlltool --dllname python35.dll --def python35.def --output libpython35.a dlltool 是GNU內建的工具，有安裝過安裝版的GNU工具包就能在本機端環境使用。 做完後就會產生 libpython35.a 這個檔案。 然後到Python的include資料夾開啟 pyconfig.h 這個檔案編輯。 搜尋並將以下內容剪下： #ifdef _WIN64 #define MS_WIN64 #endif 貼到以下內容的「上方」： #ifdef _MSC_VER ... 再到Python的 Lib\\distutils 資料夾中，開啟 cygwinccompiler.py 這個檔案。 搜尋以下內容並註解掉： self.dll_libraries = get_msvcr() 注意四周會有相似的內容，不要弄錯註解。 範例在編譯 slvs_wrap.o 時加上 -DMS_WIN64 參數。 不過這時因為已經修改過 pyconfig.h 的內容，會自動宣告 MS_WIN64 ，所以加上會提示說重複宣告。 最後編譯用的指令如下。 g++ -IW:/Anaconda3/include -Wno-unused-but-set-variable -c -o ../obj/slvs_wrap.o slvs_wrap.cxx g++ -shared -fPIC -o _slvs.so ... ../extlib/si/siapp.lib -LW:/Anaconda3/libs -lPython35 但是最後還是出現一點錯誤： 應該是內部的導入問題。 由於時間不多，所以這個部分之後再解決。 今天有稍微比較下Whitequark的原始碼，不過用法已經完全不一樣，相同的變數也改變了型態，更有系統性，但是也更難判讀，所以 .cpp 的部分還得熟悉相關的知識。 Solvespace Makefile的部分是編譯 solvespace.exe 的部分，不過Python呼叫的部分應該是不用那麼多，畢竟那些大部分都是介面檔，真正的本體只需要判斷是否衝突。 所以Solvespace Makefile的部分才做得漫不經心吧。 exposed Makefile部分的 all 為三個目標： all: cdemo _slvs.so slvs.py LD_LIBRARY_PATH=. ./cdemo CDemo的部分已經成功轉出可執行檔； _slvs.so 還在最後階段的編譯中； slvs.py 則是原作者撰寫好的（不過是Python 2）。 預計不久後就能夠測試 _slvs.so 的功能。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050720.html"},{"tags":"2016g1","title":"40323131日誌 105/07/20","text":"將Kmolprint改成在純IPV6底下 也可連線 先來放張圖片 上圖是在純 ipv6 底下進行連線的，不過控制介面是ok的，但是攝影機在純 ipv6 底下會無法顯示出來，就像下圖一樣 這邊我是不太清楚 mjpg-streamer 是否有支援 ipv6 還是說要用其他方法，這方面我還沒去研究過，所以我個人是用雙支援 ipv4 跟ipv6的方式，這樣子攝影機就會顯示出來了， 個人是認為設定的位置要改成 ipv6 的還是怎樣，可是這樣 ipv4 不知會不會出問題 再來看 octopi 的 network 的設定 要編輯 octopi-network.txt 這個檔案 ，檔案位置在 /boot裡面，進入 /boot裡頭後，用 sudo nano octopi-network.txt 編輯設定檔，如下圖所示，新增 ipv6 的 address 然後重啟 sudo reboot 一下 ，再用 ifconfig 確認一下是否有增加 ipv6的連線 再來因為我們是用 nginx 代理我們的 octoprint 跟 Webcam的，所以這邊要將 nginx 的 ipv6 連線能力打開，所以去修改位於 /etc/nginx/nginx.conf 的這個檔案，在server 底下加上 listen [::]:80; ，這樣就會代理 ipv6 了， 至於 listen 80; 這個是 ipv4的 做到這邊完成 ipv6的連線，不過還沒加上認證，目前還是 http:// 要改成 有https:// 認證的 這兩三天，將一台樹梅派 + OctoPrint + Webcam 從零開始，架設讓 ipv4 跟 ipv6都可以連線進來，這當中也參考了很多資料，還有最奇怪的是，每次做，每次的問題都不一樣，真是見鬼了...，還有要裝 nginx 時，出現錯誤的訊息，要用其他方式安裝，然後自己眼花刪錯檔案，刪到內建的系統檔，於是又從頭開始，然後裝完之後，發現沒有代理過來，然後卡了很久，於是決定先出去吃晚餐，吃完回來，重新整理網站，就看到 nginx 代理過來了，當下覺得自己剛才鬼打牆了，由於自動開啟 Webcam 的指令出錯無法成功，所以就直接加在介面的system裡，所以現在 login 之後直接按就開啟Webcam了，不用在 putty 進裡頭 下指令了，蠻方便的，總之這兩天事情還蠻多的，所以本來要改17.107那台的，沒什麼時間於是直接把目前在裝的這台，直接加上 ipv6 ，然後把 SD 卡換過去，所以現在17.107的網站是用我這兩天裝的，直接換過去，是說本來的那台好像把自動更新關掉了還是怎樣，所以無法進行 update 跟 upgrade，也剛好熟練一下安裝做完感覺蠻有成就感的。","url":"http://project.mde.tw/blog/40323131ri-zhi-1050720.html"},{"tags":"2016g1","title":"40323143 -  夾頭變更  105年7月20日","text":"變更夾頭座及夾爪 因為程式設定使原先得設計變得多餘，於是將原本的上承臂與夾頭座結合成夾頭臂。 變更夾爪連桿形狀及厚度，厚度由2mm變更為4mm。 新增底座馬達的控制程式。 夾頭臂 夾爪(暫定) 整體圖 加上底座馬達控制程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <Servo.h> Servo myservo ; Servo myservo2 ; Servo myservo3 ; void setup () { Serial . begin ( 9600 ); myservo . attach ( 9 , 500 , 2500 ); // 修正脈衝寬度範圍 myservo2 . attach ( 10 , 500 , 2500 ); // 修正脈衝寬度範圍 } void loop () { myservo . write ( 0 ); myservo2 . write ( 0 ); myservo3 . write ( 0 ); int d ; if ( Serial . available ()){ d = Serial . parseInt (); Serial . println ( d ); if ( 0 <= d && d <= 2500 ){ delay ( 3000 ); for ( int i = 500 ; i <= d ; i += 10 ){ myservo . writeMicroseconds ( i ); // 直接以脈衝寬度控制 myservo2 . writeMicroseconds ( i ); myservo3 . writeMicroseconds ( 1500 ); delay ( 10 ); } delay ( 3000 ); for ( int i = d ; i >= 500 ; i -= 10 ){ myservo . writeMicroseconds ( i ); myservo2 . writeMicroseconds ( i ); myservo3 . writeMicroseconds ( 1500 ); delay ( 10 ); } } } } 結語: 測試用的手臂可以直接用，剩下夾頭等零件列印組裝還有夾爪控制程式。","url":"http://project.mde.tw/blog/40323143-jia-tou-bian-geng-105nian-7yue-20ri.html"},{"tags":"2016bg2","title":"40323218日誌 - 105/07/19","text":"V-rep 翻譯 Inverse kinematics • Inverse kinematics enabled: 啟用或禁用所有IK計算。 • Add new IK group: 新增一個空的 IK group. IK groups 可以包含一個或多個 IK elements. IK elements 是基本運動學綁著IK任務, IK groups可以組合他們來同時運行. 當需要時只使用同時運行(比依序運算花較長的計算時間). 一個IK element 總必須被一個IK group連結，而且不能單獨存在. 在按鈕下方的列表中顯示所有的IK groups將會在IK計算時被運行. 在列表中一個 IK group需要被選擇，為了顯現它的參數在剩餘的對話框中. 在列表中的順序很重要(IK group 1的結果可能被IK group 2需要來正確地或更快的執行). 在列表旁的兩個按鈕可以改變被選擇的IK group的位置. • IK group is active: 允許啟動這個IK groups. • Explicit handling: 表示被選擇的IK group 是否應該被明確地處理. 如果打勾, 當呼叫simHandleIkGroup(sim_handle_all_except_explicit)時， 在IK 計算這個IK group將不會被處理，但只有當 simHandleIkGroup(sim_handle_all) or simHandleIkGroup(ikGroupHandle) 呼叫時除外. 這是非常有用的當如果用戶希望在 child script 而不是在 main script 處理IK group裡的kinematics (如果沒有打勾, IK計算將會被執行兩次,一次是在 main script呼叫simHandleIkGroup(sim_handle_all_except_explicit) 時, 另一次是在child script 呼叫simHandleIkGroup(ikGroupHandle)時. • Mechanism is redundant: 當被打勾時, 在IK解析時joint限制校正將被啟用. 否則，joint limits 將會簡單地被強制執行在IK 解析之後，可能導致不穩定. • Ignore max. step sizes: 如果被勾選，在 joint properties 裡的maximum step sizes 將會被忽略. • Calc. method: 具體說明IK group 決定使用的計算方式. Pseudo inverse 是最快的方式但可能不穩定當目標與 tip lie 距離太遠, 當一個運動鏈超過限制或當機構靠近一個單一組態 或 超出目標. DLS 是較慢但更穩定因為它是一個阻尼分析方式(阻尼因子可以被指定（阻尼）). 這是一個好的選擇當 pseudo inverse可能失敗. • Damping: 阻尼因子當使用DLS. 較大的值導致更穩定的分辨率，但速度很慢。適當地調整值是重要的。 • Max. iterations: 重複的最大數值可以被指定. 這是計算經過的最大數量對於給予的IK group，直到它指定的結果精度到達. DLS 經常需要比 Pseudo inverse更多的重複. • Joint limits (calculation weights): the calculation weight 應該被使用在 joint limitation constraints (joint limitation constraints 是被指定在 joint properties (position minimum andposition range). • Obstacle avoidance (calculation weights): the calculation weight 應該被使用對於 obstacle avoidance(避開障礙物) constraints. • Joint limit thresholds: 線性和角度的臨界值應該和joint limitation constraints 一起被使用. • Edit conditional parameters: 調整選擇的IK group裡附加的參數 . • Perform if... : 這是有條件的分析部分. 使用者可以選擇下拉一個在列表中的IK group， 這個IK分析結果將會決定當前IK group是否會被解決。 被認為是成功的IK group計算的IK elements都位於指定的線性/角度精度內。 • Restore if... : 允許恢復初始IK group配置（goint values）如果分析沒有成功 (位置和/或定向精度沒有達到). 與上述條件的解結合時，用戶可以例如結合兩個不同的計算方法。 這是有用的如果在操作者的目標可能超出範圍或靠近一個單一組態: 第一次分析嘗試將試著求解IK group與non-damped resolution method (pseudo inverse, fast), 而且如果不成功, 第二次嘗試將會試著解決它與damped resolution method (DLS, slower). 使用者也當然可以自由手動地處理IK resolution 從script, plugin, 等. • Edit obstacle avoidance parameters: 允許調整避障參數。 請注意，這只是對熟練的操作者有意義, 而且模擬速度會大幅度地放緩。 • Select avoidance entities / Remove avoidance constraint: 允許選擇/移除avoidance entities. 一個整體通常是機器人，其他實體是障礙物。 使用簡單地measurable objects 來快速分析. • Distance threshold: 在兩個avoidance entities 之間應該保持最小的距離. • Edit IK elements: 允許編輯各種被選擇的IK group有關聯的IK elements.","url":"http://project.mde.tw/blog/40323218ri-zhi-1050719.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/19","text":"Python-Solvespace編譯除錯中。 Netbeans的版次管理與自訂工具列 : Netbeans有內建檔案版本紀錄的功能，只要在檔案左上角的按鈕切換到 History ，就會出現修改紀錄表。 點擊其中的項目就會顯示並和目前版本的檔案做比較。 其中紅色是刪除；綠色是新增；藍色是取代。 如果想復原其中的項目，可以移到顏色區塊上，左側的版本會出現箭頭，能夠將舊版的內容復原至當前的區段中，十分方便。 若是想直接復原整個檔案，可以在紀錄上案右鍵，選擇 Revert from History 就會復原檔案。特別的是，一但復原檔案，Netbeans就會直接儲存檔案，成為新的歷史紀錄，這方面需要多注意。 而專案中的檔案名稱也會配上顏色，不論是在左側的檔案樹或是分頁上。 黑色是一般clone下來的專案；藍色是使用者修改過的檔案（縱使已經復原到原始版本）；灰色是透過MinGW以外程式編寫的檔案；綠色是自己撰寫或是由MinGW編譯出的檔案。 Netbeans是以Git功能為基礎架設的（雖然不一定要使用），因此十分注重版次管理，也支援圖形化顯示 git pull 的修改處。 另一個個人化的功能就是自訂工具列，能夠將內建或模組的功能鈕設置在工具列上。 排列方法跟Firefox一樣是抓取的。 上次的問題 : 上一篇網誌中的問題： Icons Netbeans找不到外部程式的問題已解決，只要指定程式的確切位置就能執行。 所以指定Perl在W:槽的位置，上次發現的Perl其實是MinGW的附加工具，版本是5.8。 但是新下載的是5.24，並且有安裝需要的模組\"GD\"。 修改成下面這段： PERL = W:\\Perl524\\bin\\perl.exe ... $(OBJDIR)/icons.h: png2c.pl icons/* @echo icons $(PERL) $＜ $@ $(OBJDIR)/icons-proto.h 指定後就可以執行。 而後來又有一個\"rc\"的指令： $(RES): win32/$(@B).rc icon.ico rc win32/$(@B).rc mv win32/$(@B).res $(OBJDIR)/$(@B).res （原始版本的錯誤用法＄(＠B)應該為＄(＠F)，都改為＄＜或＄&#94;較明瞭） 經查詢資料，\"rc.exe\"原是Windows Kits的一個工具。 所以就改寫用變數指定。 RC = \"C:\\Program Files (x86)\\Windows Kits\\$(RCVER)\\bin\\$(RCBIT)\\rc.exe\" RCVER = 10 RCBIT = x64 ... $(RES): resource.rc icon.ico @echo RES $(RC) $＜ mv win32/resource.res $@ 同理，其他如SWIG都可以呼叫所在位置來執行了。 ld.exe does not find libraries 要改一下語法，之前使用的 -lslvs 應該指定名稱 -l:libslvs.so 並指定同目錄： cdemo: CDemo.c libslvs.so @echo cdemo @$(CXX) $(CFLAGS) -o $@ $＜ -L. -l:libslvs.so $(LIBS) 接著就能夠找到libslvs.so。 不知道是因為沒有 -L 指定目錄還是 -l 不會看附檔名的關係，一定要標定到檔案才會容許。 錯誤紀錄 : 已解決 Function \"vasprintf\" 在\"slvs_python.hpp\"中，導入了一個stdio.h的函式 vasprintf 。 不過其實正確名稱應該要增加父項式，因此修改成 __mingw_vasprintf(&buf, fmt, args) 就沒問題了。 Netbeams應該是支援h++的標頭檔，但是\"slvs_python.hpp\"的前半段錯誤累累，應該是從屬關係和宣告的部分沒弄清楚。 目前並沒有干擾MinGW的編譯，但是這些東西應該重新整理一下，尤其是下面的導入： #include ＜string＞ #include ＜exception＞ 在編寫時好像連結不到，但是編譯時MinGW抓得到，不知道Netbeams的錯誤有沒有算入這種情形。 CMath 用SWIG剛轉出\"slvs_wrap.cxx\"時產生的問題。 出現一段錯誤： error: '::hypot' has not been declared 。 在其他人的commit中有解答： https://github.com/casadi/casadi/issues/622 是說要新增 include ＜cmath＞ 進\"slvs_wrap.cxx\"中，而且必須在\"Python.h\"之前。 所以我就在interface檔中新增了，讓轉換時會自動加入這段。 不過這個問題是暫時解決，後來又有相關的麻煩。 未解決 分成兩部分的Makefile，主要是exposed資料夾的python函式比較重要。 Solvespace Makefile 在最後一個要生成\"solvespace.exe\"時無法辨識 .obj 檔案？ g++ -D_WIN32_WINNT=0x500 -DISOLATION_AWARE_ENABLED -D_WIN32_IE=0x500 -DWIN32_LEAN_AND_MEAN -DWIN32 -g -m32 -MT -Iextlib -I..\\common\\win32 -I. -D_DEBUG -D_CRT_SECURE_NO_WARNINGS obj/ratpoly.obj ... obj/resource.res -o obj/solvespace.exe w:/mingw/bin/../lib/gcc/x86_64-w64-mingw32/6.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe:obj/ratpoly.obj: file format not recognized; treating as linker script w:/mingw/bin/../lib/gcc/x86_64-w64-mingw32/6.1.0/../../../../x86_64-w64-mingw32/bin/ld.exe:obj/ratpoly.obj:1: syntax error collect2.exe: error: ld returned 1 exit status make.exe\": *** [obj/solvespace.exe] Error 1 目前還不知道怎麼辦，因為不太了解 .o 和 .obj 的關係。 前者是暫時等待編譯的物件，後者是給記憶體參照的。 gcc對於副檔名是很重視的，可能要調整參數之類的？ Exposed Makefile 剩下幾步可以編成\"slvs_wrap.o\"。 最後跳出的錯誤，竟然是內建資料庫的問題。 In file included from W:/Anaconda3/include/Python.h:8:0, from slvs_wrap.cxx:14: W:/Anaconda3/include/pyconfig.h:262:15: error: 'std::_hypot' has not been declared #define hypot _hypot &#94; make.exe\": *** [../obj/slvs_wrap.o] Error 1 導入\"Python.h\"和相關的\"pyconfig.h\"時出現了錯誤。是從上面cmath衍生的問題。 上網搜尋了一下，好像找不到解決方法， 'std::_hypot' has not been declared 好像有出現在MinGW的Bug紀錄中。 這兩個Makefile的使用參數大相逕庭，以下是比較： Solvespace DEFINES = -D_WIN32_WINNT=0x500 -DISOLATION_AWARE_ENABLED -D_WIN32_IE=0x500 -DWIN32_LEAN_AND_MEAN -DWIN32 CFLAGS = -g -m32 -MT -Iextlib -I..\\common\\win32 -I. -D_DEBUG -D_CRT_SECURE_NO_WARNINGS Exposed WIN_DEFINES = -D_WIN32_WINNT=0x500 -D_WIN32_IE=0x500 -DWIN32_LEAN_AND_MEAN DEFINES = -DISOLATION_AWARE_ENABLED -DLIBRARY CFLAGS = -I../extlib -I../../common/win32 -I. -I.. -D_DEBUG -D_CRT_SECURE_NO_WARNINGS -O2 -g -Wno-write-strings -fpermissive CFLAGS_SHARED = -fPIC -shared $(CFLAGS) 兩個Makefile編譯階段都進入整合階段，剩下的一些編譯問題主要是對MinGW的編譯程式不熟悉的緣故。 像是一般的 .so 、 .o 都較為廣用，可是將obj檔直接轉換成可執行檔，卻找不到範例。 之後要再找找看gcc和g++的編譯範例。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050719.html"},{"tags":"2016g1","title":"40323143 -  馬達控制  105年7月19日","text":"讀取訊號控制兩顆馬達 本篇接續7/18的文章，使用輸入脈衝寬度控制的方法控制，並將序列埠輸入的程式寫進來，完成由序列埠輸入最終角度的脈衝寬度來控制馬達的程式。 MG996R馬達角度由0度到180度相對的脈衝寬度為500到2500，1個脈衝寬度相對的角度值為0.09度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include <Servo.h> Servo myservo ; //第一顆馬達 Servo myservo2 ; //第二顆馬達 void setup () { Serial . begin ( 9600 ); //通訊速率 myservo . attach ( 9 , 500 , 2500 ); // 修正脈衝寬度範圍 myservo2 . attach ( 10 , 500 , 2500 ); // 修正脈衝寬度範圍 } void loop () { myservo . write ( 0 ); myservo2 . write ( 0 ); int d ; if ( Serial . available ()){ d = Serial . parseInt (); //定義輸入訊號值為d Serial . println ( d ); if ( 0 <= d && d <= 2500 ){ //限制訊號範圍 delay ( 3000 ); for ( int i = 500 ; i <= d ; i += 10 ){ myservo . writeMicroseconds ( i ); // 直接以脈衝寬度控制 myservo2 . writeMicroseconds ( i ); delay ( 10 ); } delay ( 3000 ); for ( int i = d ; i >= 500 ; i -= 10 ){ myservo . writeMicroseconds ( i ); myservo2 . writeMicroseconds ( i ); delay ( 10 ); } } } } 結語: 以下方的程式可以將序列埠輸入的數值輸入程式中使用。 1 2 3 4 5 6 7 int d; if(Serial.available()){ d = Serial.parseInt(); //定義輸入訊號值為d Serial.println(d); if(0 <= d && d <= 2500){ //限制訊號範圍 } } 且包在其中的for迴圈可以同使對兩個馬達輸入訊號，達成控制兩個馬達的目的。","url":"http://project.mde.tw/blog/40323143-ma-da-kong-zhi-105nian-7yue-19ri.html"},{"tags":"2016g1","title":"40323131日誌 105/07/18","text":"增加一些專題書面的資料及安裝Octoprint跟Webcam的練習 介面系統介紹及架構 Kmolprint 介面系統有著Access Control (訪問控制權限)，當使用者進入到介面系統時，會顯示上圖的畫面，若是尚未登入或是註冊的用戶(匿名用戶)，只會有讀(read - only)的權限而已，無法使用其他功能；介面系統裡包含的功能有下列幾項: Printer state (printer 當前狀態) Available gcode file and stats (可用的gcode檔案及總數) Temperature (溫度) Webcam (攝影機) Gcode viewer Terminal output (端子輸出) Available time movies (可使用縮時攝影) Any component provided through plugins which are enable for anonymous user (給匿名用戶提供外掛程式的使用) 系統架構圖 在第一次登入系統時，會有配置指南，允許創建 root 管理員，如果其他用戶想要註冊使用的話，須經由root 管理員審核確認之後，才算註冊成功，採用這種審核機制，是為了避免嵌入式電腦，因接收過多的連線而當機 練習安裝Octoprint及架設Webcam 今天主要在熟悉對於Octoprint及Webcam的安裝及設定，不過情況是時好時壞，在一開始安裝Octoprint的時候，就先卡了，結果問題是出在所在的目錄不對，所以找不到檔案，再來安裝Webcam的時候，因為延遲的時間太長了，好像延遲將近20秒，這邊是去設定檔裡頭調整解析度及 fps ，然後調整成大約延遲1~2秒左右，再來是將Octoprint及Webcam設定成開機之後會自動開啟，不過這邊也卡了一下，因為都卡在要調整成自動開機的指令時出現錯誤，不過這邊花了些時間，最後Octoprint的自動開機成功了，不過Webcam的失敗了，這邊可能還要再找原因，然後Octoprint的代理伺服器也改成用 nginx 了，不過為了找問題點在哪，忘記拍照了，可能要等熟練安裝步驟之後，在一步步說明加拍照，是說網路上的步驟都講的蠻簡單的，不過實際遇到的問題好像跟網路上不太一樣，這點讓我很納悶","url":"http://project.mde.tw/blog/40323131ri-zhi-1050718.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/18","text":"改寫Python-Solvespace的Makefile運作方式。 前言 : 閱讀GNU-Make的手冊之後，已經了解Makefile基本的運作方式，所以試圖解決Python-Solvespace編譯程序中出現的問題。 手冊連結： https://www.gnu.org/software/make/manual/make.pdf 利用Interface來轉換Whitequark的新版Solvespace應該是不太可行的方式了，何況Python-Solvespace也未使用全部的功能，我們需要的是解題的函式就好。 而另一方面Solid-python現在已經完全支援Python 3，若之後要調用其功能，應該也不會有太大的障礙。 所以決定把Python-Solvespace的Makefile重新寫好，將Python-Solvespace的資料庫建構完成。 Netbeans的支援 : 其實Netbeans與$GNU開發者工具包$周邊的軟體都有良好的相依性，因此在撰寫Makefile時方便不少。 在編寫完Makefile時，可以在個別的Makefile上點擊右鍵，選擇需要的命令讓make執行，諸如all、clean等等的功能可以選擇。 Makefile中可以撰寫功能讓工程師執行，連基本的clean功能也可以自訂要刪除哪些檔案。 當然利用這點，Makefile中也可以利用Echo做help的功能，Whitequark的Solvespace就有支援。 編寫Makefile : 原本Python-Solvespace的Makefile是將檔案分類，再一類類用一樣的式子做轉換，而且語法冗長還有許多錯誤。若有新增檔案，就必須填入參數的名單中登記。 一個小型程式專案的Makefile事實上只需要下列的式子就能轉換： $(ADIR)/%.obj: $(BDIR)/%.cpp $(HEADERS) $(CXX) $(FLAGS) -c -o $@ $＜ 意思是ADIR中的obj檔都與BDIR的cpp檔、標頭檔有關聯，而每個obj檔是由每個cpp檔透過＄(CXX)命令式產生的。 $後面的＄＠表示每個目標項（包括其位置）$；同理，$＄＜亦代表每個參照項$，不過＄＜是只包含第一個條件的參照項，所以後面的多個標頭檔就不會帶入＄(CXX)命令中。 若要在命令式中使用所有條件的參照項，要使用＄+，但是更好的選擇是使用＄&#94;，會自動排除重複名稱的參照項。 這樣寫固然簡單，但是每個檔案都在不同的資料夾中，要如何讓make搜尋？ 所以必須加上VPath這個參數，讓尋找參照檔案時可以搜尋到所有符合的項目。 make在找檔案時最大的特性就是$按邏輯去找$。 也因為這點，不用顧慮產生檔案的順序問題。只要\"填寫\"檔案是如何產生的，make就會根據需要的檔案來做順序調整。 make會先忽略還沒產生的參照檔案，尋找已經備齊參照檔案的項目先做，指令亦可使用外部程式來執行。 編譯瓶頸 : 經過重新整理的Makefile，應該是沒有問題了，都將指令分配完整沒有衝突。 但是仍然遇到Makefile以外的一些問題。 已解決 Stdint.h 這個原先是C語言的額外函式庫，幫助統一化使用的格式，但是如果沒裝，就會選擇作者寫的指令。 不過這個地方應該是寫錯了，會一直認為這些是未定義的格式。 其實導入\"stdint.h\"的地方也只有上圖的前半段，所以最快的解決方法就是讓solvespace.h擁有stdint.h一部份的能力。 在上面這張Netbeans的比較圖中，直接把前半段的功能插進來用了，並成功解決問題。 Min & Max Functions 下列solvespace.h的函式出了問題。 #ifndef min #define min(x, y) ((x) < (y) ? (x) : (y)) #endif #ifndef max #define max(x, y) ((x) > (y) ? (x) : (y)) #endif 上網搜尋了一下，找到基本款的用法： #define min(x, y) (((x)＜(y)) ? (x):(y)) #define max(x, y) (((x)>(y)) ? (x):(y)) 加上括弧其實非必要，因為三元運算子的優先度本身就比大於小於還低。 不過這個判斷式使用上怪怪的，移除後直接define就沒這個問題了。 Object-oriented problem 在surface.h中有一段是這樣描述的： class STrimBy { ... static STrimBy STrimBy::EntireCurve(SShell *shell, hSCurve hsc, bool bkwds); ... }; 到stackoverflow.com的論壇尋找後，有相似的問題。 是物件導向的從屬錯誤，不應該重複稱呼，但是編譯器通常不會抓這種錯誤，解決方法是刪掉前面的父項名稱。 最後變成： class STrimBy { ... static EntireCurve(SShell *shell, hSCurve hsc, bool bkwds); ... }; 也是成功解決。 未解決 Icons 首先是圖示(icon)的問題。 Python-Solvespace的作者使用另一個語言$Perl$的程式來做出\"icons.h\"這個檔案。 Perl是一個高階語言，特點就是除了自己的寫法，還可以安裝大量模組來改變撰寫方式，甚至還繼承許多C語言的標準式。 安裝方式跟Python相同，複製檔案跟設定環境變數就能使用了。 作者用了\"GD\"這個模組來導出\"icons.h\"。 Netbeans雖然也有Perl的附加元件，但是功能比SciTE還陽春，就沒使用它了。 Perl的副檔名是pl，專案中有\"png2c.pl\"和\"pngchar2c.pl\"，應該就是將PNG檔導入C語言中的意思，Makefile中是要執行\"png2c.pl\"並產生出\"icons.h\"和\"icons-proto.h\"的樣子，不過\"icons-proto.h\"不會用到。 在Netbeans中似乎無法呼叫外部程式，會顯示無法找到Perl指令的訊息。 可是到CMD中執行時又會發生無法回應的情況，接著make就會因為找不到\"icons.h\"而無法編譯。 ld.exe does not find libraries 在exposed資料的Makefile中，g++的參數中需要導入資料庫\"-lslvs\"。 而在上一個步驟中，\"libslvs.so\"確定已經產生，但是找不到的狀況。 網路上普遍都是需要資料連結和打錯名稱，但是好像沒這種狀況，莫非是\"libslvs.so\"產生失敗，或是並非\"slvs\"這個名稱？ Python-Solvespace的作者有特別指名不要使用DLL做副檔名。 這次學到了編譯程式重要的一環，雖然make的過程中很煩人，也要一直注意是否出錯，但是最後成功時滿有成就感的。 有些錯誤當下想不出來，不過換一種想法後就能克服許多障礙，訓練眼光放遠也是一件重要的事情。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050718.html"},{"tags":"2016g1","title":"40323143 -  馬達控制  105年7月18日","text":"馬達控制 本篇為伺服馬達控制的學習筆記，共分為兩部分，第一部分為直接控制角度，第二部分以脈衝寬度控制。 控制角度: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <Servo.h> Servo myservo ; // 建立Servo物件，控制伺服馬達 void setup () { myservo . attach ( 9 ); // 連接數位腳位9，伺服馬達的訊號線 } void loop () { for ( int i = 0 ; i <= 180 ; i += 1 ){ // ( int i = 0; )表馬達初始角度為0度 //(i <= 180; )表馬達最終角度為180度 //(i+=1)表示馬達每次正轉1度 myservo . write ( i ); // 使用write，傳入角度，從0度轉到180度 delay ( 20 ); //馬達每0.02秒轉i+的角度 } for ( int i = 180 ; i >= 0 ; i -= 1 ){ // ( int i = 180; )表馬達初始角度為180度 //(i >= 0 ; )表馬達最終角度為0度 //(i-=1)表示馬達每次逆轉1度 myservo . write ( i ); // 使用write，傳入角度，從180度轉到0度 delay ( 20 ); //馬達每0.02秒轉i-的角度 } } 以脈衝寬度控制 : 馬達脈寬信號為500-1500-2500，對應的角度是-90度~+90度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <Servo.h> Servo myservo ; void setup () { myservo . attach ( 9 , 500 , 2400 ); // 修正脈衝寬度範圍 myservo . write ( 90 ); // 一開始先置中90度 delay ( 3000 ); } void loop () { for ( int i = 500 ; i <= 2500 ; i += 100 ){ // ( int i = 500; )表馬達初始訊號為500 //(i <= 2500; )表馬達最終訊號為2500 //(i+=100)表示馬達每次正轉訊號100所代表的角度 myservo . writeMicroseconds ( i ); // 直接以脈衝寬度控制 delay ( 300 ); //馬達每0.3秒轉i+=100所代表的角度 } for ( int i = 2500 ; i >= 500 ; i -= 100 ){ // ( int i = 2500; )表馬達初始訊號為2500 //(i <= 500; )表馬達最終訊號為500 //(i-=100)表示馬達每次反轉訊號100所代表的角度 myservo . writeMicroseconds ( i ); delay ( 300 ); //馬達每0.3秒轉i-=100所代表的角度 } } 來源: 葉難: Arduino練習：伺服馬達以Tower Pro SG90為例 結語: 以控制角度的方法可修改i的數值控制馬達轉角，並可透過修改i+、i-與 delay的值控制馬達旋轉的速度。 以脈衝寬度控制的方法與控制角度的方法很相似，但每一個馬達的脈衝訊號寬度不一樣，還需要以馬達的條件來設定轉角及轉速。","url":"http://project.mde.tw/blog/40323143-ma-da-kong-zhi-105nian-7yue-18ri.html"},{"tags":"2016bg2","title":"40323218日誌 - 105/07/17","text":"V-rep_solvespace_linkages 嘗試 vrep_solvespace_linkages 影片教學： vrep_solvespace_linkages from Li Steven on Vimeo . 檔案： solvespace_successful.ttt 心得： 組裝這個物件的重點我認為是在零件的順序和Dummy放置的位置，嘗試了兩天終於作了出來，對零件的從屬關係有比較OK了，有學會dummy的應用，再來就是把這些統整可以試著弄我們的 printer。","url":"http://project.mde.tw/blog/40323218ri-zhi-1050717.html"},{"tags":"2016g1","title":"報告的內容2","text":"實作部分 pyserial 因為要從樹梅派的USB到3D列印機的Arduino控制系統，必須做出一套橋梁，來做兩端的溝通，採用的方式是使用pyserial，由python第三方模組支援的串列通訊溝通，由官方提供的方法可以import pyserial後，就可以進行serial.open(Value)，開啟兩端的連接後，接者進行資料的傳送和溝通，利用3Dprinter裡面的指令，就可以下指令到3D列印機中控制他(例如:G01、M105\u0005…)，利用這樣的方式，就可以傳送基本指令控制3D列印機。 以下為串列傳輸程式碼: (包含解字、切字、utf-8、執行緒) #!/usr/bin/python3 import serial import sys import numpy as np import tkinter from matplotlib import pyplot, rcParams port = serial.Serial('COM6', 9600, timeout=1) # Tkinter canvas top = tkinter.Tk() top.title(\"Tkinter + matplotlib\") # Create flag to work with indefinite while loop flag = tkinter.BooleanVar(top) flag.set(True) def cleanText(data): data = data.replace(\"\\r\\n\", \"\") return data def onStartButtonPress(): while True: if flag.get(): line = port.readline().decode('UTF-8') reading = line.split(':') # print (reading) if len(reading) == 2: for i in range(2): if reading[0] == \"temperature\": TempLabel.config(text=cleanText(reading[1])) TempUnitLabel.config(text=\"C\") TempUnitLabel.update_idletasks() # if reading[0] == \"Temperature(F)\": # TempLabel.config(text=cleanText(reading[1])) # TempUnitLabel.config(text=\"F\") # TempUnitLabel.update_idletasks() if reading[0] == \"Humidity\": HumdLabel.config(text=cleanText(reading[1])) pData.append(float(reading[1])) del pData[0] # if reading[0] == \"Light(lx)\": # LighLabel.config(text=cleanText(reading[1])) if reading[0] == \"Flag\": # print (reading[1]) if int(reading[1]) == 1: try: print (\"In flag\") print (\"In flag -> if \") l1.set_xdata(np.arange(len(pData))) l1.set_ydata(pData) # update the data pyplot.ylim([0, 100]) pyplot.draw() # update the plot except: print (\"In flag except\") pyplot.figure() pyplot.title('Humidity') ax1 = pyplot.axes() l1, = pyplot.plot(pData) pyplot.ylim([0, 100]) if int(reading[1]) == 0: try: pyplot.close('all') l1 = None except: continue port.flushInput() top.update() else: flag.set(True) break def onExitButtonPress(): print (\"Exiting....\") flag.set(False) port.close() top.quit() top.destroy() print (\"Done.\") sys.exit() pyplot.ion() rcParams['toolbar'] = 'None' pData = [0] * 25 tkinter.Label(top, text=\"Temperature\").grid(column=1, row=1) tkinter.Label(top, text=\"Humidity\").grid(column=1, row=2) tkinter.Label(top, text=\"Light\").grid(column=1, row=3) TempLabel = tkinter.Label(top, text=\" \") TempLabel.grid(column=2, row=1) HumdLabel = tkinter.Label(top, text=\" \") HumdLabel.grid(column=2, row=2) LighLabel = tkinter.Label(top, text=\" \") LighLabel.grid(column=2, row=3) TempUnitLabel = tkinter.Label(top, text=\" \") TempUnitLabel.grid(column=3, row=1) HumdUnitLabel = tkinter.Label(top, text=\"%\") HumdUnitLabel.grid(column=3, row=2) LighUnitLabel = tkinter.Label(top, text=\"lx\") LighUnitLabel.grid(column=3, row=3) # Create Start button and associate with onStartButtonPress method StartButton = tkinter.Button(top, text=\"Start\", command=onStartButtonPress) StartButton.grid(column=1, row=4) # Create Exit button and destroy the window ExitButton = tkinter.Button(top, text=\"Exit\", command=onExitButtonPress) ExitButton.grid(column=2, row=4) top.mainloop() Flask 這邊我們選用的框架是flask，因為它輕巧、且具有大量的可擴充性，因此選用，相較於python其他兩個，他擁有比較小的空間和核心，較符合Raspberrypi的系統。 底下為利用flask看通訊端得到的資料 import flask import serial from time import sleep app = flask.Flask(__name__) app.debug = True def event_barcode(): messageid = 0 ser = serial.Serial() ser.port = COM&#94; ser.baudrate = 9600 ser.bytesize = 8 ser.parity = serial.PARITY_NONE ser.stopbits = serial.STOPBITS_ONE ser.timeout = 0 try: ser.open() except serial.SerialException as e: yield 'event:error\\n' + 'data:' + 'Serial port error({0}): {1}\\n\\n'.format(e.errno, e.strerror) messageid = messageid + 1 str_list = [] while True: sleep(0.01) nextchar = ser.read() if nextchar: str_list.append(nextchar) else: if len(str_list) > 0: yield 'id:' + str(messageid) + '\\n' + 'data:' + ''.join(str_list) + '\\n\\n' messageid = messageid + 1 str_list = [] @app.route('/barcode') def barcode(): newresponse = flask.Response(event_barcode(), mimetype=\"text/event-stream\") newresponse.headers.add('Access-Control-Allow-Origin', '*') newresponse.headers.add('Cache-Control', 'no-cache') return newresponse if __name__ == '__main__': app.run(port=5000, threaded=True) OctoPrint 我們在找相關資料的時候，發現到其實已經有人將我們實作的部分寫成一份套件包，只需要從新編譯過，就可以符合我們使用，而且他是屬於OpenSource，不會有版權上的問題，他將程式碼公開，讓我們這些後輩人學習，真的非常感動，我們照著他的code一路走，看到每個人針對他所想要走所設計的不同，看到不一樣的寫法，因此感謝他的幫助好讓我們可以有參考資料。主要他用的方法是使用我們看到的flask+js+nginx+pyserial+oprint+yaml，非常的複雜，但是在flask底下，可以很清楚的知道，每個py檔的作用和功能，可以讓我們比較好了解如何使用。","url":"http://project.mde.tw/blog/bao-gao-de-nei-rong-2.html"},{"tags":"2016g1","title":"報告的內容","text":"動機與目的 研究動機與目的 在使用3D列印機時，常常會需要長久的等待，例如:製作一個大型的物件，或者有很多複雜的小零件參雜，往往需要大量的時間去製作，途中列印完成的時間點，幾乎都落在凌晨，沒辦法讓機台持續列印下去，因為工件會附著在平台上，並沒有辦法直接操控電腦讓他進行列印動作，目前需仰賴人力，將其剷除，才可繼續進行列印動作。 隨著3D列印機日漸普及，人們開始設計、構思，裝載更多新功能的3D列印機，像是wifi版本、server版本、自動校正、判斷材料種類、自動參數…..等，但是相對於價格上，有越來越貴的趨勢，也沒有版本的觀念，一台機台可以設定的參數，會根據你所使用的切片軟體，有些廠商會開發屬於他們自家的切片軟體，以至於在我們的電腦上可能會有多套的軟體安裝。 近年來，物聯網(IOT)的觀念蓬勃發展，Raspberry pi 以及Arduino的發展漸漸邁向世界主流，人們得以結合平板、手機利用網路串連起這些嵌入式系統，直接在網路端，下達控制指令或者偵測，讓網際世界變得無遠弗屆。 若能在嵌入式系統中開發一套網際平台，讓所有可以連上網際平台的裝置，只需要登入系統，就能夠控制3D列印機，上傳、下載、列印、目前的列印狀態…等，針對目前需要人力在旁監控列印的狀態，利用嵌入式系統達到節省人力的目標，例如說:可以使用手機上傳客戶交代給你列印的檔案，利用網路上傳到嵌入式系統中，可以讓你在任何時間、地點，不受時間、空間的侷限，來控制你的3Dprinter，再配合自動下料系統，可以連續列印，節省人在機器旁邊等待的時刻，再利用自動校正加上下料系統，能夠讓機器24小時運作，並且可以在網頁上看到目前的列印狀態以及縮時攝影。因此本專題使用樹梅派(Raspberry pi)加上python製作一套可針對大部分開源的機台所使用的網際控制介面。 使用語言Python Python是一種以通用性為目的、物件導向、直譯式的高階程式語言，由Guido van Rossum在1991年發佈，python能夠安裝在許多不同的操作系統上，擁有跨平台的好處，且擁有大量第三方的函式庫(Third-party library)，在眾多領域皆有應用(科學與數學運算、大數據、經濟、電腦繪圖、網路開法等)並提供豐富的API和工具，使開發者能夠使用C、C++來擴充模組，python因為擁有許多可被應用在科學開發上的函式庫(如:Numpy、Matplotlib…等)，且其快速開發為導向的特性，因此許多領域的開發都選擇Python作為主要開發的語言。 網際網路架構(Nginx) Nginx，是一個網頁代理伺服器，在2004年發表，但是在當時因為apache server還是屬於強勢期，並沒有被大家重視，但是他的特點在近期被大家重視，主要是在效能設計的HTTP伺服器，相較於其他兩個，佔有記憶體較少，穩定性高等優勢與舊版Apache不同，Nginx不採用每個client端一執行緒的設計模型，而是充分運用異步邏輯，削減上下文排成的開銷，因此再並行服務能力更強。整體採用模組化設計，有豐富的模組庫以及第三方開發的模組，配置非常靈活。在linux系統中，Nginx使用epoll事件模型，得益於此，nginx在linux作業系統(例:ubuntu 14.04 raspbane)下效率相當高，以及可以大量平行運算等特點，在我們的嵌入式系統，採用Nginx當作代理伺服器。 web framework(flask) Flask為一種微型網際網路架構，和Django不一樣，微型不代表整的web都需要用同一個python文件(當然也是可以使用同一個)，也不代表他是缺乏功能，只擁有基本的網路架構，在微型framework指的是核心簡單易於擴充，Flask不會決定你要用什麼樣的database，或者必須安裝怎樣的模組，一切都可以看使用者，需要怎樣的功能，就安裝不一樣的模組，可針對我們需要使用的模組做延伸，因此我們選用Flask當框架使用。 Django能夠用於快速開發複雜的網站且擁有大量的第三方套件可做延伸，並具有相當完善的說明文檔、穩定的發布流程，與其他框架相比較完整，但相對於用在嵌入式電腦中，他所需要的運算量較大及對記憶體的考量，也有可能對Raspberry pi造成當機，或者運算緩慢，因此不考慮使用。 server硬體規格 Raspberry pi 3硬體規格 記憶體 1 GB CPU 1.2 GHZ 位元數 64位元 記憶卡 32 GB","url":"http://project.mde.tw/blog/bao-gao-de-nei-rong.html"},{"tags":"2016bg2","title":"40323230紀錄 - Makefile的建構","text":"閱讀GNU-Make相關的知識。 嘗試了解Python-Solvespace的Makefile運作方式。 Makefile簡介 : 閱讀資料來源： http://mropengate.blogspot.tw/2015/06/makefile-makefile.html http://jeff71321.pixnet.net/blog/post/92143030-makefile%E6%95%99%E5%AD%B8(%E4%B8%80) GNU-Make在開發者工具包有著極其重要的地位，最大的好處就是「自動化編譯」。 相較於要用shell來執行編譯的Script，GNU-Make可以只針對部分內容作測試，相當有自由度。 make.exe依靠著Makefile的設定來將整個專案按照原作者的設定，編譯成可執行文件或是連結庫。 也因為如此，只要是願意加入專案協同的工程師，裝好原作者使用的工具，無論使用哪個編譯程式，就能利用一個make命令，從頭到尾將專案編譯好進行測試或除錯。 注意事項 : GNU-Make在閱讀一份Makefile時有幾個重點。 首先若直接執行make指令，會尋找當前目錄中叫\"Makefile\"或\"makefile\"的文件。若Makefile並非這兩個名稱（亦能自訂附檔名），可以加上\"-f\"參數指定Makefile的名稱。 Makefile中包含了 ： 1. 顯式規則 ：說明如何生成一個或多個文件，有使用工具、依賴文件、使用參數等等。 2. 隱晦規則 ：不太瞭解這個功能，大約是利用自動推導原則，可以比較簡略地寫定義，篩選檔案。 3. 變量 ：自訂參數的功能，能自由更改位置或目標名稱、使用工具和參數等等。 4. 文件指示 ：Makefile之間是可以互相溝通的，也可以透過情況作出判斷。 5. 註解 ：Makefile的註解符號是\"#\"，如果要使用井字符號，必須使用反斜線\"#\"。 特別注意，在Makefile中，命令項的起始一定要使用Tab縮排，不可使用空白字元。 一般撰寫程式的編譯器都能檢視空白字元的類型。 SciTE ：View -> Whitespace Netbeams ：View -> Show Non-printable Characters 在此會發現Tab（→）和空白字元（.）的差異。 不過某些像是SciTE的編譯器，在按下Tab鍵時，會幫使用者轉換成四個空白字元，甚至會用空白字元補齊縮排，所以使用上需要注意。 Makefile中的目錄分隔號是斜線\"/\"，換行閱讀符號是反斜線\"\\\"。 GNU-Make在執行途中遇到錯誤就會停止並跳出，所以必須要整個Makefile和編譯過程都沒有干擾執行問題，才會編譯完畢。 主要規則 : 語法的結構就是目標文件（未生成）後方加上冒號和空格，接著同一行中必須接上會利用到的檔案名稱（不包含工具和include參數的項目）。 第二行是寫下如何產生目標文件的命令。 一個項目中有多個檔案時會用一個空白字元分隔。換行時如果想縮排以便閱讀，必須使用空白字元縮排，不然Tab起始的項目都會視為命令。 而如果命令不能執行時就會中斷操作。 Makefile中的參數定義和大部分的語言雷同。不過為了明顯標示，大部分使用者習慣大寫字母。 定義項目後，使用\"＄( )\"符號括住來使用變數。變數可以是目錄位置、命令名稱、參數名稱，亦有如\"＄＄(basename ＄＄(notdir ＄＄@))\"內定的用法。 編譯結果 : 途中用Netbeams作輔助檢查檔案關聯性和編寫文件，並make專案。 不過用cmd下指令也是可行。只是直接打make會用到MinGW的make，必須先指定MSYS的make。 Python-Solvespace中的Makefile編寫有一些小缺漏，是Tab和空白字元的問題，後來改正就沒問題了。 不過後來在Netbeams編譯外層\"Solvespace\"時出現了一些問題： 檢查了一下，似乎中間的檔案\"＄(SRFOBJS)\"找不到？而\"＄(SRFOBJS)\"的檔案是從\"srf\\＄(@B).cpp\"和\"＄(HEADERS)\"產生的。 其中\"srf\\＄(@B).cpp\"應該就是取下所有\\srf資料夾的cpp檔案，配上標頭檔後生成obj檔。途中不知道什麼原因obj檔沒有產生，所以才會無法找到？ 但是只編譯exposed資料夾的Makefile時又有這個問題： 上網檢查了一下這段的用途是編碼對應，可是語法照常來講應該沒錯才是。 而且後面對應的檔案導入時都出錯，所以就停止了。 Makefile和cmake的CMakelist.txt一樣都是工程師自己要創建的，所以又是一項工程，不過除了一些內定代號，其他都滿好理解的。 找了一下Python-Solvespace相關的網站，但是內容都好少。不過在Github的說明已經滿詳盡了，只是倉儲內的資料時間有點久遠，所以要花些時間偵錯。","url":"http://project.mde.tw/blog/40323230ji-lu-makefilede-jian-gou.html"},{"tags":"2016g1","title":"KmolPrint 0716","text":"關於目前設計3dprinter clouds domain name可能想要的名子(IPV6還沒弄) kmolprint.mde.tw 目前我們這組規劃圖設計以及目前擁有的功能 今天將攝影機的模組mjpg串流做好了","url":"http://project.mde.tw/blog/kmolprint-0716.html"},{"tags":"2016bg2","title":"40323218日誌 - 105/07/15","text":"V-rep 程式應用 從 irb360 程式中找尋可能用到的並嘗試解釋和整理。 simGetObjectHandle - 對物件命名 用法： number objectHandle=simGetObjectHandle(string objectName) simSetJointTargetPosition - 設置目標位置(if the joint is in torque/force mode)(motor and position control are enabled) 用法： number result=simSetJointTargetPosition(number objectHandle,number targetPosition) simGetJointPosition - 得到軸的位置(不能使用在關節上 , 用simGetJointMatrix取代) 用法： number position=simGetJointPosition(number objectHandle) simSwitchThread - 轉換到另一個程式 用法： number result=simSwitchThread() simAddStatusbarMessage - 增加一則訊息到狀態欄 用法： number result=simAddStatusbarMessage(string message) simSetIkElementProperties - 設置性質的特定反向運動元素 用法： number result=simSetIkElementProperties(number ikGroupHandle,number tipDummyHandle,number constraints,table_2 precision=nil,table_2 weight=nil 補充： IK = Inverse kinematics(在左邊功能區第三個裡) simSetJointMode - 設置joint的操作模式 用法： number result=simSetJointMode(number jointHandle,number jointMode,number options) 補充： option(現在設定為0是可以被使用，如果設定為1會啟用hybrid mode) jointMode sim_jointmode_passive sim_jointmode_motion_deprecated sim_jointmode_ik sim_jointmode_ikdependent sim_jointmode_dependent sim_jointmode_force simGetObjectAssociatedWithScript - 擷取角本附加到物體處理 用法： number objectHandle=simGetObjectAssociatedWithScript (number scriptHandle) 補充： scriptHandle = sim_handle_self simRMLMoveToJointPositions - 在同一時間幾個關節一起使用Reflexxes Motion Library type IV移動（驅動）。這功能只能在child scripts中一個thread中運行（因為這是一個阻塞的操作），而且C-API的不可使用。 用法：number result , table newPos , table newVel , table newAccel , number timeLeft = simRMLMoveToJointPositions ( table jointHandles , number flags , table currentVel , table currentAccel , table maxVel , table maxAccel , table maxJerk , table targetPos , table targetVel , table direction) 補充： jointHandles: 要驅動的joint flags: RML flags. -1 for default flags. currentVel: the current velocity of the joints. Can be nil in which case a velocity vector of 0 is used. currentAccel: the current acceleration of the joints. Can be nil in which case an acceleration vector of 0 is used. maxVel: the maximum allowed velocity of the joints maxAccel: the maximum allowed acceleration of the joints maxJerk: the maximum allowed jerk of the joints targetPos: the desired target positions of the joints targetVel: the desired velocity of the joints at the target. Can be nil in which case a velocity vector of 0 is used. direction: the desired rotation direction for cyclic revolute joints: 0 for the shortest distance, -x for a movement towards negative values, +x for a movement towards positive values (n=(x-1) represents the number of additional turns). Can be nil or omitted, in which case a value of 0 is used for all joints (待補充)","url":"http://project.mde.tw/blog/40323218ri-zhi-1050715.html"},{"tags":"2016g1","title":"40323131日誌 105/07/15","text":"將OctoPrint標題替換成KMOL 先來看關於下圖的框框處，是如何更動的 一開始用grepwin 尋找OctoPrint然後找了蠻久的，終於在下圖的地方找到了 不過後來重啟ocopi之後，發現在還沒有完全載入前，是有變換成KMOL的，不過後來又變回去OctoPrint，後來在網頁按下F12查看原始碼，發現到在下圖中框框處， load 到框框前都是KMOL，不過框框後發現到又變回去OctoPrint了 所以去查看那些檔案裡頭的程式碼，裡頭也是很多關於物件導向的東西，不過還好有惡補了一下，所以不是太難，又想到裡頭它可能有重新指向一個物件，導致它又重置了，所以又在下圖的地方發現了他有定義一個屬性項，去執行底下的程式 於是為了找webassets 這個物件，又費了一番功夫，網頁的話，想到會不會跟 .js檔有關呢? 於是到了網頁原始碼裡找，終於在下圖的地方找到了 不過由於無法直接在網頁原始碼上頭進行修改，要在設定檔裡頭修改，於是朝天花板發呆了大約5分鐘，思考了一下大概的檔案位置，於是在下圖找到了檔案位置了，將裡頭的OctoPrint修改成KMOL之後再重啟OctoPi 就會變成這樣，成功的更動，之後的小圖檔也修改成KMOL的圖示了 關於要修改裡的設定檔，跟我原本預期的不太一樣，要進到蠻底層的，才能修改到，不過也多虧了grepwin這個工具，幫了我蠻多忙，因為有進行大約一個多禮拜的python課程惡補一下，對於裡頭的程式碼大概都看得懂七八成了，所以覺得還ok，對於我的組員們，我感謝他們通融我這一個多禮拜沒什麼做事情，另外老師說的同時控制10個馬達的東西，我找過櫃子了，沒有找到，另外在櫃子裡也發現到有蠻多學長留下來的論文可以參考，所以拿給模擬作動的組別參考用了，裡頭有關平面四連桿、史都華平台機構、逆向運動學等等......","url":"http://project.mde.tw/blog/40323131ri-zhi-1050715.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/15","text":"研究Python-Solvespace。 更新Anaconda3 : 從官方網站下載最新的Anaconda 3，配有Python 3.5.2。 https://www.continuum.io/downloads 使用Path指令檢查環境變數。 確定無誤後放入可攜式環境中，並把原本的Python 3.5移除，將start.bat的環境位置改成Anaconda的資料夾。 接著再檢查Anaconda程式的運作狀態。 安裝了其他工具，也包含Leo 5.3。 說明 : Python-Solvespace 是由BBBSnowball所開發的Solvespace函式庫，另外能調用Solid-python來協助運算。 Python-Solvespace最後一次更新是在2013年，所以使用的是Python 2，SWIG可能也是舊版的。 而根據協同者們留下的\"VbDemo.vb\"紀錄，應該是用VC來編譯它的。 若要使用Solid-python，必須用\"git submodule update --init\"指令額外下載它，不然只有空資料夾。 不過目前沒有要使用Solid-python，所以可以不用下載。 按照Readme的說明，要用make指令來編譯檔案。 但是在make的時候出錯了，顯示\"missing separator. Stop.\"的錯誤，查了下面的網站，貌似是make.exe的新版本讀取舊的Makefile的問題，必須改寫他們的Makefile或使用舊版的MSYS。 http://www.crifan.com/error_missing_separator_stop_while_make_in_windows_cmd/ 而顯示的錯誤如下圖： 與Whitequark的版本比較 : 不過Python-Solvespace有留下來interface的檔案，但是它的檔案結構已經跟Whitequark的版本不一樣了，所以也不能直接讓interface對應新版的檔案來創建。 好消息是SWIG的interface檔案改變不大，新版仍能使用。只要切換到\\exposed資料夾，使用下列指令就能生成\"slvs_wrap.cxx\"。 swig -c++ -python -py3 slvs.i 新版有用到cmake來建置檔案，但是Python-Solvespace沒有，所以沒有CMakelist的清單。而CMakelist是要手動編寫的，視規模大小來分配。 Python-Solvespace似乎是只有原本Solvespace的\"src\"資料夾部分（不過外面原本就是給編譯器介紹用）。 並將\"exposed\"、\"extlib\"、\"win32\"等資料夾放了進來，並且將總標頭檔\"slvs.h\"和DLL的\"lib.cpp\"加入\"exposed\"中，讓CDemo成為主幹，調用Solvespace裡的約束函式。 但是\"exposed\"中除了原本的CDemo，還有一個h++的標頭檔\"slvs_python.hpp\"、一個\"DOC.txt\"說明Python要如何呼叫編譯好的函式列表，以及一些Python的小程式。 test.py : py檔總共有3個，其中一個是使用Solid-python的呼叫工具，其他的\"test.py\"分別用\"2.scad\"和\"3.scad\"命名。 檢查了一下Python-Solvespace附上的py檔，最後作者做了3個測試，並寫下了一些註解。 第一個\"test.py\"，展示了Python要如何取用slvs.dll的函式，長得跟原先的\"CDemo.c\"十分相似。 在這裡，可以注意到SWIG轉換後的函式名稱還是一樣，用法也極其相似。 第二個\"test2.scad.py\"匯入了slvs和solid。 由於Python只要在附近資料中尋找到宣告的項目就可運作，所以不太確定它們的副檔名究竟是DLL還是SO、PYD之類的連結庫或Python程式。 第三個\"test3.scad.py\"明顯使用了\"slvs_solid.py\"的內容，不過只有稍微閱讀過Solid-python的Readme，所以不太知道它的函式，但是看似比Solvespace更方便。 這次在Python-Solvespace碰上一些小瓶頸。 主要是MSYS的Makefile問題，論壇上滿多人討論它在編譯時的障礙，有時連參數前加個空格都會顯示錯誤，無法進行。 而Python-Solvespace應該是用不到cmake（因為原作者是用VC），如果需要用到Netbeams，就要自行撰寫一份CMakelist，或是在編譯器中捨棄它的功能。 至於需要Python 2轉Python 3的部分比較少，除非要動用Solid-python的內容。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050715.html"},{"tags":"2016g1","title":"40323143 -  日誌  105年7月15日","text":"解決手臂動力問題 日記: 今天決定了動力不足的解決方案，選擇的方案是更換馬達，原因是因為可以迅速的解決問題。於是便將除了驅動旋盤的馬達外全部換成一般型的伺服馬達。控制程式找了別人寫的馬達控制程式修改，還沒有改完。 原本打算嘗試看看減速機，但可能會多花很多時間，之後可能會再找時間看看。 今天還想了一套只用一個馬達的夾取手臂，最後因為更換馬達的決定而放棄這個方案沒有做出來。 今天還看了看研究室裡名叫創意性機構設計分析的書，覺得我先前做試的順序有很多問題，還沒有整理出來。 新手臂構想: 做一個四連桿，曲桿和搖桿等長，再將連接桿延長安裝夾頭，用馬達去驅動曲桿來控制。 初始位置為曲桿垂直地面，夾取位置為[ r sinT+C , r - r cosT +C ] T為角度，C為補正。 構想圖 備註: 1.伺服馬達是在虎尾的無名電子買的。 別人寫的馬達控制程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <Servo.h> Servo servoLeft ; // 宣告左邊伺服馬達 Servo servoRight ; // 宣告右邊伺服馬達 void setup () { servoLeft . attach ( 10 ); // 將 Pin 10 指定為左邊伺服馬達 servoRight . attach ( 9 ); // 將 Pin 9 指定為右邊伺服馬達 } void loop () { initial (); // 馬達位置歸零 delay ( 2000 ); // 執行後停止兩秒 same_degree (); // 左右伺服馬達同樣各轉30度 delay ( 2000 ); // 執行後停止兩秒 initial (); // 馬達位置歸零 delay ( 2000 ); // 執行後停止兩秒 dif_degree (); // 左伺服馬達轉30度，右伺服馬達轉150度 delay ( 2000 ); // 執行後停止兩秒 } void initial (){ servoLeft . write ( 0 ); servoRight . write ( 0 ); } void same_degree () { servoLeft . write ( 30 ); servoRight . write ( 30 ); } void dif_degree () { servoLeft . write ( 30 ); servoRight . write ( 150 ); } 來源: 修改後的程式: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <Servo.h> Servo servo1 ; Servo servo2 ; Servo servo3 ; void setup () { servo1 . attach ( 8 ); servo2 . attach ( 9 ); servo3 . attach ( 10 ); } void loop () { initial (); // 馬達位置歸零 delay ( 2000 ); // 執行後停止兩秒 same_degree (); // 伺服馬達同樣各轉40度 delay ( 2000 ); // 執行後停止兩秒 initial (); // 馬達位置歸零 delay ( 2000 ); // 執行後停止兩秒 dif_degree (); // 伺服馬達同樣各轉90度 delay ( 2000 ); // 執行後停止兩秒 } void initial (){ servo1 . write ( 0 ); servo2 . write ( 0 ); servo3 . write ( 0 ); } void same_degree () { servo1 . write ( 40 ); servo2 . write ( 40 ); servo3 . write ( 40 ); } void dif_degree () { servo1 . write ( 90 ); servo2 . write ( 90 ); servo3 . write ( 90 ); } 結語: 發現自己的思考有很多問題，有點混亂、挫折，想整理整理，看看書。","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-15ri.html"},{"tags":"2016g1","title":"KmolPrint 0715","text":"關於目前設計3dprinter clouds 目前我們的網站 將原本的網站做一次更新，並且讓設定檔做好，接下來會把setting中再加入指令檔，就可以啟動攝影機和server的從新啟動以及開關server。 網址位置在:140.130.17.107 未來是想要加damain name 讓140.130改成自己的網址，好讓自己的網站發展，以及學習如何加入自己的網址。","url":"http://project.mde.tw/blog/kmolprint-0715.html"},{"tags":"2016bg2","title":"40323231日誌 - 105/07/14","text":"3DP碰到的問題及解決 第一次組裝3D列印機，所以各個零件和電子元件的功用都不知道，所以只能從型號去著手，知道並了解運用。 在研究電子板的時候發現，熱床是時麼?而且我手邊怎麼沒有熱床? 解決:我們有熱床，只是我們的跟網路上和現有的3DP不一樣。它的功用是防止成品翹邊，由於料出來是熱的，經過板子和空氣冷卻導致成品收縮，所以熱床需給予溫度，減輕翹邊，可是不能完全避免，而且會因材料不同，需要的溫度也不同(我們的材料PLA大約60度，)。電壓不能輕易更改或太高，因為電壓高一倍，功率大四倍，所以一開始要確定給定的電壓。 在接限位開關線路的時候發現，在夢工廠老師接的線路和網路上的不一樣，三條線路分別為\"+\"\"-\"\"S\"顏色分別為\"紅\"\"藍\"\"黑\"，夢工老師接的是\"+\"接紅，\"-\"接藍，\"S\"接黑。網路是\"+\"接紅，\"-\"接黑，\"S\"接藍。而且3個限位開關的線路有的接3條，有的接2條，很混亂，沒有頭緒。 問題:1. \"+\"\"-\"\"S\"如何接? 2.為何線路有的接兩條有的接三條? 限位開關分兩種: 1. 機械微動開關接法 機械微動開關只需接2個腳位的：單純使用微動開關當作限位器，那一定要接RAMPS上的 \"S\" 跟 \"-\" 腳位。絕對不要把3個腳位都接了，如果不小心接了3個腳位，那在觸發時會發生火花，會把5V穩壓 IC燒毀。 2. 光學限位開關接法(我們的) 光學限位開關則是需要用到3條線，接到RAMPS上的\"S\"、\"-\"及\"+\" 3個腳位。 1.S為藍，+為紅，-為黑 2.常開型和常關型只有微動開關才有，所以光學開關一定要3調都接 今天進度 組裝 3DP，將缺少的材料抄寫下來，將跟工廠管理員詢問，使用VREP，看組員的所寫的網誌並實際操作","url":"http://project.mde.tw/blog/40323231ri-zhi-1050714.html"},{"tags":"2016bg2","title":"40323218日誌 - 105/07/14","text":"V-rep 翻譯文章重點 原文章網址： http://www.coppeliarobotics.com/helpFiles/en/buildingAModelTutorial.htm Building the visible shapes： 1. Automatic mesh division： [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes] (自動分割物件，有時候會無作用) [Menu bar --> Edit -> Grouping/Merging --> Merge selected shapes] (使選擇的物件組合在一起) 2. Extract the convex hull： [Menu bar --> Edit --> Morph selection into convex shapes] (使物件轉換成convex hull) 3. Decimate the mesh： [Menu bar --> Edit --> Decimate selected shape...] (減少mesh三角形量) 4. Remove the inside of the mesh： [Menu bar --> Edit --> Extract inside of selected shape] (此功能是基於視覺傳感器，可以依靠設定得到更多或更少滿意的結果。) 上述功能沒有先後順序(除了第一項應該先嘗試)，主要取決於我們如何嘗試精簡mesh。 下圖說明上述功能應用到imported mesh（沒有第一項）： 再來我們要分割imported mesh，有兩種方式可使用。 1. Automatic mesh division：跟上面一樣 2. Manual mesh division：這使用 triangle edit mode (左邊功能列第六個)，選擇你要的物體的三角形，再點 Extract shape，他會投影物件出來，再把原先選擇的三角形刪除。 Building the joints 再來我們要創建 joint，先 import mesh，使用 triangle edit mode 使物件三角形化。 我們需要使 joint 在圓心中間，所以我們點選圓形的三角形，點選 Extract cylinder 或 Extract shape ，他會在選擇的三角形上投影一個圓形出來。 右鍵→Add→Joint→Revolute(創建一個Revolute joint)， 再來我們點Revolute joint、Ctrl點投影的圓型，點 Position/Translation 按鈕，然後在 Object/item position section裡，我們點 Apply to selection (使兩物體位置相同)。再來我們點Orientation/Rotation 按鈕，然後在Object/item orientation section裡，我們點 Apply to selection(使兩物體坐標軸相同)。 Building the dynamic shapes 如果我們想要使 Robot 作動，那麼我們就需要適當地創建/配置形狀。形狀可以是： 1. dynamic or static： dynamic 是動態，如果這個形狀是動態的，它將會有重量會往下掉，也會對力/力矩造成影響。 static是靜態，他跟 dynamic 相反，他會固定在位置上或隨著 運動移動。 2. respondable or non-respondable： respondable shape 是會跟其他的 respondable shape 造成碰撞效應，他們或其對撞機，將會影響其運動(如果它們是動態的) 。 non-respondable shapes 是相反，他們不會造成碰撞運動。 respondable shape應盡可能簡單，以允許快速和穩定的模擬。一個物理引擎將能夠模擬以下5種不同程度的速度和穩定的形狀： 1. Pure shapes： [Menu bar --> Add --> Primitive shape] 一個Pure shapes是穩定的，並由物理引擎非常有效地處理。Pure shapes在幾何限制：大部分長方體，圓柱體或球體。 2. Pure compound shapes： [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes] 它是由多個Pure shape組合而成的，功能跟Pure shape雷同。 3. Convex shapes： [Menu bar --> Add --> Convex hull of selection] [Menu bar --> Edit --> Morph selection into convex shapes] Convex shapes會有點不太穩定，當物理引擎處理時需要多一點點計算時間。它允許一個比純形狀更一般的幾何形狀（唯一的要求：它必須是 convex）。 4. Compound convex shapes, or convex decomposed shapes [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes] [Menu bar --> Add --> Convex decomposition of selection...] [Menu bar --> Edit --> Morph selection into its convex decomposition...] 它是由多個convex shapes組合而成的，功能跟convex shapes雷同。 5. Random shapes： 一個Random shapes是一個形狀不是convex也不是pure。它一般具有性能差（計算速度和穩定性）。盡可能地避免使用隨機的形狀。 因此，優先順序是：pure shapes → pure compound shapes → convex shapes → compound convex shapes → random shapes。","url":"http://project.mde.tw/blog/40323218ri-zhi-1050714.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/14","text":"試圖解決SWIG問題 撰寫批次檔 : 依照 http://www.ittc.ku.edu/kusp/kusp_docs/kusp_swig_guide/index.html 提供的gcc指令，撰寫了3個批次檔來執行。 第一個命名為interface.bat，用來讓swig生成\"_wrap.c\"檔，並建立\"build\"和\"dist\"兩個資料夾。 @echo off set interface_name=example echo 編譯接口 swig -python -py3 %interface_name%.i echo 編譯完成 pause REM MKDIR echo 正在建立目錄 MKDIR \"build\" MKDIR \"dist\" echo 目錄已建立 pause 第二個是pyd.bat，主要是下gcc的編譯指令並執行runme.py，不過不知道修改後正不正確。 原理是將example.c和它的_wrap.c參照W:/Python35/include的內容變成\".o\"檔，再將它們參照W:/Python35/libs/libpython35.a編譯成\".pyd\"檔。 @echo off set target_name=example set module_name=example echo 正在建立暫存檔 gcc -c -g %target_name%.c %target_name%_wrap.c -IW:/Python35/include move %target_name%.o build\\%target_name%.o move %target_name%_wrap.o build\\%target_name%_wrap.o echo 暫存檔建立 pause echo 正在建立PYD gcc -shared build/%target_name%.o build/%target_name%_wrap.o W:/Python35/libs/libpython35.a -o dist/%module_name%.pyd echo PYD建立 copy /Y runme.py dist\\runme.py python dist\\runme.py pause 第三個式失敗後重來的清除工具，刪掉前面建立的檔案和成果檔。 @echo off set target_name=example echo RMDIR... RMDIR /S /Q .\\build RMDIR /S /Q .\\dist echo DEL... del /F /S /Q %target_name%_wrap.c del /F /S /Q %target_name%.py pause 檔案如下圖： 將interface.bat和pyd.bat分開的原因是為了檢察途中example.i和example_wrap.c是否出了問題。 執行測試 : 之前的example.c和example.i內容並沒有更動。 第一次執行後，發現會出現以下錯誤： 然後就發現example_wrap.c中的這句錯誤了，多了一個底線符號，刪除後就能導入了。 這個錯誤經過搜索後是SWIG本身的問題，要解決的話必須重新編譯原始碼。 但是這個舉動實在是太耗費時間了，所以後來放棄了。 不過更改那行後，runme.py就可以導入example.pyd，不過卻會出現TypeError，如下圖： 估計是這裡有錯誤： 不過不知道怎麼調整。 SWIG在自身的編譯上有點小錯誤，但是有些地方因為不了解Python的模組，所以不知道要怎麼修改。 另外有些不知道C語言的格式轉換是怎麼套用到Python的，所以在Python.h的函式不知該怎麼用。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050714.html"},{"tags":"2016g1","title":"40323143 -  日誌  105年7月14日","text":"寫Arduino控制程式 3 日記: 今天知道Arduino不能夠同時使兩個馬達作動，於是今天將馬達的控制程式改成有順序的動作，達成利用Arduino控制兩個馬達，但在測試的過程發現懸盤上的馬達在手臂伸出去後沒辦法收回來，原因可能是馬達的力量不夠，目前有兩個方案:(1).減速機 (2)馬達變更為可控制角度的馬達。 減速機優點: 1.提高馬達的輸出力。 2.加長手臂移動的時間，控制馬達運轉時間的方法會更精確。 3.馬達到定位後受慣性和重力的影響會變小，因為馬達本身的阻尼透過減速機會變大。 缺點: 複雜 更換馬達優點: 用了可以解決大部分問題 缺點: 目前沒想到 應該是利用第二種方案的可能性比較大，還沒有決定好。 備註: 1.今天將控制兩個馬達的程式完成 ( 程式1 )，若採用減速機來解決馬達輸出力不足的問題，這套就接上旋盤旋轉的程式完成。 2.若採用更換馬達來解決馬達輸出力不足的問題，會在新增角度控制的程式到程式中，還沒有寫出來。 程式1: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include <Servo.h> Servo myservo1 ; Servo myservo2 ; void setup () { Serial . begin ( 9600 ); myservo1 . attach ( 9 ); myservo2 . attach ( 10 ); } void loop () { int d ; int e ; //att.write(90); myservo1 . write ( 90 ); //啟動時固定 myservo2 . write ( 90 ); //啟動時固定 if ( Serial . available ()){ d = Serial . parseInt (); Serial . println ( d ); if ( 0 <= d && d <= 130 ){ //e=1000*asin(d/130)*180/PI/144; //將輸入的距離轉換成需要旋轉的時間 myservo1 . write ( 175 ); //1固定正轉 delay ( 250 ); //旋轉此時間會讓馬達與安裝面垂直 myservo1 . write ( 5 ); //慣性補正 delay ( 10 ); myservo1 . write ( 91 ); //引力補正 delay ( 1000 ); myservo2 . write ( 175 ); //2固定正轉 delay ( 250 ); //旋轉此時間會讓馬達與安裝面垂直 myservo2 . write ( 5 ); //慣性補正 delay ( 10 ); myservo2 . write ( 91 ); //引力補正 delay ( 1000 ); myservo2 . write ( 175 ); //2固定正轉 delay ( 375 ); //正轉移動到目的地所需的時間 myservo2 . write ( 5 ); //慣性補正 delay ( 10 ); myservo2 . write ( 91 ); //引力補正 delay ( 1000 ); myservo1 . write ( 175 ); //1固定正轉 delay ( 375 ); //正轉移動到目的地所需的時間 myservo1 . write ( 5 ); //慣性補正 delay ( 10 ); myservo1 . write ( 89 ); //引力補正 delay ( 1000 ); myservo1 . write ( 5 ); //固定反轉 delay ( 375 ); //反轉相同時間復歸 myservo1 . write ( 5 ); //固定反轉 delay ( 270 ); myservo2 . write ( 5 ); //固定反轉 delay ( e ); //反轉相同時間復歸 myservo2 . write ( 5 ); //固定反轉 delay ( 270 ); } } } 結語: 手臂總算有一個能夠控制的程式出來了，等到輸出力不足的問題解決後測試的手臂就算完成了，接下來就可以依使用尺寸做一個實際使用的手臂。","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-14ri.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/13","text":"Python 3.5.2軟體更新 軟體更新目標 : 之前W:沒安裝Python和Leo，所以暫時把Y:的複製過來用。 以W:為主，Y:用來撰寫網誌暫不需要更新。 1.Python 3.5及之前安裝的套件。 2.Leo 5.3正式版。 Python及套件更新步驟 : 將W:槽的Python 3.4.4 RC1更新至最新的3.5.2。 Python 3.5.2下載處： https://www.python.org/downloads/ 刪除Python34資料的所有內容後，將安裝完的Python35放進W:內，並將start.bat內的Python34位置全數改成Python35。 在Y:槽中執行以下指令以取得舊有的軟體資訊，存成名為rq.txt的清單。 pip freeze > rq.txt 清單中列的就是Python 3.4安裝的套件版本。 進入Python 3.5後使用pip指令時出現類似\"Fatal error in launcher\"的訊息，原因是官方的pip版本較舊。 如果不更新，只能用\"python -m pip\"的方式驅動它，所以先命令它為自己升級。 python -m pip install pip --upgrade 然後再利用Y:槽傳來的清單安裝，不過之前的Leo 5.1沒有在pip的下載網站裡，5.3版也要從Leo的官方下載，所以暫時先把leo剔除。 接著利用下列指令更新： pip install -r rq.txt 就會裝回所有的套件了。 使用下列指令可以查看已安裝的套件。 而只要在安裝時加入--upgrade參數就能更新，不過目前沒有全部更新的指令。 //已安裝套件 pip freeze //過期套件 pip list --outdated Leo更新步驟 : 至於安裝Leo，到 http://sourceforge.net/projects/leo/files/Leo/ 下載5.3的安裝檔，並暫時解壓縮到根目錄。 接著進入\\Leo-5.3-final\\leo\\dist資料夾，執行下面指令： python setup.py install 安裝完後，接著就能把解壓縮的檔案刪除了。 不過在pip的紀錄中還是5.0 Bata2的樣子。 新版的Leo介面（設定檔複製之前的）。 上次的swig還是沒成功，\"_wrap.c\"中似乎還要加一些python3的判斷式。 http://python3porting.com/cextensions.html#module-initialization 這裡的作者描述還是有點看不懂，雖然下了-py3的指令，但是設定還是沒調。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050713.html"},{"tags":"2016g1","title":"40323143 -  日誌  105年7月13日","text":"寫Arduino控制程式 2 日記: 今天對控制程式做了一些修改，程式新增了抵抗地心引力的補正，以及抵抗慣性的補正。 今天嘗試用一片Arduino控制兩個馬達，試著寫了兩種程式，一種不會動，另一種作動方式不對，輸入4次訊號前兩次1號馬達動，後兩次2號馬達動，都不能用。 備註: 1.移動距離轉換的數學式是 1000 (acos(d/150)/144) ，將d設成所要移動的距離，將d除以承臂長度( 150 )求出比值，再用acos轉換成需要旋轉的角度，除以角速度(144)的出需要旋轉的毫秒，在 1000得出需要的秒數。 2.角速度是由myservo.write(172); 旋轉5秒轉4圈算出來的，只有目測沒有量測。為什麼用myservo.write(172)，因為其他的速度不會轉回同個位置。 3.引力補正是用與引力相反的微速轉動馬達來對抗引力。 4.慣性補正是用與運動相反的方向相反的高速 delay(100) 來抵抗慣性。 5.新增補正的原因是因為我們的馬達是連續旋轉型的，沒辦法讓他固定，所以用補正解決。 程式: 加了補正的程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include <Servo.h> Servo myservo ; //旋盤上 void setup () { Serial . begin ( 9600 ); myservo . attach ( 9 ); } void loop () { int d ; int e ; myservo . write ( 90 ); //啟動時固定 if ( Serial . available ()){ d = Serial . parseInt (); Serial . println ( d ); if ( 0 <= d && d <= 180 ){ e = 1000 * ( acos ( d / 150 ) / 144 ); //將輸入的距離轉換成需要旋轉的時間 myservo . write ( 172 ); //固定正轉 delay ( 270 ); //旋轉此時間會讓馬達與安裝面垂直 myservo . write ( 172 ); //慣性補正 delay ( 100 ); myservo . write ( 91 ); //引力補正 delay ( 1000 ); myservo . write ( 172 ); //固定正轉 delay ( e ); // myservo . write ( 8 ); //慣性補正 delay ( 100 ); myservo . write ( 91 ); //引力補正 delay ( 1000 ); myservo . write ( 8 ); //固定反轉 delay ( e ); //反轉相同時間復歸 myservo . write ( 8 ); //固定反轉 delay ( 270 ); } } } 嘗試控制兩個馬達的程式(一個忘了存) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include <Servo.h> Servo myservo1 ; Servo myservo2 ; int x = 100 ; void setup () { Serial . begin ( 9600 ); myservo1 . attach ( 9 ); myservo2 . attach ( 9 ); } void loop () { int d ; myservo2 . write ( 90 ); if ( Serial . available ()){ d = Serial . parseInt (); Serial . println ( d ); if ( 0 <= d && d <= 180 ){ myservo2 . write ( 180 ); delay ( 1000 * ( acos ( d / 150 )) / 2.5 + 3.14 ); myservo2 . write ( 90 ); delay ( 1000 ); myservo2 . write ( 0 ); delay ( 1000 * ( acos ( d / 150 )) / 2.5 + 3.14 ); myservo1 . write ( 90 ); if ( Serial . available ()){ d = Serial . parseInt (); Serial . println ( d ); if ( 0 <= d && d <= 180 ){ myservo1 . write ( 180 ); delay ( 1000 * ( acos ( d / 150 )) / 2.5 + 3.14 ); myservo1 . write ( 90 ); delay ( 1000 ); myservo1 . write ( 0 ); delay ( 1000 * ( acos ( d / 150 )) / 2.5 + 3.14 ); } } } } } 問題: 每次程式跑到 1000*(acos(d/150)/144) 這一行馬達就會像失去動力般一小段時間，然後直接回到原點，將這段數學式改成常數後就沒有問題，想請問是什麼原因? 結語: 今天原本想說能至少把單個馬達的控制程式完成，看來有點高估自己了。","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-13ri.html"},{"tags":"2016g1","title":"Python通訊 0713","text":"今日讀的進度，以及筆記 For python3的部分 現在已經可以利用python讀取DHT11的值並且畫出圖形，主要程式部分我會列在下方，大致的作法是分析資料和切開資料 1.先確認Arduino部分送出來的值 可以發現是有下列三個值 temperature:溫度值 Humidity:濕度值 Flag:控制指標值 在Arduino程式碼的部分可以看到有serial write #include #define dht_dpin A0 //定義訊號要從Pin A0 進來 dht DHT; boolean flagPlot = true; void setup(){ Serial.begin(9600); delay(300); //Let system settle //Serial.println(\"Humidity and temperature\\n\\n\"); //Wait rest of 1000ms recommended delay before //accessing sensor } void loop(){ DHT.read11(dht_dpin); //去library裡面找DHT.read11 Serial.print(\"temperature:\"); Serial.println(DHT.temperature); delay(200); Serial.print(\"Humidity:\"); Serial.println(DHT.humidity); //Serial.print(\"% \"); delay(200); Serial.print(\"Flag:\"); Serial.println(flagPlot); delay(200); } 在python程式的部分程式有使用Tkinter #!/usr/bin/python3 import serial import sys import numpy as np import tkinter from matplotlib import pyplot, rcParams port = serial.Serial('COM6', 9600, timeout=1) # Tkinter canvas top = tkinter.Tk() top.title(\"Tkinter + matplotlib\") # Create flag to work with indefinite while loop flag = tkinter.BooleanVar(top) flag.set(True) def cleanText(data): data = data.replace(\"\\r\\n\", \"\") return data def onStartButtonPress(): while True: if flag.get(): line = port.readline().decode('UTF-8') reading = line.split(':') # print (reading) if len(reading) == 2: for i in range(2): if reading[0] == \"temperature\": TempLabel.config(text=cleanText(reading[1])) TempUnitLabel.config(text=\"C\") TempUnitLabel.update_idletasks() # if reading[0] == \"Temperature(F)\": # TempLabel.config(text=cleanText(reading[1])) # TempUnitLabel.config(text=\"F\") # TempUnitLabel.update_idletasks() if reading[0] == \"Humidity\": HumdLabel.config(text=cleanText(reading[1])) pData.append(float(reading[1])) del pData[0] # if reading[0] == \"Light(lx)\": # LighLabel.config(text=cleanText(reading[1])) if reading[0] == \"Flag\": # print (reading[1]) if int(reading[1]) == 1: try: print (\"In flag\") print (\"In flag -> if \") l1.set_xdata(np.arange(len(pData))) l1.set_ydata(pData) # update the data pyplot.ylim([0, 100]) pyplot.draw() # update the plot except: print (\"In flag except\") pyplot.figure() pyplot.title('Humidity') ax1 = pyplot.axes() l1, = pyplot.plot(pData) pyplot.ylim([0, 100]) if int(reading[1]) == 0: try: pyplot.close('all') l1 = None except: continue port.flushInput() top.update() else: flag.set(True) break def onExitButtonPress(): print (\"Exiting....\") flag.set(False) port.close() top.quit() top.destroy() print (\"Done.\") sys.exit() pyplot.ion() rcParams['toolbar'] = 'None' pData = [0] * 25 tkinter.Label(top, text=\"Temperature\").grid(column=1, row=1) tkinter.Label(top, text=\"Humidity\").grid(column=1, row=2) tkinter.Label(top, text=\"Light\").grid(column=1, row=3) TempLabel = tkinter.Label(top, text=\" \") TempLabel.grid(column=2, row=1) HumdLabel = tkinter.Label(top, text=\" \") HumdLabel.grid(column=2, row=2) LighLabel = tkinter.Label(top, text=\" \") LighLabel.grid(column=2, row=3) TempUnitLabel = tkinter.Label(top, text=\" \") TempUnitLabel.grid(column=3, row=1) HumdUnitLabel = tkinter.Label(top, text=\"%\") HumdUnitLabel.grid(column=3, row=2) LighUnitLabel = tkinter.Label(top, text=\"lx\") LighUnitLabel.grid(column=3, row=3) # Create Start button and associate with onStartButtonPress method StartButton = tkinter.Button(top, text=\"Start\", command=onStartButtonPress) StartButton.grid(column=1, row=4) # Create Exit button and destroy the window ExitButton = tkinter.Button(top, text=\"Exit\", command=onExitButtonPress) ExitButton.grid(column=2, row=4) top.mainloop() 可以得到這兩個畫面 底下為實際接線圖","url":"http://project.mde.tw/blog/pythontong-xun-0713.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/12","text":"瞭解SWIG的用法。 軟體修正 : NetBeans 為NetBeans安裝python的附加元件，使其可以編譯python文件。 這些附加元件還包含了jython2.7.0。 SWIG 上次載的版本沒有Windows使用的可執行檔，需要從原始code編譯太麻煩了，所以從以下網址下載了Windows使用的版本。 https://sourceforge.net/projects/swig/files/swigwin/ 解壓縮後就有可執行檔了，再把它的所在目錄加入start.bat的環境參數中。 接著就能用它下參數了。 SWIG簡介 : SWIG的功能就是利用自己的Interface檔案\".i\"，產生出一個\"_wrap.c\"檔，如果DLL專案一起將這個\".c\"編譯的話，就可以讓其他高階語言呼叫了。 SWIG內有個\\Examples資料夾，裡面有所有支援語言的轉換函式，參照它們的格式來撰寫自己的Interface，放在專案中。 諸如：D語言、java、javascript、lua、php、python、ruby。 練習應用 : 參考範例： /Examples/python/simple/index.html 先寫一個\".c\"程式碼。 /* File : example.c */ /* A global variable */ double Foo = 3.0; /* Compute the greatest common divisor of positive integers */ int gcd(int x, int y) { int g; g = y; while (x > 0) { g = x; x = y % x; y = g; } return g; } 然後再寫一個Interface的\".i\"文件。 至於格式可能要參考手冊的其他內容。 /* File: example.i */ %module example extern int gcd(int x, int y); extern double Foo; 然後用cmd到/Examples/python/simple中下指令： swig -python example.i 然後simple資料夾中就會產生example_wrap.c與example_wrap.py檔，再拿進編譯器Build。 但是Netbeans卻無法編譯檔案，照常來說最新的SWIG已經支援到Python 3.5，還是說有參數需要調整。 而且在動態連結庫的專案中，不知道怎麼調Build的參數成為pyd檔。 SWIG的操作大致知道了，但是仍有些許不瞭解的地方。 像是Interface的檔案撰寫，有將網路上一些範例存起來，但是下swig的指令時就出現\".i\"文件格式錯誤的訊息。 而在Netbeans裡要如何設定gcc編譯成pyd呢？在CMD裡下了跟2015cp.leo按鈕一樣的參數，可是好像都會出現上面Build的錯誤。 另外，按照SWIG的邏輯，萬一使用者的Python版本比它還低，它會修改編譯語法嗎？覺得在編譯時的錯誤可能是3.4到3.5之間的衝突。 今天上網找資料的時候，發現了ctype，可以讓python直接讀取DLL的文件，好像是SWIG之後的產物，只是Python本身必須加裝模組。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050712.html"},{"tags":"2016g1","title":"40323143 -  日誌  105年7月12日","text":"寫Arduino控制程式 日記: 今日找了3套別人寫的Arduino控制程式來常是控制馬達，其中兩套完全不能用，因為使用的馬達為連續旋轉型的伺服馬達，與兩套程式控制的伺服馬達不同，一套是用可變電阻來控制馬達旋轉角度，一套是直接指定馬達旋轉角度直接控制。在用第三套程式控制馬達時發現沒有產生預期的效果，後來發現原因是因為在使用前馬達必須通電調整馬達上的可變電阻校正，經過校正馬達變如程式所寫的運動，後來這套程式用來校正馬達。 備註: 1.今天只能把馬達控制到可以動，還不知道能不能準確的定位。 2.馬達實際跑過後，馬達的輸出可以讓手臂正常的運動，但旋盤的外接件在手臂動作時會產生晃動，原因可能是固定的鐵芯轉的不夠緊。 3.程式中距離轉換成徑度是因為我有印象有老師說過機器讀的是徑度不是角度。 程式: 第三套程式(前兩套因為用不到，所以沒有放上來) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <Servo.h> Servo myservo ; void setup () { Serial . begin ( 9600 ); myservo . attach ( 9 ); } void loop () { int d ; if ( Serial . available ()){ d = Serial . parseInt (); Serial . println ( d ); if ( 0 <= d && d <= 180 ){ myservo . write ( d ); } } } 來源: 葉難: Arduino練習：連續旋轉伺服馬達GWS S35 因應測試需要修改後的程式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <Servo.h> Servo myservo ; int x = 100 ; void setup () { Serial . begin ( 9600 ); myservo . attach ( 9 ); } void loop () { int d ; myservo . write ( 90 ); #啟動時固定 if ( Serial . available ()){ d = Serial . parseInt (); Serial . println ( d ); if ( 0 <= d && d <= 180 ){ myservo . write ( 180 ); #固定正轉 delay ( 1000 * ( acos ( d / 150 )) / 2.5 + 3.14 ); #將 d變成所要移動的距離 ，再將其轉換為所需時間 myservo . write ( 90 ); #到定點固定 delay ( 1000 ); myservo . write ( 0 ); #固定反轉 delay ( 1000 * ( acos ( d / 150 )) / 2.5 + 3.14 ); #喊轉相同時間復歸 } } } 結語: 以目前自己的能力沒辦法寫一套控制程式出來，連參考別人的程式也很吃力，今天修改出來的程式只能夠控制一個馬達，而且我只知道他能動能固定了，旋轉角度是否正確我就不知道了，還有極限開關也還沒寫進去，還得再努力。","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-12ri.html"},{"tags":"2016bg2","title":"40323218日誌 - 105/07/11","text":"V-rep 嘗試四連桿機構 理想狀態： 前期嘗試： 前期階級排列： 查詢資料： (在兩個dynamic item之間不能有static item) 修改後： 未來嘗試：製作搖擺機構 參考網站：http://www.coppeliarobotics.com/helpFiles/en/jointDescription.htm","url":"http://project.mde.tw/blog/40323218ri-zhi-1050711.html"},{"tags":"2016g1","title":"40323131日誌 105/07/11 Python 數值型別","text":"整數(int)與浮點數(float) 整數(int) 在Python語言裡由型式int代表，在2.x版裡，分為固定精確度的整數型別int與無窮精確度的長整數型別long，一旦數值超過界限，便自動轉程長整數型別，長整數會在尾巴加上(L)作標示 在3.x版裡則統和為一，只有型別int(無窮精確度) 浮點數(float) 在電腦裡會以二進位表示法來表示，但使用二進位表示法的話，有些值並無法以二進位表示法完美表示，只能儲存近似值 當浮點數要比較大小時，不該直接使用 == 運算子，而是應該設定誤差值，例如:0.001，然後比較兩數差值之絕對值是否小於此誤差，若在誤差值內應視為相等。 整數的表示法 整數的字面值，除了以十進位(decimal)書寫，也能以二進位(binary)、十六進位(hexadecimal)、八進位(octal)書寫，分別在數字之前加上 0b 、0x 、0o即可 浮點數的表示法 除了一般帶有小數點 . 的表示法，也能使用科學記號法，以指數來表示，例如: 300 等於3乘上10的2次方，寫在程式碼裡會以 e 隔開前後 ，寫成3e2 運算 數值型別的運算子 (+、-、 、 *、/、//、%)，相關內建函式abs()絕對值，divmod()商和餘數，pow()冪次方，round()四捨五入，須特別注意round() 模組math有很多數學運算相關函式，想求 x 的 1/n次方。傳入參數，必須注意 1/3 在2.x版與3.x版裡代表不同意思 條件運算式(三元運算子) x if y else z 其中 x 、 y 、z可以是任何運算式，當 y 為真時，運算式的結果會是 x ，當 y 為假時，結果是 z 物件 型別 方法 將運算子與內建函式視同\"方法(method)\" 方法幾乎等同於函式，只不過方法附屬於某種型別的物件，當要呼叫方法時，其一般型式為\"物件.方法(參數)\"。舉例: li是個串列， li.append(3)便可將整數物件3附加在此串列的尾端。 複數(complex) 由實部(real part)與虛部(imaginary part)組合而成，皆為浮點數。 跟int、float一樣，complex為不可變物件，一但建立就不能修改，有內建函式complex()，接受一或兩個數字作為參數，或一個符合格式的字串，建立出complex物件 屬性項 當想取出複數的實部或虛部，並沒有運算子或內建函式可用，僅能透過型別complex的屬性項real與imag來取用 支援complex的運算子與內建函式，跟int與 float差不多，其中須特別注意的有 : complex不支援比較運算子(<、<=、>、>=)，3.x版的複數不支援運算子(//、%)與內建函式 divmod 模組cmath含有跟comple相關的函式，如直角座標系(笛卡兒座標系)與極座標系的轉換 轉型 在運算式中若混用不同的數值型別，須轉成相同的型別才可運算， 'hello'+5 其實是'hello'. add (5)，而Python並不會自動把數字5轉成字 '5' 。 repr ，與__str__非常類似，也是回傳字串表示，但__repr__回傳的字串可當作程式碼，再給直譯器的話，建立出相同的物件，而__str__的用意是回傳給我們易讀易懂得字串來表示該物件 底下的部分，因為不太常接觸到，所以就稍微提到而已，如果需要的話，會再補充 十進位數(Decimal): Decimal物件屬於不可變物件 分數(Fraction):有時只需處理有理數，也就是以(分子/分母)型式所表示出來的數字;用 float 無法精確表示1/10，用Decimal也不能完美表示無限位數 1 / 3 ，需要能夠記錄分子與分母的型別，用 Fraction，屬於不可變 位元運算: 不把數字當做(一個數值)，而是把數字當做\"一連串的位元(bit)\"，以位元為單位進行運算。運算元只能是整數，因為浮點數的位元運算並無意義 結語 主要重心在於了解型別int跟 float ，以及新概念:方法跟屬性項，對於型別跟物件的了解有更進一步","url":"http://project.mde.tw/blog/40323131ri-zhi-1050711-python-shu-zhi-xing-bie.html"},{"tags":"2016bg2","title":"40323230練習 - 105/07/11","text":"使用2015cp範本練習\".py\"呼叫\".pyd\"。 編譯出Python的動態連結庫 : 從 https://github.com/coursemdetw/2015cp 下載老師的範本練習。 C程式的部分分成pymod和pyfun。 這兩組底下都有3個Node，分別是編譯Python動態連結庫用的button、呼叫用的Python程式和一個C++編成的函式。 button裡的內容如下： ... # compile os.system(\"Z:/C/MinGW/bin/gcc.exe -c -g -IV:/IDE/Python33/include -MMD -MP -MF build/\"+target_name+\".o.d -o build/\"+target_name+\".o \"+filename) # link 因為 .c 程式中起始為 PyInit_sum, 因此 os.system(\"Z:/C/MinGW/bin/gcc.exe -shared -o dist/\"+module_name+\".pyd build/\"+target_name+\".o V:/IDE/Python33/libs/libpython33.a\") g.es(\"done\") 在執行時顯然對應不到W:槽的MinGW和Python34，所以必須改一下它的指令。 ... # compile os.system(\"gcc -c -g -IW:/Python34/include -MMD -MP -MF build/\"+target_name+\".o.d -o build/\"+target_name+\".o \"+filename) # link 因為 .c 程式中起始為 PyInit_sum, 因此 os.system(\"gcc -shared -o dist/\"+module_name+\".pyd build/\"+target_name+\".o W:/Python34/libs/python34.lib\") g.es(\"pymod done\") 而另一邊的pyfun同理。 接著就能在\\dist資料夾中編譯出sum.pyd和pyfun.pyd了。 使用mypy.py : 接著回到@edit programs/dist/mypy.py和mypy2.py的兩個Node，只要在.leo中存檔就能建立和編輯它們。 mypy.py中導入sum，並使用它裡面的函式sum()。 print(sum.sum(1, 30)) 在sum.pyd中，函式sum()是sum2()在sum.pyd中被定義的外部名稱，由以下可知。 // 定義內部運算的函式內容 int sum2(int a, int b) { return a+b; } // sum 函式的 interface static PyObject* mod_sum(PyObject *self, PyObject *args) { int a; int b; int s; // ii 表示兩個輸入變數都是整數 if (!PyArg_ParseTuple(args,\"ii\",&a;,&b;)) return NULL; // 這裡的 sum2 則是內部的函式定義, 與外部呼叫模組或函式名稱沒有直接關係 s = sum2(a,b); // i 表示 s 為整數 return Py_BuildValue(\"i\",s); } // 這裡的 sum 是外部模組的呼叫名稱, 而 mod_sum 則是內部的呼叫名稱 (即 interface function) // Mod_Methods 為函式 (方法) 結構定義 static struct PyMethodDef Mod_Methods[] = { {\"sum\", mod_sum, METH_VARARGS, \"Description..\"}, {NULL,NULL,0,NULL} }; sum2()函式回傳的是兩個輸入值（pyd內部名為a和b），所以mypy.py收到後會顯示在畫面上。 另一邊的mypy2.py是使用pyfun.pyd，不過有兩個檔案太麻煩了，乾脆讓mypy.py導入兩個pyd就好了。 這次是加入一段字串。 print(pyfun.pyfun(\"我的字串\")) 在pyfun.pyd中，pyfun()的外部名稱和它同名，在它的函式中，建立了一個指標to_who，偵測使用動態連結庫的對象，並把輸入進來的字串傳回。 pyfun(PyObject *self,PyObject *args) { const char *to_who; if(!PyArg_ParseTuple(args,\"s\",&to;_who)) return NULL; // pyfun 函式會將輸入字串變數傳回 return PyUnicode_FromString(to_who); } 執行後的結果： 不過這兩個pyd的結尾不太一樣。 sum.pyd // 模組啟始, PyInit_ 後必須使用\"名稱\".pyd 中的模組名稱, 以便啟動 // 換言之, 若編譯連結後的動態模組名稱為 sum.pyd, 則此地的起始函式名稱必須為 PyInit_sum PyMODINIT_FUNC PyInit_sum(void) { // 建立模組的起始, 輸入為模組結構名稱之 address (void) PyModule_Create(&ModMethods;); } pyfun.pyd // 此 pyd 必須命名為 pyfun.pyd, 因為必須與 PyInit_後的名稱相同 PyInit_pyfun(void) { PyObject *m; m = PyModule_Create(&moduledef;); return m; } 意思似乎是一樣的，不過pyfun.pyd將PyModule_Create當作回傳值回傳了，不知道用意為何。 若要瞭解Python的函式用法，應該要查閱Python.h或是相關說明才能明白。 延伸應用 : 只使用既定的範本實在是太簡略了，所以試著在pyd中加一些自己寫的函式。 在sum中加入新的函式sum3，並讓它的傳回值設定為a和b相加後開平方根，再乘上10。 添加了下列指令： //導入 #include \"math.h\" //宣告 int sum3(int a, int b); //副程式sum3 int sum3(int a, int b) { return sqrt(a+b)*10; } //定義輸入值和sum3的外部名稱score static PyObject* mod_score(PyObject *self, PyObject *args) { int a; int b; int t; if (!PyArg_ParseTuple(args,\"ii\",&a;,&b;)) return NULL; t = sum3(a,b); return Py_BuildValue(\"i\",t); } 並在PyMethodDef Mod_Methods[]中再新增一串： {\"score\", mod_score, METH_VARARGS, \"Description..\"}, 接著在mypy.py中呼叫sum.score()就行了。 Leo的搜尋功能和復原功能真的不太實在。常常搜尋時就跳到其他Node去，搜尋目標也要每次都重新調整；復原直接還原到存檔前的樣子，所以用它來編譯程式真的滿吃力的。 這次使用的是Python，所以SciTE和只能寫C語言的NetBeans幫不上忙，因為無法呼叫Python.h。說不定設定環境係數可以奏效？ 不然只靠Leo編輯，它的函式分類也不是很清楚，常常不知道Python.h中的函式原型用法是甚麼，不像NetBeans可以連進去查看stdio.h或是windows.h所引用的函式。","url":"http://project.mde.tw/blog/40323230lian-xi-1050711.html"},{"tags":"2016g1","title":"40323143 -  日誌  105年7月11日","text":"發現極限開關繪製的重大錯誤 測試的手臂組裝完成 控制程式未完成 日記: 今天發現了第二種極限開關及底座裝配的問題，原因是因為在繪製第二種極限開關的固定孔時出錯，圖上的孔與實際的孔位置是相反的，導致底座列印出來時裝配出問題，己決方法是變更極限開關方向及電路配置，補救醒的讓極限開關及底座配合。 今天列印底座後發現底座中安裝馬達的槽的長度尺寸小0.3mm，使馬達安裝有問題，原因可能是因為列印的些微誤差，解決方法是用銼刀將槽挫大，以及修改繪圖尺寸。 機構的部分大概是如此，剩下的控制程式今天試著寫了一些，但是離實際上可用還有很多問題。 控制程式的構想: 1.承臂控制想利用控制通電時間來控制各個法達旋轉的角度，通電時間利用 [ acos(欲移動距離/承臂長度) ]/馬達角速度 ]求。 2.極限位置用極限開關訊號加上if來控制。 3.底座馬達的控制可能會是固定的旋轉時間 4.我還在學習怎麼寫 備註: 1.因為原先設計時極限開關的長邊中心線是通過底座中心點的，所以可以直接將極限開關反過來用，只改變電路配置。 2.與底座極限開關相撞的桿子也是用免洗筷剪短裝上去的，免洗筷是由先前的免洗筷殘留部分加工而來的，同樣十分堅固。 3.原先底座極限開關的電路配置是直接由接頭接去安裝在底座的arduino上，因安裝位置修改變更為繞過旋盤下方接上arduino。 4.這次的極限開關繪製錯誤時分嚴重，若不是因為剛好有辦法可以補救，製造成本就完全浪費了。 5.程式若沒辦法寫出來可能只會先讓手臂座固定的運動。 6.等測試用的手臂完成後就會進入夾頭的部分。 安裝完後的底座極限開關線路配置 由上往下看 底座馬達安裝孔因應誤差所做的變更 手臂組合完成圖 提問: 請問實際上在設計時常使用什麼方法來檢查特徵錯誤，或是特定的機制?","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-11ri.html"},{"tags":"2016g1","title":"PyFirmata 通訊","text":"今日讀的進度，以及筆記 For python3的部分 安裝要有的原始碼 1.安裝pyserial pip install pyserial 2.安裝Firmata 下載新版Arduino中就有了 3.安裝pyfirmata pip install pyFirmata 4.下載測試程式 Firmata Test http://www.firmata.org/wiki/Main_Page 5.啟動.exe 就有底下的畫面 利用python畫圖(利用亂數取產生點) ※需要安裝matplotlib (pip install matplotlib) from matplotlib import pyplot import random x = range(0,25) y = [random.randint(0,100) for r in range(0,25)] fig1 = pyplot.figure() pyplot.plot(x, y, '-') #繪畫的座標以及表現方法 pyplot.title('First Plot - Random integers') pyplot.xlabel('X Axis') #兩軸標示 pyplot.ylabel('Y Axis') pyplot.show() 接下來就可以導入CSV或者數學方程式畫出我們想要的圖形 以及將範例code的部分放到data裡面了","url":"http://project.mde.tw/blog/pyfirmata-tong-xun.html"},{"tags":"2016bg2","title":"40323230練習 - 105/07/10","text":"由於不熟悉動態連結庫的運作方式，先練習C語言呼叫動態連結庫，之後再研究python的方式。 編譯出C的動態連結庫 : 找到了一個別人學校的DLL簡單範例。 http://pws.niu.edu.tw/~ttlee/sp.100.2/dll/ 雖然NetBeans在截圖時很容易閃退，但是Visual Studio的專案又會把檔案搞得太複雜，所以就將就點使用NetBeans了。 使用NetBeans建立了一個C/C++ Dynamic Library。 若沒有預設Make file，也不是二進位資料，又需要動態連結庫的話，這個類別的專案是項很好的選擇。 新建完成後，Projects的欄位就會幫使用者分類： Header Files, Resource Files, Source Files, Test Files. 這些分類預設是空的，而在NetBeans中沒有分類的檔案是不能編譯的。 如果要讓既有的檔案歸類，在想添加的目錄上按下右鍵，選擇\"Add Existing Item...\"，再選擇想加入的檔案就行了。 按照範例先在SciTE中寫好了三個檔案。 編譯成DLL文件的是dllmain.c和dll.h，編譯成執行檔的是call DLL.c，在標頭檔dll.h中有相關紀錄。 DLL中的Add函式中輸入三個類型分別是char、int、int的值，會回傳一串文字，類型是char。 DLLIMPORT char* Add(char*str, int a, int b) { printf(\"This is your ID(8):\\n\"); printf(\"Your ID: %s\\n\", str); printf(\"%d+%d=%d:\\n\", a, b, a+b); return \"OK\"; } 標頭檔中也有這一段匯入，供可執行檔呼叫。 DLLIMPORT char* Add(char*, int, int); 這時候先編譯動態連結庫，在專案上按右鍵，選擇Properties。 在Build的設定中，Configuration Type的選項選擇Dynamic Library，設定好後按下Build鈕。 這時候會顯示成功，並在\\dist\\Debug\\MinGW的資料中編譯出dll檔，動態連結庫就算是成功了。 編譯出C的可執行檔 : 這時再把call DLL.c加入Source File中。 call DLL.exe主要就是接受使用者輸入的三個值，並讓動態連結庫處理完顯示值後，再把顯示值回傳，顯示給使用者看。 call DLL.c的主程式如下： int main(void) { int i1, i2; char str1[9]; printf(\"Key in:\\n\"); scanf(\"%s,%d,%d\", &str1;, i1, i2); printf(\"\\n\"); HMODULE hInst=LoadLibrary(\"DLLtest.dll\"); if(hInst==NULL){ printf(\"Can't load library.\\n\"); system(\"PAUSE\"); return 1; } char* (*CallDll)(char*, int, int); (FARPROC*)(CallDll)=GetProcAddress(hInst, \"Add\"); if(CallDll==NULL){ printf(\"NO Value.\\n\"); system(\"PAUSE\"); return 2; } printf(\"Result: %s\\n\", CallDll(str1, i1,i2)); FreeLibrary(hInst); system(\"PAUSE\"); return 0; } 然而在編譯時，NetBeans卻顯示了下列訊息： 顯示是在這段出了問題： (FARPROC*)(CallDll)=GetProcAddress(hInst, \"Add\"); 這裡的問題是定義項和被定義項的關係錯誤。 上網查了一些資料，使用的語法都試過了，但是問題仍然無法解決。 由於是內建函式，所以不太了解其格式甚麼的。 於是回去觀察Solvespace的標頭檔，發現CDemo是直接使用這段： DLL void Slvs_Solve(Slvs_System *sys, Slvs_hGroup hg); 完全不用呼叫dll名稱什麼的。 因為在slvs.h中，所有的格式在開始就寫得清清楚楚，所以若要使用，必須將需要的數值按照規定的格式填入，然後由最高層的\"Slvs_\"指派計算。 編譯後，動態連結庫取代了標頭檔的功能，包裝各項副程式後，在同個目錄下，可以供其他想使用函式的可執行檔使用。 至於工程師規定的格式在slvs.h的註解中有所說明。 雖然這次編譯基礎程式時失敗了，但是瞭解這些引用功能的方式，仍然是有所收穫。 下次應該是模仿CDemo寫題目給libslvs.dll求解，不過若之後是要使用python的話還需要再研究一下SWIG的功能。","url":"http://project.mde.tw/blog/40323230lian-xi-1050710.html"},{"tags":"2016bg2","title":"40323230紀錄 - 瞭解SWIG & CDemo的資源","text":"安裝SWIG 並檢視下列檔案： CDemo.exe CDemo.c 安裝工具 : 除了英文的資料，另外還讀了一下關於SWIG的相關中文資料： 1.Python的資料庫形式 https://read01.com/PnGeDg.html 2.Python在Windows中用SWIG呼叫C/C++的函式（VC） http://falldog7.blogspot.tw/2013/07/python-swig-c-function.html 3.SWIG概念 http://user.frdm.info/ckhung/b/mi/swig.php 接著從 swig.org 下載最新版的SWIG 3.0.10，將壓縮包解至W:內。 SWIG能夠給Windows/Unix/MacOSX三個平台使用，所以壓縮檔的附檔名是三個平台都共通的\".tar.gz\"。 解壓縮後，在Windows環境中有很多檔案是打不開的，不過說明檔是沒有附檔名的，隨便用任何一款文字編輯軟體都能查看。 如果該步驟需要完整的流程，\\Doc\\Manual中有寫好的html網頁手冊，用網頁瀏覽器就能開啟。 在閱讀\\Doc\\Manual\\Windows.html的說明之後，手冊解釋SWIG並不是使用通常的Windows類型安裝程式。 只要在編譯器中（手冊的範例是Visual Studio）設置環境變數就能使用其範例檔。 手冊上也有說明能夠用MinGW和MSYS，Build出SWIG的可執行檔swig.exe。 CDemo.exe : CDemo.exe是由CDemo.c編譯出來的可執行檔，取用libslvs.dll的動態連結庫運作。 在原本的\\exposed資料夾中還有工程師留下的VbDemo.vb，Visual Basic或是Visual C#的專案文件，不過不使用這兩個編譯器的話就用不到。 為此特別將CDemo.exe和libslvs.dll拿出來放在獨立的資料夾中。 由CMD進入資料夾中執行CDemo.exe，會發現CDemo是直接顯示了結果。 顯然CDemo.exe原先已經設定好題目，於是打開CDemo.c看看工程師的註解怎麼說。 CDemo.c : 由於NetBeans和Windows的截圖程式似乎有衝突，會常常截完圖後自動閃退，所以改用簡便的SciTE。 用SciTE開啟CDemo.c，可以發現CDemo的原始碼。 而為了方便，將它部分的原始碼貼在下面： /*--------------------------- * Some sample code for slvs.dll. We draw some geometric entities, provide * initial guesses for their positions, and then constrain them. The solver * calculates their new positions, in order to satisfy the constraints. * * Copyright 2008-2013 Jonathan Westhues. *-------------------------*/ #ifdef HAVE_CONFIG_H ... #endif #ifdef WIN32 ... #endif #include #include #include #ifdef HAVE_STDINT_H ... #endif #include static Slvs_System sys; static void *CheckMalloc(size_t n) { void *r = malloc(n); if(!r) { printf(\"out of memory!\\n\"); exit(-1); } return r; } /*--------------------------- * An example of a constraint in 3d. We create a single group, with some * entities and constraints. *-------------------------*/ void Example3d() { ... } /*--------------------------- * An example of a constraint in 2d. In our first group, we create a workplane * along the reference frame's xy plane. In a second group, we create some * entities in that group and dimension them. *-------------------------*/ void Example2d() { ... } int main() { sys.param = CheckMalloc(50*sizeof(sys.param[0])); sys.entity = CheckMalloc(50*sizeof(sys.entity[0])); sys.constraint = CheckMalloc(50*sizeof(sys.constraint[0])); sys.failed = CheckMalloc(50*sizeof(sys.failed[0])); sys.faileds = 50; /*Example3d();*/ for(;;) { Example2d(); sys.params = sys.constraints = sys.entities = 0; break; } return 0; } 在CDemo.c的主程式中，最後執行Example3d()副程式的部分被註解掉了。 所以程式的運行主要是跑Example2d()，就把它的程式碼抓出來看一下。 void Example2d() { Slvs_hGroup g; double qw, qx, qy, qz; g = 1; /* First, we create our workplane. Its origin corresponds to the origin * of our base frame (x y z) = (0 0 0) */ sys.param[sys.params++] = Slvs_MakeParam(1, g, 0.0); sys.param[sys.params++] = Slvs_MakeParam(2, g, 0.0); sys.param[sys.params++] = Slvs_MakeParam(3, g, 0.0); sys.entity[sys.entities++] = Slvs_MakePoint3d(101, g, 1, 2, 3); /* and it is parallel to the xy plane, so it has basis vectors (1 0 0) * and (0 1 0). */ Slvs_MakeQuaternion(1, 0, 0, 0, 1, 0, &qw;, &qx;, &qy;, &qz;); sys.param[sys.params++] = Slvs_MakeParam(4, g, qw); sys.param[sys.params++] = Slvs_MakeParam(5, g, qx); sys.param[sys.params++] = Slvs_MakeParam(6, g, qy); sys.param[sys.params++] = Slvs_MakeParam(7, g, qz); sys.entity[sys.entities++] = Slvs_MakeNormal3d(102, g, 4, 5, 6, 7); sys.entity[sys.entities++] = Slvs_MakeWorkplane(200, g, 101, 102); /* Now create a second group. We'll solve group 2, while leaving group 1 * constant; so the workplane that we've created will be locked down, * and the solver can't move it. */ g = 2; /* These points are represented by their coordinates (u v) within the * workplane, so they need only two parameters each. */ sys.param[sys.params++] = Slvs_MakeParam(11, g, 10.0); sys.param[sys.params++] = Slvs_MakeParam(12, g, 20.0); sys.entity[sys.entities++] = Slvs_MakePoint2d(301, g, 200, 11, 12); sys.param[sys.params++] = Slvs_MakeParam(13, g, 20.0); sys.param[sys.params++] = Slvs_MakeParam(14, g, 10.0); sys.entity[sys.entities++] = Slvs_MakePoint2d(302, g, 200, 13, 14); /* And we create a line segment with those endpoints. */ sys.entity[sys.entities++] = Slvs_MakeLineSegment(400, g, 200, 301, 302); /* Now three more points. */ sys.param[sys.params++] = Slvs_MakeParam(15, g, 100.0); sys.param[sys.params++] = Slvs_MakeParam(16, g, 120.0); sys.entity[sys.entities++] = Slvs_MakePoint2d(303, g, 200, 15, 16); sys.param[sys.params++] = Slvs_MakeParam(17, g, 120.0); sys.param[sys.params++] = Slvs_MakeParam(18, g, 110.0); sys.entity[sys.entities++] = Slvs_MakePoint2d(304, g, 200, 17, 18); sys.param[sys.params++] = Slvs_MakeParam(19, g, 115.0); sys.param[sys.params++] = Slvs_MakeParam(20, g, 115.0); sys.entity[sys.entities++] = Slvs_MakePoint2d(305, g, 200, 19, 20); /* And arc, centered at point 303, starting at point 304, ending at * point 305. */ sys.entity[sys.entities++] = Slvs_MakeArcOfCircle(401, g, 200, 102, 303, 304, 305); /* Now one more point, and a distance */ sys.param[sys.params++] = Slvs_MakeParam(21, g, 200.0); sys.param[sys.params++] = Slvs_MakeParam(22, g, 200.0); sys.entity[sys.entities++] = Slvs_MakePoint2d(306, g, 200, 21, 22); sys.param[sys.params++] = Slvs_MakeParam(23, g, 30.0); sys.entity[sys.entities++] = Slvs_MakeDistance(307, g, 200, 23); /* And a complete circle, centered at point 306 with radius equal to * distance 307. The normal is 102, the same as our workplane. */ sys.entity[sys.entities++] = Slvs_MakeCircle(402, g, 200, 306, 102, 307); /* The length of our line segment is 30.0 units. */ sys.constraint[sys.constraints++] = Slvs_MakeConstraint( 1, g, SLVS_C_PT_PT_DISTANCE, 200, 30.0, 301, 302, 0, 0); /* And the distance from our line segment to the origin is 10.0 units. */ sys.constraint[sys.constraints++] = Slvs_MakeConstraint( 2, g, SLVS_C_PT_LINE_DISTANCE, 200, 10.0, 101, 0, 400, 0); /* And the line segment is vertical. */ sys.constraint[sys.constraints++] = Slvs_MakeConstraint( 3, g, SLVS_C_VERTICAL, 200, 0.0, 0, 0, 400, 0); /* And the distance from one endpoint to the origin is 15.0 units. */ sys.constraint[sys.constraints++] = Slvs_MakeConstraint( 4, g, SLVS_C_PT_PT_DISTANCE, 200, 15.0, 301, 101, 0, 0); #if 0 /* And same for the other endpoint; so if you add this constraint then * the sketch is overconstrained and will signal an error. */ sys.constraint[sys.constraints++] = Slvs_MakeConstraint( 5, g, SLVS_C_PT_PT_DISTANCE, 200, 18.0, 302, 101, 0, 0); #endif /* 0 */ /* The arc and the circle have equal radius. */ sys.constraint[sys.constraints++] = Slvs_MakeConstraint( 6, g, SLVS_C_EQUAL_RADIUS, 200, 0.0, 0, 0, 401, 402); /* The arc has radius 17.0 units. */ sys.constraint[sys.constraints++] = Slvs_MakeConstraint( 7, g, SLVS_C_DIAMETER, 200, 17.0*2, 0, 0, 401, 0); /* If the solver fails, then ask it to report which constraints caused * the problem. */ sys.calculateFaileds = 1; /* And solve. */ Slvs_Solve(&sys;, g); if(sys.result == SLVS_RESULT_OKAY) { printf(\"solved okay\\n\"); printf(\"line from (%.3f %.3f) to (%.3f %.3f)\\n\", sys.param[7].val, sys.param[8].val, sys.param[9].val, sys.param[10].val); printf(\"arc center (%.3f %.3f) start (%.3f %.3f) finish (%.3f %.3f)\\n\", sys.param[11].val, sys.param[12].val, sys.param[13].val, sys.param[14].val, sys.param[15].val, sys.param[16].val); printf(\"circle center (%.3f %.3f) radius %.3f\\n\", sys.param[17].val, sys.param[18].val, sys.param[19].val); printf(\"%d DOF\\n\", sys.dof); } else { int i; printf(\"solve failed: problematic constraints are:\"); for(i = 0; i < sys.faileds; i++) { printf(\" %d\", sys.failed[i]); } printf(\"\\n\"); if(sys.result == SLVS_RESULT_INCONSISTENT) { printf(\"system inconsistent\\n\"); } else { printf(\"system nonconvergent\\n\"); } } } \"Slvs_hGroup g\"中的g能在群組編號中切換，離開後的群組會被鎖定。裡面的成員無法新增和編輯，不過可以被呼叫。 之後便能用\"sys.param[sys.params++]\"或是\"sys.entity[sys.entities++]\"的指令在群組下建立工作物件（回傳值，物件格式是%.3f）和建立實體（檢查結果）。 比較特別的是本程式建立座標的編號是從1開始的；建立工作點的編號是從101開始的；建立工作平面是從200開始的（這題只有一個工作平面）；建立點的編號是從301開始的（使用的座標和工作點相同層級）。之後層級越高編號都以100的倍數成長。 畫完圖之後，最後解決的程式是使用Slvs_Solve(&sys, g);，取得程式結果和輸入群組編號。至於這個範疇就是libslvs.dll和其他Solvespace部件的工作了。 閱讀完pyd檔案的作用後，大約知道它和dll的關聯性了。 不過libslvs.dll究竟是從哪裡編譯出來的呢？是從主要的cpp檔還是標頭檔建立的？Build完之後多出了libslvs.dll.a和config.h。 雖然一些簡單的dll可以直接打開編輯，不過libslvs.dll應該是不能這樣做。","url":"http://project.mde.tw/blog/40323230ji-lu-liao-jie-swig-cdemode-zi-yuan.html"},{"tags":"2016bg2","title":"40323230練習 - 105/07/09","text":"嘗試用C語言解題 BUG fix : W:槽的SciTE有點小問題，因為設定檔是從Y:複製來的，所以需要重新定義TinyC的位置。 只要修改cpp.properties的路徑就可以了。 Nutcracker Solution : 上學期的 Nutcracker網誌內容 。 之前的python題目，稍微研究一下後轉成C語言。 不過如果直接運行會跑很久。但是這裡可以練習一下小型演算法的模式。 先做了兩個程式，不過第一是介面而已，第二個才是主要架構。 撰寫的途中使用Solvespace研究，由於數學邏輯不太好，很多幾何的東西沒那麼直觀。 有時候會偷吃步測試一些解法。 第二支程式是從python的範例改來的，不過後來做了很多變化，只有解最小路徑最大角度。 演算法概念： 途中查了很多數學公式，無奈常常打錯又不知道正確性，重複試了很多次才成功。 #include #include int k=40; int h=10; int a=40; int b=80; double r=10; double pi=M_PI; int num=1000; int main() { double deg =pi/180; for (int j=45*num; j<=180*num; j++){ double num0=num; double th=j/num0*deg; double x1=a*cos(th); double y1=a*sin(th); double x2=x1+sqrt(b*b-y1*y1); double m=tan(th); double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1)); printf(\"%g\\n\", (int)(j/num0*100000+.5)/100000.); if(r1<=r){ printf(\"(%f,%f) (%f,0)\\n%f\\n%f r=%f\\nm=%f\\n\", x1, y1, x2, th/deg, r, r1, m); break; } } return 0; } 第二支程式的最後成果。 最後精確度還是沒有很高，不知道問題出在哪裡。 第一支程式是剛開始寫輸入端介面，供使用者輸入自訂參數，後來再把第二支程式的模型搬回來用，並另外寫一個解最大路徑和最小角度的程式，所有例外狀況也是在這裡排除。 後來還不知道怎麼讓副程式傳回double或其他浮點數，查一下才知道要在開始前宣告一次。 #include #include int a, b, k, h, r, lim; double o, wp, thmin, thmax; double pi=M_PI; int num=1000; double solve_minpath(int, int, int, int, int); double solve_maxangle(int, int, int, int, int); double solve_maxpath(int, int, int, int); double solve_minangle(int, int, int, int); int main() { scanf(\"%d,%d,%d,%d,%d,%d\", &a;, &b;, &k;, &h;, &r;, &lim;); //強制正值 a=abs(a); b=abs(b); h=abs(h); k=abs(k); r=abs(r); lim=abs(lim); printf(\"\\n---\\n\"); printf(\"Used pi= %f\\n\", pi); printf(\"---\\n\"); printf(\"Connecting Rod:\\n\"); printf(\"a= %d b= %d\\n\", a, b); printf(\"Rod radius= %d\\n\", r); printf(\"Rod width= %d\\n\", r*2); printf(\"Space Usage:\\n\"); printf(\"h= %d k= %d\\n\", h, k); printf(\"Work Path= %d\\n\", lim); printf(\"---\\n\\n\"); //相關參數代入副程式解題 o=solve_minpath(k, h, a, b, r); wp=solve_maxpath(lim, a, b, r)-o; thmin=solve_minangle(lim, a, b, r); thmax=solve_maxangle(k, h, a, b, r); if(a*b*lim==0){ printf(\"---ERRO---\\nSome value can't be zero.\\n\"); return 1; } else{ if(o+r>lim){ printf(\"---ERRO---\\nSpace is not enough.\\n\"); return 2; } else{ printf(\"\\n---\\n---Result---\\n\"); printf(\"Distance:\\n\"); printf(\"Offset distance:\\n\"); printf(\"o= %f\\n\", o); printf(\"Work distance:\\n\"); printf(\"wp= %f\\n\", wp); printf(\"Angle(Degree):\\n\"); printf(\"min= %f max= %f\\n---\\n\", thmin, thmax); return 0; } } } double solve_minpath(int k, int h, int a, int b, int r) { double deg =pi/180; for (int j=45*num; 180*num>=j; j++){ double num0=num; double th=j/num0*deg; double x1=a*cos(th); double y1=a*sin(th); double x2=x1+sqrt(b*b-y1*y1); double m=tan(th); double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1)); if(r>=r1){ printf(\"(%f,%f) (%f,0)\\n%f\\n%f r=%f\\nm=%f\\n\", x1, y1, x2, th/deg, r, r1, m); return x2; break; } } return 0; } double solve_maxangle(int k, int h, int a, int b, int r) { double deg =pi/180; for (int j=45*num; 180*num>=j; j++){ double num0=num; double th=j/num0*deg; double x1=a*cos(th); double y1=a*sin(th); double x2=x1+sqrt(b*b-y1*y1); double m=tan(th); double r1=abs((x2-x1)*(h-y1)-(0-y1)*(k/2-x1))/sqrt(y1*y1+(x2-x1)*(x2-x1)); if(r>=r1){ printf(\"(%f,%f) (%f,0)\\n%f\\n%f r=%f\\nm=%f\\n\", x1, y1, x2, th/deg, r, r1, m); return th/deg; break; } } return 0; } double solve_maxpath(int lim, int a, int b, int r) { double n; double th; if (lim>a+b+r){ n=a+b; th=0; } else{ n=lim-r; th=acos((a*a+n*n-b*b)/2*a*n); } return n; } double solve_minangle(int lim, int a, int b, int r) { double n; double th; if (lim>a+b+r){ n=a+b; th=0; } else{ n=lim-r; th=acos((a*a+n*n-b*b)/(2*a*n)); } return th; } 最後執行的結果： 剛開始還以為是用公式推導座標點的結果，後來回去看網誌才知道用演算法計算。電腦演算時如果一邊列出結果，會拖慢速度，所以在最後的程式碼中只留檢查用的結果。 後來也有上網看其他人使用基因演算法的案例，未能完全了解，還有很多要學習的地方。這次解題複習了一些C語言的概念，希望在往後利用上能夠駕輕就熟。","url":"http://project.mde.tw/blog/40323230lian-xi-1050709.html"},{"tags":"2016g1","title":"40323143 -  日誌  105年7月8日","text":"發現極限開關繪製的重大錯誤 測試的手臂組裝完成 控制程式未完成 今天發現了第二種極限開關及底座裝配的問題，原因是因為在繪製第二種極限開關的固定孔時出錯，圖上的孔與實際的孔位置是相反的，導致底座列印出來時裝配出問題，己決方法是變更極限開關方向及電路配置，補救醒的讓極限開關及底座配合。 今天列印底座後發現底座中安裝馬達的槽的長度尺寸小0.3mm，使馬達安裝有問題，原因可能是因為列印的些微誤差，解決方法是用銼刀將槽挫大，以及修改繪圖尺寸。 機構的部分大概是如此，剩下的控制程式今天試著寫了一些，但是離實際上可用還有很多問題。 控制程式的構想: 1.承臂控制想利用控制通電時間來控制各個法達旋轉的角度，通電時間利用 [ cos&#94;-1(欲移動距離/承臂長度) ]/馬達角速度 求。 2.極限位置用極限開關訊號加上if來控制。 3.底座馬達的控制可能會是固定的旋轉時間 4.我還在學習怎麼寫 備註: 1.因為原先設計時極限開關的長邊中心線是通過底座中心點的，所以可以直接將極限開關反過來用，只改變電路配置。 2.與底座極限開關相撞的桿子也是用免洗筷剪短裝上去的，免洗筷是由先前的免洗筷殘留部分加工而來的，同樣十分堅固。 3.原先底座極限開關的電路配置是直接由接頭接去安裝在底座的arduino上，因安裝位置修改變更為繞過旋盤下方接上arduino。 4.這次的極限開關繪製錯誤時分嚴重，若不是因為剛好有辦法可以補救，製造成本就完全浪費了。 5.程式若沒辦法寫出來可能只會先讓手臂座固定的運動。 6.等測試用的手臂完成後就會進入夾頭的部分。 安裝完後的底座極限開關線路配置 由上往下看 底座馬達安裝孔因應誤差所做的變更 手臂組合完成圖 提問: 請問實際上在設計時常使用什麼方法來檢查特徵錯誤，或是特定的機制?","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-8ri.html"},{"tags":"Misc","title":"yen - 上課專用網際程式規劃","text":"RGA 為 Real-coded Genetic Algorithm, 也就是實數編碼基因演算法, 以下為平面四連桿機構, 令其移動桿三角形頂點通過特定的 10 個座標點的尺寸合成運算.","url":"http://project.mde.tw/blog/yen-shang-ke-zhuan-yong-wang-ji-cheng-shi-gui-hua.html"},{"tags":"2016g1","title":"40323131日誌 105/07/07","text":"學習python 因為遇到了一些問題，所以打算從頭學起，希望可以真正了解問題點在哪裡，也希望可以幫到其他人 先從最基本的名稱、物件、型別、指派 命名規則 當我們要在程式裡取名時，必須遵守Python的規則 : 1. 可使用英文字母小寫 a ~ z 大寫 A ~ Z 數字 0 ~ 9 底線 _ 2. 第一個字不能是數字 Python的名稱區分大小寫，所以money跟Money代表不同的名稱，不過有些識別字被Python拿去用了，稱為保留字(reserved word)或關鍵字(keyword)，代表特定的意思，有其特殊用途，不能拿來命名，下圖為Python保留字 串列(list) 除了整數(int)、浮點數(float)、字串(str)外;叫做串列(list)，此種型別可放入任何型別的物件。想建立串列物件時，語法是方括號[]，放入想含有的物件，範例 當我們說串列內可存放物件時，是讓該串列能以索引的方是指向別的物件 可變與不可變 型別int、float、str的物件，都有不可變(immutable)的特性，一旦建立之後，其值就無法更動;可以讓名稱轉而指向別的物件，但無法修改不可變物件 別名 因為Python有不可變(int,float,str)跟可變(list)物件之分，而且名稱跟物件其實是獨立的兩樣東西，所以要注意當兩個(或以上)的名稱都指向同一個物件時的狀況，別名(alias)也叫做共享參考(shared reference) tuple(元組) 就是不可變的list(串列)，須使用小括號()放入想含有的物件 運算式 算術運算子 包括(+, -, , /, %, //, )，*是乘法， 是冪次方，/是除法，//是地板除法，%餘數運算子，來看例子 str字串跟list與tuple也可以使用 + , * 作運算 比較運算子 <, <=, >, >=, !=, <>, == :作大小比較 in, not in :檢查某元素是否在容器型物件裡頭 is , is not :判斷兩個物件是否為同一個 結果會產生bool(布林)型別的物件，True與False 邏輯運算子 and, or, not ，當and運算時，只有左右兩邊皆為True時，運算結果才會是True，其餘皆為False; or則只要有一個為True，得到的結果就是True，not則 是反轉真假值 一般的數值運算子，如(+, , /)等等，其優先順序都高於比較運算子，如(<=, !=, is not)等 述句 是Python程式裡最小最基本的執行單位，每種數據都有其獨特的語法和語意，不符合述句語法的話，就是不合法的程式碼，就不能被直譯器執行 指派述句 多重指派 序列指派 增強型指派述句 if 條件判斷述句 if述句可根據運算式結果(True或False)，作為條件來判斷應該執行哪部分的程式碼，控制走向，稱此類的述句為程式流程控制，if, elif, else那一行的最後面要加上冒號(:)，表是後面將接著一組程式述句，而裡頭的述句必須縮排。 Python因使用縮排來標示程式碼的層級，不同於C / C++ / Java / C# / JavaScript 以大括號{}來包住程式碼的方式 pass述句 pass述句什麼也不做，因為根據Python語法，有時須放進述句，但不需要或不知道該寫什麼，就放pass述句，這樣便可符合語法，否則將發生錯誤 while迴圈述句 for迴圈述句 break述句與continue述句 述句總覽表 函式 定義函式的語法 def 函式名稱 (參數0, 參數1, ......): 參數 呼叫函式時可傳入參數，這個動作跟指派幾乎一模一樣，所謂傳入參數，也就是說呼叫方把某物件指派給參數的名稱，要小心的是，如果參數是可變物件，那麼函式拿到該參數後，也可以改變該物件 return述句 可視範圍(scope) 名稱的可視範圍，決定了在程式的什麼地方能夠看到該名稱，進而存取該名稱指向的物件，在尚未定義函式的程式範圍裡，所有名稱通通都擁有[全域(global)]可視範圍，這些名稱定義在程式最高最外圍的地方，如下圖 a ,b, foo, x, y ，一旦定義後，就能存取名稱指向的物件，簡稱為(全域名稱);而定義在函式範圍裡的名稱(包括參數)，如下圖的n, m，只擁有[區域(local)]可視範圍，只有在該函式內才看得到這些名稱，簡稱(區域名稱)。 在函式(區域)裡，雖可以自由取用全域名稱，但只能讀 不能寫，該如何把新物件指派給全域名稱呢?一但在函式裡把全域名稱放在指派述句的左邊，會產生區域名稱，而不是把新物件指派給全域名稱。辦法是使用(global述句)，便可在函式內重新指派全域名稱到新物件 內建函式 跟算術相關的內建函式 求總合函式sum(), 求串列長度len() range()是建立出(能提供一連串東西的物件)，可用在for迴圈 abs()絕對值, pow()冪次方，等同於**運算子, round()四捨五入到小數點後第二位, divmod()商和餘數 跟邏輯相關的內建函式 all(), any() 有些可得知關於物件的資訊 id(), type()物件的型別, callable()是不是可被呼叫 模組(module) 當Python程式越寫越大，不可能將所有程式碼都放在一起，而應該經適當的切割，根據功能特色劃分成一個又一個的模組(module)，由主程式匯入取用。Python模組可以是Python程式碼 也可以是C語言(或其他)的程式碼 我們先建立兩個檔案，一個是主程式檔，一個是模組檔，將這兩個檔案放在同一個目錄裡(檔名自取)，不一定要跟下圖一樣 在主程式檔裡，我們使用了(import 述句)匯入模組，例如(import 模組檔名)在import後加上模組名，注意，不需要加上 .py副檔名 。 在主執行檔裡使用(import 述句)的作用，就如同去執行模組檔一樣，只不過執行後得到的名稱，會被放入模組物件裡，因為Python 模組物件具有命名空間(namespace)的功能，可存放東西(名稱); 匯入後，可使用(模組名.名稱)的語法，去存取模組裡的名稱(與其指向的物件)。 import 述句還有其它變形，把 (import 模組名) 改為(from 模組名 import * )的話，等於直接把模組名裡的名稱，直接匯到主執行檔的全域範圍裡，就能直接使用(pi, gcd, factorial)等名稱，不需要再加(模組名.)，不過這種匯入方式比較容易出問題，萬一模組名裡的名稱跟你執行檔裡的名稱一樣? 或匯入多個模組，模組名之間重疊? 可以改用(from 模組名 import 名稱)，明確的指定想匯入的名稱。 另一種import 述句變形是(import 模組名 as m)，m是為模組新取的較短名稱，然後以(模組名.名稱)的語法，來存取模組內的名稱，例如: (m.pi) (m.gcd)。 標準程式庫模組 在模組keyword裡，串列kwlist含有Python的保留字，而函式iskeyword可判定某字串是否為保留字 有個模組含有Python全部的內建名稱，包括函式、常數、異常等，名稱是__builtins__，呼叫內建函式dir可列出模組內容。2.x版是模組__builtin__、3.x版是模組builtins 模組math裡含有各種常用的數學函數，如:sqrt(x)計算平方根、pow(x, y)可算出x的y次方、log10(x)可求出x的對數、sin(x)與cos(x)等三角函數、pi與 e 等數學常數 模組random跟隨機亂數相關，提供各種產生亂數的函式，不過Python模組的ranndom提供的是虛擬亂數(pseudo random 或稱假亂數)，非真正的亂數，不可用於密碼、加密、安全等方面。這種亂數屬於(亂中有序)，若了解其機制與規則，便能知道會產生哪個亂數 模組搜尋路徑 當使用import匯入模組時，Python直譯器會根據一份模組搜尋路徑清單，逐一到路徑裡去找模組，然後載入。透過模組sys的串列path得知模組搜尋路徑 模組之名( name ) 模組具備命名空間的功能，可放進名稱，除了各個模組自行提供的常數、函式之外，Python模組預設有一些名稱，其中之一( name )，指向代表模組名的字串物件，透過這個名稱，便能判斷.py檔是被當做主程式檔交給直譯器執行，還是當做模組檔被import述句匯入 結論 最重要的重點，是搞懂名稱(name)與物件(object)的概念，以及相關的型別(type)、指派(assignment)、綁定(binding)，了解基本知識，並明白在 \"Python\"裡任何東西都是物件","url":"http://project.mde.tw/blog/40323131ri-zhi-1050707.html"},{"tags":"2016bg2","title":"40323230紀錄 - 編譯Solvespace流程","text":"由原始碼編譯出Solvespace和CDemo的執行檔 安裝工具 : 必須存放於可攜式環境內的工具，可以協助我們建立Solvespace和CDemo的執行檔。 連結為下載處。 1.MinGW (Not official version), https://nuwen.net/mingw.html 2.msys (Official version), http://www.mingw.org/wiki/msys 3.CMake (Official version), https://cmake.org/download/ 4.NetBeans (Our storage), http://140.130.17.17/public/Netbeans/ 存放位置除了CMake之外皆為W:內，CMake存於W:\\app資料夾中。 下載Solvespace原始碼 : 從 Whitequark的倉儲 git clone最新的原始碼到W:\\tmp資料夾內，並執行git submodule update --init命令以從相關倉儲下載submodule的原始碼。 NetBeans設定 : 從\\NetBeans\\bin執行NetBeans，亦可編輯start.bat和stop.bat後，在啟動時呼叫和關閉它。 在Tools->Options的C/C++中新增編譯工具，選擇GNU MinGW，並填入MinGW的存放位置。 大部分的程式位置會自動填入，不過還要指定msys的make.exe和cmake的位置。 若有必要可以為NetBeans安裝CMake的附加元件。 在Tools->Plugins的Available Plugins中搜尋cmake就能找到，勾選後按下Install鈕就能夠安裝。 執行Build : 接著按下New Project...新增專案。 選擇Project with Existing Sources繼續。 然後選擇Whitequark的Solvespace原始碼目錄。 並使用Automatic讓cmake自動清理專案，直接按完成就會開始Clean和嘗試Build。 這時在Build時會出現錯誤，顯示一串類似undefined reference to `BZ2_bzDecompressEnd'的訊息，是因為沒有加入bz2的程式庫連結所致。 這時開啟專案內的\\src\\CMakeLists.txt，找到target_link_libraries這一行，並將bz2加到最後的括弧內，就可以繼續完成Build。 註：如果不是填在最後一項會有讀取順序錯誤的問題。 修改CMake的清單後，就能順利建立solvespace.exe和CDemo.exe，分別存放在\\src和\\exposed資料夾下。 接下來就是研究如何應用CDemo的解題程式協助解開範例，最後再修改供Python3呼叫和取用其動態連結庫。","url":"http://project.mde.tw/blog/40323230ji-lu-bian-yi-solvespaceliu-cheng.html"},{"tags":"2016g1","title":"40323143 -  日誌  105年7月7日","text":"承臂和馬達組裝完成 發現極限開關固定桿問題 新增旋盤外接件 電路配置構想 日記: 今天將兩個承臂與馬達和極限開關組裝固定 ，馬達固定是利用單心線的線芯穿過馬達與承臂上的固定孔鎖緊，因為昨天新增的凹槽可以承受馬達扭轉的力量，只需要讓他不會脫落即可。另外今天還發現固定設計在承臂上極限開關的固定桿強度不足，原因可能是因為列印的方向為桿件的徑向，導致桿在承受外力時列印接合面沒有足夠的強度支撐而產生破壞，解決方法是買5分的自攻螺釘將其鎖固。 今天新增了一個新物件，目的是為了要使馬達可以有效的對懸盤輸出，與承臂上馬達安裝位置一樣。並且在旋盤底部新增了兩個直徑2.5的孔，其目的是為了配合今天新增的物件鎖固。 今天將這旋盤以上除了夾頭外的東西組裝完，並由實物來預估線路的配置，線路配置目前的方案是將電線拉的比元件與電源的距離更長，讓電線在空中以圓弧狀放置，然後在底座上極限開關接點指向方向上將所有的線集中，然後拉到安裝在底座的arduino上。實際把線抓在安裝的預備位置轉動手臂測試時，目測在旋盤再碰觸到兩個極限開關的位置間旋轉應該是沒有問題，但今天沒有足夠的時間將底座印出來，沒有實際測試。 備註: 1.5分的自攻螺釘是在虎尾的大盤大買的。單心線的線芯是在工具箱拿的，固定大概用10公分。 2.與極限開關相撞的桿子是用免洗筷剪短裝上去的，免洗筷是從系館後面的7-11跟店員要來的，十分堅固。 3.目前的線路配置絕對不是個好方法，真的絕對不是個好方法。 4.不直接在旋盤底面新增新特徵，而是新增新物件，原因是為了方便列印旋盤。 斷裂的固定桿及其光滑的斷面 承臂與馬達固定 極限開關的鎖固 觸發極限開關的桿子 底座上電線大概的集中位置 旋盤新增的孔 新增的零件 提問: 實際上在設計機構，機構上的電路配置有什麼重點需要注意?有沒有固定的配置方式?","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-7ri.html"},{"tags":"2016bg2","title":"40323230紀錄 - Solvespace","text":"找到的Solvespace原始碼版本 目前可攜式環境內存放的Solvespace原始碼 : 超連結為下載處。 1. Whitequark的倉儲 ：非官方人員開發的原始碼。 2. Solvespace 2.0 ：官方舊版2.0的原始碼。結構很簡單，沒有cmake建置的檔案。 3. Solvespace 2.1 ：官方最新穩定的版本。結構類似現在開發中的樣式。但是用NetBeans建置時會顯示\\extlib資料夾中很多資料夾是空的錯誤，2.0版沒有這些資料夾，這些空的資料夾似乎和 solvespace/libdxfrw 有關聯。 4. Solvespace的倉儲 ：官方開發中的2.2版。好像不能clone下來，只能載zip檔。也有2.1那些空資料夾。 相關連結：版本差異紀錄- Solvespace的倉儲 NetBeans方面，同樣使用C/C++ Project with Existing Sources建置檔案，官方的版本都會因為libdxfrw、libfreetype、libpng、zlib沒東西而顯示建置錯誤。 點開記錄錯誤的視窗：","url":"http://project.mde.tw/blog/40323230ji-lu-solvespace.html"},{"tags":"2016g1","title":"40323143 -  日誌  105年7月6日","text":"第二種極限開關的繪圖及安裝設計 第一種極限開關的安裝測試 承臂和馬達的安裝問題 日記: 今天將第二種極限開關新增到零件庫中，並在底座上依其尺寸新增了一個安裝位置，以及在懸盤上新增了一個用來安裝觸發極限開關突出物的安裝孔，和觸發極限開關的圓桿。 今天還發現原本馬達和承臂的組合方式在實際使用上的問題，問題原因是原本的組合方式是想將馬達上原本就有的固定孔與承臂上的固定孔用螺絲或桿件等連接材將兩個元件結合，但因為孔徑的問題使中心的連接材找不到適合的東西使用，所以今天在承臂與馬達組裝的位置新增了配合實驗室馬達尺寸的凹槽，列印出來安裝測試效果很不錯，實際使用應該就是如此了。 備註: 1.原先想用滑環或是其他具相同用途的機構解決線路纏繞的問題，但這些要在這禮拜內完成有難度，所以目前決定在底座設置極限開關作極限點，還會看情況修改。 2.馬達在Onshape上分為兩部分，在Onshape上分別是Part3和Part4，為了配合承臂上的組合點修改，馬達旋轉端( Part4 )的圖也修改為實際上馬達的外型。 3.夾頭部分因為在這禮拜完成極限開關的安裝有很大的困難，經討論後決定暫時將這部分放置，等安裝測試完成後繼續。 Oshape上的極限開關 底座上極限開關裝置結果 安裝觸發極限開關突出物的安裝孔 承臂與馬達組裝位置 承臂與馬達組裝位置實際測試結果 舊的承臂上安裝馬達極極限開關","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-6ri.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/05","text":"NetBeans的相關探索-2 註：發現目前最新的原始碼內好像很多錯誤，不知道該怎麼辦。 目前NetBeans的 官方網站 並沒有很詳盡的介紹，只有放一些改版的導覽影片。 基於如此就研究看看它跟其他編譯軟體有那些不一樣的地方。 NetBeans啟動 : 每次啟動可攜式環境，NetBeans portable都會保留之前的設定。 只要上次編譯的專案沒有關閉或是刪除，NetBeans在啟動時都會自動載入，不需要重新導入專案。 另外NetBeans需要連線的服務（ex.附加元件）也會在啟動時檢查更新。只要背景有程序執行，右下角的進度條就會提醒。 不過NetBeans似乎有時載入太多東西或其他背景程式開太多，如果再對它下指令，會反應跟不上而閃退。也有可能是在可攜環境執行的關係，比較吃資源。 設定start.bat在啟動後自動打開NetBeans。 NetBeans在啟動時載入專案的提示。 NetBeans介面 : 跟大部分的文字編譯軟體差不多的介面。 在畫面中按住Ctrl鍵選取#include或import的檔案能直接在分頁中開啟它們；如果是物件，點擊後會移到宣告的地方；如果是副程式，會移到其開始位置。 行號中會標記錯誤或警告提示，滑鼠移上去就會解說，並且按下Alt+Enter可以顯示更多提示。 捲軸的旁邊會標記標籤，顯示整個檔案中哪些位置有警告或錯誤，直接點擊可以快速移到該處。 NetBeans還有內建自動拼寫校正（註解處）。不過有時候讀取和偵錯反應比較慢。 主工具列比較簡單。新建獨立檔案／專案、讀取專案、全部儲存、復原／重做之類的基本功能。 另外還有選取專案設定檔、Build／Clean than Build的功能、執行／除錯的功能。 上方的選單比較特殊的是Team的功能，似乎能管理版次和執行git的指令，但是嘗試了一些似乎沒反應？ Project的欄目可以快速選取開啟CMake的檔案，除此之外和File的檔案結構是一樣的。 以下是File的檔案目錄和檔案總管顯示的比較。 服務頁籤中會顯示一些工具，不過不知道怎麼使用。 讀取檔案後會顯示第4個欄位Class，是拆解程式後的物件樹，點擊兩下會開啟程式碼。 在物件上點擊兩下會移到該物件所在的檔案位置。 在物件上打關鍵字並使用上下鍵移動能夠搜尋檔案中的物件。 工具列的功能說明： 1：Source-切換至編輯原始碼模式。 2：History-切換至編輯記錄模式。 3：Last Edit-回到上次編輯（插入／刪除）過的位置。 4：Go back to-上一個瀏覽過的檔案。 5：Forward-下一個瀏覽過的檔案。 6：Find Selection-在本檔案搜尋框選的文字。 7：Find Previous Occurrence-尋找前一個關鍵字。 8：Find Next Occurrence-尋找後一個關鍵字。 9：Toggle Highlight Search-切換高亮度標示。 10：Toggle Rectangular Selection-切換矩形框選模式。 11：Previous Bookmark-前一個書籤。 12：Next Bookmark-下一個書籤。 13：Toggle Bookmark-切換書籤。 14：Shift Line Left-往左縮排。 15：Shift Line Right-往右縮排。 16：Start Macro Recording-開始巨集（腳本）錄製。 17：Stop Macro Recording-停止巨集錄製。 18：Comment-註解。 19：UNcomment-刪掉註解。 20：Go to Header/Source-開啟源頭檔。 使用一款未接觸過的軟體，都會先研究它的介面和基本操作方式還有額外的設定，不過有些專業用詞不知道影響的關聯性。 以前只用過Visual Studio撰寫和測試一些簡單的程式，對這種大型的架構瞭解較少，應該會再找些相關資訊學習。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050705.html"},{"tags":"2016g1","title":"40323143 -  日誌  105年7月5日","text":"第一種極限開關的繪圖及安裝設計以及夾頭極限開關安裝問題 日記: 今天將買了三種不同接觸點種類的極限開關，並將其中一種新增進入零件庫，且由其尺寸在承臂上新增其安裝位置，在Onshape上目測沒有和其他零件有接觸，承臂上的極限開關配置應該已經確定了，但夾頭座的極限開關配置找不到適合的位置，可能需要變更夾頭座的外型，或是在畫外接的零件，底座的極限開關配置還沒有畫出來，但應該會是在底座配置極限開關，在旋盤上設置接觸點觸發極限開關。 備註: 1.應祐生要求，將會在極限開關配置完成後利用3D列印印出一組非工作尺寸的手臂。 2.Onshape上只有話接觸點最長的極限開關，實際使用時會依照實際狀況運用三種不同階典的極限開關。 3.極限開關是在虎尾的國輝電子買的，三種接頭各三顆，原先想連滑環一起買，但沒有賣。 4.想自己做滑環，但是怕會燒掉。 極限開關的實體圖及量測尺寸 承臂上極限開關裝置位置 極限開關 極限開關組合完-1 極限開關組合完-2","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-5ri.html"},{"tags":"2016bg2","title":"40323218日誌 - 105/07/04","text":"V-rep 熟悉 V-Rep 基本操作 1. 2D移動 2. 3D旋轉 3. 遠近 4. 移動畫面至物體 5. 物體定位(x,y,z) 6. 物體旋轉(x,y,z) 7. 開始模擬 8. 暫停模擬 9. 結束模擬 10. 慢速 11. 加速 嘗試製作 one_link_robot File→import→Mesh...(從資料夾中輸入 stl檔) 選擇單位和方向 點選物體使用\"object shift\"調整Z軸距離 點選物體 右鍵→Edit→Grouping/Merging→Divide selected shapes(使物體解體) 右鍵→Add→Joint→Revolute(增加旋轉軸) 連點兩下Revolute icon 打開 Scene Object Properties , 下面 Visual properties修改旋轉軸的長和直徑 接著點下面 Show dynamic properties dialog , 打勾Motor enabled 和 Lock motor ... 再來點旋轉軸 , Ctrl+左鍵點圓柱 , 使用\"object shift\"在XYZ都點Apply to selection , 在\"Orientation/Rotations\"也點 Apply , 使兩軸重疊 點選圓柱 icon , 點最下面Show dynamic properties dialog , 打勾Body is dynamic(使物體可作動) 使圓柱降階成為旋轉軸的Child 使旋轉物降階成為圓柱的Child 使旋轉軸降階成為底座的Child 按左側\"Script\" →Insert new script→Script type 選擇 Child script (threaded) , 下方 Associated object 選擇底座. double - click the child script, 在最下面加上SimExtRemoteApiStart(19999)(參考老師範例研究中) 點選\"Start simulation\" 啟動模擬 , 用SciTE 開啟老師的檔案 one_link_robot_remoteAPI.py , F5執行就會轉囉~~ 製作影片： V-Rep one_link_robot from Li Steven on Vimeo .","url":"http://project.mde.tw/blog/40323218ri-zhi-1050704.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/04-2","text":"NetBeans的相關探索 NetBeans設定 : 從 MinGW Distro - nuwen.net 下載了新版配有gcc 6.1.0和Boost 1.61.0的MinGW，原本可攜式環境的MinGW是用gcc 4.9.3，暫且在名稱加上.old不使用。 下圖是新版和舊版的比對。新版的資料夾有附一個README_STL.txt文件說明內含的附加元件版本。 這個MinGW裡還配有一個比較簡單的git工具。 NetBeans的版本是8.1，存放於根目錄W:，已經是最新版。 先在Option裡設定C語言用的Build Tool，在新增工具的下拉選單設定使用MinGW，並指定到MinGW的目錄。成功新增Tool後，NetBeans會自己抓到gcc.exe、g++.exe、as.exe、gdb.exe，最下方則是有QMake和CMake的選項，將CMake指定到存放的位置。 設定裡所有的位置都是指定於可攜式環境內，沒用到任何外部資料夾。 NetBeans專案 : 之後新建專案，選擇C語言已有源代碼的專案。 選擇模式部分選擇Solvespace的目錄。工具只有剛才設定的MinGW，並選擇自訂查看一下。 基本上是使用Predefined Command，使用的是CMake的gui設定，也就是Solvespace目錄存放的CMakeLists.txt檔。 接下來是清理和建置指令，就和打在CMD視窗裡的一樣。 幾乎每個環節都會詢問工作環境，但是Solvespace沒特別區分的話就是原本目錄內，所以直接按下一步。 按下完成鈕後會花個幾秒載入。然後就會在左側讀入原始碼資料夾和檔案的結構。 下面則會執行並顯示CMake和Clean指令輸出的訊息，最後完成後就完成編譯環境了。 左側的欄位分成Project、Files和Services。只要在Project或Files的檔案樹點兩下就能在中央開啟文件編輯。Services則可以呼叫MinGW的附加元件來用（包含gcc）。 左下的導航欄似乎能執行CMake的指令。 這次也是使用之前備份並更新過的Solvespace原始碼操作，免得被之前的檔案影響。 雖然和SciTE一樣是文字編譯軟體，但是NetBeans能夠隨時呼叫需要使用的工具來支援。與Visual Studio相比還能夠在可攜環境中保存設定檔，更為方便。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050704-2.html"},{"tags":"2016g1","title":"40323143 -  日誌  105年7月4日","text":"針對承臂的設計及修改以及夾頭的不成功構想 日記: 今天將Onshape平台上的因馬達尺寸測量錯誤導致機械手臂零件與馬達不能配合的錯誤修正，並增加馬達的外部特徵(電線接頭)及新增參數。以及因應手臂上馬達線路的配置改變設計，目前修改的有承臂末端新增一個槽及一個孔。還有嘗試一個夾頭的連桿構想，但是沒有成功。 備註: 1.馬達固定端的寬度由和馬達邊相等的20mm改成實際尺寸18mm，因應改變馬達固定孔中心距由原本的12mm變成10mm。 2.新增arm_fixhole_diameter(承臂及馬達連接孔的孔徑)和arm_fixhole_disdance(承臂及馬達連接孔的中心距)兩個參數，arm_fixhole_diameter=1.5，arm_fixhole_disdance=21。 3.承臂末端新增一個11*10的槽，以及一個直徑為6的孔。 4.夾頭的連桿構想在Assembly 3裡，原先想將兩根從動桿分別裝在主動桿不同位置，利用其旋轉時不同的位移來帶動前方橫桿的作動，達成像握住般的夾持，結果兩側的夾持變得太少，所以沒有成功。 馬達固定孔的尺寸修改 承臂與馬達連接孔尺寸修改 夾頭構想圖 提問: 請問有沒有機構能讓有連接線的物體作360度旋轉，卻不會讓線纏住的機構？","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-4ri.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/04","text":"改用CMD設定CMake CMD命令cmake連接Solvespace原始碼 : Readme的Command-line build 使用可攜式環境的Command Prompt到外部呼叫Visual Studio的vcvarsall.bat。 然後為cmake的bin資料夾設定啟動位置(Path4)，可以正常呼叫。 到CMD中下Readme中提供的指令。 接著下nmake的指令。 但是在最後出現一些錯誤，不知道原因為何。 與此同時可以用Visual Studio的相關功能。CMake也算是設定完成了。 如果要改用NetBeans，就不用下nmake的指令。 Readme的MSVC build 這次也把MinGW的bin設定進啟動位置(Path5)，可以正常呼叫。 接著同樣按照Readme的說明用CMD下指令。 不過後面的make指令會說無法讀取makefile檔。 Readme中說可以使用MinGW，只要確保git和MinGW的gcc在作業環境內就行了。至於gcc的功能繁多，還需要研究一下。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050704.html"},{"tags":"2016g1","title":"40323131日誌 105/07/03","text":"學習python3 物件導向 稍微讀了一下老師提供的有關物件導向的資料，對於物件導向有個概念了，也有稍微做了一些筆記，放在資料夾裡頭，不過對於上次的問題，還是無法順利的解決，所以只好先跳過那一部分，先解決其他部分 下面幾張圖都是有關於上次遇到無法解決的那部分，於是我將那裏先行註解掉 略過上述的那些問題，再將一些語法問題排除後，終於成功讓控制器介面跑出來了，不過跟原本的好像又差蠻多的，沒有圖片...，那部分可能還要花時間去了解，內部的一些按鈕的功能也不確定能不能使用，還有上述的那個問題，也要解決畢竟那是有關於顏色參數那方面的問題，所以非常重要，而且看指令列那邊，在執行的時候也還是出現蠻多錯誤的，而且又不知道問題出在哪裡了，所以還有好一大段路要走阿...","url":"http://project.mde.tw/blog/40323131ri-zhi-1050703.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/03-2","text":"關於編譯 Solvespace(更新) 使用CMake連接Solvespace原始碼 : Readme的GUI build 下載了放在140.130.17.17/public/Netbeans/的可攜式環境git2016，該環境使用的是W:磁碟機，不會和撰寫網誌的Y:環境衝突，可以同時開啟；但是其一關閉時會把所有cmd關掉。之後放入了Netbeans套件，不過還尚未使用。 在新的可攜式環境中存入了從GitHub下載的Solvespace的原始碼，並依照其Readme的方式，用git submodule update --init指令更新模組，並存了一個備份檔。 CMake的方面使用可攜版的Zip檔，而非Msi安裝。將CMake放在W:的根目錄下。相較於使用指令，因為可攜式環境沒辦法呼叫外部程式支援，所以用cmake-gui.exe圖形介面來設定相關環境。 一開始對cmake-gui.exe的兩個位置指向不太清楚，所以嘗試了很多次。 要在Solvespace的目錄中建立一個/build資料夾，以存放binaries。 Source code的部分是填程式專案的目錄，binaries的地方填/build資料夾，再按Configure鈕設定編譯器，完成後會設置CMake的檔案。 雖然之前的目錄已經有檔案了，但是如果binaries直接設目錄內，貌似會衝突產生問題，也無法復原設定檔，幸好有先備份資料能復原。 Configure的部分嘗試選擇MinGW的選項。 下面則選Specify native compilers來自訂編譯器位置，這時執行出現一個錯誤，無法執行MinGW。 上網尋找似乎要修改系統環境參數到MinGW的bin資料夾才找的到原本就存在的libgmp-10.dll，不知道可攜式環境有沒有其他解法。 暫時用Visual Studio的設定，但是結果似乎不理想。 參考資料： 1. 教學影片-Visual Studio 2. 教學影片-Mingw 目前還不會使用MinGW或Netbeans套件，所以暫時先放在可攜環境git2016中，之後會找資料學習如何編譯Solvespace的功能。","url":"http://project.mde.tw/blog/40323230ri-zhi-1050703-2.html"},{"tags":"2016bg2","title":"40323230日誌 - 105/07/03","text":"關於編譯 Solvespace 編譯 Solvespace 前的準備 : 從 Active State 下載了 ActivePerl，使用的是5.24.0／x64版。 從 Microsoft 下載並安裝了Visual Studio Professional 2015，安裝好像無法選擇C:以外的磁碟。 從 GitHub 下載Solvespace的原始碼，另外在 Solvespace 提供下載的頁面中也有一個較舊版的原始碼。 裝完之後用Developer Command Prompt切換至專案目錄執行nmake，就能下相關指令了。 用CMD從安裝目錄的\\VC\\bin啟動vcvars32.bat，執行nmake好像也可以，不知道其差異性。 關於NMAKE的使用方法，找了幾個中國的網站介紹： 1. NMAKE的指令 2. NMAKE的開發環境設置","url":"http://project.mde.tw/blog/40323230ri-zhi-1050703.html"},{"tags":"2016g1","title":"PySerial 問題0703","text":"今日讀的進度，以及筆記 改成執行緒的方式收值 import serial from threading import * import sys import time def handleClient(): while(True): print(\"waiting for client\") time.sleep(3) #with serial.Serial('COM6',9600,timeout = 1) as ser: def recevive(): my_list = [12] # CRLF[10]=\"\\r\\n\" with serial.Serial() as ser: ser.baudrate = 9600 ser.port = 'COM6' ser.open() #print(ser.name) while(True): text = ser.read().decode('utf-8') text = text.replace('\\r','\\n') my_list = text #想要整理成矩陣 目前無頭緒 print (my_list,end ='') if my_list[0] ==\"S\": print(\"perfect\") else: print(\"failed\") time.sleep(0.1) if __name__ == \"__main__\": t = Timer(3.0,handleClient) s = Timer(3.0,recevive) s.start() 有關執行緒的部分有多種方式可以使用，上面只是其中一個，還有別種方法是利用class的方法，不過在python3中用的方法都比較嚴謹，沒辦法隨意使用，以及他使用的語法和C其實差蠻多的，有可能後面做法做看看，利用python控制C的程式，說不定會簡單一點，但是不一定，也要實作才知道，最主要python2和python3的差別來自於他們對於編碼的方式不同，而且相對於他們使用的嚴謹，for example (encode . decode)部分的可能要需要再研讀一陣子。","url":"http://project.mde.tw/blog/pyserial-wen-ti-0703.html"},{"tags":"2016bg2","title":"40323230紀錄","text":"V-REP從範本學得的一些紀錄 V-REP Example Learning Reviews 嘗試用英文說明 Notes : The \"Scene hierarchy\" panel can show whole of outward and entity in a tree. Scene hierarchy Description page In this case, a group of parts will in the same level. they are outward, entity and joint parts. Maybe some sensor parts will put into this group. Any parts can insert a script to control them. \"Dummy\" parts is a calculation module. They are collidable, measurable and detectable like the entity. But now we are't clearly known it's application. Dummy Description page 組裝上可以使用「滑塊主動噴頭連動」或「噴頭主動滑塊連動」的方式，但是在從屬關係上必須顛倒，程式寫法也不一樣。「滑塊主動噴頭連動」的方式較符合3D印表機的物理運作。 目前整理完幾何部件的檔案。存於\\users\\g2_files\\VREP_Simulation.ttt中。","url":"http://project.mde.tw/blog/40323230ji-lu.html"},{"tags":"2016g1","title":"PySerial 問題","text":"今日讀的進度，以及筆記 發現到的問題 主要是安裝wxpython phoenix 和他原本使用的wxpython不一樣，因此需要更改一些兩者的不同，但是在wxTerminal的部分可以跑出gui介面，但是再傳收值得部分，有些許問題，來自於wxpython和wxpython phoenix 的部分他們不互相支援，可能是他們還有些問題 主要出問題的部分是來自於line 349 git clone :https://github.com/pyserial/pyserial 在example裡面的wxTerminal.py啟動收值部分有些許問題 底下為我寫的測試的程式 import serial with serial.Serial() as ser: ser.baudrate = 9600 ser.port = 'COM6' ser.open() print(ser.name) # ser.write(b'hello') while(1): # transform data #ser.write(b\"hello\") x = ser.read().decode print(x) 實際測試部分 最後補上 認真==鑽牛角尖的第二組 量螺絲","url":"http://project.mde.tw/blog/pyserial-wen-ti.html"},{"tags":"2016g1","title":"40323131日誌 105/07/01","text":"python2語法 修改成python3語法 下圖框框處，原本的程式碼是 gettext.install(domain, './locale', unicode = 1)，我是將unicode = 1 拿掉 底下的程式碼原本為imp.reload(sys) sys.setdefaultencoding('utf-8') ，在這裡我是將後面的sys.setdefaultencoding('utf-8') 拿掉，因為好像python3默認的編碼原本就是utf-8了 目前遇到的問題 下面的錯誤是說模組沒有被loaded，所以無法導入，不過我去找了一下它的目錄裡頭是有bufferedcanvas這個檔案的，所以就不清楚錯誤出在哪裡 接著底下的這個問題大概是我卡最久的地方，self.bgcolor = wx.Colour()，錯誤是說Colour這個物件沒有歸類在SetFromName裡頭，我試了蠻多次，結果都差不多.... 於是我又進到wx套件裡頭去找有沒有Colour這個物件，是找到蠻多有Colour字母的檔案，不過我不清楚要import哪一個 由於自己對於python的物件導向沒什麼概念，class跟__init__這些都不是很熟，感覺整天修改下來根本沒改什麼東西，所以感覺蠻有挫折感的...，另外用python3裡頭內建的2to3.py檔下去修改python2轉成python3語法的錯誤，感覺方便許多，我用的指令是python y:\\Python34\\Tools\\Scipts\\2to3.py -w 要修改的py檔，y:\\Python34\\Tools\\Scipts\\2to3.py 這裡是給定2to3.py檔的位置給它，-w是write的意思，然後才是要修改的py檔案","url":"http://project.mde.tw/blog/40323131ri-zhi-1050701.html"},{"tags":"2016g1","title":"PySerial進度","text":"今日讀的進度，以及筆記 三個要件 1.pyserial 2.wxpython with Phoenix 3.python3以上的版本 2.7版的wxxpython和phoenix wxpython api比較 網站連結 PySerial documation about io control 網站連結 Wxxpython API Module 網站連結 Wxxpython GUI Bulider wxGlade 今日寫程式遇到的問題點 1.在wxTeriminal中遇到問題來自於他沒辦法顯示我傳給他的值 2.以及他的pyserial中，需要詳細測試他所收到以及送的值的格式 3.才能自己寫一套for python3 Gui的程式控制 要能成功執行下方的程式必須要安裝 1.python 3.4+ 2.wxPython Phoenix 3.pyserial 關於程式碼有更改後的 #file name wxSerialConfigDialog.py import wx import serial import serial.tools.list_ports SHOW_BAUDRATE = 1 << 0 SHOW_FORMAT = 1 << 1 SHOW_FLOW = 1 << 2 SHOW_TIMEOUT = 1 << 3 SHOW_ALL = SHOW_BAUDRATE | SHOW_FORMAT | SHOW_FLOW | SHOW_TIMEOUT class SerialConfigDialog(wx.Dialog): \"\"\"\\ Serial Port configuration dialog, to be used with pySerial 2.0+ When instantiating a class of this dialog, then the \"serial\" keyword argument is mandatory. It is a reference to a serial.Serial instance. the optional \"show\" keyword argument can be used to show/hide different settings. The default is SHOW_ALL which corresponds to SHOW_BAUDRATE|SHOW_FORMAT|SHOW_FLOW|SHOW_TIMEOUT. All constants can be found in this module (not the class). \"\"\" def __init__(self, *args, **kwds): # grab the serial keyword and remove it from the dict self.serial = kwds['serial'] del kwds['serial'] self.show = SHOW_ALL if 'show' in kwds: self.show = kwds.pop('show') # begin wxGlade: SerialConfigDialog.__init__ kwds[\"style\"] = wx.DEFAULT_DIALOG_STYLE wx.Dialog.__init__(self, *args, **kwds) self.label_2 = wx.StaticText(self, -1, \"Port\") self.choice_port = wx.Choice(self, -1, choices=[]) self.label_1 = wx.StaticText(self, -1, \"Baudrate\") self.combo_box_baudrate = wx.ComboBox(self, -1, choices=[], style=wx.CB_DROPDOWN) self.sizer_1_staticbox = wx.StaticBox(self, -1, \"Basics\") self.panel_format = wx.Panel(self, -1) self.label_3 = wx.StaticText(self.panel_format, -1, \"Data Bits\") self.choice_databits = wx.Choice(self.panel_format, -1, choices=[\"choice 1\"]) self.label_4 = wx.StaticText(self.panel_format, -1, \"Stop Bits\") self.choice_stopbits = wx.Choice(self.panel_format, -1, choices=[\"choice 1\"]) self.label_5 = wx.StaticText(self.panel_format, -1, \"Parity\") self.choice_parity = wx.Choice(self.panel_format, -1, choices=[\"choice 1\"]) self.sizer_format_staticbox = wx.StaticBox(self.panel_format, -1, \"Data Format\") self.panel_timeout = wx.Panel(self, -1) self.checkbox_timeout = wx.CheckBox(self.panel_timeout, -1, \"Use Timeout\") self.text_ctrl_timeout = wx.TextCtrl(self.panel_timeout, -1, \"\") self.label_6 = wx.StaticText(self.panel_timeout, -1, \"seconds\") self.sizer_timeout_staticbox = wx.StaticBox(self.panel_timeout, -1, \"Timeout\") self.panel_flow = wx.Panel(self, -1) self.checkbox_rtscts = wx.CheckBox(self.panel_flow, -1, \"RTS/CTS\") self.checkbox_xonxoff = wx.CheckBox(self.panel_flow, -1, \"Xon/Xoff\") self.sizer_flow_staticbox = wx.StaticBox(self.panel_flow, -1, \"Flow Control\") self.button_ok = wx.Button(self, wx.ID_OK, \"\") self.button_cancel = wx.Button(self, wx.ID_CANCEL, \"\") self.__set_properties() self.__do_layout() # end wxGlade # attach the event handlers self.__attach_events() def __set_properties(self): # begin wxGlade: SerialConfigDialog.__set_properties self.SetTitle(\"Serial Port Configuration\") self.choice_databits.SetSelection(0) self.choice_stopbits.SetSelection(0) self.choice_parity.SetSelection(0) self.text_ctrl_timeout.Enable(False) self.button_ok.SetDefault() # end wxGlade self.SetTitle(\"Serial Port Configuration\") if self.show & SHOW_TIMEOUT: self.text_ctrl_timeout.Enable(0) self.button_ok.SetDefault() if not self.show & SHOW_BAUDRATE: self.label_1.Hide() self.combo_box_baudrate.Hide() if not self.show & SHOW_FORMAT: self.panel_format.Hide() if not self.show & SHOW_TIMEOUT: self.panel_timeout.Hide() if not self.show & SHOW_FLOW: self.panel_flow.Hide() # fill in ports and select current setting preferred_index = 0 self.choice_port.Clear() self.ports = [] for n, (portname, desc, hwid) in enumerate(sorted(serial.tools.list_ports.comports())): self.choice_port.Append('{} - {}'.format(portname, desc)) self.ports.append(portname) if self.serial.name == portname: preferred_index = n self.choice_port.SetSelection(preferred_index) if self.show & SHOW_BAUDRATE: preferred_index = None # fill in baud rates and select current setting self.combo_box_baudrate.Clear() for n, baudrate in enumerate(self.serial.BAUDRATES): self.combo_box_baudrate.Append(str(baudrate)) if self.serial.baudrate == baudrate: preferred_index = n if preferred_index is not None: self.combo_box_baudrate.SetSelection(preferred_index) else: self.combo_box_baudrate.SetValue('{}'.format(self.serial.baudrate)) if self.show & SHOW_FORMAT: # fill in data bits and select current setting self.choice_databits.Clear() for n, bytesize in enumerate(self.serial.BYTESIZES): self.choice_databits.Append(str(bytesize)) if self.serial.bytesize == bytesize: index = n self.choice_databits.SetSelection(index) # fill in stop bits and select current setting self.choice_stopbits.Clear() for n, stopbits in enumerate(self.serial.STOPBITS): self.choice_stopbits.Append(str(stopbits)) if self.serial.stopbits == stopbits: index = n self.choice_stopbits.SetSelection(index) # fill in parities and select current setting self.choice_parity.Clear() for n, parity in enumerate(self.serial.PARITIES): self.choice_parity.Append(str(serial.PARITY_NAMES[parity])) if self.serial.parity == parity: index = n self.choice_parity.SetSelection(index) if self.show & SHOW_TIMEOUT: # set the timeout mode and value if self.serial.timeout is None: self.checkbox_timeout.SetValue(False) self.text_ctrl_timeout.Enable(False) else: self.checkbox_timeout.SetValue(True) self.text_ctrl_timeout.Enable(True) self.text_ctrl_timeout.SetValue(str(self.serial.timeout)) if self.show & SHOW_FLOW: # set the rtscts mode self.checkbox_rtscts.SetValue(self.serial.rtscts) # set the rtscts mode self.checkbox_xonxoff.SetValue(self.serial.xonxoff) def __do_layout(self): # begin wxGlade: SerialConfigDialog.__do_layout sizer_2 = wx.BoxSizer(wx.VERTICAL) sizer_3 = wx.BoxSizer(wx.HORIZONTAL) self.sizer_flow_staticbox.Lower() sizer_flow = wx.StaticBoxSizer(self.sizer_flow_staticbox, wx.HORIZONTAL) self.sizer_timeout_staticbox.Lower() sizer_timeout = wx.StaticBoxSizer(self.sizer_timeout_staticbox, wx.HORIZONTAL) self.sizer_format_staticbox.Lower() sizer_format = wx.StaticBoxSizer(self.sizer_format_staticbox, wx.VERTICAL) grid_sizer_1 = wx.FlexGridSizer(3, 2, 0, 0) self.sizer_1_staticbox.Lower() sizer_1 = wx.StaticBoxSizer(self.sizer_1_staticbox, wx.VERTICAL) sizer_basics = wx.FlexGridSizer(3, 2, 0, 0) sizer_basics.Add(self.label_2, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_basics.Add(self.choice_port, 0, wx.EXPAND, 0) sizer_basics.Add(self.label_1, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_basics.Add(self.combo_box_baudrate, 0, wx.EXPAND, 0) sizer_basics.AddGrowableCol(1) sizer_1.Add(sizer_basics, 0, wx.EXPAND, 0) sizer_2.Add(sizer_1, 0, wx.EXPAND, 0) grid_sizer_1.Add(self.label_3, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) grid_sizer_1.Add(self.choice_databits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0) grid_sizer_1.Add(self.label_4, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) grid_sizer_1.Add(self.choice_stopbits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0) grid_sizer_1.Add(self.label_5, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) grid_sizer_1.Add(self.choice_parity, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0) sizer_format.Add(grid_sizer_1, 1, wx.EXPAND, 0) self.panel_format.SetSizer(sizer_format) sizer_2.Add(self.panel_format, 0, wx.EXPAND, 0) sizer_timeout.Add(self.checkbox_timeout, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_timeout.Add(self.text_ctrl_timeout, 0, 0, 0) sizer_timeout.Add(self.label_6, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) self.panel_timeout.SetSizer(sizer_timeout) sizer_2.Add(self.panel_timeout, 0, wx.EXPAND, 0) sizer_flow.Add(self.checkbox_rtscts, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_flow.Add(self.checkbox_xonxoff, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_flow.Add((10, 10), 1, wx.EXPAND, 0) self.panel_flow.SetSizer(sizer_flow) sizer_2.Add(self.panel_flow, 0, wx.EXPAND, 0) sizer_3.Add(self.button_ok, 0, 0, 0) sizer_3.Add(self.button_cancel, 0, 0, 0) sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4) self.SetSizer(sizer_2) sizer_2.Fit(self) self.Layout() # end wxGlade def __attach_events(self): wx.EVT_BUTTON(self, self.button_ok.GetId(), self.OnOK) wx.EVT_BUTTON(self, self.button_cancel.GetId(), self.OnCancel) if self.show & SHOW_TIMEOUT: wx.EVT_CHECKBOX(self, self.checkbox_timeout.GetId(), self.OnTimeout) def OnOK(self, events): success = True self.serial.port = self.ports[self.choice_port.GetSelection()] if self.show & SHOW_BAUDRATE: try: b = int(self.combo_box_baudrate.GetValue()) except ValueError: with wx.MessageDialog( self, 'Baudrate must be a numeric value', 'Value Error', wx.OK | wx.ICON_ERROR) as dlg: dlg.ShowModal() success = False else: self.serial.baudrate = b if self.show & SHOW_FORMAT: self.serial.bytesize = self.serial.BYTESIZES[self.choice_databits.GetSelection()] self.serial.stopbits = self.serial.STOPBITS[self.choice_stopbits.GetSelection()] self.serial.parity = self.serial.PARITIES[self.choice_parity.GetSelection()] if self.show & SHOW_FLOW: self.serial.rtscts = self.checkbox_rtscts.GetValue() self.serial.xonxoff = self.checkbox_xonxoff.GetValue() if self.show & SHOW_TIMEOUT: if self.checkbox_timeout.GetValue(): try: self.serial.timeout = float(self.text_ctrl_timeout.GetValue()) except ValueError: with wx.MessageDialog( self, 'Timeout must be a numeric value', 'Value Error', wx.OK | wx.ICON_ERROR) as dlg: dlg.ShowModal() success = False else: self.serial.timeout = None if success: self.EndModal(wx.ID_OK) def OnCancel(self, events): self.EndModal(wx.ID_CANCEL) def OnTimeout(self, events): if self.checkbox_timeout.GetValue(): self.text_ctrl_timeout.Enable(True) else: self.text_ctrl_timeout.Enable(False) # end of class SerialConfigDialog class MyApp(wx.App): \"\"\"Test code\"\"\" def OnInit(self): wx.InitAllImageHandlers() ser = serial.Serial() print(ser) # loop until cancel is pressed, old values are used as start for the next run # show the different views, one after the other # value are kept. for flags in (SHOW_BAUDRATE, SHOW_FLOW, SHOW_FORMAT, SHOW_TIMEOUT, SHOW_ALL): dialog_serial_cfg = SerialConfigDialog(None, -1, \"\", serial=ser, show=flags) self.SetTopWindow(dialog_serial_cfg) result = dialog_serial_cfg.ShowModal() print(ser) if result != wx.ID_OK: break # the user can play around with the values, CANCEL aborts the loop while True: dialog_serial_cfg = SerialConfigDialog(None, -1, \"\", serial=ser) self.SetTopWindow(dialog_serial_cfg) result = dialog_serial_cfg.ShowModal() print(ser) if result != wx.ID_OK: break return 0 # end of class MyApp if __name__ == \"__main__\": app = MyApp(0) app.MainLoop() 主程式部分 #file name wxTerminal.py import codecs import serial import threading import wx import wxSerialConfigDialog # ---------------------------------------------------------------------- # Create an own event type, so that GUI updates can be delegated # this is required as on some platforms only the main thread can # access the GUI without crashing. wxMutexGuiEnter/wxMutexGuiLeave # could be used too, but an event is more elegant. SERIALRX = wx.NewEventType() # bind to serial data receive events EVT_SERIALRX = wx.PyEventBinder(SERIALRX, 0) class SerialRxEvent(wx.PyCommandEvent): eventType = SERIALRX def __init__(self, windowID, data): wx.PyCommandEvent.__init__(self, self.eventType, windowID) self.data = data def Clone(self): self.__class__(self.GetId(), self.data) # ---------------------------------------------------------------------- ID_CLEAR = wx.NewId() ID_SAVEAS = wx.NewId() ID_SETTINGS = wx.NewId() ID_TERM = wx.NewId() ID_EXIT = wx.NewId() ID_RTS = wx.NewId() ID_DTR = wx.NewId() NEWLINE_CR = 0 NEWLINE_LF = 1 NEWLINE_CRLF = 2 class TerminalSetup: \"\"\" Placeholder for various terminal settings. Used to pass the options to the TerminalSettingsDialog. \"\"\" def __init__(self): self.echo = False self.unprintable = False self.newline = NEWLINE_CRLF class TerminalSettingsDialog(wx.Dialog): \"\"\"Simple dialog with common terminal settings like echo, newline mode.\"\"\" def __init__(self, *args, **kwds): self.settings = kwds['settings'] del kwds['settings'] # begin wxGlade: TerminalSettingsDialog.__init__ kwds[\"style\"] = wx.DEFAULT_DIALOG_STYLE wx.Dialog.__init__(self, *args, **kwds) self.checkbox_echo = wx.CheckBox(self, -1, \"Local Echo\") self.checkbox_unprintable = wx.CheckBox(self, -1, \"Show unprintable characters\") self.radio_box_newline = wx.RadioBox(self, -1, \"Newline Handling\", choices=[\"CR only\", \"LF only\", \"CR+LF\"], majorDimension=0, style=wx.RA_SPECIFY_ROWS) self.sizer_4_staticbox = wx.StaticBox(self, -1, \"Input/Output\") self.button_ok = wx.Button(self, wx.ID_OK, \"\") self.button_cancel = wx.Button(self, wx.ID_CANCEL, \"\") self.__set_properties() self.__do_layout() # end wxGlade self.__attach_events() self.checkbox_echo.SetValue(self.settings.echo) self.checkbox_unprintable.SetValue(self.settings.unprintable) self.radio_box_newline.SetSelection(self.settings.newline) def __set_properties(self): # begin wxGlade: TerminalSettingsDialog.__set_properties self.SetTitle(\"Terminal Settings\") self.radio_box_newline.SetSelection(0) self.button_ok.SetDefault() # end wxGlade def __do_layout(self): # begin wxGlade: TerminalSettingsDialog.__do_layout sizer_2 = wx.BoxSizer(wx.VERTICAL) sizer_3 = wx.BoxSizer(wx.HORIZONTAL) self.sizer_4_staticbox.Lower() sizer_4 = wx.StaticBoxSizer(self.sizer_4_staticbox, wx.VERTICAL) sizer_4.Add(self.checkbox_echo, 0, wx.ALL, 4) sizer_4.Add(self.checkbox_unprintable, 0, wx.ALL, 4) sizer_4.Add(self.radio_box_newline, 0, 0, 0) sizer_2.Add(sizer_4, 0, wx.EXPAND, 0) sizer_3.Add(self.button_ok, 0, 0, 0) sizer_3.Add(self.button_cancel, 0, 0, 0) sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4) self.SetSizer(sizer_2) sizer_2.Fit(self) self.Layout() # end wxGlade def __attach_events(self): self.Bind(wx.EVT_BUTTON, self.OnOK, id=self.button_ok.GetId()) self.Bind(wx.EVT_BUTTON, self.OnCancel, id=self.button_cancel.GetId()) def OnOK(self, events): \"\"\"Update data wil new values and close dialog.\"\"\" self.settings.echo = self.checkbox_echo.GetValue() self.settings.unprintable = self.checkbox_unprintable.GetValue() self.settings.newline = self.radio_box_newline.GetSelection() self.EndModal(wx.ID_OK) def OnCancel(self, events): \"\"\"Do not update data but close dialog.\"\"\" self.EndModal(wx.ID_CANCEL) # end of class TerminalSettingsDialog class TerminalFrame(wx.Frame): \"\"\"Simple terminal program for wxPython\"\"\" def __init__(self, *args, **kwds): self.serial = serial.Serial() self.serial.timeout = 0.5 # make sure that the alive event can be checked from time to time self.settings = TerminalSetup() # placeholder for the settings self.thread = None self.alive = threading.Event() # begin wxGlade: TerminalFrame.__init__ kwds[\"style\"] = wx.DEFAULT_FRAME_STYLE wx.Frame.__init__(self, *args, **kwds) # Menu Bar self.frame_terminal_menubar = wx.MenuBar() wxglade_tmp_menu = wx.Menu() wxglade_tmp_menu.Append(ID_CLEAR, \"&Clear;\", \"\", wx.ITEM_NORMAL) wxglade_tmp_menu.Append(ID_SAVEAS, \"&Save; Text As...\", \"\", wx.ITEM_NORMAL) wxglade_tmp_menu.AppendSeparator() wxglade_tmp_menu.Append(ID_TERM, \"&Terminal; Settings...\", \"\", wx.ITEM_NORMAL) wxglade_tmp_menu.AppendSeparator() wxglade_tmp_menu.Append(ID_EXIT, \"&Exit;\", \"\", wx.ITEM_NORMAL) self.frame_terminal_menubar.Append(wxglade_tmp_menu, \"&File;\") wxglade_tmp_menu = wx.Menu() wxglade_tmp_menu.Append(ID_RTS, \"RTS\", \"\", wx.ITEM_CHECK) wxglade_tmp_menu.Append(ID_DTR, \"&DTR;\", \"\", wx.ITEM_CHECK) wxglade_tmp_menu.Append(ID_SETTINGS, \"&Port; Settings...\", \"\", wx.ITEM_NORMAL) self.frame_terminal_menubar.Append(wxglade_tmp_menu, \"Serial Port\") self.SetMenuBar(self.frame_terminal_menubar) # Menu Bar end self.text_ctrl_output = wx.TextCtrl(self, -1, \"\", style=wx.TE_MULTILINE | wx.TE_READONLY) self.__set_properties() self.__do_layout() self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR) self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS) self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM) self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT) self.Bind(wx.EVT_MENU, self.OnRTS, id=ID_RTS) self.Bind(wx.EVT_MENU, self.OnDTR, id=ID_DTR) self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS) # end wxGlade self.__attach_events() # register events self.OnPortSettings(None) # call setup dialog on startup, opens port if not self.alive.isSet(): self.Close() def StartThread(self): \"\"\"Start the receiver thread\"\"\" self.thread = threading.Thread(target=self.ComPortThread) self.thread.setDaemon(1) self.alive.set() self.thread.start() self.serial.rts = True self.serial.dtr = True self.frame_terminal_menubar.Check(ID_RTS, self.serial.rts) self.frame_terminal_menubar.Check(ID_DTR, self.serial.dtr) def StopThread(self): \"\"\"Stop the receiver thread, wait until it's finished.\"\"\" if self.thread is not None: self.alive.clear() # clear alive event for thread self.thread.join() # wait until thread has finished self.thread = None def __set_properties(self): # begin wxGlade: TerminalFrame.__set_properties self.SetTitle(\"Serial Terminal\") self.SetSize((546, 383)) self.text_ctrl_output.SetFont(wx.Font(9, wx.MODERN, wx.NORMAL, wx.NORMAL, 0, \"\")) # end wxGlade def __do_layout(self): # begin wxGlade: TerminalFrame.__do_layout sizer_1 = wx.BoxSizer(wx.VERTICAL) sizer_1.Add(self.text_ctrl_output, 1, wx.EXPAND, 0) self.SetSizer(sizer_1) self.Layout() # end wxGlade def __attach_events(self): # register events at the controls self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR) self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS) self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT) self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS) self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM) self.text_ctrl_output.Bind(wx.EVT_CHAR, self.OnKey) self.Bind(EVT_SERIALRX, self.OnSerialRead) self.Bind(wx.EVT_CLOSE, self.OnClose) def OnExit(self, event): # wxGlade: TerminalFrame. \"\"\"Menu point Exit\"\"\" self.Close() def OnClose(self, event): \"\"\"Called on application shutdown.\"\"\" self.StopThread() # stop reader thread self.serial.close() # cleanup self.Destroy() # close windows, exit app def OnSaveAs(self, event): # wxGlade: TerminalFrame. \"\"\"Save contents of output window.\"\"\" with wx.FileDialog( None, \"Save Text As...\", \".\", \"\", \"Text File|*.txt|All Files|*\", wx.SAVE) as dlg: if dlg.ShowModal() == wx.ID_OK: filename = dlg.GetPath() with codecs.open(filename, 'w', encoding='utf-8') as f: text = self.text_ctrl_output.GetValue().encode(\"utf-8\") f.write(text) def OnClear(self, event): # wxGlade: TerminalFrame. \"\"\"Clear contents of output window.\"\"\" self.text_ctrl_output.Clear() def OnPortSettings(self, event): # wxGlade: TerminalFrame. \"\"\" Show the port settings dialog. The reader thread is stopped for the settings change. \"\"\" if event is not None: # will be none when called on startup self.StopThread() self.serial.close() ok = False while not ok: with wxSerialConfigDialog.SerialConfigDialog( self, -1, \"\", show=wxSerialConfigDialog.SHOW_BAUDRATE | wxSerialConfigDialog.SHOW_FORMAT | wxSerialConfigDialog.SHOW_FLOW, serial=self.serial) as dialog_serial_cfg: dialog_serial_cfg.CenterOnParent() result = dialog_serial_cfg.ShowModal() # open port if not called on startup, open it on startup and OK too if result == wx.ID_OK or event is not None: try: self.serial.open() except serial.SerialException as e: with wx.MessageDialog(self, str(e), \"Serial Port Error\", wx.OK | wx.ICON_ERROR)as dlg: dlg.ShowModal() else: self.StartThread() self.SetTitle(\"Serial Terminal on {} [{},{},{},{}{}{}]\".format( self.serial.portstr, self.serial.baudrate, self.serial.bytesize, self.serial.parity, self.serial.stopbits, ' RTS/CTS' if self.serial.rtscts else '', ' Xon/Xoff' if self.serial.xonxoff else '', )) ok = True else: # on startup, dialog aborted self.alive.clear() ok = True def OnTermSettings(self, event): # wxGlade: TerminalFrame. \"\"\"\\ Menu point Terminal Settings. Show the settings dialog with the current terminal settings. \"\"\" with TerminalSettingsDialog(self, -1, \"\", settings=self.settings) as dialog: dialog.CenterOnParent() dialog.ShowModal() def OnKey(self, event): \"\"\"\\ Key event handler. If the key is in the ASCII range, write it to the serial port. Newline handling and local echo is also done here. \"\"\" code = event.GetUnicodeKey() if code < 256: # XXX bug in some versions of wx returning only capital letters code = event.GetKeyCode() if code == 13: # is it a newline? (check for CR which is the RETURN key) if self.settings.echo: # do echo if needed self.text_ctrl_output.AppendText('\\n') if self.settings.newline == NEWLINE_CR: self.serial.write(b'\\r') # send CR elif self.settings.newline == NEWLINE_LF: self.serial.write(b'\\n') # send LF elif self.settings.newline == NEWLINE_CRLF: self.serial.write(b'\\r\\n') # send CR+LF else: char = chr(code) if self.settings.echo: # do echo if needed self.WriteText(char) self.serial.write(char.encode('UTF-8', 'replace')) # send the character def WriteText(self, text): if self.settings.unprintable: text = ''.join([c if (c >= ' ' and c != '\\x7f') else chr(0x2400 + ord(c)) for c in text]) self.text_ctrl_output.AppendText(text) def OnSerialRead(self, event): \"\"\"Handle input from the serial port.\"\"\" self.WriteText(event.data.decode('UTF-8', 'replace')) def ComPortThread(self): \"\"\"\\ Thread that handles the incoming traffic. Does the basic input transformation (newlines) and generates an SerialRxEvent \"\"\" while self.alive.isSet(): b = self.serial.read(self.serial.in_waiting or 1) if b: # newline transformation if self.settings.newline == NEWLINE_CR: b = b.replace(b'\\r', b'\\n') elif self.settings.newline == NEWLINE_LF: pass elif self.settings.newline == NEWLINE_CRLF: b = b.replace(b'\\r\\n', b'\\n') event = SerialRxEvent(self.GetId(), b) self.GetEventHandler().AddPendingEvent(event) def OnRTS(self, event): # wxGlade: TerminalFrame. self.serial.rts = event.IsChecked() def OnDTR(self, event): # wxGlade: TerminalFrame. self.serial.dtr = event.Checked() # end of class TerminalFrame class MyApp(wx.App): def OnInit(self): wx.InitAllImageHandlers() frame_terminal = TerminalFrame(None, -1, \"\") self.SetTopWindow(frame_terminal) frame_terminal.Show(True) return 1 # end of class MyApp if __name__ == \"__main__\": app = MyApp(0) app.MainLoop()","url":"http://project.mde.tw/blog/pyserialjin-du.html"},{"tags":"2016g1","title":"40323131日誌 105/06/30","text":"安裝wxpython 與 將control_3dprinter 從原本python2語法 修改成python3語法 python2語法 修改成python3語法 原本圖片的紅框處為 except IOError, x:為python2語法，將它修改成能在python3上執行 原來python2 為Queue 將它修改成queue 因為python3裡頭更改成queue了 還有要加上括號，因為python2上執行可以不需要括號起來，但是在python3上執行要加上小括號，目前找到這些語法問題 目前遇到的問題 在下圖執行的時候跑出name 'reload' is not define 上網google一下，找到了有可能是沒有reload到，所以多 import imp 可是又遇到了下圖的問題，好像是python2默認的使用的是ascii，要將它更改成utf-8，不過看起來沒有成功 想要執行一下，來確認一下是否更改成功，不過不知道為什麼又跑出name 'reload' is not define 目前卡在這邊，無法想通為什麼會變成這樣","url":"http://project.mde.tw/blog/40323131ri-zhi-1050630.html"},{"tags":"2016g1","title":"PySerial","text":"更新資料Wxpython for python3 安裝方法 https://www.youtube.com/watch?v=_djD5EHfNCw #先檢查網路 #確定python版本為python3.4 pip install -U --trusted-host wxpython.org --pre -f https://wxpython.org/Phoenix/snapshot-builds/ wxPython_Phoenix #記得打開terimal 檢查import wx #看有沒有成功 #因為要做串列傳輸Serial #要下指令安裝pyserial pip install pyserial 接下來先用範例程式測試串列傳輸 https://github.com/pyserial/pyserial/tree/master/examples # #!/usr/bin/env python # # A simple terminal application with wxPython. # # (C) 2001-2015 Chris Liechti # # SPDX-License-Identifier: BSD-3-Clause import codecs import serial import threading import wx import wxSerialConfigDialog SERIALRX = wx.NewEventType() # bind to serial data receive events EVT_SERIALRX = wx.PyEventBinder(SERIALRX, 0) class SerialRxEvent(wx.PyCommandEvent): eventType = SERIALRX def __init__(self, windowID, data): wx.PyCommandEvent.__init__(self, self.eventType, windowID) self.data = data def Clone(self): self.__class__(self.GetId(), self.data) # ---------------------------------------------------------------------- ID_CLEAR = wx.NewId() ID_SAVEAS = wx.NewId() ID_SETTINGS = wx.NewId() ID_TERM = wx.NewId() ID_EXIT = wx.NewId() ID_RTS = wx.NewId() ID_DTR = wx.NewId() NEWLINE_CR = 0 NEWLINE_LF = 1 NEWLINE_CRLF = 2 class TerminalSetup: \"\"\" Placeholder for various terminal settings. Used to pass the options to the TerminalSettingsDialog. \"\"\" def __init__(self): self.echo = False self.unprintable = False self.newline = NEWLINE_CRLF class TerminalSettingsDialog(wx.Dialog): \"\"\"Simple dialog with common terminal settings like echo, newline mode.\"\"\" def __init__(self, *args, **kwds): self.settings = kwds['settings'] del kwds['settings'] # begin wxGlade: TerminalSettingsDialog.__init__ kwds[\"style\"] = wx.DEFAULT_DIALOG_STYLE wx.Dialog.__init__(self, *args, **kwds) self.checkbox_echo = wx.CheckBox(self, -1, \"Local Echo\") self.checkbox_unprintable = wx.CheckBox(self, -1, \"Show unprintable characters\") self.radio_box_newline = wx.RadioBox(self, -1, \"Newline Handling\", choices=[\"CR only\", \"LF only\", \"CR+LF\"], majorDimension=0, style=wx.RA_SPECIFY_ROWS) self.sizer_4_staticbox = wx.StaticBox(self, -1, \"Input/Output\") self.button_ok = wx.Button(self, wx.ID_OK, \"\") self.button_cancel = wx.Button(self, wx.ID_CANCEL, \"\") self.__set_properties() self.__do_layout() # end wxGlade self.__attach_events() self.checkbox_echo.SetValue(self.settings.echo) self.checkbox_unprintable.SetValue(self.settings.unprintable) self.radio_box_newline.SetSelection(self.settings.newline) def __set_properties(self): # begin wxGlade: TerminalSettingsDialog.__set_properties self.SetTitle(\"Terminal Settings\") self.radio_box_newline.SetSelection(0) self.button_ok.SetDefault() # end wxGlade def __do_layout(self): # begin wxGlade: TerminalSettingsDialog.__do_layout sizer_2 = wx.BoxSizer(wx.VERTICAL) sizer_3 = wx.BoxSizer(wx.HORIZONTAL) self.sizer_4_staticbox.Lower() sizer_4 = wx.StaticBoxSizer(self.sizer_4_staticbox, wx.VERTICAL) sizer_4.Add(self.checkbox_echo, 0, wx.ALL, 4) sizer_4.Add(self.checkbox_unprintable, 0, wx.ALL, 4) sizer_4.Add(self.radio_box_newline, 0, 0, 0) sizer_2.Add(sizer_4, 0, wx.EXPAND, 0) sizer_3.Add(self.button_ok, 0, 0, 0) sizer_3.Add(self.button_cancel, 0, 0, 0) sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4) self.SetSizer(sizer_2) sizer_2.Fit(self) self.Layout() # end wxGlade def __attach_events(self): self.Bind(wx.EVT_BUTTON, self.OnOK, id=self.button_ok.GetId()) self.Bind(wx.EVT_BUTTON, self.OnCancel, id=self.button_cancel.GetId()) def OnOK(self, events): \"\"\"Update data wil new values and close dialog.\"\"\" self.settings.echo = self.checkbox_echo.GetValue() self.settings.unprintable = self.checkbox_unprintable.GetValue() self.settings.newline = self.radio_box_newline.GetSelection() self.EndModal(wx.ID_OK) def OnCancel(self, events): \"\"\"Do not update data but close dialog.\"\"\" self.EndModal(wx.ID_CANCEL) # end of class TerminalSettingsDialog class TerminalFrame(wx.Frame): \"\"\"Simple terminal program for wxPython\"\"\" def __init__(self, *args, **kwds): self.serial = serial.Serial() self.serial.timeout = 0.5 # make sure that the alive event can be checked from time to time self.settings = TerminalSetup() # placeholder for the settings self.thread = None self.alive = threading.Event() # begin wxGlade: TerminalFrame.__init__ kwds[\"style\"] = wx.DEFAULT_FRAME_STYLE wx.Frame.__init__(self, *args, **kwds) # Menu Bar self.frame_terminal_menubar = wx.MenuBar() wxglade_tmp_menu = wx.Menu() wxglade_tmp_menu.Append(ID_CLEAR, \"&Clear;\", \"\", wx.ITEM_NORMAL) wxglade_tmp_menu.Append(ID_SAVEAS, \"&Save; Text As...\", \"\", wx.ITEM_NORMAL) wxglade_tmp_menu.AppendSeparator() wxglade_tmp_menu.Append(ID_TERM, \"&Terminal; Settings...\", \"\", wx.ITEM_NORMAL) wxglade_tmp_menu.AppendSeparator() wxglade_tmp_menu.Append(ID_EXIT, \"&Exit;\", \"\", wx.ITEM_NORMAL) self.frame_terminal_menubar.Append(wxglade_tmp_menu, \"&File;\") wxglade_tmp_menu = wx.Menu() wxglade_tmp_menu.Append(ID_RTS, \"RTS\", \"\", wx.ITEM_CHECK) wxglade_tmp_menu.Append(ID_DTR, \"&DTR;\", \"\", wx.ITEM_CHECK) wxglade_tmp_menu.Append(ID_SETTINGS, \"&Port; Settings...\", \"\", wx.ITEM_NORMAL) self.frame_terminal_menubar.Append(wxglade_tmp_menu, \"Serial Port\") self.SetMenuBar(self.frame_terminal_menubar) # Menu Bar end self.text_ctrl_output = wx.TextCtrl(self, -1, \"\", style=wx.TE_MULTILINE | wx.TE_READONLY) self.__set_properties() self.__do_layout() self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR) self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS) self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM) self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT) self.Bind(wx.EVT_MENU, self.OnRTS, id=ID_RTS) self.Bind(wx.EVT_MENU, self.OnDTR, id=ID_DTR) self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS) # end wxGlade self.__attach_events() # register events self.OnPortSettings(None) # call setup dialog on startup, opens port if not self.alive.isSet(): self.Close() def StartThread(self): \"\"\"Start the receiver thread\"\"\" self.thread = threading.Thread(target=self.ComPortThread) self.thread.setDaemon(1) self.alive.set() self.thread.start() self.serial.rts = True self.serial.dtr = True self.frame_terminal_menubar.Check(ID_RTS, self.serial.rts) self.frame_terminal_menubar.Check(ID_DTR, self.serial.dtr) def StopThread(self): \"\"\"Stop the receiver thread, wait until it's finished.\"\"\" if self.thread is not None: self.alive.clear() # clear alive event for thread self.thread.join() # wait until thread has finished self.thread = None def __set_properties(self): # begin wxGlade: TerminalFrame.__set_properties self.SetTitle(\"Serial Terminal\") self.SetSize((546, 383)) self.text_ctrl_output.SetFont(wx.Font(9, wx.MODERN, wx.NORMAL, wx.NORMAL, 0, \"\")) # end wxGlade def __do_layout(self): # begin wxGlade: TerminalFrame.__do_layout sizer_1 = wx.BoxSizer(wx.VERTICAL) sizer_1.Add(self.text_ctrl_output, 1, wx.EXPAND, 0) self.SetSizer(sizer_1) self.Layout() # end wxGlade def __attach_events(self): # register events at the controls self.Bind(wx.EVT_MENU, self.OnClear, id=ID_CLEAR) self.Bind(wx.EVT_MENU, self.OnSaveAs, id=ID_SAVEAS) self.Bind(wx.EVT_MENU, self.OnExit, id=ID_EXIT) self.Bind(wx.EVT_MENU, self.OnPortSettings, id=ID_SETTINGS) self.Bind(wx.EVT_MENU, self.OnTermSettings, id=ID_TERM) self.text_ctrl_output.Bind(wx.EVT_CHAR, self.OnKey) self.Bind(EVT_SERIALRX, self.OnSerialRead) self.Bind(wx.EVT_CLOSE, self.OnClose) def OnExit(self, event): # wxGlade: TerminalFrame. \"\"\"Menu point Exit\"\"\" self.Close() def OnClose(self, event): \"\"\"Called on application shutdown.\"\"\" self.StopThread() # stop reader thread self.serial.close() # cleanup self.Destroy() # close windows, exit app def OnSaveAs(self, event): # wxGlade: TerminalFrame. \"\"\"Save contents of output window.\"\"\" with wx.FileDialog( None, \"Save Text As...\", \".\", \"\", \"Text File|*.txt|All Files|*\", wx.SAVE) as dlg: if dlg.ShowModal() == wx.ID_OK: filename = dlg.GetPath() with codecs.open(filename, 'w', encoding='utf-8') as f: text = self.text_ctrl_output.GetValue().encode(\"utf-8\") f.write(text) def OnClear(self, event): # wxGlade: TerminalFrame. \"\"\"Clear contents of output window.\"\"\" self.text_ctrl_output.Clear() def OnPortSettings(self, event): # wxGlade: TerminalFrame. \"\"\" Show the port settings dialog. The reader thread is stopped for the settings change. \"\"\" if event is not None: # will be none when called on startup self.StopThread() self.serial.close() ok = False while not ok: with wxSerialConfigDialog.SerialConfigDialog( self, -1, \"\", show=wxSerialConfigDialog.SHOW_BAUDRATE | wxSerialConfigDialog.SHOW_FORMAT | wxSerialConfigDialog.SHOW_FLOW, serial=self.serial) as dialog_serial_cfg: dialog_serial_cfg.CenterOnParent() result = dialog_serial_cfg.ShowModal() # open port if not called on startup, open it on startup and OK too if result == wx.ID_OK or event is not None: try: self.serial.open() except serial.SerialException as e: with wx.MessageDialog(self, str(e), \"Serial Port Error\", wx.OK | wx.ICON_ERROR)as dlg: dlg.ShowModal() else: self.StartThread() self.SetTitle(\"Serial Terminal on {} [{},{},{},{}{}{}]\".format( self.serial.portstr, self.serial.baudrate, self.serial.bytesize, self.serial.parity, self.serial.stopbits, ' RTS/CTS' if self.serial.rtscts else '', ' Xon/Xoff' if self.serial.xonxoff else '', )) ok = True else: # on startup, dialog aborted self.alive.clear() ok = True def OnTermSettings(self, event): # wxGlade: TerminalFrame. \"\"\"\\ Menu point Terminal Settings. Show the settings dialog with the current terminal settings. \"\"\" with TerminalSettingsDialog(self, -1, \"\", settings=self.settings) as dialog: dialog.CenterOnParent() dialog.ShowModal() def OnKey(self, event): \"\"\"\\ Key event handler. If the key is in the ASCII range, write it to the serial port. Newline handling and local echo is also done here. \"\"\" code = event.GetUnicodeKey() if code < 256: # XXX bug in some versions of wx returning only capital letters code = event.GetKeyCode() if code == 13: # is it a newline? (check for CR which is the RETURN key) if self.settings.echo: # do echo if needed self.text_ctrl_output.AppendText('\\n') if self.settings.newline == NEWLINE_CR: self.serial.write(b'\\r') # send CR elif self.settings.newline == NEWLINE_LF: self.serial.write(b'\\n') # send LF elif self.settings.newline == NEWLINE_CRLF: self.serial.write(b'\\r\\n') # send CR+LF else: char = unichr(code) if self.settings.echo: # do echo if needed self.WriteText(char) self.serial.write(char.encode('UTF-8', 'replace')) # send the character def WriteText(self, text): if self.settings.unprintable: text = ''.join([c if (c >= ' ' and c != '\\x7f') else unichr(0x2400 + ord(c)) for c in text]) self.text_ctrl_output.AppendText(text) def OnSerialRead(self, event): \"\"\"Handle input from the serial port.\"\"\" self.WriteText(event.data.decode('UTF-8', 'replace')) def ComPortThread(self): \"\"\"\\ Thread that handles the incoming traffic. Does the basic input transformation (newlines) and generates an SerialRxEvent \"\"\" while self.alive.isSet(): b = self.serial.read(self.serial.in_waiting or 1) if b: # newline transformation if self.settings.newline == NEWLINE_CR: b = b.replace(b'\\r', b'\\n') elif self.settings.newline == NEWLINE_LF: pass elif self.settings.newline == NEWLINE_CRLF: b = b.replace(b'\\r\\n', b'\\n') event = SerialRxEvent(self.GetId(), b) self.GetEventHandler().AddPendingEvent(event) def OnRTS(self, event): # wxGlade: TerminalFrame. self.serial.rts = event.IsChecked() def OnDTR(self, event): # wxGlade: TerminalFrame. self.serial.dtr = event.Checked() # end of class TerminalFrame class MyApp(wx.App): def OnInit(self): wx.InitAllImageHandlers() frame_terminal = TerminalFrame(None, -1, \"\") self.SetTopWindow(frame_terminal) frame_terminal.Show(True) return 1 # end of class MyApp if __name__ == \"__main__\": app = MyApp(0) app.MainLoop() wxSerialConfigDialog.py #!/usr/bin/env python # # A serial port configuration dialog for wxPython. A number of flags can # be used to configure the fields that are displayed. # # (C) 2001-2015 Chris Liechti # # SPDX-License-Identifier: BSD-3-Clause import wx import serial import serial.tools.list_ports SHOW_BAUDRATE = 1 << 0 SHOW_FORMAT = 1 << 1 SHOW_FLOW = 1 << 2 SHOW_TIMEOUT = 1 << 3 SHOW_ALL = SHOW_BAUDRATE | SHOW_FORMAT | SHOW_FLOW | SHOW_TIMEOUT class SerialConfigDialog(wx.Dialog): \"\"\"\\ Serial Port configuration dialog, to be used with pySerial 2.0+ When instantiating a class of this dialog, then the \"serial\" keyword argument is mandatory. It is a reference to a serial.Serial instance. the optional \"show\" keyword argument can be used to show/hide different settings. The default is SHOW_ALL which corresponds to SHOW_BAUDRATE|SHOW_FORMAT|SHOW_FLOW|SHOW_TIMEOUT. All constants can be found in this module (not the class). \"\"\" def __init__(self, *args, **kwds): # grab the serial keyword and remove it from the dict self.serial = kwds['serial'] del kwds['serial'] self.show = SHOW_ALL if 'show' in kwds: self.show = kwds.pop('show') # begin wxGlade: SerialConfigDialog.__init__ kwds[\"style\"] = wx.DEFAULT_DIALOG_STYLE wx.Dialog.__init__(self, *args, **kwds) self.label_2 = wx.StaticText(self, -1, \"Port\") self.choice_port = wx.Choice(self, -1, choices=[]) self.label_1 = wx.StaticText(self, -1, \"Baudrate\") self.combo_box_baudrate = wx.ComboBox(self, -1, choices=[], style=wx.CB_DROPDOWN) self.sizer_1_staticbox = wx.StaticBox(self, -1, \"Basics\") self.panel_format = wx.Panel(self, -1) self.label_3 = wx.StaticText(self.panel_format, -1, \"Data Bits\") self.choice_databits = wx.Choice(self.panel_format, -1, choices=[\"choice 1\"]) self.label_4 = wx.StaticText(self.panel_format, -1, \"Stop Bits\") self.choice_stopbits = wx.Choice(self.panel_format, -1, choices=[\"choice 1\"]) self.label_5 = wx.StaticText(self.panel_format, -1, \"Parity\") self.choice_parity = wx.Choice(self.panel_format, -1, choices=[\"choice 1\"]) self.sizer_format_staticbox = wx.StaticBox(self.panel_format, -1, \"Data Format\") self.panel_timeout = wx.Panel(self, -1) self.checkbox_timeout = wx.CheckBox(self.panel_timeout, -1, \"Use Timeout\") self.text_ctrl_timeout = wx.TextCtrl(self.panel_timeout, -1, \"\") self.label_6 = wx.StaticText(self.panel_timeout, -1, \"seconds\") self.sizer_timeout_staticbox = wx.StaticBox(self.panel_timeout, -1, \"Timeout\") self.panel_flow = wx.Panel(self, -1) self.checkbox_rtscts = wx.CheckBox(self.panel_flow, -1, \"RTS/CTS\") self.checkbox_xonxoff = wx.CheckBox(self.panel_flow, -1, \"Xon/Xoff\") self.sizer_flow_staticbox = wx.StaticBox(self.panel_flow, -1, \"Flow Control\") self.button_ok = wx.Button(self, wx.ID_OK, \"\") self.button_cancel = wx.Button(self, wx.ID_CANCEL, \"\") self.__set_properties() self.__do_layout() # end wxGlade # attach the event handlers self.__attach_events() def __set_properties(self): # begin wxGlade: SerialConfigDialog.__set_properties self.SetTitle(\"Serial Port Configuration\") self.choice_databits.SetSelection(0) self.choice_stopbits.SetSelection(0) self.choice_parity.SetSelection(0) self.text_ctrl_timeout.Enable(False) self.button_ok.SetDefault() # end wxGlade self.SetTitle(\"Serial Port Configuration\") if self.show & SHOW_TIMEOUT: self.text_ctrl_timeout.Enable(0) self.button_ok.SetDefault() if not self.show & SHOW_BAUDRATE: self.label_1.Hide() self.combo_box_baudrate.Hide() if not self.show & SHOW_FORMAT: self.panel_format.Hide() if not self.show & SHOW_TIMEOUT: self.panel_timeout.Hide() if not self.show & SHOW_FLOW: self.panel_flow.Hide() # fill in ports and select current setting preferred_index = 0 self.choice_port.Clear() self.ports = [] for n, (portname, desc, hwid) in enumerate(sorted(serial.tools.list_ports.comports())): self.choice_port.Append(u'{} - {}'.format(portname, desc)) self.ports.append(portname) if self.serial.name == portname: preferred_index = n self.choice_port.SetSelection(preferred_index) if self.show & SHOW_BAUDRATE: preferred_index = None # fill in baud rates and select current setting self.combo_box_baudrate.Clear() for n, baudrate in enumerate(self.serial.BAUDRATES): self.combo_box_baudrate.Append(str(baudrate)) if self.serial.baudrate == baudrate: preferred_index = n if preferred_index is not None: self.combo_box_baudrate.SetSelection(preferred_index) else: self.combo_box_baudrate.SetValue(u'{}'.format(self.serial.baudrate)) if self.show & SHOW_FORMAT: # fill in data bits and select current setting self.choice_databits.Clear() for n, bytesize in enumerate(self.serial.BYTESIZES): self.choice_databits.Append(str(bytesize)) if self.serial.bytesize == bytesize: index = n self.choice_databits.SetSelection(index) # fill in stop bits and select current setting self.choice_stopbits.Clear() for n, stopbits in enumerate(self.serial.STOPBITS): self.choice_stopbits.Append(str(stopbits)) if self.serial.stopbits == stopbits: index = n self.choice_stopbits.SetSelection(index) # fill in parities and select current setting self.choice_parity.Clear() for n, parity in enumerate(self.serial.PARITIES): self.choice_parity.Append(str(serial.PARITY_NAMES[parity])) if self.serial.parity == parity: index = n self.choice_parity.SetSelection(index) if self.show & SHOW_TIMEOUT: # set the timeout mode and value if self.serial.timeout is None: self.checkbox_timeout.SetValue(False) self.text_ctrl_timeout.Enable(False) else: self.checkbox_timeout.SetValue(True) self.text_ctrl_timeout.Enable(True) self.text_ctrl_timeout.SetValue(str(self.serial.timeout)) if self.show & SHOW_FLOW: # set the rtscts mode self.checkbox_rtscts.SetValue(self.serial.rtscts) # set the rtscts mode self.checkbox_xonxoff.SetValue(self.serial.xonxoff) def __do_layout(self): # begin wxGlade: SerialConfigDialog.__do_layout sizer_2 = wx.BoxSizer(wx.VERTICAL) sizer_3 = wx.BoxSizer(wx.HORIZONTAL) self.sizer_flow_staticbox.Lower() sizer_flow = wx.StaticBoxSizer(self.sizer_flow_staticbox, wx.HORIZONTAL) self.sizer_timeout_staticbox.Lower() sizer_timeout = wx.StaticBoxSizer(self.sizer_timeout_staticbox, wx.HORIZONTAL) self.sizer_format_staticbox.Lower() sizer_format = wx.StaticBoxSizer(self.sizer_format_staticbox, wx.VERTICAL) grid_sizer_1 = wx.FlexGridSizer(3, 2, 0, 0) self.sizer_1_staticbox.Lower() sizer_1 = wx.StaticBoxSizer(self.sizer_1_staticbox, wx.VERTICAL) sizer_basics = wx.FlexGridSizer(3, 2, 0, 0) sizer_basics.Add(self.label_2, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_basics.Add(self.choice_port, 0, wx.EXPAND, 0) sizer_basics.Add(self.label_1, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_basics.Add(self.combo_box_baudrate, 0, wx.EXPAND, 0) sizer_basics.AddGrowableCol(1) sizer_1.Add(sizer_basics, 0, wx.EXPAND, 0) sizer_2.Add(sizer_1, 0, wx.EXPAND, 0) grid_sizer_1.Add(self.label_3, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) grid_sizer_1.Add(self.choice_databits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0) grid_sizer_1.Add(self.label_4, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) grid_sizer_1.Add(self.choice_stopbits, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0) grid_sizer_1.Add(self.label_5, 1, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) grid_sizer_1.Add(self.choice_parity, 1, wx.EXPAND | wx.ALIGN_RIGHT, 0) sizer_format.Add(grid_sizer_1, 1, wx.EXPAND, 0) self.panel_format.SetSizer(sizer_format) sizer_2.Add(self.panel_format, 0, wx.EXPAND, 0) sizer_timeout.Add(self.checkbox_timeout, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_timeout.Add(self.text_ctrl_timeout, 0, 0, 0) sizer_timeout.Add(self.label_6, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) self.panel_timeout.SetSizer(sizer_timeout) sizer_2.Add(self.panel_timeout, 0, wx.EXPAND, 0) sizer_flow.Add(self.checkbox_rtscts, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_flow.Add(self.checkbox_xonxoff, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 4) sizer_flow.Add((10, 10), 1, wx.EXPAND, 0) self.panel_flow.SetSizer(sizer_flow) sizer_2.Add(self.panel_flow, 0, wx.EXPAND, 0) sizer_3.Add(self.button_ok, 0, 0, 0) sizer_3.Add(self.button_cancel, 0, 0, 0) sizer_2.Add(sizer_3, 0, wx.ALL | wx.ALIGN_RIGHT, 4) self.SetSizer(sizer_2) sizer_2.Fit(self) self.Layout() # end wxGlade def __attach_events(self): wx.EVT_BUTTON(self, self.button_ok.GetId(), self.OnOK) wx.EVT_BUTTON(self, self.button_cancel.GetId(), self.OnCancel) if self.show & SHOW_TIMEOUT: wx.EVT_CHECKBOX(self, self.checkbox_timeout.GetId(), self.OnTimeout) def OnOK(self, events): success = True self.serial.port = self.ports[self.choice_port.GetSelection()] if self.show & SHOW_BAUDRATE: try: b = int(self.combo_box_baudrate.GetValue()) except ValueError: with wx.MessageDialog( self, 'Baudrate must be a numeric value', 'Value Error', wx.OK | wx.ICON_ERROR) as dlg: dlg.ShowModal() success = False else: self.serial.baudrate = b if self.show & SHOW_FORMAT: self.serial.bytesize = self.serial.BYTESIZES[self.choice_databits.GetSelection()] self.serial.stopbits = self.serial.STOPBITS[self.choice_stopbits.GetSelection()] self.serial.parity = self.serial.PARITIES[self.choice_parity.GetSelection()] if self.show & SHOW_FLOW: self.serial.rtscts = self.checkbox_rtscts.GetValue() self.serial.xonxoff = self.checkbox_xonxoff.GetValue() if self.show & SHOW_TIMEOUT: if self.checkbox_timeout.GetValue(): try: self.serial.timeout = float(self.text_ctrl_timeout.GetValue()) except ValueError: with wx.MessageDialog( self, 'Timeout must be a numeric value', 'Value Error', wx.OK | wx.ICON_ERROR) as dlg: dlg.ShowModal() success = False else: self.serial.timeout = None if success: self.EndModal(wx.ID_OK) def OnCancel(self, events): self.EndModal(wx.ID_CANCEL) def OnTimeout(self, events): if self.checkbox_timeout.GetValue(): self.text_ctrl_timeout.Enable(True) else: self.text_ctrl_timeout.Enable(False) # end of class SerialConfigDialog class MyApp(wx.App): \"\"\"Test code\"\"\" def OnInit(self): wx.InitAllImageHandlers() ser = serial.Serial() print(ser) # loop until cancel is pressed, old values are used as start for the next run # show the different views, one after the other # value are kept. for flags in (SHOW_BAUDRATE, SHOW_FLOW, SHOW_FORMAT, SHOW_TIMEOUT, SHOW_ALL): dialog_serial_cfg = SerialConfigDialog(None, -1, \"\", serial=ser, show=flags) self.SetTopWindow(dialog_serial_cfg) result = dialog_serial_cfg.ShowModal() print(ser) if result != wx.ID_OK: break # the user can play around with the values, CANCEL aborts the loop while True: dialog_serial_cfg = SerialConfigDialog(None, -1, \"\", serial=ser) self.SetTopWindow(dialog_serial_cfg) result = dialog_serial_cfg.ShowModal() print(ser) if result != wx.ID_OK: break return 0 # end of class MyApp if __name__ == \"__main__\": app = MyApp(0) app.MainLoop()","url":"http://project.mde.tw/blog/pyserial.html"},{"tags":"2016bg2","title":"40323250日誌 - 105/06/29","text":"暑期第一個禮拜的 星期三 進度 目前組了兩個版本，一個是簡易版，沒有多餘零件，另一個是完整版，有畫的零件都組上去了，如圖: 以下是零件 以下是v-rep拆解後的截圖 簡易版 完整版 明天應該就可以開始測試模擬了。 Onshape零件及兩個stl檔案都放在users/g2_files目錄下，歡迎取用。","url":"http://project.mde.tw/blog/40323250ri-zhi-1050629.html"},{"tags":"2016bg2","title":"40323250日誌 - 105/06/28","text":"暑期第一個禮拜的 星期二 目前組合進度 目前遇到的狀況 我把滑塊設定為slider，能在滑軌上做相對移動，但是在拉到一半的時候，Onshape整個圖形就消失了，然後點選左方的zoom to section還是能顯示，但呈現以下狀態 滑鼠選轉及縮放也跟著出問題，點選右方試圖方塊圖又會不見，只能重新再組一次。","url":"http://project.mde.tw/blog/40323250ri-zhi-1050628.html"},{"tags":"2016g1","title":"40323131日誌 105/06/28","text":"研讀Octopi的設定檔 設定檔位置位在 /Octoprint/src/octoprint/setting.py 設定檔位置位在 /Octoprint/src/octoprint/static/less/octoprint.less 目前遇到的問題 host位置顯示在0.0.0.0:5000 可是網頁開起來無法顯示","url":"http://project.mde.tw/blog/40323131ri-zhi-1050628.html"},{"tags":"2016g1","title":"40323143 -  日誌  105年6月28日","text":"在Onshape上充實零件庫 日記: 今天將所有機械手臂零件全部合進零件庫，並用零件庫的零件再組合出一個組圖。今天沒有設定新的變數，未來將會新增有關手臂長度的零件參數，並由實際使用需求及感測器尺寸調整參數。 備註: 1.夾頭動力傳輸由原先畫的6齒圓齒輪改成25齒的正齒輪 6/28零件庫 組合圖","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-6yue-28ri.html"},{"tags":"2016g1","title":"Octopi測試與實作","text":"設定使用octopi與實作 octopi走乙太網路線進行控制以及連線 實際測試的照片以及需要用到的方法","url":"http://project.mde.tw/blog/octopice-shi-yu-shi-zuo.html"},{"tags":"2016g1","title":"ubuntu IPV4 IPV6 使用教學","text":"關於IPV4 IPV6設定 #先檢查網路 $ ifconfig #修改/etc/network/interface的檔案 # interfaces(5) file used by ifup(8) and ifdown(8) auto lo iface lo inet loopback sudo eth0 iface eth0 inet static address 140.130.17.105 netmask 255.255.255.0 network 140.130.17.0 broadcast 140.130.17.255 gateway 140.130.17.254 # dns-* options are implemented by the resolvconf package, if $ dns-nameservers 140.130.1.2 140.130.17.3 168.95.1.1 dns-search mde.nfu.edu.tw #老師的地址3004 #從新啟動 可以到IPV6的網站測試是否可以連線 試用ubuntu系統改成IPV6和IPV4使用，並測試速度的使用上的問題，主要是在沒有IPV6的網站沒辦法連上去，這部份可能需要依靠proxy進行代理伺服器","url":"http://project.mde.tw/blog/ubuntu-ipv4-ipv6-shi-yong-jiao-xue.html"},{"tags":"2016g1","title":"40323143 -  日誌  105年6月27日","text":"在Onshape上建立零件庫 日記: 今天將個人Onshape上的機械手臂部分零件合進零件庫，設定六個參數，分別是motor_fixhole , motor_x , motor_y , motor_z , suan_pan , degore 六個參數，motor_fixhole為設定馬達固定孔大小，motor_x , motor_y , motor_z為設定馬達的長寬高， suan_pan為設定旋盤的大小，大小為motor_y的1.7倍\u0007，degore為設定底座的直徑，大小為3倍的suan_pan。 合進零件庫的零件 參數設定","url":"http://project.mde.tw/blog/40323143-ri-zhi-105nian-6yue-27ri.html"},{"tags":"2016g1","title":"樹梅派指令表和使用","text":"找到的些許文章和探討 在Octoprint底下有個資料夾 底層有些方法包括模組以及設定檔 linux指令: cp mv 指令再raspberry pi 要熟悉，因為在搬移檔案以及設定檔案，會常使用到，以及設定需要的檔案，像是網路的方法，以及未來可能要用到的USB掛載傳輸資料或者使用 #先檢查自己找到的usb數量 $ sudo fdisk -l #...省略.... #Device Boot Start End Sectors Size Id Type #/dev/mmcblk0p1 8192 137215 129024 63M c W95 FAT32 (LBA) #/dev/mmcblk0p2 137216 31116287 30979072 14.8G 83 Linux $ sudo mkdir /media/usbstick $ sudo chown pi:pi /media/usbstick #手動掛載 $ sudo mount -t vfat -o uid=pi,gid=pi /dev/sda1 /media/usbstick #就可以進行存取 #要拔除時要下指令 $ sudo umount /media/usbstick 在這些設定檔中使用到的可以更改圖片或者是把程式碼拿出來理解目前解讀進度: 1.再octoprint中有將各模組拆開來，近日把python的設定看完，可能會接近5%的進度 2.圖片用到的部分，可能要從新Make(command)才可以用 待完成部分: 1.javascript 2.往後寫出一套for our flask.py 3.plugin部分","url":"http://project.mde.tw/blog/shu-mei-pai-zhi-ling-biao-he-shi-yong.html"},{"tags":"2016bg2","title":"Summer Plan","text":"Summer project 1.畫3D Printer (V-rep ,Onshape) 2.實驗室網站介面 3.Octopi ,機械手臂 4.OpenCV 5.RGA演算 6.認證主機(Virtual Box) 7.Proxy 8.報告(拍照 ,內容整理) 9.找碩班教授 暑期人數 : 七月:第一組3人 ,第二組4人 八月:第一組3人 ,第二組4人 ,第三組1人 You can't see me","url":"http://project.mde.tw/blog/summer-plan.html"},{"tags":"2016bg2","title":"OpenCv範例執行","text":"OpenCv example with python test 實作系統Ubuntu 14.04 以及 老師整合的檔案 範例網址1. 使用到的圖片 程式碼 import numpy as np import cv2 img = cv2.imread('messi.jpg',0) cv2.imshow('image',img) k = cv2.waitKey(0) if k == 27: # wait for ESC key to exit cv2.destroyAllWindows() elif k == ord('s'): # wait for 's' key to save and exit cv2.imwrite('messigray.png',img) cv2.destroyAllWindows() 執行結果 範例網址2. 程式碼 import numpy as np import cv2 cap = cv2.VideoCapture(0) while(True): # Capture frame-by-frame ret, frame = cap.read() # Our operations on the frame come here gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # Display the resulting frame cv2.imshow('frame',gray) if cv2.waitKey(1) & 0xFF == ord('q'): break When everything done, release the capture cap.release() cv2.destroyAllWindows() 執行結果 範例網址3.(同上) 程式碼 import numpy as np import cv2 cap = cv2.VideoCapture(0) Define the codec and create VideoWriter object fourcc = cv2.VideoWriter_fourcc(*'XVID') out = cv2.VideoWriter('output.avi',fourcc, 20.0, (640,480)) while(cap.isOpened()): ret, frame = cap.read() if ret==True: frame = cv2.flip(frame,1) # write the flipped frame out.write(frame) cv2.imshow('frame',frame) if cv2.waitKey(1) & 0xFF == ord('q'): break else: break Release everything if job is finished cap.release() out.release() cv2.destroyAllWindows() 執行結果 得到檔案名稱為output的avi影片檔","url":"http://project.mde.tw/blog/opencvfan-li-zhi-xing.html"},{"tags":"Tutorial","title":"yen - RGA 基因演算法","text":"RGA 為 Real-coded Genetic Algorithm, 也就是實數編碼基因演算法, 以下為平面四連桿機構, 令其移動桿三角形頂點通過特定的 10 個座標點的尺寸合成運算. # https://github.com/flukeskywalker/PyRGA # 原始程式為 Python2 修改為 Python3 格式 # 除了原先的最大化適應值外, 增加最小化方法設定 import numpy as np import random from math import * # 請注意各代族群數必須為 4 的倍數 class GA: # popsize must be multiple of 4 def __init__(self, obj, dim, popsize, ngen, pc, pm, etac, etam, min): self.EPSILON = 10e-6 self.INFINITY = 10e6 self.pop = [] self.fits = [] self.obj = obj self.dim = dim self.popsize = popsize self.ngen = ngen self.pc = pc self.pm = pm self.etac = etac self.etam = etam # min = 1 表最小化, min = -1 表最大化 self.min = min self.RIGID = 0 self.lowb = -self.INFINITY*np.ones(self.dim) self.highb = self.INFINITY*np.ones(self.dim) self.tourneylist = range(0, self.popsize) self.tourneysize = 2 # works for 2 for now self.bestmemyet = np.zeros(self.dim) # 若是求最大值 if self.min == -1: self.bestfityet = -np.inf else: # 若是求最小值 self.bestfityet = np.inf self.pop_init() def pop_init(self): self.pop = [np.random.rand(self.dim) for _ in range(self.popsize)] for member in self.pop: for i in range(self.dim): member[i] = self.lowb[i] + member[i]*(self.highb[i]-self.lowb[i]) self.fits = [self.obj(member) for member in self.pop] #self.pop_print() return def setbounds(self, lows, highs): for i in range(self.dim): self.lowb[i] = lows[i] self.highb[i] = highs[i] self.pop_init() return def run(self): for gen in range(self.ngen): print(\"Generation \", gen) self.pop = self.getnewpop() self.eval_pop() #self.pop_print() return [self.bestmemyet, self.bestfityet] def getnewpop(self): newpop = [] #self.tourneylist = range(0, self.popsize) random.shuffle(list(self.tourneylist)) self.tourneypos = 0 for i in range(0, self.popsize, 2): [p1, p2] = self.getparents() #return parents, not just indices [c1, c2] = self.xover(p1, p2) #return children, not just indices c1 = self.mutate(c1) c2 = self.mutate(c2) newpop.append(c1) newpop.append(c2) return newpop def getparents(self): if (self.popsize - self.tourneypos) < self.tourneysize: random.shuffle(list(self.tourneylist)) self.tourneypos = 0 if self.min == -1: if (self.fits[self.tourneylist[self.tourneypos]]>self.fits[self.tourneylist[self.tourneypos+1]]): p1 = self.pop[self.tourneylist[self.tourneypos]] else: p1 = self.pop[self.tourneylist[self.tourneypos+1]] else: if (self.fits[self.tourneylist[self.tourneypos]] self.fits[self.tourneylist[self.tourneypos+1]]): p2 = self.pop[self.tourneylist[self.tourneypos]] else: p2 = self.pop[self.tourneylist[self.tourneypos+1]] else: if (self.fits[self.tourneylist[self.tourneypos]] p2: p1, p2 = p2, p1 # p1 must be smaller mean = (p1+p2)*0.5 diff = (p2-p1) dist = max(min(p1-low, high-p2), 0) if (self.RIGID and diff > self.EPSILON): alpha = 1.0 + (2.0*dist/diff) umax = 1.0 - (0.5/pow(alpha, (self.etac+1.0))) seed = umax*random.random() else: seed = random.random() beta = self.getbeta(seed) if (abs(diff*beta) > self.INFINITY): beta = self.INFINITY/diff c2 = mean + beta*0.5*diff c1 = mean - beta*0.5*diff c1 = max(low, min(c1, high)) c2 = max(low, min(c2, high)) return [c1, c2] def getbeta(self, seed): if (1 - seed) < self.EPSILON: seed = 1 - self.EPSILON seed = max(0.0, seed) if seed < 0.5: beta = pow(2.0*seed, (1.0/(self.etac+1.0))) else: beta = pow((0.5/(1.0-seed)), (1.0/(self.etac+1.0))) return beta def getdelta(self, seed, delta_low, delta_high): if seed >= 1.0 - (self.EPSILON/1e3): return delta_high if seed <= (self.EPSILON/1e3): return delta_low if seed <= 0.5: dummy = 2.0*seed + (1.0 - 2.0*seed)*pow((1+delta_low), (self.etam+1.0)) delta = pow(dummy, (1.0/(self.etam+1.0))) - 1.0 else: dummy = 2.0*(1.0 - seed) + 2.0*(seed - 0.5)*pow((1-delta_high), (self.etam+1.0)) delta = 1.0 - pow(dummy, (1.0/(self.etam+1.0))) return delta def mutate(self, member): mut_member = np.zeros_like(member) for i in range(member.size): low = self.lowb[i] high = self.highb[i] if random.random() <= self.pm: # pm is simply the prob of a variable to mutate if self.RIGID: value = member[i] delta_low = max((low-value)/(high-low), -1.0) delta_high = min((high-value)/(high-low), 1.0) if abs(delta_low) self.bestfityet: # 則將此最大適應值指為目前為止最佳適應值 self.bestfityet = bestfitness # 並且將最佳族群成員指向目前最佳成員 self.bestmemyet = bestmember else: if bestfitness < self.bestfityet: self.bestfityet = bestfitness self.bestmemyet = bestmember print(\"Current best: \", bestfitness, \"Best yet: \", self.bestfityet) def pop_print(self): for i in range(self.popsize): print(self.pop[i], self.fits[i]) return # 若單獨存在則需導入 GA 所有方法 #import GA #from GA import * import numpy as np def square(x): term1 = (x[0]*x[0]+x[1]-11.0)*(x[0]*x[0]+x[1]-11.0) term2 = (x[0]+x[1]*x[1]- 7.0)*(x[0]+x[1]*x[1]- 7.0) term3 = term1+term2 return term3 # 最大化體積題目 def volume(x): surface = 80.0 z = (surface-x[0]*x[1])/(2.0*(x[0]+x[1])) volume = x[0]*x[1]*z return volume def miniex1(x): '''Minimizing Beale's function (optimal value f(3, 0.5) = 0): ga=GA(miniex1, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.3, etac=2, etam=100, min=1) ga.setbounds(np.zeros(10), 10*np.ones(10)) ''' term1 = 1.5 - x[0] + x[0]*x[1] term2 = 2.25 - x[0] + x[0]*x[1]*x[1] term3 = 2.625 - x[0] + x[0]*x[1]*x[1]*x[1] return term1*term1 + term2*term2 + term3*term3 def miniex2(x): '''Schaffer function #2. Minimium at (0,0), equal to 0 ga=GA(miniex2, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1) ga.setbounds(np.zeros(10), 10*np.ones(10)) ''' return 0.5 + (pow(sin(x[0]*x[0]-x[1]*x[1]), 2) - 0.5)/pow(1+0.001*(x[0]*x[0]+x[1]*x[1]), 2) ''' 開始四連桿運算 ''' class Point(object): '''Creates a point on a coordinate plane with values x and y.''' def __init__(self, x, y): '''Defines x and y variables''' self.x = x self.y = y def triangletip_coord(x0, y0, R0, R1, x1, y1, localt): mech_loop = -1 tip_coord = Point(0,0) if (localt >= 0 and localt < pi): # 計算 tip 點的 x 座標 tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0 # 計算 tip 點的 y 座標 tip_coord.y = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0 else: # 計算 tip 點的 x 座標 tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0 # 計算 tip 點的 y 座標 tip_coord.y = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0 return tip_coord def distance(x0, y0, x1, y1): return sqrt(pow((x1-x0),2) + pow((y1-y0),2)) def rr(L1, dd, theta): return sqrt(L1*L1+dd*dd-2*L1*dd*cos(theta)) # input_angles = [] 也就是必須為 list 且各樹為 NUM_OF_POINTS def mechanism(x0, y0, x1, y1, L1, L2, L3, L5, L6, input_angles): ''' mechanism(0,0,10,0,5,20,10,10,10,input_angles) x0 = 0.0; y0 = 0.0; x1 = 10.0; y1 = 0.0; L1 = 5.0; L2 = 10; L3 = 10; L5 = 10; L6 = 10; ''' link1_tip = Point(0,0) link2_tip = Point(0,0) output_points = list() degree = pi/180. NUM_OF_POINTS = 5 dd_length = distance(x0, y0, x1, y1) # 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式 angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5)); for i in range(NUM_OF_POINTS): angle = input_angles[i]*degree rr_length = rr(L1, dd_length, angle) # 第一次三角形疊代 link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle) #print(angle, rr_length, link1_tip.x, link1_tip.y) # 第二次三角形疊代 # 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式 angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length)) link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2) # 第三次三角形疊代 (改為以 finaltip_coord() 取值, 而非第三次疊代 ''' triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3); output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3); ''' # 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負 output_points.append(finaltip_coord(link1_tip, link2_tip, L5, L6)) return output_points def finaltip_coord(tip1_coord, tip2_coord, r1, r2): tip3_coord = Point(0,0) length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2)) length4 = sqrt(pow(r1,2) + pow(r2,2)) theta3 = acos((tip2_coord.x - tip1_coord.x) / length3) theta4 = acos(r1/length4) tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4) tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4) return tip3_coord # 誤差函式 def error_function(output_points, target_points): NUM_OF_POINTS = 5 error = 0 for i in range(NUM_OF_POINTS): error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y)) return error # 組成機構的變數個樹 9 + 通過點數所對應的角度值, 若通過 5 點則共有 14 個變數 # mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points); def fourbar(x): PENALITY = 1000 NUM_OF_POINTS = 10 # x0 與 x1 點位於 -50 與 50 中間, 0, 1, 2, 3 for i in range(4): if(x[i] < -50 or x[i] > 50): return PENALITY # 三個連桿值, 一定要為正, 4, 5, 6, for i in range(4, 7): if(x[i] < 0 or x[i] >50): return PENALITY # L5 L6 可以為 0 或負值, 7, 8 for i in range(7, 9): if(x[i] < -50 or x[i] > 50): return PENALITY # 角度值一定要大於 0 for i in range(NUM_OF_POINTS): if(x[9+i] < 0): return PENALITY result = 0 target_points = list() output_points = list() input_angles = list() # 定義四連桿關鍵點所要通過的點 p1 = Point(1, 1) p2 = Point(2, 2) p3 = Point(3, 3) p4 = Point(4, 4) p5 = Point(5, 5) p6 = Point(6, 6) p7 = Point(7, 7) p8 = Point(8, 8) p9 = Point(9, 9) p10 = Point(10, 10) target_points = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10] for i in range(9, 9+NUM_OF_POINTS): input_angles.append(x[i]) # 這裡要加入查驗各參數是否符合四連桿組成條件 try: output_points = mechanism(x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],input_angles) except: return PENALITY result = error_function(output_points, target_points) return result #ga=GA(square, dim=2, popsize=40, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=-1) # min = -1 表示要最大化適應方程式的值, 若 min = 1 表示要最小化 #ga=GA(volume, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.1, etac=2, etam=100, min=-1) # 請注意 popsize 必須為 4 的倍數 #ga=GA(miniex1, dim=2, popsize=12, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1) ga=GA(fourbar, dim=19, popsize=120000, ngen=10000, pc=0.9, pm=0.5, etac=2, etam=100, min=1) #ga.setbounds(np.zeros(10), 10*np.ones(10)) #ga.setbounds(-10*np.ones(10), 10*np.ones(10)) ga.setbounds(-50*np.ones(20), 50*np.ones(20)) #ga.pop_init() print(ga.run()) 利用 C 與 Differential Evolution 解上述相同問題的原始碼: // 必須在演算過程中, 設法限制各變數的上下限!!! 否則演化非常容易發散?? /*************************************************************** ** ** ** D I F F E R E N T I A L E V O L U T I O N ** ** ** ** Program: de.c ** ** Version: 3.6 ** ** ** ** Authors: Dr. Rainer Storn ** ** c/o ICSI, 1947 Center Street, Suite 600 ** ** Berkeley, CA 94707 ** ** Tel.: 510-642-4274 (extension 192) ** ** Fax.: 510-643-7684 ** ** E-mail: storn@icsi.berkeley.edu ** ** WWW: http://http.icsi.berkeley.edu/~storn/ ** ** on leave from ** ** Siemens AG, ZFE T SN 2, Otto-Hahn Ring 6 ** ** D-81739 Muenchen, Germany ** ** Tel: 636-40502 ** ** Fax: 636-44577 ** ** E-mail: rainer.storn@zfe.siemens.de ** ** ** ** Kenneth Price ** ** 836 Owl Circle ** ** Vacaville, CA 95687 ** ** E-mail: kprice@solano.community.net ** ** ** ** This program implements some variants of Differential ** ** Evolution (DE) as described in part in the techreport ** ** tr-95-012.ps of ICSI. You can get this report either via ** ** ftp.icsi.berkeley.edu/pub/techreports/1995/tr-95-012.ps.Z ** ** or via WWW: http://http.icsi.berkeley.edu/~storn/litera.html* ** A more extended version of tr-95-012.ps is submitted for ** ** publication in the Journal Evolutionary Computation. ** ** ** ** You may use this program for any purpose, give it to any ** ** person or change it according to your needs as long as you ** ** are referring to Rainer Storn and Ken Price as the origi- ** ** nators of the the DE idea. ** ** If you have questions concerning DE feel free to contact ** ** us. We also will be happy to know about your experiences ** ** with DE and your suggestions of improvement. ** ** ** ***************************************************************/ /**H*O*C************************************************************** ** ** ** No.!Version! Date ! Request ! Modification ! Author ** ** ---+-------+------+---------+---------------------------+------- ** ** 1 + 3.1 +5/18/95+ - + strategy DE/rand-to-best/1+ Storn ** ** + + + + included + ** ** 1 + 3.2 +6/06/95+C.Fleiner+ change loops into memcpy + Storn ** ** 2 + 3.2 +6/06/95+ - + update comments + Storn ** ** 1 + 3.3 +6/15/95+ K.Price + strategy DE/best/2 incl. + Storn ** ** 2 + 3.3 +6/16/95+ - + comments and beautifying + Storn ** ** 3 + 3.3 +7/13/95+ - + upper and lower bound for + Storn ** ** + + + + initialization + ** ** 1 + 3.4 +2/12/96+ - + increased printout prec. + Storn ** ** 1 + 3.5 +5/28/96+ - + strategies revisited + Storn ** ** 2 + 3.5 +5/28/96+ - + strategy DE/rand/2 incl. + Storn ** ** 1 + 3.6 +8/06/96+ K.Price + Binomial Crossover added + Storn ** ** 2 + 3.6 +9/30/96+ K.Price + cost variance output + Storn ** ** 3 + 3.6 +9/30/96+ - + alternative to ASSIGND + Storn ** ** 4 + 3.6 +10/1/96+ - + variable checking inserted + Storn ** ** 5 + 3.6 +10/1/96+ - + strategy indic. improved + Storn ** ** ** ***H*O*C*E***********************************************************/ #include \"stdio.h\" #include \"stdlib.h\" #include \"math.h\" #include \"memory.h\" #include <time.h> // 最大族群數, NP #define MAXPOP 5000 // 最大向量維度, D #define MAXDIM 35 #define MAXIMAPROBLEM 0 #define PENALITY 1000 /*------Constants for rnd_uni()--------------------------------------------*/ #define IM1 2147483563 #define IM2 2147483399 #define AM (1.0/IM1) #define IMM1 (IM1-1) #define IA1 40014 #define IA2 40692 #define IQ1 53668 #define IQ2 52774 #define IR1 12211 #define IR2 3791 #define NTAB 32 #define NDIV (1+IMM1/NTAB) #define EPS 1.2e-7 #define RNMX (1.0-EPS) // 與機構合成相關的常數定義 #define PI 3.1415926 #define degree PI/180.0 #define mech_loop -1 #define NUM_OF_POINTS 10 /*------------------------Macros----------------------------------------*/ /*#define ASSIGND(a,b) memcpy((a),(b),sizeof(double)*D) */ /* quick copy by Claudio */ /* works only for small */ /* arrays, but is faster.*/ /*------------------------Globals---------------------------------------*/ long rnd_uni_init; /* serves as a seed for rnd_uni() */ double c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM]; double (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM]; /*---------Function declarations----------------------------------------*/ void assignd(int D, double a[], double b[]); double rnd_uni(long *idum); /* uniform pseudo random number generator */ double extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */ // 與機構合成相關的函式宣告 double distance(double x0, double y0, double x1, double y1); double rr(double L1, double dd, double theta); struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt); void mechanism(double x0, double y0, double x1, double y1, double L1, double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]); double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]); struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2); /*---------Function definitions-----------------------------------------*/ // 指定向量 b 為 a void assignd(int D, double a[], double b[]) /**C*F**************************************************************** ** ** ** Assigns D-dimensional vector b to vector a. ** ** You might encounter problems with the macro ASSIGND on some ** ** machines. If yes, better use this function although it's slower. ** ** ** ***C*F*E*************************************************************/ { int j; for (j=0; j<D; j++) { a[j] = b[j]; } } // 產生 0 ~ 1 間的亂數 double rnd_uni(long *idum) /**C*F**************************************************************** ** ** ** SRC-FUNCTION :rnd_uni() ** ** LONG_NAME :random_uniform ** ** AUTHOR :(see below) ** ** ** ** DESCRIPTION :rnd_uni() generates an equally distributed ran- ** ** dom number in the interval [0,1]. For further ** ** reference see Press, W.H. et alii, Numerical ** ** Recipes in C, Cambridge University Press, 1992. ** ** ** ** FUNCTIONS :none ** ** ** ** GLOBALS :none ** ** ** ** PARAMETERS :*idum serves as a seed value ** ** ** ** PRECONDITIONS :*idum must be negative on the first call. ** ** ** ** POSTCONDITIONS :*idum will be changed ** ** ** ***C*F*E*************************************************************/ { long j; long k; static long idum2=123456789; static long iy=0; static long iv[NTAB]; double temp; if (*idum <= 0) { if (-(*idum) < 1) *idum=1; else *idum = -(*idum); idum2=(*idum); for (j=NTAB+7;j>=0;j--) { k=(*idum)/IQ1; *idum=IA1*(*idum-k*IQ1)-k*IR1; if (*idum < 0) *idum += IM1; if (j < NTAB) iv[j] = *idum; } iy=iv[0]; } k=(*idum)/IQ1; *idum=IA1*(*idum-k*IQ1)-k*IR1; if (*idum < 0) *idum += IM1; k=idum2/IQ2; idum2=IA2*(idum2-k*IQ2)-k*IR2; if (idum2 < 0) idum2 += IM2; j=iy/NDIV; iy=iv[j]-idum2; iv[j] = *idum; if (iy < 1) iy += IMM1; if ((temp=AM*iy) > RNMX) return RNMX; else return temp; }/*------End of rnd_uni()--------------------------*/ // 將上下限轉為全域變數 double inibound_h; /* upper parameter bound */ double inibound_l; /* lower parameter bound */ // 與機構合成相關的全域變數 // 宣告一個座標結構 struct Coord { double x; double y; // 這裡保留 double z; }; main(int argc, char *argv[]) /**C*F**************************************************************** ** ** ** SRC-FUNCTION :main() ** ** LONG_NAME :main program ** ** AUTHOR :Rainer Storn, Kenneth Price ** ** ** ** DESCRIPTION :driver program for differential evolution. ** ** ** ** FUNCTIONS :rnd_uni(), evaluate(), printf(), fprintf(), ** ** fopen(), fclose(), fscanf(). ** ** ** ** GLOBALS :rnd_uni_init input variable for rnd_uni() ** ** ** ** PARAMETERS :argc #arguments = 3 ** ** argv pointer to argument strings ** ** ** ** PRECONDITIONS :main must be called with three parameters ** ** e.g. like de1 <input-file> <output-file>, if ** ** the executable file is called de1. ** ** The input file must contain valid inputs accor- ** ** ding to the fscanf() section of main(). ** ** ** ** POSTCONDITIONS :main() produces consecutive console outputs and ** ** writes the final results in an output file if ** ** the program terminates without an error. ** ** ** ***C*F*E*************************************************************/ { char chr; /* y/n choice variable */ char *strat[] = /* strategy-indicator */ { \"\", \"DE/best/1/exp\", \"DE/rand/1/exp\", \"DE/rand-to-best/1/exp\", \"DE/best/2/exp\", \"DE/rand/2/exp\", \"DE/best/1/bin\", \"DE/rand/1/bin\", \"DE/rand-to-best/1/bin\", \"DE/best/2/bin\", \"DE/rand/2/bin\" }; int i, j, L, n; /* counting variables */ int r1, r2, r3, r4; /* placeholders for random indexes */ int r5; /* placeholders for random indexes */ int D; /* Dimension of parameter vector */ int NP; /* number of population members */ int imin; /* index to member with lowest energy */ int refresh; /* refresh rate of screen output */ int strategy; /* choice parameter for screen output */ int gen, genmax, seed; long nfeval; /* number of function evaluations */ double trial_cost; /* buffer variable */ // 將上下限轉為全域變數, 可能要根據各變數加以設定 //double inibound_h; /* upper parameter bound */ //double inibound_l; /* lower parameter bound */ double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members */ double cost[MAXPOP]; /* obj. funct. values */ double cvar; /* computes the cost variance */ double cmean; /* mean cost */ double F,CR; /* control variables of DE */ double cmin; /* help variables */ FILE *fpin_ptr; FILE *fpout_ptr; // 計算執行過程所需時間起點, 需要導入 time.h clock_t start = clock(); /*------Initializations----------------------------*/ //if (argc != 3) /* number of arguments */ //{ //printf(\"\\nUsage : de <input-file> <output-file>\\n\"); //exit(1); //} // 將結果寫入 out.dat fpout_ptr = fopen(\"out.dat\",\"w\"); /* open output file for reading, */ /* to see whether it already exists */ /* if ( fpout_ptr != NULL ) { printf(\"\\nOutput file %s does already exist, \\ntype y if you \",argv[2]); printf(\"want to overwrite it, \\nanything else if you want to exit.\\n\"); chr = (char)getchar(); if ((chr != 'y') && (chr != 'Y')) { exit(1); } fclose(fpout_ptr); } */ /*-----Read input data------------------------------------------------*/ //fpin_ptr = fopen(argv[1],\"r\"); /* if (fpin_ptr == NULL) { printf(\"\\nCannot open input file\\n\"); exit(1); }*/ //fscanf(fpin_ptr,\"%d\",&strategy); /*---choice of strategy-----------------*/ //fscanf(fpin_ptr,\"%d\",&genmax); /*---maximum number of generations------*/ //fscanf(fpin_ptr,\"%d\",&refresh); /*---output refresh cycle---------------*/ //fscanf(fpin_ptr,\"%d\",&D); /*---number of parameters---------------*/ //fscanf(fpin_ptr,\"%d\",&NP); /*---population size.-------------------*/ //fscanf(fpin_ptr,\"%lf\",&inibound_h); /*---upper parameter bound for init-----*/ //fscanf(fpin_ptr,\"%lf\",&inibound_l); /*---lower parameter bound for init-----*/ //fscanf(fpin_ptr,\"%lf\",&F); /*---weight factor----------------------*/ //fscanf(fpin_ptr,\"%lf\",&CR); /*---crossing over factor---------------*/ //fscanf(fpin_ptr,\"%d\",&seed); /*---random seed------------------------*/ // 目前已經採用 strategy 3 可以得到最佳結果 strategy = 3; genmax = 2000; refresh = 100; // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 5 個通過點角度值 D = 19; NP = 200; inibound_h = 50.; inibound_l = 0.; /*得到最佳解 F = 0.85; CR 必須介於 0 to 1. 之間 CR = 1.; */ F = 0.85; CR = 1.; seed = 3; //fclose(fpin_ptr); /*-----Checking input variables for proper range----------------------------*/ if (D > MAXDIM) { printf(\"\\nError! D=%d > MAXDIM=%d\\n\",D,MAXDIM); exit(1); } if (D <= 0) { printf(\"\\nError! D=%d, should be > 0\\n\",D); exit(1); } if (NP > MAXPOP) { printf(\"\\nError! NP=%d > MAXPOP=%d\\n\",NP,MAXPOP); exit(1); } if (NP <= 0) { printf(\"\\nError! NP=%d, should be > 0\\n\",NP); exit(1); } if ((CR < 0) || (CR > 1.0)) { printf(\"\\nError! CR=%f, should be ex [0,1]\\n\",CR); exit(1); } if (seed <= 0) { printf(\"\\nError! seed=%d, should be > 0\\n\",seed); exit(1); } if (refresh <= 0) { printf(\"\\nError! refresh=%d, should be > 0\\n\",refresh); exit(1); } if (genmax <= 0) { printf(\"\\nError! genmax=%d, should be > 0\\n\",genmax); exit(1); } if ((strategy < 0) || (strategy > 10)) { printf(\"\\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\\n\",strategy); exit(1); } if (inibound_h < inibound_l) { printf(\"\\nError! inibound_h=%f < inibound_l=%f\\n\",inibound_h, inibound_l); exit(1); } /*-----Open output file-----------------------------------------------*/ //fpout_ptr = fopen(argv[2],\"w\"); /* open output file for writing */ //if (fpout_ptr == NULL) //{ //printf(\"\\nCannot open output file\\n\"); //exit(1); //} /*-----Initialize random number generator-----------------------------*/ rnd_uni_init = -(long)seed; /* initialization of rnd_uni() */ nfeval = 0; /* reset number of function evaluations */ /*------Initialization------------------------------------------------*/ /*------Right now this part is kept fairly simple and just generates--*/ /*------random numbers in the range [-initfac, +initfac]. You might---*/ /*------want to extend the init part such that you can initialize-----*/ /*------each parameter separately.------------------------------------*/ for (i=0; i<NP; i++) { for (j=0; j<D; j++) /* spread initial population members */ { c[i][j] = inibound_l + rnd_uni(&rnd_uni_init)*(inibound_h - inibound_l); } cost[i] = evaluate(D,c[i],&nfeval); /* obj. funct. value */ } cmin = cost[0]; imin = 0; for (i=1; i<NP; i++) { if(MAXIMAPROBLEM == 1) { // 改為最大化 if (cost[i]>cmin) { cmin = cost[i]; imin = i; } } else { // 最小化問題 if (cost[i]<cmin) { cmin = cost[i]; imin = i; } } } assignd(D,best,c[imin]); /* save best member ever */ assignd(D,bestit,c[imin]); /* save best member of generation */ pold = &c; /* old population (generation G) */ pnew = &d; /* new population (generation G+1) */ /*=======================================================================*/ /*=========Iteration loop================================================*/ /*=======================================================================*/ gen = 0; /* generation counter reset */ while ((gen < genmax) /*&& (kbhit() == 0)*/) /* remove comments if conio.h */ { /* is accepted by compiler */ gen++; imin = 0; for (i=0; i<NP; i++) /* Start of loop through ensemble */ { do /* Pick a random population member */ { /* Endless loop for NP < 2 !!! */ r1 = (int)(rnd_uni(&rnd_uni_init)*NP); }while(r1==i); do /* Pick a random population member */ { /* Endless loop for NP < 3 !!! */ r2 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r2==i) || (r2==r1)); do /* Pick a random population member */ { /* Endless loop for NP < 4 !!! */ r3 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r3==i) || (r3==r1) || (r3==r2)); do /* Pick a random population member */ { /* Endless loop for NP < 5 !!! */ r4 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3)); do /* Pick a random population member */ { /* Endless loop for NP < 6 !!! */ r5 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4)); /*=======Choice of strategy===============================================================*/ /*=======We have tried to come up with a sensible naming-convention: DE/x/y/z=============*/ /*=======DE : stands for Differential Evolution==========================================*/ /*=======x : a string which denotes the vector to be perturbed==========================*/ /*=======y : number of difference vectors taken for perturbation of x===================*/ /*=======z : crossover method (exp = exponential, bin = binomial)=======================*/ /* */ /*=======There are some simple rules which are worth following:===========================*/ /*=======1) F is usually between 0.5 and 1 (in rare cases > 1)===========================*/ /*=======2) CR is between 0 and 1 with 0., 0.3, 0.7 and 1. being worth to be tried first=*/ /*=======3) To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence=*/ /* happens. */ /*=======4) If you increase NP, F usually has to be decreased============================*/ /*=======5) When the DE/best... schemes fail DE/rand... usually works and vice versa=====*/ /*=======EXPONENTIAL CROSSOVER============================================================*/ /*-------DE/best/1/exp--------------------------------------------------------------------*/ /*-------Our oldest strategy but still not bad. However, we have found several------------*/ /*-------optimization problems where misconvergence occurs.-------------------------------*/ if (strategy == 1) /* strategy DE0 (not in our paper) */ { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]); n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/rand/1/exp-------------------------------------------------------------------*/ /*-------This is one of my favourite strategies. It works especially well when the-------*/ /*-------\"bestit[]\"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/ /*-------as a first guess.---------------------------------------------------------------*/ else if (strategy == 2) /* strategy DE1 in the techreport */ { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]); n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/ /*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/ /*-------If you get misconvergence try to increase NP. If this doesn't help you----------*/ /*-------should play around with all three control variables.----------------------------*/ else if (strategy == 3) /* similiar to DE2 but generally better */ { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]); n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/ else if (strategy == 4) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = bestit[n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/ else if (strategy == 5) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = (*pold)[r5][n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/ /*-------DE/best/1/bin--------------------------------------------------------------------*/ else if (strategy == 6) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]); } n = (n+1)%D; } } /*-------DE/rand/1/bin-------------------------------------------------------------------*/ else if (strategy == 7) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]); } n = (n+1)%D; } } /*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/ else if (strategy == 8) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]); } n = (n+1)%D; } } /*-------DE/best/2/bin--------------------------------------------------------------------*/ else if (strategy == 9) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = bestit[n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; } n = (n+1)%D; } } /*-------DE/rand/2/bin--------------------------------------------------------------------*/ else { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = (*pold)[r5][n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; } n = (n+1)%D; } } /*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/ trial_cost = evaluate(D,tmp,&nfeval); /* Evaluate new vector in tmp[] */ if(MAXIMAPROBLEM == 1) { // 改為最大化 if (trial_cost >= cost[i]) /* improved objective function value ? */ { cost[i]=trial_cost; assignd(D,(*pnew)[i],tmp); if (trial_cost>cmin) /* Was this a new minimum? */ { /* if so...*/ cmin=trial_cost; /* reset cmin to new low...*/ imin=i; assignd(D,best,tmp); } } else { assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */ } } else { // 最小化問題 if (trial_cost <= cost[i]) /* improved objective function value ? */ { cost[i]=trial_cost; assignd(D,(*pnew)[i],tmp); if (trial_cost<cmin) /* Was this a new minimum? */ { /* if so...*/ cmin=trial_cost; /* reset cmin to new low...*/ imin=i; assignd(D,best,tmp); } } else { assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */ } } } /* End mutation loop through pop. */ assignd(D,bestit,best); /* Save best population member of current iteration */ /* swap population arrays. New generation becomes old one */ pswap = pold; pold = pnew; pnew = pswap; /*----Compute the energy variance (just for monitoring purposes)-----------*/ cmean = 0.; /* compute the mean value first */ for (j=0; j<NP; j++) { cmean += cost[j]; } cmean = cmean/NP; cvar = 0.; /* now the variance */ for (j=0; j<NP; j++) { cvar += (cost[j] - cmean)*(cost[j] - cmean); } cvar = cvar/(NP-1); /*----Output part----------------------------------------------------------*/ if (gen%refresh==1) /* display after every refresh generations */ { /* ABORT works only if conio.h is accepted by your compiler */ printf(\"\\n\\n PRESS ANY KEY TO ABORT\"); printf(\"\\n\\n\\n Best-so-far cost funct. value=%-15.10g\\n\",cmin); for (j=0;j<D;j++) { printf(\"\\n best[%d]=%-15.10g\",j,best[j]); } printf(\"\\n\\n Generation=%d NFEs=%ld Strategy: %s \",gen,nfeval,strat[strategy]); printf(\"\\n NP=%d F=%-4.2g CR=%-4.2g cost-variance=%-10.5g\\n\", NP,F,CR,cvar); } fprintf(fpout_ptr,\"%ld %-15.10g\\n\",nfeval,cmin); } /*=======================================================================*/ /*=========End of iteration loop=========================================*/ /*=======================================================================*/ /*-------Final output in file-------------------------------------------*/ fprintf(fpout_ptr,\"\\n\\n\\n Best-so-far obj. funct. value = %-15.10g\\n\",cmin); for (j=0;j<D;j++) { fprintf(fpout_ptr,\"\\n best[%d]=%-15.10g\",j,best[j]); } fprintf(fpout_ptr,\"\\n\\n Generation=%d NFEs=%ld Strategy: %s \",gen,nfeval,strat[strategy]); fprintf(fpout_ptr,\"\\n NP=%d F=%-4.2g CR=%-4.2g cost-variance=%-10.5g\\n\", NP,F,CR,cvar); fclose(fpout_ptr); /* Code you want timed here */ printf(\"Time elapsed: %f\\n\", ((double)clock() - start) / CLOCKS_PER_SEC); return(0); } /*-----------End of main()------------------------------------------*/ // 適應函式 fittness function (cost function) double evaluate(int D, double tmp[], long *nfeval) { // 先處理通過 5 個點的四連桿問題 // x0, y0 為左方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[0], tmp[1] // x1, y1 為右方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[2], tmp[3] // L1 為第一桿件的長度, 必須 > 0, 且小於 100 - 設為 tmp[4] // L2 為第二桿件的長度, 必須 > 0, 且小於 100 - 設為 tmp[5] // L3 為第三桿件的長度, 必須 > 0, 且小於 100 - 設為 tmp[6] // L5, L6 與 L2 共同圍出可動桿 L2 對應的三角形, 關注的三角形頂點即 L5 與 L6 的交點, 而 angle3 則為 L6 之對應角(為固定值) // L5, L6 必須 > 0, 且小於 100 - 設為 tmp[7], tmp[8] // 以下的角度輸入值, 會隨著目標點數的增加而增加, 其索引值由 9 + 通過點數 - 1 決定, 5 點, 則索引至 13, 若通過 25 點, 則索引值為 9 + 24 = 33 // input_angles[] 為五的輸入的雙浮點數角度值,代表個體的角度向量值 - 分別設為 tmp[9], tmp[10], tmp[11], tmp[12], tmp[13] // output_points[] 則為與 input_angles[] 對應的五個三角形的頂點值, 為座標結構值, 分別有 x 與 y 分量值 // 當利用個體的向量值, 代入 mechanism 後所得到得 output_points[] 再與 target_points[] 進行 cost function 的誤差值最小化 /* void mechanism(double x0, double y0, double x1, double y1, double L1, double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])*/ struct Coord target_points[NUM_OF_POINTS], output_points[NUM_OF_POINTS]; double input_angles[NUM_OF_POINTS], result; int i; (*nfeval)++; target_points[0].x = 1.0; target_points[0].y = 1.0; target_points[1].x = 2.0; target_points[1].y = 2.0; target_points[2].x = 3.0; target_points[2].y = 3.0; target_points[3].x = 4.0; target_points[3].y = 4.0; target_points[4].x = 5.0; target_points[4].y = 5.0; target_points[5].x = 6.0; target_points[5].y = 6.0; target_points[6].x = 7.0; target_points[6].y = 7.0; target_points[7].x = 8.0; target_points[7].y = 8.0; target_points[8].x = 9.0; target_points[8].y = 9.0; target_points[9].x = 10.0; target_points[9].y = 10.0; // 輸入角度值與 tmp[] 的設定 for(i = 0; i < NUM_OF_POINTS; i++) { input_angles[i] = tmp[i + 9]; } // 呼叫 mechanism() 以便計算 output_points[] mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points); // for debug /* if(*nfeval%3000 == 0) { for(i = 0; i < NUM_OF_POINTS; i++) { printf(\"%-15.10g : %-15.10g\\n\", output_points[i].x, output_points[i].y); } printf(\"#####################################\\n\"); } */ // 利用 output_points[] 與 target_points 計算誤差值, 該誤差值就是 cost result = error_function(output_points, target_points); // 這裡要分別針對各變數的約束條件與範圍值來設定傳回 PENALITY 或 誤差值 result // x0 與 x1 點位於 -500 與 500 中間 for(i = 0; i < 4; i++) { if(tmp[i] < -50 || tmp[i] > 50){ return PENALITY; } } // 三個連桿值, 一定要為正 for(i = 4; i < 7; i++) { if(tmp[i] < 0 || tmp[i] > 50){ return PENALITY; } } // L5 L6 可以為 0 或負值 for(i = 7; i < 9; i++) { if(tmp[i] < -50 || tmp[i] > 50){ return PENALITY; } } // 角度值一定要大於 0 for(i = 1; i <= NUM_OF_POINTS; i++) { if((tmp[D-i] < 0)){ return PENALITY; } } return result; /* double result=0, surface = 80.0, z, volume, penality; (*nfeval)++; z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1])); volume = tmp[0]*tmp[1]*z; if(volume <= 0){ return PENALITY; } if((tmp[0] <= inibound_l)|| (tmp[0] >inibound_h)){ return PENALITY; } if((tmp[1] <= inibound_l) || (tmp[1] >inibound_h)){ return PENALITY; } // volume must >0 and max volume // 目前為最小化問題 return 1+1/(volume*volume); */ } struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt) { struct Coord tip_coord; if (localt>=0 && localt <PI) { // 目前蓋掉的式子為利用手動代換出來的版本 //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(-mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0; // 以下的式子,先利用文字編輯器,將原先 stringout() 出來的 sqrt 替換成 sqrtt, 以防止被 maxima 中的 subst(\"&#94;\"=pow,expr) 所替換, subst 之後,再使用文字編輯器換回來,就可以得到正確的 C 對應碼. tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+ pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0; } else { // 目前蓋掉的式子為利用手動代換出來的版本 //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0; tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+ pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+ pow(x1-x0,2))/2)+x0; } // 請注意,與 Maxma 公式中的差異為,在 sqrt()中加入 fabs(),避免因為sqrt()中的負值而造成 NaN (Not a Number 問題. if (localt>=0 && localt <PI) { tip_coord.y = /*((x1-x0)*(-mech_loop)*sqrt( fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2) /(4*(pow((y1-y0),2)+pow((x1-x0),2))) )) +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2)) +y0;*/ // 利用 sqrtt 居中進行代換所得到的式子 pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+ pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0; } else { tip_coord.y = /*((x1-x0)*(mech_loop)*sqrt( fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2) /(4*(pow((y1-y0),2)+pow((x1-x0),2))) )) +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2)) +y0;*/ pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+ pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0; } return tip_coord; } double distance(double x0, double y0, double x1, double y1) { double distance_value; distance_value = sqrt(pow((x1-x0),2) + pow((y1-y0),2)); return distance_value; } double rr(double L1, double dd, double theta) { double rr_value; rr_value = sqrt(L1*L1+dd*dd-2*L1*dd*cos(theta)); return rr_value; } // 輸入每一個體的變數向量, 然後求各三角形頂點的座標陣列[NUM_OF_POINTS] void mechanism(double x0, double y0, double x1, double y1, double L1, double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]) { // 此函式要輸入控制變數, 然後計算機構尺寸合成的關注點座標位置 // 以下為可能的處理變數宣告 // 這裡希望能夠定義一個 struct 來處理座標點 double rr_length, dd_length, angle; struct Coord link1_tip, link2_tip, triangle_tip; double angle2, angle3; int i; // 開始進行三角形頂點座標的計算 // 以下變數由每一個體向量提供 /* x0 = 0.0; y0 = 0.0; x1 = 10.0; y1 = 0.0; L1 = 5.0; L2 = 20; L3 = 10; L5 = 10; L6 = 10; */ dd_length = distance(x0, y0, x1, y1); /* 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式 */ angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5)); for(i = 0; i < NUM_OF_POINTS; i++) { // 先建立第一點座標, 即 i=0 者 // i=0; // angle = i*degree; /* // 利用角度增量進行運算, 相對於 input_angles[0] 作為基準 if(i > 0) { input_angles[i] = input_angles[i] + input_angles[i-1]; } */ angle = input_angles[i]*degree; rr_length = rr(L1, dd_length, angle); // 第一次三角形疊代 link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle); // 第二次三角形疊代 /* 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式 */ angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length)); link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2); // 第三次三角形疊代 //triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3); // output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3); // 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負 output_points[i] = finaltip_coord(link1_tip, link2_tip, L5, L6); } } double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]) { double error = 0.0; int i; for(i = 0; i < NUM_OF_POINTS; i++) { error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y)); } return error; } struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2) { struct Coord tip3_coord; double theta3, theta4, length3, length4; length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2)); length4 = sqrt(pow(r1,2) + pow(r2,2)); theta3 = acos((tip2_coord.x - tip1_coord.x) / length3); theta4 = acos(r1 / length4); tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4); tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4); return tip3_coord; } 為了要讓 C 程式碼可以在 Pelican 網誌 Markdown 格式編輯模式下能夠與 highlight 套件結合, 首先程式碼中的所有大於與小於符號必須轉為 html special charactor 之外, 還要全部內縮, 否則內容將會在 Pelican 轉換過程中被視為 html 而自動加入錯誤的標註符號. 以下則為 de 25 點四連桿尺寸合成參考程式: /*************************************************************** ** ** ** D I F F E R E N T I A L E V O L U T I O N ** ** ** ** Program: de.c ** ** Version: 3.6 ** ** ** ** Authors: Dr. Rainer Storn ** ** c/o ICSI, 1947 Center Street, Suite 600 ** ** Berkeley, CA 94707 ** ** Tel.: 510-642-4274 (extension 192) ** ** Fax.: 510-643-7684 ** ** E-mail: storn@icsi.berkeley.edu ** ** WWW: http://http.icsi.berkeley.edu/~storn/ ** ** on leave from ** ** Siemens AG, ZFE T SN 2, Otto-Hahn Ring 6 ** ** D-81739 Muenchen, Germany ** ** Tel: 636-40502 ** ** Fax: 636-44577 ** ** E-mail: rainer.storn@zfe.siemens.de ** ** ** ** Kenneth Price ** ** 836 Owl Circle ** ** Vacaville, CA 95687 ** ** E-mail: kprice@solano.community.net ** ** ** ** This program implements some variants of Differential ** ** Evolution (DE) as described in part in the techreport ** ** tr-95-012.ps of ICSI. You can get this report either via ** ** ftp.icsi.berkeley.edu/pub/techreports/1995/tr-95-012.ps.Z ** ** or via WWW: http://http.icsi.berkeley.edu/~storn/litera.html* ** A more extended version of tr-95-012.ps is submitted for ** ** publication in the Journal Evolutionary Computation. ** ** ** ** You may use this program for any purpose, give it to any ** ** person or change it according to your needs as long as you ** ** are referring to Rainer Storn and Ken Price as the origi- ** ** nators of the the DE idea. ** ** If you have questions concerning DE feel free to contact ** ** us. We also will be happy to know about your experiences ** ** with DE and your suggestions of improvement. ** ** ** ***************************************************************/ /**H*O*C************************************************************** ** ** ** No.!Version! Date ! Request ! Modification ! Author ** ** ---+-------+------+---------+---------------------------+------- ** ** 1 + 3.1 +5/18/95+ - + strategy DE/rand-to-best/1+ Storn ** ** + + + + included + ** ** 1 + 3.2 +6/06/95+C.Fleiner+ change loops into memcpy + Storn ** ** 2 + 3.2 +6/06/95+ - + update comments + Storn ** ** 1 + 3.3 +6/15/95+ K.Price + strategy DE/best/2 incl. + Storn ** ** 2 + 3.3 +6/16/95+ - + comments and beautifying + Storn ** ** 3 + 3.3 +7/13/95+ - + upper and lower bound for + Storn ** ** + + + + initialization + ** ** 1 + 3.4 +2/12/96+ - + increased printout prec. + Storn ** ** 1 + 3.5 +5/28/96+ - + strategies revisited + Storn ** ** 2 + 3.5 +5/28/96+ - + strategy DE/rand/2 incl. + Storn ** ** 1 + 3.6 +8/06/96+ K.Price + Binomial Crossover added + Storn ** ** 2 + 3.6 +9/30/96+ K.Price + cost variance output + Storn ** ** 3 + 3.6 +9/30/96+ - + alternative to ASSIGND + Storn ** ** 4 + 3.6 +10/1/96+ - + variable checking inserted + Storn ** ** 5 + 3.6 +10/1/96+ - + strategy indic. improved + Storn ** ** ** ***H*O*C*E***********************************************************/ #include \"stdio.h\" #include \"stdlib.h\" #include \"math.h\" #include \"memory.h\" #include <time.h> // 最大族群數, NP #define MAXPOP 5000 // 最大向量維度, D #define MAXDIM 60 // 1 為最大化問題, 0 為最小化問題 #define MAXIMAPROBLEM 0 // 可能要配合最大或最小化進行變號 #define PENALITY 1.0E20 /*------Constants for rnd_uni()--------------------------------------------*/ #define IM1 2147483563 #define IM2 2147483399 #define AM (1.0/IM1) #define IMM1 (IM1-1) #define IA1 40014 #define IA2 40692 #define IQ1 53668 #define IQ2 52774 #define IR1 12211 #define IR2 3791 #define NTAB 32 #define NDIV (1+IMM1/NTAB) #define EPS 1.2e-7 #define RNMX (1.0-EPS) // 與機構合成相關的常數定義 #define PI 3.1415926 #define degree PI/180.0 #define mech_loop -1 #define NUM_OF_POINTS 25 /*------------------------Macros----------------------------------------*/ /*#define ASSIGND(a,b) memcpy((a),(b),sizeof(double)*D) */ /* quick copy by Claudio */ /* works only for small */ /* arrays, but is faster.*/ /*------------------------Globals---------------------------------------*/ long rnd_uni_init; /* serves as a seed for rnd_uni() */ double c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM]; double (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM]; /*---------Function declarations----------------------------------------*/ void assignd(int D, double a[], double b[]); double rnd_uni(long *idum); /* uniform pseudo random number generator */ double extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */ // 與機構合成相關的函式宣告 double distance(double x0, double y0, double x1, double y1); double rr(double L1, double dd, double theta); struct Coord triangletip_coord(double x0, double y0, double R0, double R1, double x1, double y1, double localt); void mechanism(double x0, double y0, double x1, double y1, double L1, double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]); double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]); // 用來利用 tip1 與 tip2 的座標, 以及 r1, r2 求最後的三角形頂點座標 struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2); /*---------Function definitions-----------------------------------------*/ // 指定向量 b 為 a void assignd(int D, double a[], double b[]) /**C*F**************************************************************** ** ** ** Assigns D-dimensional vector b to vector a. ** ** You might encounter problems with the macro ASSIGND on some ** ** machines. If yes, better use this function although it's slower. ** ** ** ***C*F*E*************************************************************/ { int j; for (j=0; j<D; j++) { a[j] = b[j]; } } // 產生 0 ~ 1 間的亂數 double rnd_uni(long *idum) /**C*F**************************************************************** ** ** ** SRC-FUNCTION :rnd_uni() ** ** LONG_NAME :random_uniform ** ** AUTHOR :(see below) ** ** ** ** DESCRIPTION :rnd_uni() generates an equally distributed ran- ** ** dom number in the interval [0,1]. For further ** ** reference see Press, W.H. et alii, Numerical ** ** Recipes in C, Cambridge University Press, 1992. ** ** ** ** FUNCTIONS :none ** ** ** ** GLOBALS :none ** ** ** ** PARAMETERS :*idum serves as a seed value ** ** ** ** PRECONDITIONS :*idum must be negative on the first call. ** ** ** ** POSTCONDITIONS :*idum will be changed ** ** ** ***C*F*E*************************************************************/ { long j; long k; static long idum2=123456789; static long iy=0; static long iv[NTAB]; double temp; if (*idum <= 0) { if (-(*idum) < 1) *idum=1; else *idum = -(*idum); idum2=(*idum); for (j=NTAB+7;j>=0;j--) { k=(*idum)/IQ1; *idum=IA1*(*idum-k*IQ1)-k*IR1; if (*idum < 0) *idum += IM1; if (j < NTAB) iv[j] = *idum; } iy=iv[0]; } k=(*idum)/IQ1; *idum=IA1*(*idum-k*IQ1)-k*IR1; if (*idum < 0) *idum += IM1; k=idum2/IQ2; idum2=IA2*(idum2-k*IQ2)-k*IR2; if (idum2 < 0) idum2 += IM2; j=iy/NDIV; iy=iv[j]-idum2; iv[j] = *idum; if (iy < 1) iy += IMM1; if ((temp=AM*iy) > RNMX) return RNMX; else return temp; }/*------End of rnd_uni()--------------------------*/ // 將上下限轉為全域變數 double inibound_h; /* upper parameter bound */ double inibound_l; /* lower parameter bound */ // 與機構合成相關的全域變數 // 宣告一個座標結構 struct Coord { double x; double y; // 這裡保留 double z; }; int main(int argc, char *argv[]) /**C*F**************************************************************** ** ** ** SRC-FUNCTION :main() ** ** LONG_NAME :main program ** ** AUTHOR :Rainer Storn, Kenneth Price ** ** ** ** DESCRIPTION :driver program for differential evolution. ** ** ** ** FUNCTIONS :rnd_uni(), evaluate(), printf(), fprintf(), ** ** fopen(), fclose(), fscanf(). ** ** ** ** GLOBALS :rnd_uni_init input variable for rnd_uni() ** ** ** ** PARAMETERS :argc #arguments = 3 ** ** argv pointer to argument strings ** ** ** ** PRECONDITIONS :main must be called with three parameters ** ** e.g. like de1 <input-file> <output-file>, if ** ** the executable file is called de1. ** ** The input file must contain valid inputs accor- ** ** ding to the fscanf() section of main(). ** ** ** ** POSTCONDITIONS :main() produces consecutive console outputs and ** ** writes the final results in an output file if ** ** the program terminates without an error. ** ** ** ***C*F*E*************************************************************/ { char chr; /* y/n choice variable */ char *strat[] = /* strategy-indicator */ { \"\", \"DE/best/1/exp\", \"DE/rand/1/exp\", \"DE/rand-to-best/1/exp\", \"DE/best/2/exp\", \"DE/rand/2/exp\", \"DE/best/1/bin\", \"DE/rand/1/bin\", \"DE/rand-to-best/1/bin\", \"DE/best/2/bin\", \"DE/rand/2/bin\" }; int i, j, L, n; /* counting variables */ int r1, r2, r3, r4; /* placeholders for random indexes */ int r5; /* placeholders for random indexes */ int D; /* Dimension of parameter vector */ int NP; /* number of population members */ int imin; /* index to member with lowest energy */ int refresh; /* refresh rate of screen output */ int strategy; /* choice parameter for screen output */ int gen, genmax, seed; long nfeval; /* number of function evaluations */ double trial_cost; /* buffer variable */ // 將上下限轉為全域變數, 可能要根據各變數加以設定 //double inibound_h; /* upper parameter bound */ //double inibound_l; /* lower parameter bound */ double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members */ double cost[MAXPOP]; /* obj. funct. values */ double cvar; /* computes the cost variance */ double cmean; /* mean cost */ double F,CR; /* control variables of DE */ double cmin; /* help variables */ FILE *fpin_ptr; FILE *fpout_ptr; // 計算執行過程所需時間起點, 需要導入 time.h clock_t start = clock(); /*------Initializations----------------------------*/ //if (argc != 3) /* number of arguments */ //{ //printf(\"\\nUsage : de <input-file> <output-file>\\n\"); //exit(1); //} // 將結果寫入 out.dat fpout_ptr = fopen(\"out.dat\",\"w\"); /* open output file for reading, */ /* to see whether it already exists */ /* if ( fpout_ptr != NULL ) { printf(\"\\nOutput file %s does already exist, \\ntype y if you \",argv[2]); printf(\"want to overwrite it, \\nanything else if you want to exit.\\n\"); chr = (char)getchar(); if ((chr != 'y') && (chr != 'Y')) { exit(1); } fclose(fpout_ptr); } */ /*-----Read input data------------------------------------------------*/ //fpin_ptr = fopen(argv[1],\"r\"); /* if (fpin_ptr == NULL) { printf(\"\\nCannot open input file\\n\"); exit(1); }*/ //fscanf(fpin_ptr,\"%d\",&strategy); /*---choice of strategy-----------------*/ //fscanf(fpin_ptr,\"%d\",&genmax); /*---maximum number of generations------*/ //fscanf(fpin_ptr,\"%d\",&refresh); /*---output refresh cycle---------------*/ //fscanf(fpin_ptr,\"%d\",&D); /*---number of parameters---------------*/ //fscanf(fpin_ptr,\"%d\",&NP); /*---population size.-------------------*/ //fscanf(fpin_ptr,\"%lf\",&inibound_h); /*---upper parameter bound for init-----*/ //fscanf(fpin_ptr,\"%lf\",&inibound_l); /*---lower parameter bound for init-----*/ //fscanf(fpin_ptr,\"%lf\",&F); /*---weight factor----------------------*/ //fscanf(fpin_ptr,\"%lf\",&CR); /*---crossing over factor---------------*/ //fscanf(fpin_ptr,\"%d\",&seed); /*---random seed------------------------*/ strategy = 3; genmax = 200000; // refresh 為每幾筆運算後進行資料列印 refresh = 100; // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 25 (NUM_OF_POINTS) 個通過點角度值 // tmp[0~8] 為機構尺寸, tmp[9~33] 為通過點角度值 D = 9 + NUM_OF_POINTS; NP = 200; // 機構變數值上限 inibound_h = 50.; // 機構變數值下限 inibound_l = 0.; // for strategy 1, F=0.9, CR = 1. // for strategy 2 F=0.7, CR=0.5 // 一個小時得到 9.7 的誤差 // 25 點的題目, 若 penality 只取 1000 則 F = 0.7 似乎為 最大 bound for strategy 1, CR = 1. F = 0.85; CR = 0.7; seed = 3; //fclose(fpin_ptr); /*-----Checking input variables for proper range----------------------------*/ if (D > MAXDIM) { printf(\"\\nError! D=%d > MAXDIM=%d\\n\",D,MAXDIM); exit(1); } if (D <= 0) { printf(\"\\nError! D=%d, should be > 0\\n\",D); exit(1); } if (NP > MAXPOP) { printf(\"\\nError! NP=%d > MAXPOP=%d\\n\",NP,MAXPOP); exit(1); } if (NP <= 0) { printf(\"\\nError! NP=%d, should be > 0\\n\",NP); exit(1); } if ((CR < 0) || (CR > 1.0)) { printf(\"\\nError! CR=%f, should be ex [0,1]\\n\",CR); exit(1); } if (seed <= 0) { printf(\"\\nError! seed=%d, should be > 0\\n\",seed); exit(1); } if (refresh <= 0) { printf(\"\\nError! refresh=%d, should be > 0\\n\",refresh); exit(1); } if (genmax <= 0) { printf(\"\\nError! genmax=%d, should be > 0\\n\",genmax); exit(1); } if ((strategy < 0) || (strategy > 10)) { printf(\"\\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\\n\",strategy); exit(1); } if (inibound_h < inibound_l) { printf(\"\\nError! inibound_h=%f < inibound_l=%f\\n\",inibound_h, inibound_l); exit(1); } /*-----Open output file-----------------------------------------------*/ //fpout_ptr = fopen(argv[2],\"w\"); /* open output file for writing */ //if (fpout_ptr == NULL) //{ //printf(\"\\nCannot open output file\\n\"); //exit(1); //} /*-----Initialize random number generator-----------------------------*/ rnd_uni_init = -(long)seed; /* initialization of rnd_uni() */ nfeval = 0; /* reset number of function evaluations */ /*------Initialization------------------------------------------------*/ /*------Right now this part is kept fairly simple and just generates--*/ /*------random numbers in the range [-initfac, +initfac]. You might---*/ /*------want to extend the init part such that you can initialize-----*/ /*------each parameter separately.------------------------------------*/ for (i=0; i<NP; i++) { for (j=0; j<D; j++) /* spread initial population members */ { c[i][j] = inibound_l + rnd_uni(&rnd_uni_init)*(inibound_h - inibound_l); } cost[i] = evaluate(D,c[i],&nfeval); /* obj. funct. value */ } cmin = cost[0]; imin = 0; for (i=1; i<NP; i++) { if(MAXIMAPROBLEM == 1) { // 最大化問題 if (cost[i]>cmin) { cmin = cost[i]; imin = i; } } else { // 最小化問題 if (cost[i]<cmin) { cmin = cost[i]; imin = i; } } } assignd(D,best,c[imin]); /* save best member ever */ assignd(D,bestit,c[imin]); /* save best member of generation */ pold = &c; /* old population (generation G) */ pnew = &d; /* new population (generation G+1) */ /*=======================================================================*/ /*=========Iteration loop================================================*/ /*=======================================================================*/ gen = 0; /* generation counter reset */ while ((gen < genmax) /*&& (kbhit() == 0)*/) /* remove comments if conio.h */ { /* is accepted by compiler */ gen++; imin = 0; for (i=0; i<NP; i++) /* Start of loop through ensemble */ { do /* Pick a random population member */ { /* Endless loop for NP < 2 !!! */ r1 = (int)(rnd_uni(&rnd_uni_init)*NP); }while(r1==i); do /* Pick a random population member */ { /* Endless loop for NP < 3 !!! */ r2 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r2==i) || (r2==r1)); do /* Pick a random population member */ { /* Endless loop for NP < 4 !!! */ r3 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r3==i) || (r3==r1) || (r3==r2)); do /* Pick a random population member */ { /* Endless loop for NP < 5 !!! */ r4 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3)); do /* Pick a random population member */ { /* Endless loop for NP < 6 !!! */ r5 = (int)(rnd_uni(&rnd_uni_init)*NP); }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4)); /*=======Choice of strategy===============================================================*/ /*=======We have tried to come up with a sensible naming-convention: DE/x/y/z=============*/ /*=======DE : stands for Differential Evolution==========================================*/ /*=======x : a string which denotes the vector to be perturbed==========================*/ /*=======y : number of difference vectors taken for perturbation of x===================*/ /*=======z : crossover method (exp = exponential, bin = binomial)=======================*/ /* */ /*=======There are some simple rules which are worth following:===========================*/ /*=======1) F is usually between 0.5 and 1 (in rare cases > 1)===========================*/ /*=======2) CR is between 0 and 1 with 0., 0.3, 0.7 and 1. being worth to be tried first=*/ /*=======3) To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence=*/ /* happens. */ /*=======4) If you increase NP, F usually has to be decreased============================*/ /*=======5) When the DE/best... schemes fail DE/rand... usually works and vice versa=====*/ /*=======EXPONENTIAL CROSSOVER============================================================*/ /*-------DE/best/1/exp--------------------------------------------------------------------*/ /*-------Our oldest strategy but still not bad. However, we have found several------------*/ /*-------optimization problems where misconvergence occurs.-------------------------------*/ // 1 為最原始的解題邏輯方法 if (strategy == 1) /* strategy DE0 (not in our paper) */ { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]); n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/rand/1/exp-------------------------------------------------------------------*/ /*-------This is one of my favourite strategies. It works especially well when the-------*/ /*-------\"bestit[]\"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/ /*-------as a first guess.---------------------------------------------------------------*/ // 配合邏輯方法 2 選用 R=0.7, CR=0.5 else if (strategy == 2) /* strategy DE1 in the techreport */ { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]); n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/ /*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/ /*-------If you get misconvergence try to increase NP. If this doesn't help you----------*/ /*-------should play around with all three control variables.----------------------------*/ // 方法 3 建議 F=0.85 CR=1. else if (strategy == 3) /* similiar to DE2 but generally better */ { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]); n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/ else if (strategy == 4) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = bestit[n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/ else if (strategy == 5) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); L = 0; do { tmp[n] = (*pold)[r5][n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; n = (n+1)%D; L++; }while((rnd_uni(&rnd_uni_init) < CR) && (L < D)); } /*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/ /*-------DE/best/1/bin--------------------------------------------------------------------*/ else if (strategy == 6) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]); } n = (n+1)%D; } } /*-------DE/rand/1/bin-------------------------------------------------------------------*/ else if (strategy == 7) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]); } n = (n+1)%D; } } /*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/ else if (strategy == 8) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]); } n = (n+1)%D; } } /*-------DE/best/2/bin--------------------------------------------------------------------*/ else if (strategy == 9) { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = bestit[n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; } n = (n+1)%D; } } /*-------DE/rand/2/bin--------------------------------------------------------------------*/ else { assignd(D,tmp,(*pold)[i]); n = (int)(rnd_uni(&rnd_uni_init)*D); for (L=0; L<D; L++) /* perform D binomial trials */ { if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */ { tmp[n] = (*pold)[r5][n] + ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F; } n = (n+1)%D; } } /*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/ trial_cost = evaluate(D,tmp,&nfeval); /* Evaluate new vector in tmp[] */ if(MAXIMAPROBLEM == 1) { // 改為最大化 if (trial_cost >= cost[i]) /* improved objective function value ? */ { cost[i]=trial_cost; assignd(D,(*pnew)[i],tmp); if (trial_cost>cmin) /* Was this a new minimum? */ { /* if so...*/ cmin=trial_cost; /* reset cmin to new low...*/ imin=i; assignd(D,best,tmp); } } else { assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */ } } else { // 最小化問題 if (trial_cost <= cost[i]) /* improved objective function value ? */ { cost[i]=trial_cost; assignd(D,(*pnew)[i],tmp); if (trial_cost<cmin) /* Was this a new minimum? */ { /* if so...*/ cmin=trial_cost; /* reset cmin to new low...*/ imin=i; assignd(D,best,tmp); } } else { assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */ } } } /* End mutation loop through pop. */ assignd(D,bestit,best); /* Save best population member of current iteration */ /* swap population arrays. New generation becomes old one */ pswap = pold; pold = pnew; pnew = pswap; /*----Compute the energy variance (just for monitoring purposes)-----------*/ cmean = 0.; /* compute the mean value first */ for (j=0; j<NP; j++) { cmean += cost[j]; } cmean = cmean/NP; cvar = 0.; /* now the variance */ for (j=0; j<NP; j++) { cvar += (cost[j] - cmean)*(cost[j] - cmean); } cvar = cvar/(NP-1); /*----Output part----------------------------------------------------------*/ if (gen%refresh==1) /* display after every refresh generations */ { /* ABORT works only if conio.h is accepted by your compiler */ printf(\"\\n\\n PRESS ANY KEY TO ABORT\"); printf(\"\\n\\n\\n Best-so-far cost funct. value=%-15.10g\\n\",cmin); for (j=0;j<D;j++) { printf(\"\\n best[%d]=%-15.10g\",j,best[j]); } printf(\"\\n\\n Generation=%d NFEs=%ld Strategy: %s \",gen,nfeval,strat[strategy]); printf(\"\\n NP=%d F=%-4.2g CR=%-4.2g cost-variance=%-10.5g\\n\", NP,F,CR,cvar); } fprintf(fpout_ptr,\"%ld %-15.10g\\n\",nfeval,cmin); } /*=======================================================================*/ /*=========End of iteration loop=========================================*/ /*=======================================================================*/ /*-------Final output in file-------------------------------------------*/ fprintf(fpout_ptr,\"\\n\\n\\n Best-so-far obj. funct. value = %-15.10g\\n\",cmin); for (j=0;j<D;j++) { fprintf(fpout_ptr,\"\\n best[%d]=%-15.10g\",j,best[j]); } fprintf(fpout_ptr,\"\\n\\n Generation=%d NFEs=%ld Strategy: %s \",gen,nfeval,strat[strategy]); fprintf(fpout_ptr,\"\\n NP=%d F=%-4.2g CR=%-4.2g cost-variance=%-10.5g\\n\", NP,F,CR,cvar); fclose(fpout_ptr); /* Code you want timed here */ printf(\"Time elapsed: %f\\n\", ((double)clock() - start) / CLOCKS_PER_SEC); return(0); } /*-----------End of main()------------------------------------------*/ // 適應函式 fittness function (cost function) double evaluate(int D, double tmp[], long *nfeval) { // 先處理通過 5 個點的四連桿問題 // x0, y0 為左方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[0], tmp[1] // x1, y1 為右方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[2], tmp[3] // L1 為第一桿件的長度, 必須 > 0, 且小於 100 - 設為 tmp[4] // L2 為第二桿件的長度, 必須 > 0, 且小於 100 - 設為 tmp[5] // L3 為第三桿件的長度, 必須 > 0, 且小於 100 - 設為 tmp[6] // L5, L6 與 L2 共同圍出可動桿 L2 對應的三角形, 關注的三角形頂點即 L5 與 L6 的交點, 而 angle3 則為 L6 之對應角(為固定值) // L5, L6 必須 > 0, 且小於 100 - 設為 tmp[7], tmp[8] // 以下的角度輸入值, 會隨著目標點數的增加而增加, 其索引值由 9 + 通過點數 - 1 決定, 5 點, 則索引至 13, 若通過 25 點, 則索引值為 9 + 24 = 33 // input_angles[] 為五的輸入的雙浮點數角度值,代表個體的角度向量值 - 分別設為 tmp[9], tmp[10], tmp[11], tmp[12], tmp[13] // 這裡的輸入角度值, 將採用以第一角度>0 作為起點, 隨後則為角度增量, 也都必須大於零 // output_points[] 則為與 input_angles[] 對應的五個三角形的頂點值, 為座標結構值, 分別有 x 與 y 分量值 // 當利用個體的向量值, 代入 mechanism 後所得到得 output_points[] 再與 target_points[] 進行 cost function 的誤差值最小化 /* void mechanism(double x0, double y0, double x1, double y1, double L1, double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])*/ struct Coord target_points[NUM_OF_POINTS], output_points[NUM_OF_POINTS]; double input_angles[NUM_OF_POINTS], result, total_angle; int i; (*nfeval)++; target_points[0].x = 4.5; target_points[0].y = 6.75; target_points[1].x = 5.07; target_points[1].y = 6.85; target_points[2].x = 5.45; target_points[2].y = 6.84; target_points[3].x = 5.89; target_points[3].y = 6.83; target_points[4].x = 6.41; target_points[4].y = 6.8; target_points[5].x = 6.92; target_points[5].y = 6.58; target_points[6].x = 7.03; target_points[6].y = 5.99; target_points[7].x = 6.95; target_points[7].y = 5.45; target_points[8].x = 6.77; target_points[8].y = 5.03; target_points[9].x = 6.4; target_points[9].y = 4.6; target_points[10].x = 5.91; target_points[10].y = 4.03; target_points[11].x = 5.43; target_points[11].y = 3.56; target_points[12].x = 4.93; target_points[12].y = 2.94; target_points[13].x = 4.67; target_points[13].y = 2.6; target_points[14].x = 4.38; target_points[14].y = 2.2; target_points[15].x = 4.04; target_points[15].y = 1.67; target_points[16].x = 3.76; target_points[16].y = 1.22; target_points[17].x = 3.76; target_points[17].y = 1.97; target_points[18].x = 3.76; target_points[18].y = 2.78; target_points[19].x = 3.76; target_points[19].y = 3.56; target_points[20].x = 3.76; target_points[20].y = 4.34; target_points[21].x = 3.76; target_points[21].y = 4.91; target_points[22].x = 3.76; target_points[22].y = 5.47; target_points[23].x = 3.8; target_points[23].y = 5.98; target_points[24].x = 4.07; target_points[24].y = 6.4; // 輸入角度值與 tmp[] 的設定 for(i = 0; i < NUM_OF_POINTS; i++) { input_angles[i] = tmp[i + 9]; } // 呼叫 mechanism() 以便計算 output_points[] mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points); // for debug /* if(*nfeval%5000 == 0) { for(i = 0; i < NUM_OF_POINTS; i++) { printf(\"%-15.10g : %-15.10g\\n\", output_points[i].x, output_points[i].y); } printf(\"#####################################\\n\"); } */ // 利用 output_points[] 與 target_points 計算誤差值, 該誤差值就是 cost result = error_function(output_points, target_points); // 這裡要分別針對各變數的約束條件與範圍值來設定傳回 PENALITY 或 誤差值 result // x0 與 x1 點位於 -50 與 50 中間 for(i = 0; i < 4; i++) { if(tmp[i] < -100 || tmp[i] > 100){ return PENALITY; } } // 三個連桿值, 一定要為正 for(i = 4; i < 7; i++) { if(tmp[i] < 0 || tmp[i] > 100){ return PENALITY; } } // L5 L6 可以為 0 或負值 for(i = 7; i < 9; i++) { if(tmp[i] < -100 || tmp[i] > 100){ return PENALITY; } } // 角度值不可以小於 0 for(i = 1; i <= NUM_OF_POINTS; i++) { if(tmp[D-i] < 0){ return PENALITY; } } /* for(i = 0; i < D - NUM_OF_POINTS; i++) { if((tmp[i] <= inibound_l)|| (tmp[i] >inibound_h)){ return PENALITY; } } for(i = 1; i <= NUM_OF_POINTS; i++) { if(tmp[D-i] < 0){ return PENALITY; } } */ return result; /* double result=0, surface = 80.0, z, volume, penality; (*nfeval)++; z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1])); volume = tmp[0]*tmp[1]*z; if(volume <= 0){ return PENALITY; } if((tmp[0] <= inibound_l)|| (tmp[0] >inibound_h)){ return PENALITY; } if((tmp[1] <= inibound_l) || (tmp[1] >inibound_h)){ return PENALITY; } // volume must >0 and max volume // 目前為最小化問題 return 1+1/(volume*volume); */ } struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt) { struct Coord tip_coord; if (localt>=0 && localt <PI) { // 目前蓋掉的式子為利用手動代換出來的版本 //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(-mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0; // 以下的式子,先利用文字編輯器,將原先 stringout() 出來的 sqrt 替換成 sqrtt, 以防止被 maxima 中的 subst(\"&#94;\"=pow,expr) 所替換, subst 之後,再使用文字編輯器換回來,就可以得到正確的 C 對應碼. tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+ pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0; } else { // 目前蓋掉的式子為利用手動代換出來的版本 //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0; tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+ pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+ pow(x1-x0,2))/2)+x0; } // 請注意,與 Maxma 公式中的差異為,在 sqrt()中加入 fabs(),避免因為sqrt()中的負值而造成 NaN (Not a Number 問題. if (localt>=0 && localt <PI) { tip_coord.y = /*((x1-x0)*(-mech_loop)*sqrt( fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2) /(4*(pow((y1-y0),2)+pow((x1-x0),2))) )) +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2)) +y0;*/ // 利用 sqrtt 居中進行代換所得到的式子 pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+ pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0; } else { tip_coord.y = /*((x1-x0)*(mech_loop)*sqrt( fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2) /(4*(pow((y1-y0),2)+pow((x1-x0),2))) )) +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2)) +y0;*/ pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+ pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+ pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0; } return tip_coord; } double distance(double x0, double y0, double x1, double y1) { double distance_value; distance_value = sqrt(pow((x1-x0),2) + pow((y1-y0),2)); return distance_value; } double rr(double L1, double dd, double theta) { double rr_value; rr_value = sqrt(L1*L1+dd*dd - 2*L1*dd*cos(theta)); return rr_value; } // 輸入每一個體的變數向量, 然後求各三角形頂點的座標陣列[NUM_OF_POINTS] void mechanism(double x0, double y0, double x1, double y1, double L1, double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]) { // 這裡的輸入角度, 改採第一角度為起始角, 隨後的角度值則為增量值 // 此函式要輸入控制變數, 然後計算機構尺寸合成的關注點座標位置 // 以下為可能的處理變數宣告 // 這裡希望能夠定義一個 struct 來處理座標點 double rr_length, dd_length, angle; struct Coord link1_tip, link2_tip, triangle_tip; double angle2, angle3; int i; // 開始進行三角形頂點座標的計算 // 以下變數由每一個體向量提供 /* x0 = 0.0; y0 = 0.0; x1 = 10.0; y1 = 0.0; L1 = 5.0; L2 = 20; L3 = 10; L5 = 10; L6 = 10; */ dd_length = distance(x0, y0, x1, y1); /* 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式 */ // 假如採用 finaltip_coord, 則不需要 angle3 angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5)); for(i = 0; i < NUM_OF_POINTS; i++) { // 先建立第一點座標, 即 i=0 者 // i=0; // angle = i*degree; /* // 利用角度增量進行運算, 相對於 input_angles[0] 作為基準 if(i > 0) { input_angles[i] = input_angles[i] + input_angles[i-1]; } */ angle = input_angles[i]*degree; rr_length = rr(L1, dd_length, angle); // 第一次三角形疊代 link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle); // 第二次三角形疊代 /* 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式 */ angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length)); link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2); // 第三次三角形疊代 //triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3); // output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3); // 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負 output_points[i] = finaltip_coord(link1_tip, link2_tip, L5, L6); } } double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]) { double error = 0.0; int i; for(i = 0; i < NUM_OF_POINTS; i++) { error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y)); } return error; } struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2) { struct Coord tip3_coord; double theta3, theta4, length3, length4; length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2)); length4 = sqrt(pow(r1,2) + pow(r2,2)); theta3 = acos((tip2_coord.x - tip1_coord.x) / length3); theta4 = acos(r1 / length4); tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4); tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4); return tip3_coord; }","url":"http://project.mde.tw/blog/yen-rga-ji-yin-yan-suan-fa.html"},{"tags":"2016g1","title":"R2C2的資料","text":"新的R2C2資料 中間有新的資料for raspberrypi 是使用node.js啟動server client端可以看到的 https://github.com/nneves/Raspberrypi_NodeJS RaspberryPi R2C2","url":"http://project.mde.tw/blog/r2c2de-zi-liao.html"},{"tags":"2016g1","title":"OpenCv實作","text":"OpenCv in python and use 實作系統Ubuntu 14.04 剛開始必須要先安裝依些相關的compiler以及設定黨 步驟如同老師所下載的順序 # apt-get 更新 $ sudo apt-get update # apt-get 升級 $ sudo apt-get upgrade # 安裝所需的開發套件 $ sudo apt-get install build-essential cmake git pkg-config # 安裝編譯過程所需的程式庫 $ sudo apt-get install libjpeg8-dev libtiff4-dev libjasper-dev libpng12-dev # 安裝編譯過程所需的程式庫 $ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev # 安裝編譯過程所需的程式庫 $ sudo apt-get install libgtk2.0-dev # 安裝編譯過程所需的 fortran 編譯器 $ sudo apt-get install libatlas-base-dev gfortran # 安裝編譯過程所需的原始碼 $ sudo apt-get install python3.4-dev # 本台機器的 python 為 2.7 版, 而 python3 則為 python 3.4, 這裡安裝 numpy 模組 $ sudo pip3 install numpy # 希望在帳號目錄下的 tmp 進行編譯工作 $ cd #new folder $ mkdir tmp # 更換目錄到 tmp $ cd tmp # 利用 git clone 取得原始碼 $ git clone https://github.com/Itseez/opencv.git # 準備進入倉儲切換分支 $ cd opencv # 採用 3.1.0 版 $ git checkout 3.1.0 # 回到用戶目錄 $ cd .. # 再利用 git clone 下載原始碼 $ git clone https://github.com/Itseez/opencv_contrib.git # 準備進入倉儲切換分支 $ cd opencv_contrib # 與 opencv 配合, 採用 3.1.0 版 $ git checkout 3.1.0 $ cd .. # 準備開始建立程式庫 $ cd opencv $ mkdir build $ cd build # 這裡會同時建立 Python2 與 Python3 的 OpenCV 程式庫檔案 $ cmake -D CMAKE_BUILD_TYPE=RELEASE \\ -D CMAKE_INSTALL_PREFIX=/usr/local \\ -D INSTALL_C_EXAMPLES=OFF \\ -D INSTALL_PYTHON_EXAMPLES=ON \\ -D PYTHON_EXECUTABLE=$(which python3) \\ -D OPENCV_EXTRA_MODULES_PATH= ./../../opencv_contrib/modules \\ -D BUILD_EXAMPLES=ON .. $ make -j4 $ sudo make install $ sudo ldconfig 有做些許更改同樣也可以達到使用上的設定 windows中 只需要開起2016spring中把py檔 用cmd line 來執行 下python3 你的程式碼的名子 只要有攝影機就可以執行 請注意 必須要裝好攝影機的驅動才可以執行cvcapture(0) 否則無法執行 0是預設的第1台攝影機 1是第2台 以此類推","url":"http://project.mde.tw/blog/opencvshi-zuo.html"},{"tags":"2016g1","title":"40323123 - 專題參考資料","text":"raspberry pi connect 3d printer to control the 3d printer 1.回報目前專題進度: 事項一:目前題目定義 製作一台3D printer跟atom同樣款式的 事項二:因為有三組的成員，目前分配如下所示 40323123 這組:利用octopi來進行遠端控制，以及自動下料等的問題，自動下料的機構利用GA進行運算 40323250 這組:進行組裝，設計，Onshape組裝，V-Rep(組裝設計模擬) 黃婉菁這組:先利用opencv來產生3d module並轉換成stl進行列印(主要目的影像建模出3Dstl) 參考資料: 1.octopi octopi 2.octoprintDocs octoprint Docs 3.octopi_github octoprint WIKI FAQ Github 4.flux 3d printer中的底板樣式以及掃描方式 5.OpenCv 3d nodule OpenCv可參考","url":"http://project.mde.tw/blog/40323123-zhuan-ti-can-kao-zi-liao.html"},{"tags":"2016g1","title":"保養3D列印機","text":"Control 3D printer and some Question 1.第一步清理平台 2.幫滑軌上專用潤滑油 3.加熱後將線材退出 4.清理機台外觀 5.確保滑軌滑動順利 約兩個禮拜做一次，自動校正，不要太長使用，會導致買新的噴頭。 詳細注意事項，在另行公告","url":"http://project.mde.tw/blog/bao-yang-3dlie-yin-ji.html"},{"tags":"Tutorial","title":"yen - 如何建立一好的 Wordpress 網站","text":"機械設計專題專用的 Wordpress 必須俱備幾項特點: 能夠輸入數學公式, 能夠放入高亮顯示的程式碼, 能夠內嵌影片, 能夠利用 Gmail 帳號寄信, 能夠納入 Disqus 討論區, 能夠杜絕垃圾註冊. 當然假如能夠如 http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html 中所言, 可以利用 Leo Editor 的指令按鈕, 讓 Wordpress 網誌內容能與 Pelican 靜態網誌內容保持同步, 或許就能同時擁有改版歷程資料與即時動態維護內容的優點. Disqus 的討論區留言首推: https://wordpress.org/plugins/disqus-comment-system/ 嵌入影片專用: https://wordpress.org/plugins/iframe/ 程式碼的高亮則建議使用: https://wordpress.org/plugins/syntaxhighlighter/ 輸入數學公式: https://wordpress.org/plugins/wp-latex/ 寄信 plugin: https://wordpress.org/plugins/wp-latex/ 防止垃圾註冊 plugin: https://wordpress.org/plugins/wp-recaptcha/ 至於, 在 WordPress 網誌中利用 https://wordpress.org/plugins/wp-mail-smtp/ Plugin 與 Gmail 帳號寄信的設定, 有兩個關鍵: 第1項就是設定選項: 選擇 Send all WordPress emails via SMTP 選擇 smtp.gmail.com: 465 選擇 Use SSL encryption 選擇 Use SMTP authentication 然後給定對應的 Gmail 帳號 與 Gmail 密碼 之後存檔. 第2項設定則是必須配合所使用的 Gmail 帳號, 利用 https://www.google.com/settings/security/lesssecureapps 將原定的 Turn off 改為 Turn on, 也就是降低安全設定等級, 接著就可以寄出測試信件, 若成功, 則 WordPress 中的其他模組就可以利用設定寄信.","url":"http://project.mde.tw/blog/yen-ru-he-jian-li-yi-hao-de-wordpress-wang-zhan.html"},{"tags":"Tutorial","title":"yen - Solvespace 與 V-rep 結合應用","text":"Solvespace 是一套小型的參數式 3D 繪圖開源套件, 而 V-rep 則是一套允許教育界免費使用的開源動態模擬套件, 結合這兩個套件在機械設計專題應用, 一方面使用者可以在可攜的架構下來進行產品開發與模擬, 更重要的是, 使用者可以透過原始程式碼, 一窺專業人士編寫電腦輔助機械設計與分析工具時, 所應用的理論分析與基本架構. Solvespace: http://solvespace.com/ 與 https://github.com/whitequark/solvespace V-rep: http://www.coppeliarobotics.com/","url":"http://project.mde.tw/blog/yen-solvespace-yu-v-rep-jie-he-ying-yong.html"},{"tags":"Misc","title":"yen - 機械設計專題的表達、技術領域與考量層面","text":"這是一個利用 Python3 的模組 blockdiag: http://blockdiag.com/en/ , 將文字敘述轉為 2D 流程圖的範例. 機械設計專題內容流程圖： 機械設計專題 隨身卡片電腦規劃 流程圖： 機械設計專題內容流程圖的文字敘述: blockdiag { default_shape = roundedbox; // 內定寬度為 128 node_width = 140; // 內定高度為 40 node_height = 50; default_fontsize = 15; default_node_color = \"lightyellow\"; edge_layout = flowchart; // 表達方式 表達 [label = \"六種表達方式\"]; 1 [label = \"口語表達(聲音)\"]; 2 [label = \"文字表達\"]; 3 [label = \"2D表達(靜態影像)\"]; 4 [label = \"3D表達(動態影像)\"]; 5 [label = \"理論表達(定量分析)\"]; 6 [label = \"實體表達\"]; 表達 -> 1; 表達 -> 2; 表達 -> 3; 表達 -> 4; 表達 -> 5; 表達 -> 6; // 學門 學門 [label = \"四種技術領域\"]; 學門1 [label = \"熱流力學\"]; 學門2 [label = \"固體力學\"]; 學門3 [label = \"電機電子\"]; 學門4 [label = \"資訊通信\"]; 學門 -> 學門1; 學門 -> 學門2; 學門 -> 學門3; 學門 -> 學門4; // 流程 流程 [label = \"四個層面\"]; 流程1 [label = \"設計\"]; 流程2 [label = \"製造\"]; 流程3 [label = \"控制\"]; 流程4 [label = \"管理\"]; 流程 -> 流程1; 流程 -> 流程2; 流程 -> 流程3; 流程 -> 流程4; //專題 專題 [label = \"機械設計專題\", stacked]; 專題 -> 表達; 專題 -> 流程; 專題 -> 學門; } 機械設計專題 隨身卡片電腦規劃 流程圖的文字敘述: blockdiag { default_shape = roundedbox; // 內定寬度為 128 node_width = 140; // 內定高度為 40 node_height = 50; default_fontsize = 15; default_node_color = \"lightyellow\"; edge_layout = flowchart; // 表達方式 表達 [label = \"六種表達方式\"]; 1 [label = \"口語表達(聲音)\"]; 2 [label = \"文字表達\", color=\"#99ff33\"]; 3 [label = \"2D表達(靜態影像)\"]; 4 [label = \"3D表達(動態影像)\"]; 5 [label = \"理論表達(定量分析)\"]; 6 [label = \"實體表達\", color=\"#99ff33\"]; 表達 -> 1; 表達 -> 2; 表達 -> 3; 表達 -> 4; 表達 -> 5; 表達 -> 6; // 學門 學門 [label = \"四種技術領域\"]; 學門1 [label = \"熱流力學\"]; 學門2 [label = \"固體力學\"]; 學門3 [label = \"電機電子\"]; 學門4 [label = \"資訊通信\", color=\"#99ff33\"]; 學門 -> 學門1; 學門 -> 學門2; 學門 -> 學門3; 學門 -> 學門4; // 流程 流程 [label = \"四個層面\"]; 流程1 [label = \"設計\", color=\"#99ff33\"]; 流程2 [label = \"製造\"]; 流程3 [label = \"控制\"]; 流程4 [label = \"管理\", color=\"#99ff33\"]; 流程 -> 流程1; 流程 -> 流程2; 流程 -> 流程3; 流程 -> 流程4; //專題 //專題 [label = \"機械設計專題\", stacked]; 專題 [label = \"隨身卡片電腦選購\", stacked, color=\"#ff5050\"]; 專題 -> 表達; 專題 -> 流程; 專題 -> 學門; }","url":"http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-de-biao-da-ji-shu-ling-yu-yu-kao-liang-ceng-mian.html"},{"tags":"Misc","title":"yen - 機械設計專題學員的隨身 Jupyter hub","text":"我們知道自從 2013 年底開始, 與 Raspberry Pi 搭配的 Raspbian 操作系統, 就已經免費放入 Mathematica 相關的套件系統, 但是只允許非營利使用, 相較之下, 以 Python3 為主打造的 Jupyter 就比較自由, 而且全部開源, 因此更值得推廣. 這裡就以 Raspberry Pi 3 卡片電腦上的 Jupyter hub 安裝與啟動為例, 希望作為機械設計專題學員隨身的網際工程運算系統. 最新的 Raspbian 操作系統已經內建 Python3 以及 node.js, 因此當基本的操作系統配置完成, 而且啟動 SSH 之後, 就可以透過下列步驟安裝 Jupyter hub . jupyterhub 安裝 sudo apt-get install npm nodejs-legacy sudo npm install -g configurable-http-proxy sudo pip3 install jupyterhub sudo pip3 install IPython sudo pip3 install jupyter 以 SSL 啟動: 先建立 key 與 certificate: sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout jupyterhub.key -out jupyterhub.crt 以指定的 IP 啟動: jupyterhub --ip 192.168.1.1 --port 443 --ssl-key jupyterhub.key --ssl-cert jupyterhub.crt 或不指定 IP: jupyterhub --port 9443 --ssl-key jupyterhub.key --ssl-cert jupyterhub.crt 之後則可以 http://jupyterIP:9443 或 https://jupyterIP:9443 連線","url":"http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-xue-yuan-de-sui-shen-jupyter-hub.html"},{"tags":"Misc","title":"yen - Raspberry Pi 3 基本設定","text":"Raspberry Pi 3 Model B 終於在 2016 年 2 月推出了, 這片採用 1.2GHz 64位元四核心 CPU ARMv8 晶片的卡片電腦, 將帶給機械設計專題更多應用的題目. raspbian 安裝 首先, 為了簡化新的 Raspberry Pi 3 安裝 https://www.raspberrypi.org/downloads/noobs/ 多重開機系統的過程, http://cadlab.mde.tw 特別採購一批支援 HDMI 介面的電腦螢幕. 由於 noobs 內含的 https://www.raspberrypi.org/downloads/raspbian/ 與 Ubuntu 操作系統都屬於 Debian 系列, 因此未來幾年, 本地端與區域網路上的伺服器, 都將安裝 Ubuntu 16.04 LTS, 而希望學生人手一塊的 Raspberry Pi 3, 就以安裝 noobs 為主. 完成操作系統安裝後, 必須 enable SSH, 並且參考 這裡 的說明, 安裝並設定中文系統. 基本過程為: 安裝繁體中文語系: $ sudo locale-gen zh_TW.UTF-8 將 /etc/locale.gen 檔案內 # zh_TW.UTF-8 UTF-8 的註解# 拿掉: $ sudo vi /etc/locale.gen 產生繁體中文語系: $ sudo locale-gen 更改預設語系為 zh_TW.UTF-8: $ sudo vi /etc/default/locale LANG=zh_TW.UTF-8 安裝繁體中文字型: $ sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy 安裝 scim 注音輸入: $ sudo apt-get install scim scim-tables-zh scim-chewing PYQt5 與 Leo Editor 安裝 因為 Raspberry Pi 3 在機械設計專題流程中仍以機電控制為主, 而且 raspbian 已經內建 Python3 與 pip3, 因此只要利用 sudo apt-get install python3-pyqt5 安裝 PyQt5 即可. 只是在實際操作 sudo pip3 install https://github.com/leo-editor/leo-editor/archive/master.zip 時, 發現 Leo Editor 無法正確完成安裝, 最後只好下載 Leo Editor 原始碼, 並且將 leo 模組目錄, 直接放到 /usr/local/lib/python3.4/dist-packages 目錄下, 然後再利用 python3 launchLeo.py 啟動 Leo Editor. launchLeo.py 程式碼: #!/usr/bin/env python \"\"\" Leo launcher script A minimal script to launch leo. \"\"\" import leo.core.runLeo leo.core.runLeo.run() Raspberry Pi 無線網路設定 利用 sudo vi 編輯 /etc/wpa_supplicant/wpa_supplicant.conf, 並且採用下列格式, 將周遭卡片電腦移動時可能擷取的無線網路, 以並列的方式進行設定登記. 格式: network={ ssid=\"net1\" psk=\"net1_wifi_password\" key_mgmt=WPA-PSK } network={ ssid=\"net2\" psk=\"net2_wifi_password\" key_mgmt=WPA-PSK } 相關指令: sudo ifdown wlan0 (關閉無線網路) sudo ifup wlan0 (啟動無線網路) ifconfig (察看網路設定) Webcam 拍照 請參考 https://www.raspberrypi.org/documentation/usage/webcams/ , 讓 Raspberry Pi 可以帶著 Webcam, 以 Python3 程式控制拍照流程. 至於安裝 OpenCV 與 Python3 的過程與 http://project.mde.tw/blog/yen-dao-ru-opencv-yu-python3.html 中的說明完全相同, 一旦完成, Raspberry Pi 就可以與其他機構結合, 進行基本的影像辨識應用.","url":"http://project.mde.tw/blog/yen-raspberry-pi-3-ji-ben-she-ding.html"},{"tags":"Misc","title":"yen - 如何在 Pelican 網誌中加入 Github stl 檢視","text":"因為這個網誌系統分為本地端與 Github 端的資料搜尋 ,因此一般並不建議直接將要展示的 stl 帶進倉儲, 否則就必須要分別在近端與遠端的 template 目錄中, 各放置一份檔案. 也就是說, 就這個機械設計專題的協同倉儲網誌來說, 各組員可以分別在自己的個人帳號下建立具有 gh-pages 分支的倉儲, 然後再將 STL 零組件檔案的檢式, 以 Github 特有的標註, 放到文章中, 因為 STL 檔案已經是終端檔案, 比較不會有協同編輯改版的需求, 因此可以放在個人所屬的倉儲中, 只需要透過連結可以檢視即可. 但是若這些檔案真要放到機械設計專題所屬的倉儲中, 也是可以, 但是就必須在近端的 theme/pelican-bootstrap3_local/static 目錄, 以及 theme/pelican-bootstrap3/static 目錄中, 各放一份, 例如, 現在已經在這兩個目錄中各放入 files 目錄, 而且其中還有 40323143 目錄, 並將所有的 STL 零組件檔全部放入. 這時若利用 local-pelican 或 gh-pages-pelican 按鈕建立 blog 中的資料, Pelican 就會將前面提到的 files 目錄, 複製到 blog/theme 目錄中, 因此隨後在 gh-pages 的網頁中, 就是到 blog/theme/files/40323143 目錄來擷取這些零組件檔案. 例如: blog/theme/files/40323143/1long.stl 檔案, 就可以疊上 https://embed.github.com/view/3d/coursemdetw/project_site/gh-pages/, 並用 script 標註圈住, 讓使用者可以在瀏覽器中檢視.","url":"http://project.mde.tw/blog/yen-ru-he-zai-pelican-wang-zhi-zhong-jia-ru-github-stl-jian-shi.html"},{"tags":"2016g1","title":"40323143 - 3D printer 列印完下料後的倉儲機構設計理念及繪圖","text":"只要是具備協同權限的用戶, 都可以在機械設計專題網誌中貢獻內容 這裡為 40323130 所寫的文章主要內容 這是設計構想的全圖 我的想法是讓3D printer 在一個輸送帶上的平面列印，在輸送帶後方因為曲率不同使成品自然脫落，然後用一個盛盤接住成品一動到固定位置，使成盤傾斜讓成品掉落我們想要放置的位置。 我使用一個由上而往看下呈一個工字型的機構，因為我認為這種機構機構簡單、組裝容易、運動路徑明確，控制上應該比較方便，可以節省很多製造、控制上的麻煩。 動力方面想使用馬達接上摩擦輪驅動另外兩個摩擦輪，原本想用齒輪作為動力傳輸，但考慮到組原想要自己製造出來的想法，齒輪對我們來說製造難度太高，所以改用摩擦輪。 組裝上也是盡量用簡單方便的方法組裝，例如摩擦輪就只是挖一個槽用重力固定，馬達安裝是用夾板鎖螺栓固定，其餘都是鎖螺栓夾緊，在組裝上應該不會有困難。 零件圖:","url":"http://project.mde.tw/blog/40323143-3d-printer-lie-yin-wan-xia-liao-hou-de-cang-chu-ji-gou-she-ji-li-nian-ji-hui-tu.html"},{"tags":"Misc","title":"yen - Python 數位運算與較有未來的技術","text":"身為一位機械設計工程專長學員, 該如何看待數位運算, 那些技術較有未來? 機械設計專題是一項資訊密集的動態流程, 資訊之所以密集, 肇因於後續的許多控制、製造與管理, 都以設計的發動起始, 因此機械設計者憑藉著口語, 文字, 2D/3D, 理論與實體, 來紀錄並驗證概念與規格的可行性, 即便產品交付客戶手中, 各種後續服務、回收與處理再利用的相關細節規劃, 所涉及的許多資訊與數據處理, 就產品生命週期的概念而言, 都是設計者該盡力思量的範疇. 現在對於手握 Python3 作為數位運算的機械設計專題推動者, 有了福音, 因為 https://software.intel.com/en-us/python-distribution 的推出, 將可讓 Jupyter hub 上的各種機械設計純 Python3 最佳化運算速度提升幾十倍. 並且, 從 http://www.infoworld.com/article/3039935/application-development/21-hot-programming-trends-and-21-going-cold.html 的提醒, 也可以讓即將參與機械設計專題的學員了解, 應該如何取捨工具與技術, 畢竟數位運算科技的快速發展, 應該是機械設計者的絕對利多, 假如大家真能妥善發揮這些較有未來科技功能於工作的每一個流程.","url":"http://project.mde.tw/blog/yen-python-shu-wei-yun-suan-yu-jiao-you-wei-lai-de-ji-shu.html"},{"tags":"Misc","title":"yen - 導入 OpenCV 與 Python3","text":"OpenCV (Open Source Computer Vision) 是一套實時影像程式庫, 這裡希望利用 Python3 來進行應用程式開發. 安裝 Windows 可以直接從 https://github.com/chiamingyen/kmol2016 git clone 可攜系統. 測試程式: import numpy as np import cv2 # 建立一個黑色背景 img = np.zeros((512,512,3), np.uint8) # 以寬度 5 px 畫一條藍色的對角線 img = cv2.line(img,(0,0),(511,511),(255,0,0),5) # 呈現此影像 cv2.imshow('image',img) cv2.waitKey(0) cv2.destroyAllWindows() ''' # 載入 jpg 圖檔 image = cv2.imread(\"mario.jpg\", flags=cv2.IMREAD_COLOR) # 然後呈現此影像 cv2.imshow('image',image) cv2.waitKey(0) cv2.destroyAllWindows() ''' 在 Windows 環境執行結果: Ubuntu 14.04 在 Ubuntu 操作系統中 for Python2 與 Python3 的 OpenCV 程式庫編譯流程如下: # apt-get 更新 $ sudo apt-get update # apt-get 升級 $ sudo apt-get upgrade # 安裝所需的開發套件 $ sudo apt-get install build-essential cmake git pkg-config # 安裝編譯過程所需的程式庫 $ sudo apt-get install libjpeg8-dev libtiff4-dev libjasper-dev libpng12-dev # 安裝編譯過程所需的程式庫 $ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev # 安裝編譯過程所需的程式庫 $ sudo apt-get install libgtk2.0-dev # 安裝編譯過程所需的 fortran 編譯器 $ sudo apt-get install libatlas-base-dev gfortran # 安裝編譯過程所需的原始碼 $ sudo apt-get install python3.4-dev # 本台機器的 python 為 2.7 版, 而 python3 則為 python 3.4, 這裡安裝 numpy 模組 $ pip3 install numpy # 希望在帳號目錄下的 tmp 進行編譯工作 $ cd # 更換目錄到 tmp $ cd tmp # 利用 git clone 取得原始碼 $ git clone https://github.com/Itseez/opencv.git # 準備進入倉儲切換分支 $ cd opencv # 採用 3.1.0 版 $ git checkout 3.1.0 # 回到用戶目錄 $ cd .. # 再利用 git clone 下載原始碼 $ git clone https://github.com/Itseez/opencv_contrib.git # 準備進入倉儲切換分支 $ cd opencv_contrib # 與 opencv 配合, 採用 3.1.0 版 $ git checkout 3.1.0 $ cd .. # 準備開始建立程式庫 $ cd opencv $ mkdir build $ cd build # 這裡會同時建立 Python2 與 Python3 的 OpenCV 程式庫檔案 $ cmake -D CMAKE_BUILD_TYPE=RELEASE \\ -D CMAKE_INSTALL_PREFIX=/usr/local \\ -D INSTALL_C_EXAMPLES=OFF \\ -D INSTALL_PYTHON_EXAMPLES=ON \\ -D PYTHON_EXECUTABLE=$(which python3) \\ -D OPENCV_EXTRA_MODULES_PATH= ./../../opencv_contrib/modules \\ -D BUILD_EXAMPLES=ON .. $ make -j4 $ sudo make install $ sudo ldconfig 完成安裝後, 執行上一個測試程式結果: 以下則為人臉變識程式: https://github.com/shantnu/FaceDetect/ : 執行需要取得 haarcascade_frontalface_default.xml import cv2 import sys cascPath = \"haarcascade_frontalface_default.xml\" faceCascade = cv2.CascadeClassifier(cascPath) video_capture = cv2.VideoCapture(0) while True: # 逐一以影格取像 ret, frame = video_capture.read() gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) faces = faceCascade.detectMultiScale( gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30), flags=cv2.CASCADE_SCALE_IMAGE ) # 在辨識的臉形外圍畫一個矩形 for (x, y, w, h) in faces: cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 0), 2) # 呈現影像 cv2.imshow('Video', frame) if cv2.waitKey(1) & 0xFF == ord('q'): break # 停止執行 video_capture.release() cv2.destroyAllWindows() 人臉辨識程式執行結果:","url":"http://project.mde.tw/blog/yen-dao-ru-opencv-yu-python3.html"},{"tags":"Misc","title":"yen - 機械設計專題隨身開發電腦","text":"此項測試目的在利用樹莓派卡片電腦, 以無線網路取得區域網路 IP, 然後從電腦教室中的 Windows 10, 以 X-Windows Server 連線到 Raspberry Pi 電腦系統, 嘗試讓機械設計工程學員評估, 能否在 Windows 10 與隨身的 Ubuntu 電腦系統間, 搭建合用的協同產品開發環境. Windows 10 環境中擬採用的 X-Windows Server: https://sourceforge.net/projects/xming/ Raspberry Pi 擬安裝操作系統: Ubuntu Server + sudo apt-get install ubuntu-desktop 樹莓派採購清單: 操作步驟: 完成清單中的樹莓派硬體採購 在樹莓派中安裝即將推出的 Ubuntu 16.04 LTS Server 版本, 加上 ubuntu-desktop. 測試如何在 http://cadlab.mde.tw 電腦輔助設計室中利用樹莓派的內建 Wifi 取得固定 IP 測試如何在樹莓派系統中以 IPV6 環境上網, 或在樹莓派系統中植入 IPV6 與 IPV4 雙支援, 並安裝 squid Proxy Server, 測試樹莓派在純 IPV6 環境中, 擔任區域網路代理伺服器的效能. 利用本地端的 Windows 10 Professional, 啟動 xming 伺服器後, 以 putty 加上 X11 forwarding 設定, 從 Windows 10 連線到樹莓派, 然後在 Ubuntu 中安裝 Leo Editor, Jupyter, Flask 與 Weppy 等相關機械設計專題工具, 並利用 Firefox 連線到 Onshape, 測試各項工具的使用效能. 完成上述各項任務後, 將流程與心得留在各組對應的機械設計專題倉儲中, 若過程中有些資料不適合在第1時間公開, 則另在 bitbucket 建 private 倉儲, 以五名協同者的編制進行管理. 上述流程中, 各學員同時考量該如何將心得整理為論文或專題報告 pdf 發表格式. 在 KMOL 知識地圖中的屬性: 四種主要的學門領域: 熱流、固力、電子電機 、資通. 六種表達方式: 口語 、文字、 2D、3D、理論分析 、實體 四種流程階段: 設計、 製造、控制 、管理 機械設計專題倉儲: https://github.com/2015fallproject","url":"http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-sui-shen-kai-fa-dian-nao.html"},{"tags":"Misc","title":"yen - 機械設計專題倉儲","text":"機械設計工程師在面對四種主要的學門領域, 六種表達方式, 以及四種開發流程階段的交互串聯下, 能否在分散式版次管理系統的協助中, 勇往直前? 四種主要的學門領域: 熱流、固力、電子電機、資通. 六種表達方式: 口語、文字、2D、3D、理論分析、實體 四種流程階段: 設計、製造、控制、管理 機械設計專題倉儲: https://github.com/2015fallproject","url":"http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-cang-chu.html"},{"tags":"Tutorial","title":"yen - 編譯 Solvespace","text":"我們有沒有能力在機械設計專題中, 自行編譯 Solvespace, 並且了解其中的原理後, 新增自己需要的零件設計功能? https://github.com/whitequark/solvespace http://solvespace.com 自行編譯 solvespace: 從 http://www.activestate.com/activeperl/downloads 下載 ActivePerl, 並完成安裝. 下載並安裝 Visual Studio Express. 從 Visual Studio Express 表單中啟動 Dos Command. 進入 Solvespace Makefile 所在目錄, 執行 nmake. 就可以完成 Solvespace.exe 的編譯.","url":"http://project.mde.tw/blog/yen-bian-yi-solvespace.html"},{"tags":"2016g1","title":"40323143 - 說明如何參與協同機械設計專題網誌編寫","text":"只要是具備協同權限的用戶, 都可以在機械設計專題網誌中貢獻內容 這裡為 40323130 所寫的文章主要內容 本機械設計專題網誌的架構包含近端與遠端的資料檢視設計, 專案資料以 Leo Editor 進行管理. 以下教學影片示範從 http://project.mde.tw 機械設計專題網誌中取得倉儲的網址後, 可以利用 git clone 複製倉儲資料, 之後: 利用 git checkout gh-pages 將工作目錄指到 Github pages 的對應分支內容 以 Leo Editor 開啟 users 目錄下的 user_template.leo 檔案 根據自己的帳號, 修改 .md 檔案存檔的名稱, 目的在透過加入帳號與時間註記, 避免 content 目錄中的檔案彼此複寫 在 .md 的 Title 標題中, 冠上自己的帳號, 主要也是避免 Pelican 將 .md 根據標題轉成 html 時, 產生檔案複寫 本系統的 Pelican 分為近端與遠端轉檔按鈕, 因此若要在近端檢查時, 與要推送到 Github 時採用不同轉檔按鈕 為了簡化 git 指令的 add, commit 與 push, 加入 ungit, 只要啟動隨身系統候, 再利用 start_ungit.bat 開啟, 就可以在瀏覽器中簡化改版過程 Vimeo: 2016project_1 from 虎尾科大機械設計工程 on Vimeo . Youtube:","url":"http://project.mde.tw/blog/40323143-shuo-ming-ru-he-can-yu-xie-tong-ji-jie-she-ji-zhuan-ti-wang-zhi-bian-xie.html"},{"tags":"Misc","title":"yen - Pelican 靜態網頁與 Wordpress 的整合","text":"許多網路上的文章都只說明如何從動態的網誌系統轉到靜態網誌架構, 但當我們認定動靜之間各有優劣時, 能否兩者整合並存? Worpress 是一套全世界最廣為使用的動態網誌系統, 採用 PHP 編寫, 一般使用 MySQL 資料庫存放資料, 由於 Wordpress 的安裝與使用都非常直覺, 從許多角度來看, 是一套接近完美的動態網誌系統. 但是, PHP 加上 MySQL 的架構仍然需要在伺服器中運行全球資訊網加上 PHP 解譯器, 同時還要 MySQL 資料庫的支援才能啟動運作, 假如管理者沒有跟上 Wordpress 程式碼或 plugin 的漏洞更新, 或者 MySQL 資料庫未能正常提供資料, 這個用 Wordpress 架構的網誌就會出現危機或者無法使用. 雖然 Wordpress 網誌中的動態程式與資料庫具有潛在缺點, 但是動態性也同時展現優點, 因為使用者一般可以透過瀏覽器, 隨時更改網誌系統的設定, 可以即時更新所有內容. 至於 Pellican 靜態網誌系統, 則針對 Wordpress 動態的問題, 將網誌的編寫格式定調在資料提供者能夠閱讀的 Markdown 或其他類似格式, 然後在近端用各種編輯器完成初步 Markdown 文章的存檔後, 再執行 Pelican 的轉檔指令, 讓 Python 程式將一堆設定與一堆 Markdown 資料中, 轉換成一整套所有內容之間互相串連的 html 檔案, 之後再將這批純 html 格式的文檔加上一些 css 與 Javascript 檔案, 送到全球資訊網伺服器中運行. Pelican 的網誌內容, 因為不需要動態的程式編譯執行, 而只在全球資訊網伺服器中存有 html 與 Javascript, 因此沒有動態程式碼漏洞更新的問題, 也不會有線上的網誌管理系統被入侵的問題, 唯一會產生問題的只有全球資訊網伺服器, 運作或不運作, Javascript 有沒有正確存取的問題, 相較於 Wordpress 的動態程式與資料庫互動, 性質單純許多. 但是 Pelican 的靜態性也同時存在問題, 因為大多數的用戶通常採用文字編輯器來準備或管理 Markdown 檔案, 而且是採用命令列的方式來執行 Pelican 轉檔指令, 因此對於電腦程式操作較不熟悉的使用者來說, 導入 Pelican 靜態網誌的距離仍然遙遠, 況且靜態網誌也有不夠動態與直覺的問題, 許多在 Wordpress 線上能夠直接預覽的功能, 在 Pellican 就沒有那麼方便, 而且有很多的 html 與 css 的特定格式, Pelican 的 Markdown 語法根本就不支援. 可是 Pelican 純文本的 Markdown 與 html, 還有一個最大的好處, 就是可以透過 Github Pages 的網頁架構系統, 讓每一個版本的靜態網誌都以分散式版本系統管理, 這是 Wordpress 現存的版次管理 Plugin 所無法做到的功能, 因此一份內容, 同時呈現在 Wordpress 與 Pelican 網誌是最理想的情況, 但是該如何完成? 由於要整合 Pelican 靜態網誌與 Wordpress 動態網誌, 需要透過程式方法來進行, 這裡只先提供可行的初步技術, 驗證魚與熊掌可以兼得, 我們所採用的管理系統為 Leo Editor: https://github.com/leo-editor/leo-editor , 所有的資料處理流程都是依靠 Python3 程式完成. 首先, 看看 Leo Editor 如何透過 Python3 的程式方法與 Wordpress 網誌互動, 這裡所使用的是 XMLRPC 協定 https://en.wikipedia.org/wiki/XML-RPC , 基本上, 從 Leo Editor 節點, 將新資料送到 Wordpress 系統的按鈕程式. # new_to_wp 按鍵 #coding: utf-8 import xmlrpc.client import datetime import os def get_cat_tag_content(data): data_list = data.split(\"\\n\") # 只有一項資料的 category 型別為字串 category = data_list[0] # 只有一項資料的 tags 型別為字串 tags = data_list[1] # 有多項資料的 content 型別為數列 # 再將第3行之後的資料數列串回成以跳行隔開的資料 content = \"\\n\".join(data_list[2:]) return category, tags, content os.environ['TZ'] = 'Asia/Taipei' ################################# # Open a file, 這裡將存取 Wordpress 網誌的對應帳號與密碼, 存在操作系統中 # 路徑則從資料節點上層根節點的 body 內文取得 fo = open(p.parent().b, \"r+\") data = [] for line in fo.readlines(): data.append(line) #print(line) #print(data[0]) # Close opend file fo.close() # 從網誌節點的 parent().h 取得 wp_url # 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑 wp_url = \"https://\"+p.parent().h+\"/xmlrpc.php\" wp_username = data[0] wp_password = data[1] ################################# wp_blogid = \"0\" status_draft = 0 status_published = 1 server = xmlrpc.client.ServerProxy(wp_url) title = p.h #content = p.b category_str, tags_str, content = get_cat_tag_content(p.b) # 指定時間出版 ''' date_created = xmlrpc.client.DateTime(datetime.datetime.strptime(\"2013-01-01 00:00\", \"%Y-%m-%d %H:%M\")) ''' # 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表 (因為伺服主機與操作端時差而定) date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \\ datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),\"%Y-%m-%d %H:%M\")) #categories = [\"Uncategorized\"] #tags = [\"python\", \"測試\"] categories = [category_str.split(\":\")[1]] # 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料 tags = tags_str.split(\":\")[1].split(\",\") data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags} post_id = server.metaWeblog.newPost(wp_blogid, wp_username, wp_password, data, status_published) # 利用最後的 child 節點來儲存 post_id to_save_post_id = p.insertAsLastChild() to_save_post_id.b = post_id to_save_post_id.h = \"文章 id\" # 因為新增節點, commander 必須 redraw c.redraw() g.es(\"post_id 為\", post_id) g.es(\"已經送出資料!\") ''' 其他 metaWeblog 的用法: metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid) metaWeblog.editPost (postid, username, password, struct, publish) returns true metaWeblog.getPost (postid, username, password) returns struct(blog content) ''' 至於在 Leo Editor 系統中, 用來編輯既有的 Wordpress 文章的按鈕節點程式碼, 則為: #edit_to_wp #coding: utf-8 import xmlrpc.client import datetime import os def get_cat_tag_content(data): data_list = data.split(\"\\n\") # 只有一項資料的 category 型別為字串 category = data_list[0] # 只有一項資料的 tags 型別為字串 tags = data_list[1] # 有多項資料的 content 型別為數列 # 再將第3行之後的資料數列串回成以跳行隔開的資料 content = \"\\n\".join(data_list[2:]) return category, tags, content os.environ['TZ'] = 'Asia/Taipei' ################################# # Open a file fo = open(p.parent().b, \"r+\") data = [] for line in fo.readlines(): data.append(line) #print(line) #print(data[0]) # Close opend file fo.close() # 從網誌節點的 parent().h 取得 wp_url # 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑 wp_url = \"https://\"+p.parent().h+\"/xmlrpc.php\" wp_username = data[0] wp_password = data[1] ################################# wp_blogid = \"0\" status_draft = 0 status_published = 1 server = xmlrpc.client.ServerProxy(wp_url) title = p.h #content = p.b category_str, tags_str, content = get_cat_tag_content(p.b) # 指定時間出版 ''' date_created = xmlrpc.client.DateTime(datetime.datetime.strptime(\"2013-01-01 00:00\", \"%Y-%m-%d %H:%M\")) ''' # 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表 (因為伺服主機與操作端時差而定) date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \\ datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),\"%Y-%m-%d %H:%M\")) #categories = [\"Uncategorized\"] #tags = [\"python\", \"測試\"] categories = [category_str.split(\":\")[1]] # 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料 tags = tags_str.split(\":\")[1].split(\",\") data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags} # 設法取得原 post 的 id origin_post = p.getLastChild() post_id = origin_post.b status = server.metaWeblog.editPost(post_id, wp_username, wp_password, data, status_published) if status: g.es(\"資料已經更新!\") else: g.es(\"有問題, 資料沒有更新!\") ''' 其他 metaWeblog 的用法: metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid) metaWeblog.editPost (postid, username, password, struct, publish) returns true metaWeblog.getPost (postid, username, password) returns struct(blog content) ''' 最後若要經由 Leo Editor 的節點按鈕, 取回既有的 Wordpress 網誌文章, 則可以使用 get_from_wp 按鈕節點: #get_from_wp #coding: utf-8 import xmlrpc.client # 導入 html 模組, 使用 html.unescape 轉換 html 特殊符號 import html ################################# # Open a file fo = open(p.parent().b, \"r+\") data = [] for line in fo.readlines(): data.append(line) fo.close() # 從網誌節點的 parent().h 取得 wp_url # 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑 wp_url = \"https://\"+p.parent().h+\"/xmlrpc.php\" wp_username = data[0] wp_password = data[1] ################################# server = xmlrpc.client.ServerProxy(wp_url) # 設法透過上述網誌網址, 帳號與密碼, 以及文章 id, 取回 categories, tags, 文章標題, 文章內容等資 # 從最後的 child 節點來取 post_id origin_post = p.getLastChild() post_id = origin_post.b # 取回與 post_id 對應的網誌文章內容 blog_content = server.metaWeblog.getPost (post_id, wp_username, wp_password) title = blog_content[\"title\"] # 這裡要利用 html.unescape 轉回特殊符號 description = html.unescape(blog_content[\"description\"]) mt_text_more = html.unescape(blog_content[\"mt_text_more\"]) if mt_text_more != \"\": post_content = description + \"\\n \\n\"+mt_text_more else: post_content = description # 所取回的 categories 為 list categories = blog_content[\"categories\"] # 索取回的 tags 為以逗點隔開的字串 mt_keywords = blog_content[\"mt_keywords\"] p.h = title categories_str = \"\" for category in categories: # 假如不是最後一個 if category != categories[len(categories)-1]: categories_str += category + \", \" else: # 這是最後一個 categories_str += category p.b = \"categories:\"+categories_str+\"\\ntags:\"+mt_keywords+\"\\n\"+post_content # 因為節點資料更新, commander 必須 redraw c.redraw() g.es(\"資料已經取回\") 好了, 上面的3個 Leo Editor 的按鈕節點程式, 只是從操作系統的特定路徑取出能夠管理遠端 Wordpress 網誌系統的帳號密碼, 然後再透過 XML-RPC 協定, 進行 Wordpress 網誌文章的新增、編輯與取回, 表示使用者可以在一個 Leo Editor 專案檔中完成這些事, 接下來則需要讓 Pelican 轉出的 html 檔案, 能夠同步送到對應的 Wordpress 動態網誌系統, 並且可以做到即時的內容同步, 既可保有靜態網誌的版次管理與單純伺服架構, 而且又可以將 Wordpress 視為 Pelican 的另外一個出口 (意思就是說, Wordpress 中只有特定的內容由 Pelican 端提供, 其他的使用者則仍然透過瀏覽器的方法對 Wordpress 網誌提供內容), 至於後續的處理與可行性驗證, 將在隨後的文章中進行討論.","url":"http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he.html"},{"tags":"Misc","title":"yen - Pelican 靜態網頁與 Wordpress 的整合方案","text":"利用 Leo Editor 的節點資料程式方法, 可以讓 Pelican 靜態網誌的內容與 Wordpress 動態網誌保持同步. 因為 Pelican 靜態網頁結合 Github Pages 網站, 可以完整保留各版本的所有差異資料 ,而 Wordpress 的動態特性也具有即時更新的優點, 因此本機械設計專題網站, 就利用 Leo Editor 建立了3個按鈕, 可以在靜態與動態網誌之間雙向交換內容. 首先是先編寫 Pelican 網誌的文章, 然後再經由下列 Leo Editor 的按鈕, 以 XML-RPC 協定, 將文章送到對應的 Wordpress 網誌. ＃new-to-wp button #coding: utf-8 import xmlrpc.client import datetime import os def get_cat_tag_content(data): # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python # 用跳行符號分割 data_list = data.split(\"\\n\") #第2行為 title title= data_list[1] #第3行為 category category = data_list[2] #第4行為 tags tags = data_list[3] # 有多項資料的 content 型別為數列 # 再將第7行之後的資料數列串回成以跳行隔開的資料 content = \"\\n\".join(data_list[6:]) # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 content = content.replace(' ', ' ') # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式 content = content.replace('~~~python', '[code lang=\"python\"]') content = content.replace('~~~', '[/code]') return title, category, tags, content os.environ['TZ'] = 'Asia/Taipei' ################################# filepath = \"/your/wordpress/username/and/passwrod.txt\" wordpress = \"your.wordpress.site.domain\" fo = open(filepath, \"r+\") data = [] for line in fo.readlines(): data.append(line) fo.close() # 從網誌節點的 parent().h 取得 wp_url # 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑 wp_url = \"https://\"+wordpress+\"/xmlrpc.php\" wp_username = data[0] wp_password = data[1] ################################# wp_blogid = \"0\" status_draft = 0 status_published = 1 server = xmlrpc.client.ServerProxy(wp_url) # 從目前所在節點的 body pan 中取出類別, tags 以及文章內容 title_str, category_str, tags_str, content = get_cat_tag_content(p.b) # title 是一個單獨的字串 title = title_str.split(\":\")[1] # 指定時間出版 ''' date_created = xmlrpc.client.DateTime(datetime.datetime.strptime(\"2013-01-01 00:00\", \"%Y-%m-%d %H:%M\")) ''' # 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表 date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \\ datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),\"%Y-%m-%d %H:%M\")) categories = [category_str.split(\":\")[1]] # 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料 # 先用 : 斷開標投頭的 Tags:, 然後再透過逗點隔開, 將標註轉為數列資料 tags = tags_str.split(\":\")[1].split(\",\") data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags} post_id = server.metaWeblog.newPost(wp_blogid, wp_username, wp_password, data, status_published) # 利用最後的 child 節點來儲存 post_id to_save_post_id = p.insertAsLastChild() # 改為內文為空的節點, id 直接標在 head 標題 to_save_post_id.b = \"\" to_save_post_id.h = post_id # 因為新增節點, commander 必須 redraw c.redraw() g.es(\"post_id 為\", post_id) g.es(\"已經送出資料!\") 其中 filepath 是存放 Wordpress 網誌管理帳號與密碼的存文字檔案路徑 (例如: \"/home/user/file.txt\"), 而 wordpress 則宣告希望對應連結的網址 (例如: \"www.yoursite.blog\"). 當 Wordpress 的網誌文章新增後, 若 Pelican 端的文章改版, 則可以透過下列 edit-to-wp 按鈕進行更新: # edit-to-wp #coding: utf-8 import xmlrpc.client import datetime import os def get_cat_tag_content(data): # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python # 用跳行符號分割 data_list = data.split(\"\\n\") #第2行為 title title= data_list[1] #第3行為 category category = data_list[2] #第4行為 tags tags = data_list[3] # 有多項資料的 content 型別為數列 # 再將第7行之後的資料數列串回成以跳行隔開的資料 content = \"\\n\".join(data_list[6:]) # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 content = content.replace(' ', ' ') # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式 content = content.replace('~~~python', '[code lang=\"python\"]') content = content.replace('~~~', '[/code]') return title, category, tags, content os.environ['TZ'] = 'Asia/Taipei' ################################# filepath = \"/your/wordpress/username/and/passwrod.txt\" wordpress = \"your.wordpress.site.domain\" fo = open(filepath, \"r+\") data = [] for line in fo.readlines(): data.append(line) fo.close() wp_url = \"https://\"+wordpress+\"/xmlrpc.php\" wp_username = data[0] wp_password = data[1] ################################# wp_blogid = \"0\" status_draft = 0 status_published = 1 server = xmlrpc.client.ServerProxy(wp_url) # 從目前所在節點的 body pan 中取出類別, tags 以及文章內容 title_str, category_str, tags_str, content = get_cat_tag_content(p.b) # title 是一個單獨的字串 title = title_str.split(\":\")[1] # 指定時間出版 ''' date_created = xmlrpc.client.DateTime(datetime.datetime.strptime(\"2013-01-01 00:00\", \"%Y-%m-%d %H:%M\")) ''' # 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表 date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \\ datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),\"%Y-%m-%d %H:%M\")) categories = [category_str.split(\":\")[1]] # 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料 tags = tags_str.split(\":\")[1].split(\",\") data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags} # 設法取得原 post 的 id origin_post = p.getLastChild() # 直接從標題取得 post 的 id 號碼 post_id = origin_post.h status = server.metaWeblog.editPost(post_id, wp_username, wp_password, data, status_published) if status: g.es(\"資料已經更新!\") else: g.es(\"有問題, 資料沒有更新!\") 最後, 假如使用者透過 Wordpress 的瀏覽器介面新增文章, Pelican 端也可以準備一個空白節點, 並將文章的 id 號碼作為該空白節點的子節點, 且將該子節點的 header, 設為文章的 id 數, 接下來再用滑鼠停在父空白節點上, 然後以滑鼠點按下列的 get-from-wp 按鈕, 就可以將 Wordpress 端的文章取回, 且節點標題會被填入該文章的標題, 之後 Pelican 端的使用者再依據規劃, 以 @clean 存檔的標題命名該節點. # get-from-wp #coding: utf-8 import xmlrpc.client # 導入 html 模組, 使用 html.unescape 轉換 html 特殊符號 import html ################################# filepath = \"/your/wordpress/username/and/passwrod.txt\" wordpress = \"your.wordpress.site.domain\" fo = open(filepath, \"r+\") data = [] for line in fo.readlines(): data.append(line) fo.close() # 從網誌節點的 parent().h 取得 wp_url # 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑 wp_url = \"https://\"+wordpress+\"/xmlrpc.php\" wp_username = data[0] wp_password = data[1] ################################# server = xmlrpc.client.ServerProxy(wp_url) # 設法透過上述網誌網址, 帳號與密碼, 以及文章 id, 取回 categories, tags, 文章標題, 文章內容等資 # 從最後的 child 節點來取 post_id origin_post = p.getLastChild() post_id = origin_post.h # 取回與 post_id 對應的網誌文章內容 blog_content = server.metaWeblog.getPost(post_id, wp_username, wp_password) title = blog_content[\"title\"] # 這裡要利用 html.unescape 轉回特殊符號 description = html.unescape(blog_content[\"description\"]) mt_text_more = html.unescape(blog_content[\"mt_text_more\"]) if mt_text_more != \"\": post_content = description + \"\\n \\n\"+mt_text_more else: post_content = description # 所取回的 categories 為 list categories = blog_content[\"categories\"] # 所取回的 tags 為以逗點隔開的字串 mt_keywords = blog_content[\"mt_keywords\"] # 取回文章作者 author = blog_content[\"wp_author_display_name\"] p.h = title categories_str = \"\" for category in categories: # 假如不是最後一個 if category != categories[len(categories)-1]: categories_str += category + \", \" else: # 這是最後一個 categories_str += category line1 = \"@language md\\n\" line2 = \"Title: \" +title + \"\\n\" line3 = \"Category: \" + categories_str + \"\\n\" line4 = \"Tags: \" + mt_keywords + \"\\n\" line5 = \"Author: \" + author + \"\\n@others\\n\" post_content = post_content.replace(' ', '\\n \\n') post_content = post_content.replace('[code lang=\"python\"]', '~~~python') post_content = post_content.replace('[/code]', '~~~') p.b = line1 + line2 + line3 + line4 + line5 + post_content + \"\\n\" # 因為節點資料更新, commander 必須 redraw c.redraw() g.es(\"資料已經取回\")","url":"http://project.mde.tw/blog/yen-pelican-jing-tai-wang-ye-yu-wordpress-de-zheng-he-fang-an.html"},{"tags":"Tutorial","title":"yen - 如何參與 project.mde.tw 的協同編輯","text":"只要是 KMOL 機械設計專題的成員, 就可以依照特定程序, 管理 project.mde.tw 網站上的資料 首先, 你必須是 https://github.com/coursemdetw/project_site/watchers 名單上的成員, 否則就必須透過 Pull Request 的方式來參與 http://project.mde.tw 網誌內容的協同管理. 接下來, 利用 git clone 的方式, 將 https://github.com/coursemdetw/project_site 的倉儲資料複製到近端, 並且將分支切換到 gh-pages, 就可以利用 Leo Editor 開啟或建立, 位於 users 目錄中的 user_template.leo, 然後轉存為\"學號.leo\" 檔案, 透過這個 Leo Editor 的專案檔, 就可以新增文章, 修改其他人的文章, 甚至修改本網誌系統中的任何設定. 將 user_template.leo 轉存為 \"學號.leo\" 後, 第1件重要的事就是修改 @edit user_20160301.md 中的 user_20160301.md 的存檔檔名, 改為 學號_當天日期.md, 然後修改此一 md 檔案的文章標題: Title: user - 使用者的範例網誌文章標題, 因為這個網誌系統根據 Title: 之後的名稱來轉換 html, 若有兩個 .md 檔案的 Title: 資料完全一樣, Pelican 將無法轉檔, 並且會在轉檔的命令列中出現錯誤訊息. 其他的 .md 檔案中, Category: 為文章的類別, 可以參考現有的\"2016g1, Misc 與 Tutorial\" 等3個類別, 可以是組別或是文章的屬性類別. Tags: 則是文章的內容標籤,可以就文章的內容關鍵字加以界定, 至於 Author: 則是用戶的名稱. 在每一個 .md 檔案中, 出現在 \"PELICAN_END_SUMMARY\" 超文件註解標註之前的內容, Pelican 會視為文章的摘要, 當各文章並列時, 文章只會列出標題與摘要. \"PELICAN_END_SUMMARY\" 超文件註解標註之後的內容就是文章的主要內容. 文章中的程式可以利用: for i in range(5): print(i, \":hello\") 來加以標示. 圖檔則可以利用 img 標註引用: 影片引用則可以直接使用 Vimeo 或 Youtube 的 embedded 語法. 因為本網誌能夠在近端與遠端等兩個不同環境下運作, 而兩端的關鍵字搜尋流程與格式不同, 因此轉檔的按鈕也分為 local-pelican 與 gh-pages-pelican 等兩個, 要在近端測試時, 必須滑鼠停在 local-pelican 轉檔按鈕的對應節點上, 然後按下 local-pelican, 經過瀏覽器檢查近端文章轉檔與內容無誤後, 必須將滑鼠停在 gh-pages-pelican 轉檔按鈕的對應節點上, 然後按下 gh-pages-pelican 按鈕, 之後若無任何問題, 就可以將資料提交推送到遠端倉儲的 gh-pages 分支中, 指令如下: git add -A git commit -m \"提交說明訊息\" git push origin gh-pages 最後, 與 http://project.mde.tw 網站維護有關的訊息溝通或註記, 請透過 倉儲 Wiki 進行.","url":"http://project.mde.tw/blog/yen-ru-he-can-yu-projectmdetw-de-xie-tong-bian-ji.html"},{"tags":"Tutorial","title":"yen - 網際 Flask 程式架構","text":"Flask 是一套支援 Python3 的全球資訊網程式框架, 這裡希望用它來開發網際輔助機械設計程式. http://flask.pocoo.org/ 是一套簡潔的 Python3 網際程式框架, 在這一系列的導引資料中, 將利用 https://github.com/2015fallhw/simpleflask 倉儲來存放資料, 並將資料同步推送到 http://simpleflask-2014openshift.rhcloud.com/ 執行. 程式環境 假如在 Windows 環境中, 使用可攜套件: https://github.com/chiamingyen/kmol2016 , 則已經內建 Flask 模組, 假如沒有, 可以利用 pip install Flask 安裝. 假如是在 Ubuntu, 可以要用 pip3 install Flask 安裝, 至於在 OpenShift 的 Python3 應用程式, 則是透過 setup.py 安裝. #setup.py 檔案 from setuptools import setup setup(name='KMOL 2016 project', version='1.0', description='OpenShift App', author='KMOL', author_email='course@mde.tw', url='https://www.python.org/community/sigs/current/distutils-sig', install_requires=['Flask>=0.10.1'], ) 由於這裡所開發的 Flask 程式, 需要在近端與 OpenShift 都能運作, 因此 wsgi.py 的內容設計為: #!/usr/bin/python # 導入 os 模組, 主要用來判斷是否在 OpenShift 上執行 import os # 導入同目錄下的 myflaskapp.py import myflaskapp # 以下開始判斷在 OpenShift 或近端執行 if 'OPENSHIFT_REPO_DIR' in os.environ.keys(): # 表示程式在雲端執行 application = myflaskapp.app else: # 表示在近端執行, 以 python3 wsgi.py 執行, 若採 uwsgi 則與 Openshift 運作模式相同 myflaskapp.app.run(debug=True) 也就是說, wsgi.py 會透過os.environ.keys() 的值來判定執行的環境, 若是在 uwsgi 的環境執行時, 則必須使用與 OpenShift 環境相同的啟動模式. 而 wsgi.py 中所導入的 myflaskapp.py 內容則為: # coding: utf-8 from flask import Flask, send_from_directory, request, redirect, render_template, session, make_response import random app = Flask(__name__) # 使用 session 必須要設定 secret_key # In order to use sessions you have to set a secret key # set the secret key. keep this really secret: app.secret_key = 'A0Zr9@8j/3yX R~XHH!jmN]LWX/,?R@T' @app.route(\"/\") def index(): #這是猜數字遊戲的起始表單, 主要在產生答案, 並且將 count 歸零 # 將標準答案存入 answer session 對應區 theanswer = random.randint(1, 100) thecount = 0 # 將答案與計算次數變數存進 session 對應變數 session['answer'] = theanswer session['count'] = thecount return render_template(\"index.html\", answer=theanswer, count=thecount) @app.route('/user/ ') # 為了避免 syntaxhighlighter 自動加上 , 在這裡先行用註解補上, 之後再找解決方案 def user(name): return render_template(\"user.html\", name=name) @app.route('/red') def red(): # 重新導向 google return redirect(\"http://www.google.com\") @app.route('/guessform') def guessform(): session[\"count\"] += 1 guess = session.get(\"guess\") theanswer = session.get(\"answer\") count = session.get(\"count\") return render_template(\"guessform.html\", guess=guess, answer=theanswer, count=count) @app.route('/docheck', methods=['POST']) def docheck(): # session[] 存資料 # session.get() 取 session 資料 # 利用 request.form[] 取得表單欄位資料, 然後送到 template guess = request.form[\"guess\"] session[\"guess\"] = guess # 假如使用者直接執行 doCheck, 則設法轉回根方法 if guess is None: redirect(\"/\") # 從 session 取出 answer 對應資料, 且處理直接執行 docheck 時無法取 session 值情況 try: theanswer = int(session.get('answer')) except: redirect(\"/\") # 經由表單所取得的 guess 資料型別為 string try: theguess = int(guess) except: return redirect(\"/guessform\") # 每執行 doCheck 一次,次數增量一次 session[\"count\"] += 1 count = session.get(\"count\") # 答案與所猜數字進行比對 if theanswer < theguess: return render_template(\"toobig.html\", guess=guess, answer=theanswer, count=count) elif theanswer > theguess: return render_template(\"toosmall.html\", guess=guess, answer=theanswer, count=count) else: # 已經猜對, 從 session 取出累計猜測次數 thecount = session.get('count') return \"猜了 \"+str(thecount)+\" 次, 終於猜對了, 正確答案為 \"+str(theanswer)+\": 再猜 \" return render_template(\"docheck.html\", guess=guess) @app.route('/option', methods=[\"GET\", \"POST\"]) def option(): option_list1 = [\"1\", \"2\", \"3\", \"4\"] option_list2 = [\"a\", \"b\"] return render_template('option.html', option_list1=option_list1, option_list2=option_list2) @app.route('/optionaction', methods=['POST']) def optionaction(): # 這裡將根據使用者所選擇的選項值, 來進行後續的設計運算 return request.form[\"option1\"] + \":\" + request.form[\"option2\"] # 等運算或資料處理結束後, 再將相關值送到對應的 template 進行資料的展示 #return render_template('optionaction.html', option_list1=option_list1, option_list2=option_list2) if __name__ == \"__main__\": app.run() 此外, 因為 Flask 內定靜態目錄名稱為 static, 且 template 名稱為 templates, 因此在最基本的 Flask 程式架構中, 也需要自行建立這兩個目錄, 然後將靜態文件放入 static 目錄中, 而對應的 template 文件檔案, 則放入 templates 目錄中.","url":"http://project.mde.tw/blog/yen-wang-ji-flask-cheng-shi-jia-gou.html"},{"tags":"2016g1","title":"40323123 - 3d printer","text":"raspberry pi connect 3d printer to control the 3d printer 遠端控制3D列印 這邊使用的遠端列印是使用web client控制 目前有兩套在觀望的系統~ 一個是 octopi 另一個是 Astropromt 或者是我們自己寫一套 兩套皆使用樹梅派當為控制電腦及server 使用心得:在之前已經有安裝過octopi，使用狀況是不錯，但是gui介面有些許的問題，使用上是沒什麼大礙，在3D printer的控制板，做動方式，像是一般CNC一樣，接收 G指令 Gcoce 大全 控制系統的code解析 這兩套系統，都有開放原始碼，不過因為解析程式有巨大的阻礙，因為對python和樹梅派不熟悉，導致只會安裝不會自己編譯。","url":"http://project.mde.tw/blog/40323123-3d-printer.html"},{"tags":"Misc","title":"yen - 機械設計專題分類","text":"機械設計專題題目的分類, 一般就學門領域的組合, 可視為熱流體力學, 固體力學, 電子電機與資訊科技的綜合體. 雖然機械設計專題, 以設計流程為主, 但是通常離不開製造、控制與管理的範疇. 也就是說, 機械設計流程必須納入製造、控制與管理的層面, 才能得到更大的價值. 機械指的是機巧的配置, 而配置的內容, 來自熱流體力學, 固體力學, 電子電機與資訊科技的內涵, 其中更因不同的設計、製造、控制與管理流程, 而產生不同的功用. 至於設計則隱含內容的表達與驗證, 其表達的方式通常指口語表達, 文字表達, 2D 圖形表達, 3D 影像表達, 理論分析表達與實體原型的表達等六大類. 因此機械設計專題, 就可以從熱流體力學, 固體力學, 電子電機與資訊科技的組合搭配中, 納入各種設計、製造、控制與管理工具的運用, 最後用表達方式加以呈現的差異, 進行分類. 換言之, 機械設計專題的題目與施行內容的分類, 可以從3個大軸向切入: 所包含的學門領域軸向, 也就是熱流體力學, 固體力學, 電子電機與資訊科技等. 所牽涉的流程層面, 也就是設計、製造、控制與管理流程等. 所使用的表達方式, 也就是口語表達, 文字表達, 2D 圖形表達, 3D 影像表達, 理論分析表達與實體原型的表達等. 其中隸屬於設計的工程設計面, 又可細分為: 選用設計, 也就是從現有的零件或配件群中選用的設計. 配置設計, 也就是根據所選擇的零配件加以組合, 以決定設計的組合順序或組合方式. 參數設計, 也就是決定內容所需的數據或尺寸. 原創設計, 也就是前所未見的配置參數設計或前所未見的整體設計. 重新設計, 也就是根據的新的需求、新的材料與元件發明, 所進行的設計. 客製化設計, 又稱為多選項設計, 也就是設計中的每一個功能, 都提供客戶不同等級的元件選擇所牽涉的設計. 總之, 這裡針對機械設計專題題目分類的目的, 在讓選擇專題題目與製作內容的成員能有些初步概念, 儘管機械設計的範圍很廣, 能夠採用的方式與納入的內容也很多, 但是只要關注機械設計所牽涉的領域、流程與表達方法, 使專題題目具有代表性與功能性, 就能讓最後交付的內容更具價值.","url":"http://project.mde.tw/blog/yen-ji-jie-she-ji-zhuan-ti-fen-lei.html"},{"tags":"Tutorial","title":"user - 使用者的範例網誌文章標題","text":"這裡放入 user 所寫的文章摘要 這裡為 user 所寫的文章主要內容","url":"http://project.mde.tw/blog/user-shi-yong-zhe-de-fan-li-wang-zhi-wen-zhang-biao-ti.html"},{"tags":"2016g1","title":"40323123 - 專題組員的範例文章標題","text":"這裡放入 40323123 所寫的文章摘要 這裡為 40323123 所寫的文章主要內容","url":"http://project.mde.tw/blog/40323123-zhuan-ti-zu-yuan-de-fan-li-wen-zhang-biao-ti.html"},{"tags":"Tutorial","title":"yen - 2016 年專題啟動","text":"利用 Github Pages 與 Pelican 建立協同專題製作網誌 機械設計工程網誌啟動 本網誌自 2016 Spring 開始啟動, 相關建置步驟如下: 以 https://github.com/coursemdetw 帳號建立 Gihub 倉儲 https://github.com/coursemdetw/project_site 將倉儲資料 git clone 到近端 利用 git branch 指令, 建立 gh-pages 分支 利用 git checkout 指令, 切換至 gh-pages 分支 開始建立 Pelican 網誌所需的協同架構資料 安排 users 目錄, 將分別存放各協同組員的 .leo 檔案 確定 gh-pages 分支中的網誌 http://coursemdetw.github.io/project_site/ 可以正常運作 根據 Github pages 專用網域設定說明 https://help.github.com/articles/using-a-custom-domain-with-github-pages/ , 建立 CNAME, 納入 project.mde.tw 將 https://github.com/coursemdetw/project_site 倉儲的 Default Branch 設為 gh-pages 分支 在 mde.tw 網域的 DNS 代管設定中, 加入 project.mde.tw 與 coursemdetw.github.io 之間的 CNAME 別名設定 等待 CNAME 別名生效後, http://project.mde.tw 即可正常連結使用 Pelican 網誌設定 由於本網誌將 Pelican https://github.com/getpelican/pelican 設定相關的所有資料都留在 Gihub 倉儲 https://github.com/coursemdetw/project_site 中, 目的在讓其他人可以參考本網誌的所有細節內容. 一般在實際應用, 只需將 blog 目錄 https://github.com/coursemdetw/project_site/tree/gh-pages/blog 中的資料送到全球資訊網伺服器即可. 本專題製作採用 http://leoeditor.com/ 管理所有資料, 但各參與協同的人員各自在 users 目錄下擁有一個 .leo 檔案, 可以分別控管本網誌的所有設定, 並且以協同方式維護網誌內容. 本網誌分為近端與 Github Pages 端的資料管理配置, 關鍵字搜尋採用 https://github.com/getpelican/pelican-plugins/tree/master/tipue_search , 近端的設定檔案為 local_publishconf.py, 而 Github Pages 端的特有設定為 publishconf.py, 且為了區隔兩端的資料連結差異, 近端的 Pelican 轉檔按鈕為 @button local pelican, 而 Github Pages 端的轉檔按鈕為 @button gh-pages pelican. 最後, 為了有效區隔各組員所寫的網誌文章, content 目錄內的各 .md 檔案, 除了要求必須冠上組員帳號外, 也希望在文章標題前面加上組員帳號標示, 以避免組員間因為使用相同的文章標題名稱而無法正確完成 Pelican 網誌的轉檔 (本系統採用自動文章標題轉換為 html 檔名的設定). 組員參與協同 所有專題製作成員均為 https://github.com/coursemdetw/project_site 倉儲的協同者, git clone 資料後, 即可將分支固定在 gh-pages 後進行各項資料協同管理的工作. 參與協同的步驟: git clone 倉儲資料. 確定在近端已經切換分支到 gh-pages, 利用 Leo Editor 開啟 users 目錄下的 user_template.leo 檔案. 修改 @edit user_20160301.md 的標題與內容, 例如, 將 @edit user_20160301.md 改為 @edit 學號_20160301.md, 且將 \"Title: user - 使用者的範例網誌文章標題\" 改為 \"Title: 學號 - 使用者的範例網誌文章標題\", \"Author: user\" 改為 \"Author: 學號\" 之後, 記得將已經修改過的 user_template.leo 存為 學號.leo 檔案. 在學號.leo 專案檔案中, 將滑鼠停在 @button local pelican 節點上, 再點擊 local-pelican 按鈕進行轉檔, 最後利用瀏覽器開啟 project_site 目錄中的 index.html, 檢查是否在近端可以正確轉檔. 若近端的 Pelican 網誌可以正確納入所新增的文章內容, 改將滑鼠停在 @button gh-pages pelican 節點上, 再點擊 gh-pages-pelican 按鈕, 進行 Github Pages 端所需要的內容轉檔. 利用 git add -A, git commit -m \"訊息\", git push origin gh-pages 等3個步驟, 將 gh-pages 分支資料, 提交並推送到 http://project.mde.tw 網誌資料儲存規劃 一個靜態網站的內容除了文字檔案外, 還包括 Javascript 檔案, Brython 檔案, 圖檔, 影片檔案, 以及其他各種非 html 的文件檔, 為了保有本網誌專案倉儲的簡潔, 除了必要的設定與文字檔案外, 其他資料均存放在倉儲以外的相關資源位置, 其規劃如下: Javascript 與 Brython 程式檔案, 除了儘量使用各 CDN 所提供的最新版本外, 目前以 https://github.com/2015fallhw/cptocadp/tree/master/static 對應的 OpenShift 網站存放, 例如, Cango-8v03.js 位於 http://cptocadp-2015fallhw.rhcloud.com/static/Cango-8v03.js 一般圖檔與非 html 文件檔案, 建議以 Github Pages 的網頁架構儲存在獨立的倉儲中, 且該倉儲僅存放檔案, 而無文字檔案, 例如: http://coursemdetw.github.io/project_site_files/files/kmol_1172x340_color_3yrs.png 即為其中的一個圖檔. 影片檔案則分別存在 https://vimeo.com/ 與 https://www.youtube.com/ (相同檔案各存一份). 圖檔引用 影片檔引用 Gocycle_disassemble from 虎尾科大機械設計工程 on Vimeo . 特別提醒 本網誌為了同時支援近端與遠端的資料內容使用, 資料轉檔分為近端按鈕與遠端按鈕, 協同成員在推送資料到遠端之前, 必須確定資料為遠端 Github Pages 格式. 鼓勵各成員深入研究本網誌的細節架構, 勇於提出問題, 解決問題, 打造出最適合機械設計工程團隊使用的網際協同架構、模式與系統工具.","url":"http://project.mde.tw/blog/yen-2016-nian-zhuan-ti-qi-dong.html"},{"tags":"Misc","title":"yen - Github Pages 網頁資料更新問題","text":"突然間, Github Pages 的網頁轉換機制不再更新 使用 Github Pages 建立網頁最大的問題就是, 在完全沒有任何錯誤訊息提醒的情況下, 送到 Github Pages 對應分支倉儲的資料不再成功轉為網頁資料. 因應之道, 只能刪除原先不再更新的倉儲, 另外再建立一個對應的 Github Pages 倉儲, 重新進行各項設定.","url":"http://project.mde.tw/blog/yen-github-pages-wang-ye-zi-liao-geng-xin-wen-ti.html"},{"tags":"Misc","title":"yen - 協同產品設計課程 Task0 延伸練習","text":"如何將電腦教室分組, 比序與排座位的流程網際自動化 在 https://chiamingyen.github.io/kmolab/blog/2016-spring-cd-task0.html 中, 說明了一個實際的電腦教室排座位的流程, 其中使用了網際即時試算表 https://ethercalc.tw/ , 以及幾個 Python3 的資料處理程式, 最後可以根據電腦教室的配置, 完成各組員的座位編排. 座位編排流程如下: 讓所有學員自行分組 分組確定後, 根據學號比序, 產生各組組長 再根據各組組長學號, 再進行組長學號比序, 以決定各組的組序 完成各組序與各組內的組員順序後, 再根據座位編排規定, 最後列出學員座位表, 讓學員依序入座 本機械設計專題製作練習, 希望能夠利用網際程式方法, 以 https://github.com/mitsuhiko/flask , https://www.sqlite.org/ 將流程自動化, 當操作者從網際即時試算表中取得各組分組資料後, 可以輸入本練習所完成的網站表單中, 然後操作者可以根據頁面中的選項, 選擇各組選出組長的方式, 依據學號增量排序, 學號最小者為組長, 或遞減排序, 學號大者為組長, 或者亂數排序後, 排序第一組為組長等三種選擇. 接著操作者可以在頁面選擇組序排列的選項, 也是學號遞增排序, 學號遞減排序或學號亂數排序, 以便訂出各組的組序. 當操作者決定各組內與組外的排序選項後, 按下\"排電腦教室座位\" (也可加入排座位的選項, 列先排, 行先排或者全部按亂數排. 完成座位安排後, 必須將各組組員名單與分組名單分別存入資料庫, 以便後續讓使用者查詢各組座位與分組資訊, 並且在隨後 加入各組員回報電腦使用情形與各組員自評登錄成績之應用. 原始倉儲資料: https://github.com/2015fallhw/2016springcd/tree/gh-pages","url":"http://project.mde.tw/blog/yen-xie-tong-chan-pin-she-ji-ke-cheng-task0-yan-shen-lian-xi.html"}]}