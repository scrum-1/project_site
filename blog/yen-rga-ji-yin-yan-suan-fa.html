<!DOCTYPE html>
<html lang="en"
>
<head>
    <title>yen - RGA 基因演算法 - 機械設計專題 (虎尾科大MDE)</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">




<style type="text/css">

/*some stuff for output/input prompts*/
div.cell{border:1px solid transparent;display:-webkit-box;-webkit-box-orient:vertical;-webkit-box-align:stretch;display:-moz-box;-moz-box-orient:vertical;-moz-box-align:stretch;display:box;box-orient:vertical;box-align:stretch;display:flex;flex-direction:column;align-items:stretch}div.cell.selected{border-radius:4px;border:thin #ababab solid}
div.cell.edit_mode{border-radius:4px;border:thin #008000 solid}
div.cell{width:100%;padding:5px 5px 5px 0;margin:0;outline:none}
div.prompt{min-width:11ex;padding:.4em;margin:0;font-family:monospace;text-align:right;line-height:1.21429em}
@media (max-width:480px){div.prompt{text-align:left}}div.inner_cell{display:-webkit-box;-webkit-box-orient:vertical;-webkit-box-align:stretch;display:-moz-box;-moz-box-orient:vertical;-moz-box-align:stretch;display:box;box-orient:vertical;box-align:stretch;display:flex;flex-direction:column;align-items:stretch;-webkit-box-flex:1;-moz-box-flex:1;box-flex:1;flex:1}
div.input_area{border:1px solid #cfcfcf;border-radius:4px;background:#f7f7f7;line-height:1.21429em}
div.prompt:empty{padding-top:0;padding-bottom:0}
div.input{page-break-inside:avoid;display:-webkit-box;-webkit-box-orient:horizontal;-webkit-box-align:stretch;display:-moz-box;-moz-box-orient:horizontal;-moz-box-align:stretch;display:box;box-orient:horizontal;box-align:stretch;}
div.inner_cell{width:90%;}
div.input_area{border:1px solid #cfcfcf;border-radius:4px;background:#f7f7f7;}
div.input_prompt{color:navy;border-top:1px solid transparent;}
div.output_wrapper{margin-top:5px;position:relative;display:-webkit-box;-webkit-box-orient:vertical;-webkit-box-align:stretch;display:-moz-box;-moz-box-orient:vertical;-moz-box-align:stretch;display:box;box-orient:vertical;box-align:stretch;width:100%;}
div.output_scroll{height:24em;width:100%;overflow:auto;border-radius:4px;-webkit-box-shadow:inset 0 2px 8px rgba(0, 0, 0, 0.8);-moz-box-shadow:inset 0 2px 8px rgba(0, 0, 0, 0.8);box-shadow:inset 0 2px 8px rgba(0, 0, 0, 0.8);}
div.output_collapsed{margin:0px;padding:0px;display:-webkit-box;-webkit-box-orient:vertical;-webkit-box-align:stretch;display:-moz-box;-moz-box-orient:vertical;-moz-box-align:stretch;display:box;box-orient:vertical;box-align:stretch;width:100%;}
div.out_prompt_overlay{height:100%;padding:0px 0.4em;position:absolute;border-radius:4px;}
div.out_prompt_overlay:hover{-webkit-box-shadow:inset 0 0 1px #000000;-moz-box-shadow:inset 0 0 1px #000000;box-shadow:inset 0 0 1px #000000;background:rgba(240, 240, 240, 0.5);}
div.output_prompt{color:darkred;}

a.anchor-link:link{text-decoration:none;padding:0px 20px;visibility:hidden;}
h1:hover .anchor-link,h2:hover .anchor-link,h3:hover .anchor-link,h4:hover .anchor-link,h5:hover .anchor-link,h6:hover .anchor-link{visibility:visible;}
/* end stuff for output/input prompts*/


.highlight-ipynb .hll { background-color: #ffffcc }
.highlight-ipynb  { background: #f8f8f8; }
.highlight-ipynb .c { color: #408080; font-style: italic } /* Comment */
.highlight-ipynb .err { border: 1px solid #FF0000 } /* Error */
.highlight-ipynb .k { color: #008000; font-weight: bold } /* Keyword */
.highlight-ipynb .o { color: #666666 } /* Operator */
.highlight-ipynb .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight-ipynb .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight-ipynb .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight-ipynb .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight-ipynb .gd { color: #A00000 } /* Generic.Deleted */
.highlight-ipynb .ge { font-style: italic } /* Generic.Emph */
.highlight-ipynb .gr { color: #FF0000 } /* Generic.Error */
.highlight-ipynb .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight-ipynb .gi { color: #00A000 } /* Generic.Inserted */
.highlight-ipynb .go { color: #888888 } /* Generic.Output */
.highlight-ipynb .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight-ipynb .gs { font-weight: bold } /* Generic.Strong */
.highlight-ipynb .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight-ipynb .gt { color: #0044DD } /* Generic.Traceback */
.highlight-ipynb .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight-ipynb .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight-ipynb .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight-ipynb .kp { color: #008000 } /* Keyword.Pseudo */
.highlight-ipynb .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight-ipynb .kt { color: #B00040 } /* Keyword.Type */
.highlight-ipynb .m { color: #666666 } /* Literal.Number */
.highlight-ipynb .s { color: #BA2121 } /* Literal.String */
.highlight-ipynb .na { color: #7D9029 } /* Name.Attribute */
.highlight-ipynb .nb { color: #008000 } /* Name.Builtin */
.highlight-ipynb .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight-ipynb .no { color: #880000 } /* Name.Constant */
.highlight-ipynb .nd { color: #AA22FF } /* Name.Decorator */
.highlight-ipynb .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight-ipynb .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight-ipynb .nf { color: #0000FF } /* Name.Function */
.highlight-ipynb .nl { color: #A0A000 } /* Name.Label */
.highlight-ipynb .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight-ipynb .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight-ipynb .nv { color: #19177C } /* Name.Variable */
.highlight-ipynb .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight-ipynb .w { color: #bbbbbb } /* Text.Whitespace */
.highlight-ipynb .mf { color: #666666 } /* Literal.Number.Float */
.highlight-ipynb .mh { color: #666666 } /* Literal.Number.Hex */
.highlight-ipynb .mi { color: #666666 } /* Literal.Number.Integer */
.highlight-ipynb .mo { color: #666666 } /* Literal.Number.Oct */
.highlight-ipynb .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight-ipynb .sc { color: #BA2121 } /* Literal.String.Char */
.highlight-ipynb .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight-ipynb .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight-ipynb .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight-ipynb .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight-ipynb .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight-ipynb .sx { color: #008000 } /* Literal.String.Other */
.highlight-ipynb .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight-ipynb .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight-ipynb .ss { color: #19177C } /* Literal.String.Symbol */
.highlight-ipynb .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight-ipynb .vc { color: #19177C } /* Name.Variable.Class */
.highlight-ipynb .vg { color: #19177C } /* Name.Variable.Global */
.highlight-ipynb .vi { color: #19177C } /* Name.Variable.Instance */
.highlight-ipynb .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>

<style type="text/css">
/* Overrides of notebook CSS for static HTML export */
div.entry-content {
  overflow: visible;
  padding: 8px;
}
.input_area {
  padding: 0.2em;
}

a.heading-anchor {
 white-space: normal;
}

.rendered_html
code {
 font-size: .8em;
}

pre.ipynb {
  color: black;
  background: #f7f7f7;
  border: none;
  box-shadow: none;
  margin-bottom: 0;
  padding: 0;
  margin: 0px;
  font-size: 13px;
}

/* remove the prompt div from text cells */
div.text_cell .prompt {
    display: none;
}

/* remove horizontal padding from text cells, */
/* so it aligns with outer body text */
div.text_cell_render {
    padding: 0.5em 0em;
}

img.anim_icon{padding:0; border:0; vertical-align:middle; -webkit-box-shadow:none; -box-shadow:none}
</style>

<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
<script type="text/javascript">
init_mathjax = function() {
    if (window.MathJax) {
        // MathJax loaded
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            },
            displayAlign: 'left', // Change this to 'center' to center equations.
            "HTML-CSS": {
                styles: {'.MathJax_Display': {"margin": 0}}
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    }
}
init_mathjax();
</script>

<link rel="canonical" href="http://project.mde.tw/blog/yen-rga-ji-yin-yan-suan-fa.html">

        <meta name="author" content="yen" />
        <meta name="keywords" content="RGA" />
        <meta name="description" content="RGA 為 Real-coded Genetic Algorithm, 也就是實數編碼基因演算法, 以下為平面四連桿機構, 令其移動桿三角形頂點通過特定的 10 個座標點的尺寸合成運算." />

        <meta property="og:site_name" content="機械設計專題 (虎尾科大MDE)" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="yen - RGA 基因演算法"/>
        <meta property="og:url" content="http://project.mde.tw/blog/yen-rga-ji-yin-yan-suan-fa.html"/>
        <meta property="og:description" content="RGA 為 Real-coded Genetic Algorithm, 也就是實數編碼基因演算法, 以下為平面四連桿機構, 令其移動桿三角形頂點通過特定的 10 個座標點的尺寸合成運算."/>
        <meta property="article:published_time" content="2016-07-01" />
            <meta property="article:section" content="Tutorial" />
            <meta property="article:tag" content="RGA" />
            <meta property="article:author" content="yen" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://project.mde.tw/blog/theme/css/bootstrap.united.min.css" type="text/css"/>
    <link href="http://project.mde.tw/blog/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://project.mde.tw/blog/theme/css/pygments/monokai.css" rel="stylesheet">
    <link href="http://project.mde.tw/blog/theme/tipuesearch/tipuesearch.css" rel="stylesheet">
    <link rel="stylesheet" href="http://project.mde.tw/blog/theme/css/style.css" type="text/css"/>

        <link href="http://project.mde.tw/blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="機械設計專題 (虎尾科大MDE) ATOM Feed"/>

<script type="text/javascript" src="http://coursemdetw.github.io/project_site_files/files/syntaxhighlighter/shCore.js"></script>
<script type="text/javascript" src="http://coursemdetw.github.io/project_site_files/files/syntaxhighlighter/shBrushJScript.js"></script>
<script type="text/javascript" src="http://coursemdetw.github.io/project_site_files/files/syntaxhighlighter/shBrushJava.js"></script>
<script type="text/javascript" src="http://coursemdetw.github.io/project_site_files/files/syntaxhighlighter/shBrushPython.js"></script>
<script type="text/javascript" src="http://coursemdetw.github.io/project_site_files/files/syntaxhighlighter/shBrushSql.js"></script>
<script type="text/javascript" src="http://coursemdetw.github.io/project_site_files/files/syntaxhighlighter/shBrushXml.js"></script>
<script type="text/javascript" src="http://coursemdetw.github.io/project_site_files/files/syntaxhighlighter/shBrushPhp.js"></script>
<script type="text/javascript" src="http://coursemdetw.github.io/project_site_files/files/syntaxhighlighter/shBrushCpp.js"></script>
<script type="text/javascript" src="http://coursemdetw.github.io/project_site_files/files/syntaxhighlighter/shBrushCss.js"></script>
<script type="text/javascript" src="http://coursemdetw.github.io/project_site_files/files/syntaxhighlighter/shBrushCSharp.js"></script>
<script type="text/javascript" src="http://coursemdetw.github.io/project_site_files/files/syntaxhighlighter/shBrushBash.js"></script>
<script type='text/javascript'>
	(function(){
		var corecss = document.createElement('link');
		var themecss = document.createElement('link');
		var corecssurl = "http://chiamingyen.github.io/kmolab_data/files/syntaxhighlighter/css/shCore.css";
		if ( corecss.setAttribute ) {
				corecss.setAttribute( "rel", "stylesheet" );
				corecss.setAttribute( "type", "text/css" );
				corecss.setAttribute( "href", corecssurl );
		} else {
				corecss.rel = "stylesheet";
				corecss.href = corecssurl;
		}
		document.getElementsByTagName("head")[0].insertBefore( corecss, document.getElementById("syntaxhighlighteranchor") );
		var themecssurl = "http://chiamingyen.github.io/kmolab_data/files/syntaxhighlighter/css/shThemeDefault.css?ver=3.0.9b";
		if ( themecss.setAttribute ) {
				themecss.setAttribute( "rel", "stylesheet" );
				themecss.setAttribute( "type", "text/css" );
				themecss.setAttribute( "href", themecssurl );
		} else {
				themecss.rel = "stylesheet";
				themecss.href = themecssurl;
		}
		//document.getElementById("syntaxhighlighteranchor").appendChild(themecss);
		document.getElementsByTagName("head")[0].insertBefore( themecss, document.getElementById("syntaxhighlighteranchor") );
	})();
	SyntaxHighlighter.config.strings.expandSource = '+ expand source';
	SyntaxHighlighter.config.strings.help = '?';
	SyntaxHighlighter.config.strings.alert = 'SyntaxHighlighter\n\n';
	SyntaxHighlighter.config.strings.noBrush = 'Can\'t find brush for: ';
	SyntaxHighlighter.config.strings.brushNotHtmlScript = 'Brush wasn\'t configured for html-script option: ';
	SyntaxHighlighter.defaults['pad-line-numbers'] = false;
	SyntaxHighlighter.defaults['toolbar'] = false;
	SyntaxHighlighter.all();
</script>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://project.mde.tw/blog/" class="navbar-brand">
機械設計專題 (虎尾科大MDE)            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                         <li><a href="http://project.mde.tw/blog/pages/about/">
                             About
                          </a></li>
                        <li >
                            <a href="http://project.mde.tw/blog/category/2016bg2.html">2016bg2</a>
                        </li>
                        <li >
                            <a href="http://project.mde.tw/blog/category/2016g1.html">2016g1</a>
                        </li>
                        <li >
                            <a href="http://project.mde.tw/blog/category/misc.html">Misc</a>
                        </li>
                        <li class="active">
                            <a href="http://project.mde.tw/blog/category/tutorial.html">Tutorial</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><span>
                <form class="navbar-search" action="http://project.mde.tw/blog/search.html">
                  <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input" required>
                </form></span>
              </li>
              <li><a href="http://project.mde.tw/blog/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">

    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="http://project.mde.tw/blog/yen-rga-ji-yin-yan-suan-fa.html"
                       rel="bookmark"
                       title="Permalink to yen - RGA 基因演算法">
                        yen - RGA 基因演算法
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2016-07-01T12:10:06.041363+08:00"> 週五 01 七月 2016</time>
    </span>
            <span class="label label-default">By</span>
            <a href="http://project.mde.tw/blog/author/yen.html"><i class="fa fa-user"></i> yen</a>



<span class="label label-default">Tags</span>
	<a href="http://project.mde.tw/blog/tag/rga.html">RGA</a>
    
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>RGA 為 Real-coded Genetic Algorithm, 也就是實數編碼基因演算法, 以下為平面四連桿機構, 令其移動桿三角形頂點通過特定的 10 個座標點的尺寸合成運算.</p>


<pre class="brush: python">
# https://github.com/flukeskywalker/PyRGA
# 原始程式為 Python2 修改為 Python3 格式
# 除了原先的最大化適應值外, 增加最小化方法設定
import numpy as np
import random
from math import *

# 請注意各代族群數必須為 4 的倍數
class GA: # popsize must be multiple of 4
    def __init__(self, obj, dim, popsize, ngen, pc, pm, etac, etam, min):
        self.EPSILON = 10e-6
        self.INFINITY = 10e6
        self.pop = []
        self.fits = []
        self.obj = obj
        self.dim = dim
        self.popsize = popsize
        self.ngen = ngen
        self.pc = pc
        self.pm = pm
        self.etac = etac
        self.etam = etam
        # min = 1 表最小化, min = -1 表最大化
        self.min = min
        self.RIGID = 0
        self.lowb = -self.INFINITY*np.ones(self.dim)
        self.highb = self.INFINITY*np.ones(self.dim)
        self.tourneylist = range(0, self.popsize)
        self.tourneysize = 2 # works for 2 for now
        self.bestmemyet = np.zeros(self.dim)
        # 若是求最大值
        if self.min == -1:
            self.bestfityet = -np.inf
        else:
        # 若是求最小值
            self.bestfityet = np.inf
        self.pop_init()

    def pop_init(self):
        self.pop = [np.random.rand(self.dim) for _ in range(self.popsize)]
        for member in self.pop:
            for i in range(self.dim):
                member[i] = self.lowb[i] + member[i]*(self.highb[i]-self.lowb[i])
        self.fits = [self.obj(member) for member in self.pop]
        #self.pop_print()
        return

    def setbounds(self, lows, highs):
        for i in range(self.dim):
            self.lowb[i] = lows[i]
            self.highb[i] = highs[i]
        self.pop_init()
        return

    def run(self):
        for gen in range(self.ngen):
            print("Generation ", gen)
            self.pop = self.getnewpop()
            self.eval_pop()
            #self.pop_print()
        return [self.bestmemyet, self.bestfityet]

    def getnewpop(self):
        newpop = []
        #self.tourneylist = range(0, self.popsize)
        random.shuffle(list(self.tourneylist))
        self.tourneypos = 0
        for i in range(0, self.popsize, 2):
            [p1, p2] = self.getparents() #return parents, not just indices
            [c1, c2] = self.xover(p1, p2) #return children, not just indices
            c1 = self.mutate(c1)
            c2 = self.mutate(c2)
            newpop.append(c1)
            newpop.append(c2)
        return newpop

    def getparents(self):
        if (self.popsize - self.tourneypos) < self.tourneysize:
            random.shuffle(list(self.tourneylist))
            self.tourneypos = 0
        if self.min == -1:
            if (self.fits[self.tourneylist[self.tourneypos]]>self.fits[self.tourneylist[self.tourneypos+1]]):
                p1 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p1 = self.pop[self.tourneylist[self.tourneypos+1]]
        else:
            if (self.fits[self.tourneylist[self.tourneypos]]<self.fits[self.tourneylist[self.tourneypos+1]]):
                p1 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p1 = self.pop[self.tourneylist[self.tourneypos+1]]
        self.tourneypos += self.tourneysize

        if self.min == -1:
            if (self.fits[self.tourneylist[self.tourneypos]]>self.fits[self.tourneylist[self.tourneypos+1]]):
                p2 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p2 = self.pop[self.tourneylist[self.tourneypos+1]]
        else:
            if (self.fits[self.tourneylist[self.tourneypos]]<self.fits[self.tourneylist[self.tourneypos+1]]):
                p2 = self.pop[self.tourneylist[self.tourneypos]]
            else:
                p2 = self.pop[self.tourneylist[self.tourneypos+1]]
        self.tourneypos += self.tourneysize
        return [p1, p2]

    def xover(self, p1, p2): # Here p1 and p2 are pop members
        c1 = np.zeros_like(p1)
        c2 = np.zeros_like(p2)
        if random.random()<=self.pc: # do crossover
            for i in range(p1.size):
                if random.random()<0.5: # 50% variables crossover
                    [c1[i], c2[i]] = self.crossvars(p1[i], p2[i], self.lowb[i], self.highb[i])
                else:
                    [c1[i], c2[i]] = [p1[i], p2[i]]
        else:
            c1 = p1
            c2 = p2
        return [c1, c2]

    def crossvars(self, p1, p2, low, high): # Here p1 and p2 are variables
        if p1>p2:
            p1, p2 = p2, p1 # p1 must be smaller
        mean = (p1+p2)*0.5
        diff = (p2-p1)
        dist = max(min(p1-low, high-p2), 0)
        if (self.RIGID and diff > self.EPSILON):
            alpha = 1.0 + (2.0*dist/diff)
            umax = 1.0 - (0.5/pow(alpha, (self.etac+1.0)))
            seed = umax*random.random()
        else:
            seed = random.random()
        beta = self.getbeta(seed)
        if (abs(diff*beta) > self.INFINITY):
            beta = self.INFINITY/diff
        c2 = mean + beta*0.5*diff
        c1 = mean - beta*0.5*diff
        c1 = max(low, min(c1, high))
        c2 = max(low, min(c2, high))
        return [c1, c2]

    def getbeta(self, seed):
        if (1 - seed) < self.EPSILON:
            seed = 1 - self.EPSILON
        seed = max(0.0, seed)
        if seed < 0.5:
            beta = pow(2.0*seed, (1.0/(self.etac+1.0)))
        else:
            beta = pow((0.5/(1.0-seed)), (1.0/(self.etac+1.0)))
        return beta

    def getdelta(self, seed, delta_low, delta_high):
        if seed >= 1.0 - (self.EPSILON/1e3):
            return delta_high
        if seed <= (self.EPSILON/1e3):
            return delta_low
        if seed <= 0.5:
            dummy = 2.0*seed + (1.0 - 2.0*seed)*pow((1+delta_low), (self.etam+1.0))
            delta = pow(dummy, (1.0/(self.etam+1.0))) - 1.0
        else:
            dummy = 2.0*(1.0 - seed) + 2.0*(seed - 0.5)*pow((1-delta_high), (self.etam+1.0))
            delta = 1.0 - pow(dummy, (1.0/(self.etam+1.0)))
        return delta

    def mutate(self, member):
        mut_member = np.zeros_like(member)
        for i in range(member.size):
            low = self.lowb[i]
            high = self.highb[i]
            if random.random() <= self.pm: # pm is simply the prob of a variable to mutate
                if self.RIGID:
                    value = member[i]
                    delta_low = max((low-value)/(high-low), -1.0)
                    delta_high = min((high-value)/(high-low), 1.0)
                    if abs(delta_low)<abs(delta_high):
                        delta_high = -delta_low
                    else:
                        delta_low = -delta_high
                else:
                    delta_low = -1.0
                    delta_high = 1.0
                seed = random.random()
                delta = self.getdelta(seed, delta_low, delta_high)*(high-low)
                mut_member[i] = max(low, min(member[i] + delta, high))
            else:
                mut_member[i] = member[i]
        return mut_member

    def eval_pop(self):
        self.fits = [self.obj(member) for member in self.pop]
        # 若是最大化適應值題目者
        if self.min == -1:
            # 將所有適應值中最大者, 指向 bestindex
            bestindex = np.argmax(self.fits)
        else:
            # 將所有適應值中最大者, 指向 bestindex
            bestindex = np.argmin(self.fits)
        bestmember = self.pop[bestindex]
        bestfitness = self.fits[bestindex]
        # self.min = -1 for maximization, self.min = 1 for minimization
        if self.min == -1:
            # 若是在族群中的最佳適應值大於目前為止最佳的適應值
            if bestfitness > self.bestfityet:
                # 則將此最大適應值指為目前為止最佳適應值
                self.bestfityet = bestfitness
                # 並且將最佳族群成員指向目前最佳成員
                self.bestmemyet = bestmember
        else:
            if bestfitness < self.bestfityet:
                self.bestfityet = bestfitness
                self.bestmemyet = bestmember
        print("Current best: ", bestfitness, "Best yet: ", self.bestfityet)

    def pop_print(self):
        for i in range(self.popsize):
            print(self.pop[i], self.fits[i])
        return

# 若單獨存在則需導入 GA 所有方法
#import GA
#from GA import *
import numpy as np

def square(x):
    term1 = (x[0]*x[0]+x[1]-11.0)*(x[0]*x[0]+x[1]-11.0)
    term2 = (x[0]+x[1]*x[1]- 7.0)*(x[0]+x[1]*x[1]- 7.0)
    term3 = term1+term2
    return term3

# 最大化體積題目
def volume(x):
    surface = 80.0
    z = (surface-x[0]*x[1])/(2.0*(x[0]+x[1]))
    volume = x[0]*x[1]*z
    return volume


def miniex1(x):
    '''Minimizing Beale's function (optimal value f(3, 0.5) = 0):
    ga=GA(miniex1, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.3, etac=2, etam=100, min=1)
    ga.setbounds(np.zeros(10), 10*np.ones(10))
    '''
    term1 = 1.5 - x[0] + x[0]*x[1]
    term2 = 2.25 - x[0] + x[0]*x[1]*x[1]
    term3 = 2.625 - x[0] + x[0]*x[1]*x[1]*x[1]
    return term1*term1 + term2*term2 + term3*term3

def miniex2(x):
    '''Schaffer function #2. Minimium at (0,0), equal to 0
    ga=GA(miniex2, dim=2, popsize=100, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)
    ga.setbounds(np.zeros(10), 10*np.ones(10))
    '''
    return 0.5 + (pow(sin(x[0]*x[0]-x[1]*x[1]), 2) - 0.5)/pow(1+0.001*(x[0]*x[0]+x[1]*x[1]), 2)

''' 開始四連桿運算
'''
class Point(object):
    '''Creates a point on a coordinate plane with values x and y.'''
    def __init__(self, x, y):
        '''Defines x and y variables'''
        self.x = x
        self.y = y

def triangletip_coord(x0, y0, R0, R1, x1, y1, localt):
    mech_loop = -1
    tip_coord = Point(0,0)
    if (localt >= 0 and localt < pi):
        # 計算 tip 點的 x 座標
        tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0
        # 計算 tip 點的 y 座標
        tip_coord.y = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0
    else:
        # 計算 tip 點的 x 座標
        tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0
        # 計算 tip 點的 y 座標
        tip_coord.y = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0
    return tip_coord

def distance(x0, y0, x1, y1):
    return sqrt(pow((x1-x0),2) + pow((y1-y0),2))

def rr(L1, dd, theta):
    return sqrt(L1*L1+dd*dd-2*L1*dd*cos(theta))

# input_angles  = [] 也就是必須為 list 且各樹為 NUM_OF_POINTS
def mechanism(x0, y0, x1, y1, L1, L2, L3, L5, L6, input_angles):
    '''
    mechanism(0,0,10,0,5,20,10,10,10,input_angles)
    x0 = 0.0;
    y0 = 0.0;
    x1 = 10.0;
    y1 = 0.0;
    L1 = 5.0;
    L2 = 10;
    L3 = 10;
    L5 = 10;
    L6 = 10;
    '''
    link1_tip = Point(0,0)
    link2_tip = Point(0,0)
    output_points = list()
    degree = pi/180.
    NUM_OF_POINTS = 5
    dd_length = distance(x0, y0, x1, y1)
    # 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式
    angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5));
    for i in range(NUM_OF_POINTS):
        angle = input_angles[i]*degree
        rr_length = rr(L1, dd_length, angle)
        # 第一次三角形疊代
        link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle)
        #print(angle, rr_length, link1_tip.x, link1_tip.y)
        # 第二次三角形疊代
        # 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式
        angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length))
        link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2)
        # 第三次三角形疊代 (改為以 finaltip_coord() 取值, 而非第三次疊代
        '''
        triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        '''
        # 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負
        output_points.append(finaltip_coord(link1_tip, link2_tip, L5, L6))
    return output_points

def finaltip_coord(tip1_coord, tip2_coord, r1, r2):
    tip3_coord = Point(0,0)
    length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2))
    length4 = sqrt(pow(r1,2) + pow(r2,2))
    theta3 = acos((tip2_coord.x - tip1_coord.x) / length3)
    theta4 = acos(r1/length4)
    tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4)
    tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4)
    return tip3_coord

# 誤差函式
def error_function(output_points, target_points):
    NUM_OF_POINTS = 5
    error = 0
    for i in range(NUM_OF_POINTS):
        error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y))
    return error

# 組成機構的變數個樹 9 + 通過點數所對應的角度值, 若通過 5 點則共有 14 個變數
#   mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points);
def fourbar(x):
    PENALITY = 1000
    NUM_OF_POINTS = 10

    # x0 與 x1 點位於 -50 與 50 中間, 0, 1, 2, 3
    for i in range(4):
        if(x[i] < -50 or x[i] > 50):
            return PENALITY
    # 三個連桿值, 一定要為正, 4, 5, 6,
    for i in range(4, 7):
        if(x[i] < 0 or x[i] >50):
            return PENALITY

    # L5 L6 可以為 0 或負值, 7, 8 
    for i in range(7, 9):
        if(x[i] < -50 or x[i] > 50):
            return PENALITY

    # 角度值一定要大於 0
    for i in range(NUM_OF_POINTS):
        if(x[9+i] < 0):
            return PENALITY

    result = 0
    target_points = list()
    output_points = list()
    input_angles = list()
    # 定義四連桿關鍵點所要通過的點
    p1 = Point(1, 1)
    p2 = Point(2, 2)
    p3 = Point(3, 3)
    p4 = Point(4, 4)
    p5 = Point(5, 5)
    p6 = Point(6, 6)
    p7 = Point(7, 7)
    p8 = Point(8, 8)
    p9 = Point(9, 9)
    p10 = Point(10, 10)
    target_points = [p1, p2, p3, p4, p5, p6, p7, p8, p9, p10]
    for i in range(9, 9+NUM_OF_POINTS):
        input_angles.append(x[i])
    # 這裡要加入查驗各參數是否符合四連桿組成條件
    try:
        output_points = mechanism(x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],input_angles)
    except:
        return PENALITY
    result = error_function(output_points, target_points)
    return result

#ga=GA(square, dim=2, popsize=40, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)
# min = -1 表示要最大化適應方程式的值, 若 min = 1 表示要最小化
#ga=GA(volume, dim=2, popsize=400, ngen=500, pc=0.9, pm=0.1, etac=2, etam=100, min=-1)
# 請注意 popsize 必須為 4 的倍數
#ga=GA(miniex1, dim=2, popsize=12, ngen=50, pc=0.9, pm=0.1, etac=2, etam=100, min=1)
ga=GA(fourbar, dim=19, popsize=120000, ngen=10000, pc=0.9, pm=0.5, etac=2, etam=100, min=1)
#ga.setbounds(np.zeros(10), 10*np.ones(10))
#ga.setbounds(-10*np.ones(10), 10*np.ones(10))
ga.setbounds(-50*np.ones(20), 50*np.ones(20))
#ga.pop_init()
print(ga.run())
</pre>

<p>利用 C 與 Differential Evolution 解上述相同問題的原始碼:</p>
<pre class="brush: c">
    // 必須在演算過程中, 設法限制各變數的上下限!!! 否則演化非常容易發散??

    /***************************************************************
    **                                                            **
    **        D I F F E R E N T I A L     E V O L U T I O N       **
    **                                                            **
    ** Program: de.c                                              **
    ** Version: 3.6                                               **
    **                                                            **
    ** Authors: Dr. Rainer Storn                                  **
    **          c/o ICSI, 1947 Center Street, Suite 600           **
    **          Berkeley, CA 94707                                **
    **          Tel.:   510-642-4274 (extension 192)              **
    **          Fax.:   510-643-7684                              **
    **          E-mail: storn@icsi.berkeley.edu                   **
    **          WWW: http://http.icsi.berkeley.edu/~storn/        **
    **          on leave from                                     **
    **          Siemens AG, ZFE T SN 2, Otto-Hahn Ring 6          **
    **          D-81739 Muenchen, Germany                         **
    **          Tel:    636-40502                                 **
    **          Fax:    636-44577                                 **
    **          E-mail: rainer.storn@zfe.siemens.de               **
    **                                                            **
    **          Kenneth Price                                     **
    **          836 Owl Circle                                    **
    **          Vacaville, CA 95687                               **
    **          E-mail: kprice@solano.community.net               ** 
    **                                                            **
    ** This program implements some variants of Differential      **
    ** Evolution (DE) as described in part in the techreport      **
    ** tr-95-012.ps of ICSI. You can get this report either via   **
    ** ftp.icsi.berkeley.edu/pub/techreports/1995/tr-95-012.ps.Z  **
    ** or via WWW: http://http.icsi.berkeley.edu/~storn/litera.html*
    ** A more extended version of tr-95-012.ps is submitted for   **
    ** publication in the Journal Evolutionary Computation.       ** 
    **                                                            **
    ** You may use this program for any purpose, give it to any   **
    ** person or change it according to your needs as long as you **
    ** are referring to Rainer Storn and Ken Price as the origi-  **
    ** nators of the the DE idea.                                 **
    ** If you have questions concerning DE feel free to contact   **
    ** us. We also will be happy to know about your experiences   **
    ** with DE and your suggestions of improvement.               **
    **                                                            **
    ***************************************************************/
    /**H*O*C**************************************************************
    **                                                                  **
    ** No.!Version! Date ! Request !    Modification           ! Author **
    ** ---+-------+------+---------+---------------------------+------- **
    **  1 + 3.1  +5/18/95+   -     + strategy DE/rand-to-best/1+  Storn **
    **    +      +       +         + included                  +        **
    **  1 + 3.2  +6/06/95+C.Fleiner+ change loops into memcpy  +  Storn **
    **  2 + 3.2  +6/06/95+   -     + update comments           +  Storn **
    **  1 + 3.3  +6/15/95+ K.Price + strategy DE/best/2 incl.  +  Storn **
    **  2 + 3.3  +6/16/95+   -     + comments and beautifying  +  Storn **
    **  3 + 3.3  +7/13/95+   -     + upper and lower bound for +  Storn **
    **    +      +       +         + initialization            +        **
    **  1 + 3.4  +2/12/96+   -     + increased printout prec.  +  Storn **
    **  1 + 3.5  +5/28/96+   -     + strategies revisited      +  Storn **
    **  2 + 3.5  +5/28/96+   -     + strategy DE/rand/2 incl.  +  Storn **
    **  1 + 3.6  +8/06/96+ K.Price + Binomial Crossover added  +  Storn **
    **  2 + 3.6  +9/30/96+ K.Price + cost variance output      +  Storn **
    **  3 + 3.6  +9/30/96+   -     + alternative to ASSIGND    +  Storn **
    **  4 + 3.6  +10/1/96+   -    + variable checking inserted +  Storn **
    **  5 + 3.6  +10/1/96+   -     + strategy indic. improved  +  Storn **
    **                                                                  **
    ***H*O*C*E***********************************************************/

    #include "stdio.h"
    #include "stdlib.h"
    #include "math.h"
    #include "memory.h"
    #include &lt;time.h&gt;

    // 最大族群數, NP
    #define MAXPOP  5000
    // 最大向量維度, D
    #define MAXDIM  35
    #define MAXIMAPROBLEM 0
    #define PENALITY 1000

    /*------Constants for rnd_uni()--------------------------------------------*/

    #define IM1 2147483563
    #define IM2 2147483399
    #define AM (1.0/IM1)
    #define IMM1 (IM1-1)
    #define IA1 40014
    #define IA2 40692
    #define IQ1 53668
    #define IQ2 52774
    #define IR1 12211
    #define IR2 3791
    #define NTAB 32
    #define NDIV (1+IMM1/NTAB)
    #define EPS 1.2e-7
    #define RNMX (1.0-EPS)

    // 與機構合成相關的常數定義
    #define PI 3.1415926
    #define degree PI/180.0
    #define mech_loop -1
    #define NUM_OF_POINTS 10

    /*------------------------Macros----------------------------------------*/

    /*#define ASSIGND(a,b) memcpy((a),(b),sizeof(double)*D) */  /* quick copy by Claudio */
                                                               /* works only for small  */
                                                               /* arrays, but is faster.*/

    /*------------------------Globals---------------------------------------*/

    long  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */
    double c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];
    double (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];

    /*---------Function declarations----------------------------------------*/

    void  assignd(int D, double a[], double b[]);
    double rnd_uni(long *idum);    /* uniform pseudo random number generator */
    double extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */

    // 與機構合成相關的函式宣告
    double distance(double x0, double y0, double x1, double y1);
    double rr(double L1, double dd, double theta);
    struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt);
    void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]);
    double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]);

    struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2);

    /*---------Function definitions-----------------------------------------*/
    // 指定向量 b 為 a
    void  assignd(int D, double a[], double b[])
    /**C*F****************************************************************
    **                                                                  **
    ** Assigns D-dimensional vector b to vector a.                      **
    ** You might encounter problems with the macro ASSIGND on some      **
    ** machines. If yes, better use this function although it's slower. **
    **                                                                  **
    ***C*F*E*************************************************************/
    {
       int j;
       for (j=0; j&lt;D; j++)
       {
          a[j] = b[j];
       }
    }

    // 產生 0 ~ 1 間的亂數
    double rnd_uni(long *idum)
    /**C*F****************************************************************
    **                                                                  **
    ** SRC-FUNCTION   :rnd_uni()                                        **
    ** LONG_NAME      :random_uniform                                   **
    ** AUTHOR         :(see below)                                      **
    **                                                                  **
    ** DESCRIPTION    :rnd_uni() generates an equally distributed ran-  **
    **                 dom number in the interval [0,1]. For further    **
    **                 reference see Press, W.H. et alii, Numerical     **
    **                 Recipes in C, Cambridge University Press, 1992.  **
    **                                                                  **
    ** FUNCTIONS      :none                                             **
    **                                                                  **
    ** GLOBALS        :none                                             **
    **                                                                  **
    ** PARAMETERS     :*idum    serves as a seed value                  **
    **                                                                  **
    ** PRECONDITIONS  :*idum must be negative on the first call.        **
    **                                                                  **
    ** POSTCONDITIONS :*idum will be changed                            **
    **                                                                  **
    ***C*F*E*************************************************************/
    {
      long j;
      long k;
      static long idum2=123456789;
      static long iy=0;
      static long iv[NTAB];
      double temp;

      if (*idum &lt;= 0)
      {
        if (-(*idum) &lt; 1) *idum=1;
        else *idum = -(*idum);
        idum2=(*idum);
        for (j=NTAB+7;j&gt;=0;j--)
        {
          k=(*idum)/IQ1;
          *idum=IA1*(*idum-k*IQ1)-k*IR1;
          if (*idum &lt; 0) *idum += IM1;
          if (j &lt; NTAB) iv[j] = *idum;
        }
        iy=iv[0];
      }
      k=(*idum)/IQ1;
      *idum=IA1*(*idum-k*IQ1)-k*IR1;
      if (*idum &lt; 0) *idum += IM1;
      k=idum2/IQ2;
      idum2=IA2*(idum2-k*IQ2)-k*IR2;
      if (idum2 &lt; 0) idum2 += IM2;
      j=iy/NDIV;
      iy=iv[j]-idum2;
      iv[j] = *idum;
      if (iy &lt; 1) iy += IMM1;
      if ((temp=AM*iy) &gt; RNMX) return RNMX;
      else return temp;

    }/*------End of rnd_uni()--------------------------*/

    // 將上下限轉為全域變數
    double inibound_h;      /* upper parameter bound              */
    double inibound_l;      /* lower parameter bound              */
    // 與機構合成相關的全域變數
    // 宣告一個座標結構
    struct Coord {
        double x;
        double y;
      // 這裡保留 double z;
    };

    main(int argc, char *argv[])
    /**C*F****************************************************************
    **                                                                  **
    ** SRC-FUNCTION   :main()                                           **
    ** LONG_NAME      :main program                                     **
    ** AUTHOR         :Rainer Storn, Kenneth Price                      **
    **                                                                  **
    ** DESCRIPTION    :driver program for differential evolution.       **
    **                                                                  **
    ** FUNCTIONS      :rnd_uni(), evaluate(), printf(), fprintf(),      **
    **                 fopen(), fclose(), fscanf().                     **
    **                                                                  **
    ** GLOBALS        :rnd_uni_init    input variable for rnd_uni()     **
    **                                                                  **
    ** PARAMETERS     :argc            #arguments = 3                   **
    **                 argv            pointer to argument strings      **
    **                                                                  **
    ** PRECONDITIONS  :main must be called with three parameters        **
    **                 e.g. like de1 &lt;input-file&gt; &lt;output-file&gt;, if     **
    **                 the executable file is called de1.               **
    **                 The input file must contain valid inputs accor-  **
    **                 ding to the fscanf() section of main().          **
    **                                                                  **
    ** POSTCONDITIONS :main() produces consecutive console outputs and  **
    **                 writes the final results in an output file if    **
    **                 the program terminates without an error.         **
    **                                                                  **
    ***C*F*E*************************************************************/

    {
       char  chr;             /* y/n choice variable                */
       char  *strat[] =       /* strategy-indicator                 */
       {
                "",
                "DE/best/1/exp",
                "DE/rand/1/exp",
                "DE/rand-to-best/1/exp",
                "DE/best/2/exp",
                "DE/rand/2/exp",
                "DE/best/1/bin",
                "DE/rand/1/bin",
                "DE/rand-to-best/1/bin",
                "DE/best/2/bin",
                "DE/rand/2/bin"
       };

       int   i, j, L, n;      /* counting variables                 */
       int   r1, r2, r3, r4;  /* placeholders for random indexes    */
       int   r5;              /* placeholders for random indexes    */
       int   D;               /* Dimension of parameter vector      */
       int   NP;              /* number of population members       */
       int   imin;            /* index to member with lowest energy */
       int   refresh;         /* refresh rate of screen output      */
       int   strategy;        /* choice parameter for screen output */
       int   gen, genmax, seed;   

       long  nfeval;          /* number of function evaluations     */

       double trial_cost;      /* buffer variable                    */
       // 將上下限轉為全域變數, 可能要根據各變數加以設定
       //double inibound_h;      /* upper parameter bound              */
       //double inibound_l;      /* lower parameter bound              */
       double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */
       double cost[MAXPOP];    /* obj. funct. values                 */
       double cvar;            /* computes the cost variance         */
       double cmean;           /* mean cost                          */
       double F,CR;            /* control variables of DE            */
       double cmin;            /* help variables                     */

       FILE  *fpin_ptr;
       FILE  *fpout_ptr;

    // 計算執行過程所需時間起點, 需要導入 time.h
      clock_t start = clock();

    /*------Initializations----------------------------*/

     //if (argc != 3)                                 /* number of arguments */
     //{
        //printf("\nUsage : de &lt;input-file&gt; &lt;output-file&gt;\n");
        //exit(1);
     //}

    // 將結果寫入 out.dat
     fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */
                                              /* to see whether it already exists */
     /*
     if ( fpout_ptr != NULL )
     {
        printf("\nOutput file %s does already exist, \ntype y if you ",argv[2]);
        printf("want to overwrite it, \nanything else if you want to exit.\n");
        chr = (char)getchar();
        if ((chr != 'y') &amp;&amp; (chr != 'Y'))
        {
          exit(1);
        }
        fclose(fpout_ptr);
     }
    */

    /*-----Read input data------------------------------------------------*/

     //fpin_ptr   = fopen(argv[1],"r");
    /*
     if (fpin_ptr == NULL)
     {
        printf("\nCannot open input file\n");
        exit(1);
     }*/

     //fscanf(fpin_ptr,"%d",&amp;strategy);       /*---choice of strategy-----------------*/
     //fscanf(fpin_ptr,"%d",&amp;genmax);         /*---maximum number of generations------*/
     //fscanf(fpin_ptr,"%d",&amp;refresh);        /*---output refresh cycle---------------*/
     //fscanf(fpin_ptr,"%d",&amp;D);              /*---number of parameters---------------*/
     //fscanf(fpin_ptr,"%d",&amp;NP);             /*---population size.-------------------*/
     //fscanf(fpin_ptr,"%lf",&amp;inibound_h);    /*---upper parameter bound for init-----*/
     //fscanf(fpin_ptr,"%lf",&amp;inibound_l);    /*---lower parameter bound for init-----*/
     //fscanf(fpin_ptr,"%lf",&amp;F);             /*---weight factor----------------------*/
     //fscanf(fpin_ptr,"%lf",&amp;CR);            /*---crossing over factor---------------*/
     //fscanf(fpin_ptr,"%d",&amp;seed);           /*---random seed------------------------*/
    // 目前已經採用 strategy 3 可以得到最佳結果
      strategy = 3;
      genmax = 2000;
      refresh = 100;
      // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 5 個通過點角度值
      D = 19;
      NP = 200;
      inibound_h = 50.;
      inibound_l = 0.;
    /*得到最佳解
      F = 0.85;
    CR 必須介於 0 to 1. 之間
      CR = 1.;
    */
      F = 0.85;
      CR = 1.;
      seed = 3;

     //fclose(fpin_ptr);

    /*-----Checking input variables for proper range----------------------------*/

      if (D &gt; MAXDIM)
      {
         printf("\nError! D=%d &gt; MAXDIM=%d\n",D,MAXDIM);
         exit(1);
      }
      if (D &lt;= 0)
      {
         printf("\nError! D=%d, should be &gt; 0\n",D);
         exit(1);
      }
      if (NP &gt; MAXPOP)
      {
         printf("\nError! NP=%d &gt; MAXPOP=%d\n",NP,MAXPOP);
         exit(1);
      }
      if (NP &lt;= 0)
      {
         printf("\nError! NP=%d, should be &gt; 0\n",NP);
         exit(1);
      }
      if ((CR &lt; 0) || (CR &gt; 1.0))
      {
         printf("\nError! CR=%f, should be ex [0,1]\n",CR);
         exit(1);
      }
      if (seed &lt;= 0)
      {
         printf("\nError! seed=%d, should be &gt; 0\n",seed);
         exit(1);
      }
      if (refresh &lt;= 0)
      {
         printf("\nError! refresh=%d, should be &gt; 0\n",refresh);
         exit(1);
      }
      if (genmax &lt;= 0)
      {
         printf("\nError! genmax=%d, should be &gt; 0\n",genmax);
         exit(1);
      }
      if ((strategy &lt; 0) || (strategy &gt; 10))
      {
         printf("\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\n",strategy);
         exit(1);
      }
      if (inibound_h &lt; inibound_l)
      {
         printf("\nError! inibound_h=%f &lt; inibound_l=%f\n",inibound_h, inibound_l);
         exit(1);
      }


    /*-----Open output file-----------------------------------------------*/

       //fpout_ptr   = fopen(argv[2],"w");  /* open output file for writing */

       //if (fpout_ptr == NULL)
       //{
          //printf("\nCannot open output file\n");
          //exit(1);
       //}


    /*-----Initialize random number generator-----------------------------*/

     rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */
     nfeval       =  0;  /* reset number of function evaluations */



    /*------Initialization------------------------------------------------*/
    /*------Right now this part is kept fairly simple and just generates--*/
    /*------random numbers in the range [-initfac, +initfac]. You might---*/
    /*------want to extend the init part such that you can initialize-----*/
    /*------each parameter separately.------------------------------------*/

       for (i=0; i&lt;NP; i++)
       {
          for (j=0; j&lt;D; j++) /* spread initial population members */
          {
            c[i][j] = inibound_l + rnd_uni(&amp;rnd_uni_init)*(inibound_h - inibound_l);
          }
          cost[i] = evaluate(D,c[i],&amp;nfeval); /* obj. funct. value */
       }
       cmin = cost[0];
       imin = 0;
       for (i=1; i&lt;NP; i++)
       {
         if(MAXIMAPROBLEM == 1)
         {
           // 改為最大化
            if (cost[i]&gt;cmin)
            {
              cmin = cost[i];
              imin = i;
            }
          }
          else
          {
            // 最小化問題
            if (cost[i]&lt;cmin)
            {
              cmin = cost[i];
              imin = i;
            }
          }
       }

       assignd(D,best,c[imin]);            /* save best member ever          */
       assignd(D,bestit,c[imin]);          /* save best member of generation */

       pold = &amp;c; /* old population (generation G)   */
       pnew = &amp;d; /* new population (generation G+1) */

    /*=======================================================================*/
    /*=========Iteration loop================================================*/
    /*=======================================================================*/

       gen = 0;                          /* generation counter reset */
       while ((gen &lt; genmax) /*&amp;&amp; (kbhit() == 0)*/) /* remove comments if conio.h */
       {                                            /* is accepted by compiler    */
          gen++;
          imin = 0;

          for (i=0; i&lt;NP; i++)         /* Start of loop through ensemble  */
          {
         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &lt; 2 !!!     */
           r1 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
         }while(r1==i);            

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &lt; 3 !!!     */
           r2 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
         }while((r2==i) || (r2==r1));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &lt; 4 !!!     */
           r3 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
         }while((r3==i) || (r3==r1) || (r3==r2));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &lt; 5 !!!     */
           r4 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
         }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &lt; 6 !!!     */
           r5 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
         }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));


    /*=======Choice of strategy===============================================================*/
    /*=======We have tried to come up with a sensible naming-convention: DE/x/y/z=============*/
    /*=======DE :  stands for Differential Evolution==========================================*/
    /*=======x  :  a string which denotes the vector to be perturbed==========================*/
    /*=======y  :  number of difference vectors taken for perturbation of x===================*/
    /*=======z  :  crossover method (exp = exponential, bin = binomial)=======================*/
    /*                                                                                        */
    /*=======There are some simple rules which are worth following:===========================*/
    /*=======1)  F is usually between 0.5 and 1 (in rare cases &gt; 1)===========================*/
    /*=======2)  CR is between 0 and 1 with 0., 0.3, 0.7 and 1. being worth to be tried first=*/
    /*=======3)  To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence=*/
    /*           happens.                                                                     */
    /*=======4)  If you increase NP, F usually has to be decreased============================*/
    /*=======5)  When the DE/best... schemes fail DE/rand... usually works and vice versa=====*/


    /*=======EXPONENTIAL CROSSOVER============================================================*/

    /*-------DE/best/1/exp--------------------------------------------------------------------*/
    /*-------Our oldest strategy but still not bad. However, we have found several------------*/
    /*-------optimization problems where misconvergence occurs.-------------------------------*/
         if (strategy == 1) /* strategy DE0 (not in our paper) */
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D);
           L = 0;
           do
           {                       
             tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
         }
    /*-------DE/rand/1/exp-------------------------------------------------------------------*/
    /*-------This is one of my favourite strategies. It works especially well when the-------*/
    /*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/
    /*-------as a first guess.---------------------------------------------------------------*/
         else if (strategy == 2) /* strategy DE1 in the techreport */
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D);
           L = 0;
           do
           {                       
             tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
         }
    /*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/
    /*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/
    /*-------If you get misconvergence try to increase NP. If this doesn't help you----------*/
    /*-------should play around with all three control variables.----------------------------*/
         else if (strategy == 3) /* similiar to DE2 but generally better */
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                       
             tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
         }
    /*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/
         else if (strategy == 4)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                           
             tmp[n] = bestit[n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
         }
    /*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/
         else if (strategy == 5)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                           
             tmp[n] = (*pold)[r5][n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
         }

    /*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/

    /*-------DE/best/1/bin--------------------------------------------------------------------*/
         else if (strategy == 6) 
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
               for (L=0; L&lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand/1/bin-------------------------------------------------------------------*/
         else if (strategy == 7) 
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
               for (L=0; L&lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/
         else if (strategy == 8) 
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
               for (L=0; L&lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/best/2/bin--------------------------------------------------------------------*/
         else if (strategy == 9)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
               for (L=0; L&lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = bestit[n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand/2/bin--------------------------------------------------------------------*/
         else
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
               for (L=0; L&lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = (*pold)[r5][n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             }
             n = (n+1)%D;
               }
         }


    /*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/

         trial_cost = evaluate(D,tmp,&amp;nfeval);  /* Evaluate new vector in tmp[] */
       if(MAXIMAPROBLEM == 1)
       {
        // 改為最大化
           if (trial_cost &gt;= cost[i])   /* improved objective function value ? */
           {                                  
              cost[i]=trial_cost;         
              assignd(D,(*pnew)[i],tmp);
              if (trial_cost&gt;cmin)          /* Was this a new minimum? */
              {                               /* if so...*/
                 cmin=trial_cost;           /* reset cmin to new low...*/
                 imin=i;
                 assignd(D,best,tmp);           
              }                           
           }                            
           else
           {
              assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
           }
        }
        else
        {
              // 最小化問題
           if (trial_cost &lt;= cost[i])   /* improved objective function value ? */
           {                                  
              cost[i]=trial_cost;         
              assignd(D,(*pnew)[i],tmp);
              if (trial_cost&lt;cmin)          /* Was this a new minimum? */
              {                               /* if so...*/
                 cmin=trial_cost;           /* reset cmin to new low...*/
                 imin=i;
                 assignd(D,best,tmp);           
              }                           
           }                            
           else
           {
              assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
           }
        }

          }   /* End mutation loop through pop. */

          assignd(D,bestit,best);  /* Save best population member of current iteration */

          /* swap population arrays. New generation becomes old one */

          pswap = pold;
          pold  = pnew;
          pnew  = pswap;

    /*----Compute the energy variance (just for monitoring purposes)-----------*/

          cmean = 0.;          /* compute the mean value first */
          for (j=0; j&lt;NP; j++)
          {
             cmean += cost[j];
          }
          cmean = cmean/NP;

          cvar = 0.;           /* now the variance              */
          for (j=0; j&lt;NP; j++)
          {
             cvar += (cost[j] - cmean)*(cost[j] - cmean);
          }
          cvar = cvar/(NP-1);


    /*----Output part----------------------------------------------------------*/

          if (gen%refresh==1)   /* display after every refresh generations */
          { /* ABORT works only if conio.h is accepted by your compiler */
        printf("\n\n                         PRESS ANY KEY TO ABORT"); 
        printf("\n\n\n Best-so-far cost funct. value=%-15.10g\n",cmin);

        for (j=0;j&lt;D;j++)
        {
          printf("\n best[%d]=%-15.10g",j,best[j]);
        }
        printf("\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
        printf("\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\n",
                   NP,F,CR,cvar);
          }

          fprintf(fpout_ptr,"%ld   %-15.10g\n",nfeval,cmin);
       }
    /*=======================================================================*/
    /*=========End of iteration loop=========================================*/
    /*=======================================================================*/

    /*-------Final output in file-------------------------------------------*/


       fprintf(fpout_ptr,"\n\n\n Best-so-far obj. funct. value = %-15.10g\n",cmin);

       for (j=0;j&lt;D;j++)
       {
         fprintf(fpout_ptr,"\n best[%d]=%-15.10g",j,best[j]);
       }
       fprintf(fpout_ptr,"\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
       fprintf(fpout_ptr,"\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\n",
               NP,F,CR,cvar); 

      fclose(fpout_ptr);

      /* Code you want timed here */
      printf("Time elapsed: %f\n", ((double)clock() - start) / CLOCKS_PER_SEC);
       return(0);
    }

    /*-----------End of main()------------------------------------------*/

    // 適應函式 fittness function (cost function)
    double evaluate(int D, double tmp[], long *nfeval)
    {
      // 先處理通過 5 個點的四連桿問題
      // x0, y0 為左方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[0], tmp[1]
      // x1, y1 為右方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[2], tmp[3]
      // L1 為第一桿件的長度, 必須 &gt; 0, 且小於 100 - 設為 tmp[4]
      // L2 為第二桿件的長度, 必須 &gt; 0, 且小於 100 - 設為 tmp[5]
      // L3 為第三桿件的長度, 必須 &gt; 0, 且小於 100 - 設為 tmp[6]
      // L5, L6 與 L2 共同圍出可動桿 L2 對應的三角形, 關注的三角形頂點即 L5 與 L6 的交點, 而 angle3 則為 L6 之對應角(為固定值)
      // L5, L6 必須 &gt; 0, 且小於 100 - 設為 tmp[7], tmp[8]
      // 以下的角度輸入值, 會隨著目標點數的增加而增加, 其索引值由 9 + 通過點數 - 1 決定, 5 點, 則索引至 13, 若通過 25 點, 則索引值為 9 + 24 = 33
      // input_angles[] 為五的輸入的雙浮點數角度值,代表個體的角度向量值 - 分別設為 tmp[9], tmp[10], tmp[11], tmp[12], tmp[13]
      // output_points[] 則為與 input_angles[] 對應的五個三角形的頂點值, 為座標結構值, 分別有 x 與 y 分量值
      // 當利用個體的向量值, 代入 mechanism 後所得到得 output_points[] 再與 target_points[] 進行 cost function 的誤差值最小化
      /* void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])*/
      struct Coord target_points[NUM_OF_POINTS], output_points[NUM_OF_POINTS];
      double input_angles[NUM_OF_POINTS], result;
      int i;

      (*nfeval)++;

      target_points[0].x = 1.0;
      target_points[0].y = 1.0;

      target_points[1].x = 2.0;
      target_points[1].y = 2.0;

      target_points[2].x = 3.0;
      target_points[2].y = 3.0;

      target_points[3].x = 4.0;
      target_points[3].y = 4.0;

      target_points[4].x = 5.0;
      target_points[4].y = 5.0;

      target_points[5].x = 6.0;
      target_points[5].y = 6.0;

      target_points[6].x = 7.0;
      target_points[6].y = 7.0;

      target_points[7].x = 8.0;
      target_points[7].y = 8.0;

      target_points[8].x = 9.0;
      target_points[8].y = 9.0;

      target_points[9].x = 10.0;
      target_points[9].y = 10.0;

      // 輸入角度值與 tmp[] 的設定
      for(i = 0; i &lt; NUM_OF_POINTS; i++)
      {
        input_angles[i] = tmp[i + 9];
      }
      // 呼叫 mechanism() 以便計算 output_points[]
      mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points);

      // for debug
      /*
      if(*nfeval%3000 == 0)
      {
        for(i = 0; i &lt; NUM_OF_POINTS; i++)
        {
          printf("%-15.10g : %-15.10g\n", output_points[i].x, output_points[i].y);
        }
        printf("#####################################\n");
      }
      */
      // 利用 output_points[] 與 target_points 計算誤差值, 該誤差值就是 cost
      result = error_function(output_points, target_points);
      // 這裡要分別針對各變數的約束條件與範圍值來設定傳回 PENALITY 或 誤差值 result

      // x0 與 x1 點位於 -500 與 500 中間
        for(i = 0; i &lt; 4; i++)
      {
        if(tmp[i] &lt; -50 || tmp[i] &gt; 50){
          return PENALITY;
        }
      }

      // 三個連桿值, 一定要為正
        for(i = 4; i &lt; 7; i++)
      {
        if(tmp[i] &lt; 0 || tmp[i] &gt; 50){
          return PENALITY;
        }
      }

        // L5 L6 可以為 0 或負值
        for(i = 7; i &lt; 9; i++)
      {
        if(tmp[i] &lt; -50 || tmp[i] &gt; 50){
          return PENALITY;
        }
      }

      // 角度值一定要大於 0

      for(i = 1; i &lt;= NUM_OF_POINTS; i++)
      {
        if((tmp[D-i] &lt; 0)){
          return PENALITY;
        }
      }

      return result;

      /*
       double result=0, surface = 80.0, z, volume, penality;
       (*nfeval)++;
       z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));
       volume = tmp[0]*tmp[1]*z;

      if(volume &lt;= 0){
        return PENALITY;
      }

      if((tmp[0] &lt;= inibound_l)|| (tmp[0] &gt;inibound_h)){
        return PENALITY;
      }

      if((tmp[1] &lt;= inibound_l) || (tmp[1] &gt;inibound_h)){
        return PENALITY;
      }
      // volume must &gt;0 and max volume
      // 目前為最小化問題
       return 1+1/(volume*volume);
       */
    }

    struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt)
    {
        struct Coord tip_coord;

        if (localt&gt;=0 &amp;&amp; localt &lt;PI)
        {
            // 目前蓋掉的式子為利用手動代換出來的版本
            //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(-mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
            // 以下的式子,先利用文字編輯器,將原先 stringout() 出來的  sqrt 替換成  sqrtt, 以防止被  maxima 中的 subst("^"=pow,expr) 所替換, subst 之後,再使用文字編輯器換回來,就可以得到正確的 C 對應碼.
            tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
        pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0;
        }
        else
        {
            // 目前蓋掉的式子為利用手動代換出來的版本
            //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
            tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
        pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+
        pow(x1-x0,2))/2)+x0;
        }

    // 請注意,與 Maxma 公式中的差異為,在 sqrt()中加入 fabs(),避免因為sqrt()中的負值而造成 NaN (Not a Number 問題.
        if (localt&gt;=0 &amp;&amp; localt &lt;PI)
        {
            tip_coord.y = /*((x1-x0)*(-mech_loop)*sqrt(
                    fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                    /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                    ))
                    +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                    +y0;*/
                    // 利用 sqrtt 居中進行代換所得到的式子
                    pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
        pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;

        }
        else
        {
            tip_coord.y = /*((x1-x0)*(mech_loop)*sqrt(
                    fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                    /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                    ))
                    +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                    +y0;*/
                    pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
        pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;
        }

      return tip_coord;
    }

    double distance(double x0, double y0, double x1, double y1)
    {
        double distance_value;
        distance_value = sqrt(pow((x1-x0),2) + pow((y1-y0),2));
        return distance_value;
    }

    double rr(double L1, double dd, double theta)
    {
        double rr_value;
        rr_value = sqrt(L1*L1+dd*dd-2*L1*dd*cos(theta));
        return rr_value;
    }

    // 輸入每一個體的變數向量, 然後求各三角形頂點的座標陣列[NUM_OF_POINTS]
    void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])
    {
      // 此函式要輸入控制變數, 然後計算機構尺寸合成的關注點座標位置
      // 以下為可能的處理變數宣告
      // 這裡希望能夠定義一個 struct 來處理座標點
      double rr_length, dd_length, angle;
      struct Coord link1_tip, link2_tip, triangle_tip;
        double angle2, angle3;
      int i;

      // 開始進行三角形頂點座標的計算
      // 以下變數由每一個體向量提供
      /*
        x0 = 0.0;
        y0 = 0.0;
        x1 = 10.0;
        y1 = 0.0;
        L1 = 5.0;
        L2 = 20;
        L3 = 10;
        L5 = 10;
        L6 = 10;
      */
      dd_length = distance(x0, y0, x1, y1);
      /* 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式 */
      angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5));

      for(i = 0; i &lt; NUM_OF_POINTS; i++)
      {
        // 先建立第一點座標, 即 i=0 者
        // i=0;
        // angle = i*degree;
        /*
        // 利用角度增量進行運算, 相對於 input_angles[0] 作為基準
        if(i &gt; 0)
        {
          input_angles[i] = input_angles[i] + input_angles[i-1];
        }
        */
        angle = input_angles[i]*degree;
        rr_length = rr(L1, dd_length, angle);
        // 第一次三角形疊代
        link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle);
        // 第二次三角形疊代
        /* 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式 */
        angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length));
        link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2);
        // 第三次三角形疊代
        //triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        // output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        // 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負
        output_points[i] = finaltip_coord(link1_tip, link2_tip, L5, L6);
      }
    }

    double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS])
    {
      double error = 0.0;
      int i;
      for(i = 0; i &lt; NUM_OF_POINTS; i++)
      {
        error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y));
      }
      return error;
    }

    struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2)
    {
      struct Coord tip3_coord;
      double theta3, theta4, length3, length4;
      length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2));
      length4 = sqrt(pow(r1,2) + pow(r2,2));  
      theta3 = acos((tip2_coord.x - tip1_coord.x) / length3);
      theta4 = acos(r1 / length4);
      tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4);
      tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4);

      return tip3_coord;
    }
</pre>

<p>為了要讓 C 程式碼可以在 Pelican 網誌 Markdown 格式編輯模式下能夠與 highlight 套件結合, 首先程式碼中的所有大於與小於符號必須轉為 html special charactor 之外, 還要全部內縮, 否則內容將會在 Pelican 轉換過程中被視為 html 而自動加入錯誤的標註符號.</p>
<p>以下則為 de 25 點四連桿尺寸合成參考程式:</p>
<pre class="brush: c">
    /***************************************************************
    **                                                            **
    **        D I F F E R E N T I A L     E V O L U T I O N       **
    **                                                            **
    ** Program: de.c                                              **
    ** Version: 3.6                                               **
    **                                                            **
    ** Authors: Dr. Rainer Storn                                  **
    **          c/o ICSI, 1947 Center Street, Suite 600           **
    **          Berkeley, CA 94707                                **
    **          Tel.:   510-642-4274 (extension 192)              **
    **          Fax.:   510-643-7684                              **
    **          E-mail: storn@icsi.berkeley.edu                   **
    **          WWW: http://http.icsi.berkeley.edu/~storn/        **
    **          on leave from                                     **
    **          Siemens AG, ZFE T SN 2, Otto-Hahn Ring 6          **
    **          D-81739 Muenchen, Germany                         **
    **          Tel:    636-40502                                 **
    **          Fax:    636-44577                                 **
    **          E-mail: rainer.storn@zfe.siemens.de               **
    **                                                            **
    **          Kenneth Price                                     **
    **          836 Owl Circle                                    **
    **          Vacaville, CA 95687                               **
    **          E-mail: kprice@solano.community.net               ** 
    **                                                            **
    ** This program implements some variants of Differential      **
    ** Evolution (DE) as described in part in the techreport      **
    ** tr-95-012.ps of ICSI. You can get this report either via   **
    ** ftp.icsi.berkeley.edu/pub/techreports/1995/tr-95-012.ps.Z  **
    ** or via WWW: http://http.icsi.berkeley.edu/~storn/litera.html*
    ** A more extended version of tr-95-012.ps is submitted for   **
    ** publication in the Journal Evolutionary Computation.       ** 
    **                                                            **
    ** You may use this program for any purpose, give it to any   **
    ** person or change it according to your needs as long as you **
    ** are referring to Rainer Storn and Ken Price as the origi-  **
    ** nators of the the DE idea.                                 **
    ** If you have questions concerning DE feel free to contact   **
    ** us. We also will be happy to know about your experiences   **
    ** with DE and your suggestions of improvement.               **
    **                                                            **
    ***************************************************************/
    /**H*O*C**************************************************************
    **                                                                  **
    ** No.!Version! Date ! Request !    Modification           ! Author **
    ** ---+-------+------+---------+---------------------------+------- **
    **  1 + 3.1  +5/18/95+   -     + strategy DE/rand-to-best/1+  Storn **
    **    +      +       +         + included                  +        **
    **  1 + 3.2  +6/06/95+C.Fleiner+ change loops into memcpy  +  Storn **
    **  2 + 3.2  +6/06/95+   -     + update comments           +  Storn **
    **  1 + 3.3  +6/15/95+ K.Price + strategy DE/best/2 incl.  +  Storn **
    **  2 + 3.3  +6/16/95+   -     + comments and beautifying  +  Storn **
    **  3 + 3.3  +7/13/95+   -     + upper and lower bound for +  Storn **
    **    +      +       +         + initialization            +        **
    **  1 + 3.4  +2/12/96+   -     + increased printout prec.  +  Storn **
    **  1 + 3.5  +5/28/96+   -     + strategies revisited      +  Storn **
    **  2 + 3.5  +5/28/96+   -     + strategy DE/rand/2 incl.  +  Storn **
    **  1 + 3.6  +8/06/96+ K.Price + Binomial Crossover added  +  Storn **
    **  2 + 3.6  +9/30/96+ K.Price + cost variance output      +  Storn **
    **  3 + 3.6  +9/30/96+   -     + alternative to ASSIGND    +  Storn **
    **  4 + 3.6  +10/1/96+   -    + variable checking inserted +  Storn **
    **  5 + 3.6  +10/1/96+   -     + strategy indic. improved  +  Storn **
    **                                                                  **
    ***H*O*C*E***********************************************************/

    #include "stdio.h"
    #include "stdlib.h"
    #include "math.h"
    #include "memory.h"
    #include &lt;time.h&gt;

    // 最大族群數, NP
    #define MAXPOP  5000
    // 最大向量維度, D
    #define MAXDIM  60
    // 1 為最大化問題, 0 為最小化問題
    #define MAXIMAPROBLEM 0
    // 可能要配合最大或最小化進行變號
    #define PENALITY 1.0E20

    /*------Constants for rnd_uni()--------------------------------------------*/

    #define IM1 2147483563
    #define IM2 2147483399
    #define AM (1.0/IM1)
    #define IMM1 (IM1-1)
    #define IA1 40014
    #define IA2 40692
    #define IQ1 53668
    #define IQ2 52774
    #define IR1 12211
    #define IR2 3791
    #define NTAB 32
    #define NDIV (1+IMM1/NTAB)
    #define EPS 1.2e-7
    #define RNMX (1.0-EPS)

    // 與機構合成相關的常數定義
    #define PI 3.1415926
    #define degree PI/180.0
    #define mech_loop -1
    #define NUM_OF_POINTS 25

    /*------------------------Macros----------------------------------------*/

    /*#define ASSIGND(a,b) memcpy((a),(b),sizeof(double)*D) */  /* quick copy by Claudio */
                                                               /* works only for small  */
                                                               /* arrays, but is faster.*/

    /*------------------------Globals---------------------------------------*/

    long  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */
    double c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];
    double (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];

    /*---------Function declarations----------------------------------------*/

    void  assignd(int D, double a[], double b[]);
    double rnd_uni(long *idum);    /* uniform pseudo random number generator */
    double extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */

    // 與機構合成相關的函式宣告
    double distance(double x0, double y0, double x1, double y1);
    double rr(double L1, double dd, double theta);
    struct Coord triangletip_coord(double x0, double y0, double R0, double R1, double x1, double y1, double localt);
    void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS]);
    double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS]);
    // 用來利用 tip1 與 tip2 的座標, 以及 r1, r2 求最後的三角形頂點座標
    struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2);

    /*---------Function definitions-----------------------------------------*/
    // 指定向量 b 為 a
    void  assignd(int D, double a[], double b[])
    /**C*F****************************************************************
    **                                                                  **
    ** Assigns D-dimensional vector b to vector a.                      **
    ** You might encounter problems with the macro ASSIGND on some      **
    ** machines. If yes, better use this function although it's slower. **
    **                                                                  **
    ***C*F*E*************************************************************/
    {
       int j;
       for (j=0; j&lt;D; j++)
       {
          a[j] = b[j];
       }
    }

    // 產生 0 ~ 1 間的亂數
    double rnd_uni(long *idum)
    /**C*F****************************************************************
    **                                                                  **
    ** SRC-FUNCTION   :rnd_uni()                                        **
    ** LONG_NAME      :random_uniform                                   **
    ** AUTHOR         :(see below)                                      **
    **                                                                  **
    ** DESCRIPTION    :rnd_uni() generates an equally distributed ran-  **
    **                 dom number in the interval [0,1]. For further    **
    **                 reference see Press, W.H. et alii, Numerical     **
    **                 Recipes in C, Cambridge University Press, 1992.  **
    **                                                                  **
    ** FUNCTIONS      :none                                             **
    **                                                                  **
    ** GLOBALS        :none                                             **
    **                                                                  **
    ** PARAMETERS     :*idum    serves as a seed value                  **
    **                                                                  **
    ** PRECONDITIONS  :*idum must be negative on the first call.        **
    **                                                                  **
    ** POSTCONDITIONS :*idum will be changed                            **
    **                                                                  **
    ***C*F*E*************************************************************/
    {
      long j;
      long k;
      static long idum2=123456789;
      static long iy=0;
      static long iv[NTAB];
      double temp;

      if (*idum &lt;= 0)
      {
        if (-(*idum) &lt; 1) *idum=1;
        else *idum = -(*idum);
        idum2=(*idum);
        for (j=NTAB+7;j&gt;=0;j--)
        {
          k=(*idum)/IQ1;
          *idum=IA1*(*idum-k*IQ1)-k*IR1;
          if (*idum &lt; 0) *idum += IM1;
          if (j &lt; NTAB) iv[j] = *idum;
        }
        iy=iv[0];
      }
      k=(*idum)/IQ1;
      *idum=IA1*(*idum-k*IQ1)-k*IR1;
      if (*idum &lt; 0) *idum += IM1;
      k=idum2/IQ2;
      idum2=IA2*(idum2-k*IQ2)-k*IR2;
      if (idum2 &lt; 0) idum2 += IM2;
      j=iy/NDIV;
      iy=iv[j]-idum2;
      iv[j] = *idum;
      if (iy &lt; 1) iy += IMM1;
      if ((temp=AM*iy) &gt; RNMX) return RNMX;
      else return temp;

    }/*------End of rnd_uni()--------------------------*/

    // 將上下限轉為全域變數
    double inibound_h;      /* upper parameter bound              */
    double inibound_l;      /* lower parameter bound              */
    // 與機構合成相關的全域變數
    // 宣告一個座標結構
    struct Coord {
        double x;
        double y;
      // 這裡保留 double z;
    };

    int main(int argc, char *argv[])
    /**C*F****************************************************************
    **                                                                  **
    ** SRC-FUNCTION   :main()                                           **
    ** LONG_NAME      :main program                                     **
    ** AUTHOR         :Rainer Storn, Kenneth Price                      **
    **                                                                  **
    ** DESCRIPTION    :driver program for differential evolution.       **
    **                                                                  **
    ** FUNCTIONS      :rnd_uni(), evaluate(), printf(), fprintf(),      **
    **                 fopen(), fclose(), fscanf().                     **
    **                                                                  **
    ** GLOBALS        :rnd_uni_init    input variable for rnd_uni()     **
    **                                                                  **
    ** PARAMETERS     :argc            #arguments = 3                   **
    **                 argv            pointer to argument strings      **
    **                                                                  **
    ** PRECONDITIONS  :main must be called with three parameters        **
    **                 e.g. like de1 &lt;input-file&gt; &lt;output-file&gt;, if     **
    **                 the executable file is called de1.               **
    **                 The input file must contain valid inputs accor-  **
    **                 ding to the fscanf() section of main().          **
    **                                                                  **
    ** POSTCONDITIONS :main() produces consecutive console outputs and  **
    **                 writes the final results in an output file if    **
    **                 the program terminates without an error.         **
    **                                                                  **
    ***C*F*E*************************************************************/

    {
       char  chr;             /* y/n choice variable                */
       char  *strat[] =       /* strategy-indicator                 */
       {
                "",
                "DE/best/1/exp",
                "DE/rand/1/exp",
                "DE/rand-to-best/1/exp",
                "DE/best/2/exp",
                "DE/rand/2/exp",
                "DE/best/1/bin",
                "DE/rand/1/bin",
                "DE/rand-to-best/1/bin",
                "DE/best/2/bin",
                "DE/rand/2/bin"
       };

       int   i, j, L, n;      /* counting variables                 */
       int   r1, r2, r3, r4;  /* placeholders for random indexes    */
       int   r5;              /* placeholders for random indexes    */
       int   D;               /* Dimension of parameter vector      */
       int   NP;              /* number of population members       */
       int   imin;            /* index to member with lowest energy */
       int   refresh;         /* refresh rate of screen output      */
       int   strategy;        /* choice parameter for screen output */
       int   gen, genmax, seed;   

       long  nfeval;          /* number of function evaluations     */

       double trial_cost;      /* buffer variable   */

       // 將上下限轉為全域變數, 可能要根據各變數加以設定
       //double inibound_h;      /* upper parameter bound              */
       //double inibound_l;      /* lower parameter bound              */
       double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */
       double cost[MAXPOP];    /* obj. funct. values                 */
       double cvar;            /* computes the cost variance         */
       double cmean;           /* mean cost                          */
       double F,CR;            /* control variables of DE            */
       double cmin;            /* help variables                     */

       FILE  *fpin_ptr;
       FILE  *fpout_ptr;

    // 計算執行過程所需時間起點, 需要導入 time.h
      clock_t start = clock();

    /*------Initializations----------------------------*/

     //if (argc != 3)                                 /* number of arguments */
     //{
        //printf("\nUsage : de &lt;input-file&gt; &lt;output-file&gt;\n");
        //exit(1);
     //}

    // 將結果寫入 out.dat
     fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */
                                              /* to see whether it already exists */
     /*
     if ( fpout_ptr != NULL )
     {
        printf("\nOutput file %s does already exist, \ntype y if you ",argv[2]);
        printf("want to overwrite it, \nanything else if you want to exit.\n");
        chr = (char)getchar();
        if ((chr != 'y') &amp;&amp; (chr != 'Y'))
        {
          exit(1);
        }
        fclose(fpout_ptr);
     }
    */

    /*-----Read input data------------------------------------------------*/

     //fpin_ptr   = fopen(argv[1],"r");
    /*
     if (fpin_ptr == NULL)
     {
        printf("\nCannot open input file\n");
        exit(1);
     }*/

     //fscanf(fpin_ptr,"%d",&amp;strategy);       /*---choice of strategy-----------------*/
     //fscanf(fpin_ptr,"%d",&amp;genmax);         /*---maximum number of generations------*/
     //fscanf(fpin_ptr,"%d",&amp;refresh);        /*---output refresh cycle---------------*/
     //fscanf(fpin_ptr,"%d",&amp;D);              /*---number of parameters---------------*/
     //fscanf(fpin_ptr,"%d",&amp;NP);             /*---population size.-------------------*/
     //fscanf(fpin_ptr,"%lf",&amp;inibound_h);    /*---upper parameter bound for init-----*/
     //fscanf(fpin_ptr,"%lf",&amp;inibound_l);    /*---lower parameter bound for init-----*/
     //fscanf(fpin_ptr,"%lf",&amp;F);             /*---weight factor----------------------*/
     //fscanf(fpin_ptr,"%lf",&amp;CR);            /*---crossing over factor---------------*/
     //fscanf(fpin_ptr,"%d",&amp;seed);           /*---random seed------------------------*/
      strategy = 3;
      genmax = 200000;
      // refresh 為每幾筆運算後進行資料列印
      refresh = 100;
      // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 25 (NUM_OF_POINTS) 個通過點角度值
      // tmp[0~8] 為機構尺寸, tmp[9~33] 為通過點角度值
      D = 9 + NUM_OF_POINTS;
      NP = 200;
      // 機構變數值上限
      inibound_h = 50.;
      // 機構變數值下限
      inibound_l = 0.;
      // for strategy 1, F=0.9, CR = 1.
      // for strategy 2 F=0.7, CR=0.5
      // 一個小時得到 9.7 的誤差
      // 25 點的題目, 若 penality 只取 1000 則 F = 0.7 似乎為 最大 bound for strategy 1, CR = 1.
      F = 0.85;
      CR = 0.7;
      seed = 3;

     //fclose(fpin_ptr);

    /*-----Checking input variables for proper range----------------------------*/

      if (D &gt; MAXDIM)
      {
         printf("\nError! D=%d &gt; MAXDIM=%d\n",D,MAXDIM);
         exit(1);
      }
      if (D &lt;= 0)
      {
         printf("\nError! D=%d, should be &gt; 0\n",D);
         exit(1);
      }
      if (NP &gt; MAXPOP)
      {
         printf("\nError! NP=%d &gt; MAXPOP=%d\n",NP,MAXPOP);
         exit(1);
      }
      if (NP &lt;= 0)
      {
         printf("\nError! NP=%d, should be &gt; 0\n",NP);
         exit(1);
      }
      if ((CR &lt; 0) || (CR &gt; 1.0))
      {
         printf("\nError! CR=%f, should be ex [0,1]\n",CR);
         exit(1);
      }
      if (seed &lt;= 0)
      {
         printf("\nError! seed=%d, should be &gt; 0\n",seed);
         exit(1);
      }
      if (refresh &lt;= 0)
      {
         printf("\nError! refresh=%d, should be &gt; 0\n",refresh);
         exit(1);
      }
      if (genmax &lt;= 0)
      {
         printf("\nError! genmax=%d, should be &gt; 0\n",genmax);
         exit(1);
      }
      if ((strategy &lt; 0) || (strategy &gt; 10))
      {
         printf("\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\n",strategy);
         exit(1);
      }
      if (inibound_h &lt; inibound_l)
      {
         printf("\nError! inibound_h=%f &lt; inibound_l=%f\n",inibound_h, inibound_l);
         exit(1);
      }


    /*-----Open output file-----------------------------------------------*/

       //fpout_ptr   = fopen(argv[2],"w");  /* open output file for writing */

       //if (fpout_ptr == NULL)
       //{
          //printf("\nCannot open output file\n");
          //exit(1);
       //}


    /*-----Initialize random number generator-----------------------------*/

     rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */
     nfeval       =  0;  /* reset number of function evaluations */



    /*------Initialization------------------------------------------------*/
    /*------Right now this part is kept fairly simple and just generates--*/
    /*------random numbers in the range [-initfac, +initfac]. You might---*/
    /*------want to extend the init part such that you can initialize-----*/
    /*------each parameter separately.------------------------------------*/

       for (i=0; i&lt;NP; i++)
       {
          for (j=0; j&lt;D; j++) /* spread initial population members */
          {
            c[i][j] = inibound_l + rnd_uni(&amp;rnd_uni_init)*(inibound_h - inibound_l);
          }
          cost[i] = evaluate(D,c[i],&amp;nfeval); /* obj. funct. value */
       }
       cmin = cost[0];
       imin = 0;
       for (i=1; i&lt;NP; i++)
       {
         if(MAXIMAPROBLEM == 1)
         {
           // 最大化問題
            if (cost[i]&gt;cmin)
            {
              cmin = cost[i];
              imin = i;
            }
          }
          else
          {
            // 最小化問題
            if (cost[i]&lt;cmin)
            {
              cmin = cost[i];
              imin = i;
            }
          }
       }

       assignd(D,best,c[imin]);            /* save best member ever          */
       assignd(D,bestit,c[imin]);          /* save best member of generation */

       pold = &amp;c; /* old population (generation G)   */
       pnew = &amp;d; /* new population (generation G+1) */

    /*=======================================================================*/
    /*=========Iteration loop================================================*/
    /*=======================================================================*/

       gen = 0;                          /* generation counter reset */
       while ((gen &lt; genmax) /*&amp;&amp; (kbhit() == 0)*/) /* remove comments if conio.h */
       {                                            /* is accepted by compiler    */
          gen++;
          imin = 0;

          for (i=0; i&lt;NP; i++)         /* Start of loop through ensemble  */
          {
         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &lt; 2 !!!     */
           r1 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
         }while(r1==i);            

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &lt; 3 !!!     */
           r2 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
         }while((r2==i) || (r2==r1));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &lt; 4 !!!     */
           r3 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
         }while((r3==i) || (r3==r1) || (r3==r2));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &lt; 5 !!!     */
           r4 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
         }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));

         do                        /* Pick a random population member */
         {                         /* Endless loop for NP &lt; 6 !!!     */
           r5 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
         }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));


    /*=======Choice of strategy===============================================================*/
    /*=======We have tried to come up with a sensible naming-convention: DE/x/y/z=============*/
    /*=======DE :  stands for Differential Evolution==========================================*/
    /*=======x  :  a string which denotes the vector to be perturbed==========================*/
    /*=======y  :  number of difference vectors taken for perturbation of x===================*/
    /*=======z  :  crossover method (exp = exponential, bin = binomial)=======================*/
    /*                                                                                        */
    /*=======There are some simple rules which are worth following:===========================*/
    /*=======1)  F is usually between 0.5 and 1 (in rare cases &gt; 1)===========================*/
    /*=======2)  CR is between 0 and 1 with 0., 0.3, 0.7 and 1. being worth to be tried first=*/
    /*=======3)  To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence=*/
    /*           happens.                                                                     */
    /*=======4)  If you increase NP, F usually has to be decreased============================*/
    /*=======5)  When the DE/best... schemes fail DE/rand... usually works and vice versa=====*/


    /*=======EXPONENTIAL CROSSOVER============================================================*/

    /*-------DE/best/1/exp--------------------------------------------------------------------*/
    /*-------Our oldest strategy but still not bad. However, we have found several------------*/
    /*-------optimization problems where misconvergence occurs.-------------------------------*/
    // 1 為最原始的解題邏輯方法
         if (strategy == 1) /* strategy DE0 (not in our paper) */
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D);
           L = 0;
           do
           {                       
             tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
         }
    /*-------DE/rand/1/exp-------------------------------------------------------------------*/
    /*-------This is one of my favourite strategies. It works especially well when the-------*/
    /*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/
    /*-------as a first guess.---------------------------------------------------------------*/
      // 配合邏輯方法 2 選用 R=0.7, CR=0.5
       else if (strategy == 2) /* strategy DE1 in the techreport */
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D);
           L = 0;
           do
           {                       
             tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
         }
    /*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/
    /*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/
    /*-------If you get misconvergence try to increase NP. If this doesn't help you----------*/
    /*-------should play around with all three control variables.----------------------------*/
         // 方法 3 建議 F=0.85 CR=1.
       else if (strategy == 3) /* similiar to DE2 but generally better */
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                       
             tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
         }
    /*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/
         else if (strategy == 4)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                           
             tmp[n] = bestit[n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
         }
    /*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/
         else if (strategy == 5)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           L = 0;
           do
           {                           
             tmp[n] = (*pold)[r5][n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             n = (n+1)%D;
             L++;
           }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
         }

    /*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/

    /*-------DE/best/1/bin--------------------------------------------------------------------*/
         else if (strategy == 6) 
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
               for (L=0; L&lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand/1/bin-------------------------------------------------------------------*/
         else if (strategy == 7) 
         {
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
               for (L=0; L&lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/
         else if (strategy == 8) 
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
               for (L=0; L&lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/best/2/bin--------------------------------------------------------------------*/
         else if (strategy == 9)
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
               for (L=0; L&lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = bestit[n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             }
             n = (n+1)%D;
               }
         }
    /*-------DE/rand/2/bin--------------------------------------------------------------------*/
         else
         { 
           assignd(D,tmp,(*pold)[i]);
           n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
               for (L=0; L&lt;D; L++) /* perform D binomial trials */
               {
             if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
             {                       
               tmp[n] = (*pold)[r5][n] + 
                  ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
             }
             n = (n+1)%D;
               }
         }


    /*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/
         trial_cost = evaluate(D,tmp,&amp;nfeval);  /* Evaluate new vector in tmp[] */
       if(MAXIMAPROBLEM == 1)
       {
        // 改為最大化
           if (trial_cost &gt;= cost[i])   /* improved objective function value ? */
           {                                  
              cost[i]=trial_cost;         
              assignd(D,(*pnew)[i],tmp);
              if (trial_cost&gt;cmin)          /* Was this a new minimum? */
              {                               /* if so...*/
                 cmin=trial_cost;           /* reset cmin to new low...*/
                 imin=i;
                 assignd(D,best,tmp);           
              }                           
           }                            
           else
           {
              assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
           }
        }
        else
        {
              // 最小化問題
           if (trial_cost &lt;= cost[i])   /* improved objective function value ? */
           {                                  
              cost[i]=trial_cost;         
              assignd(D,(*pnew)[i],tmp);
              if (trial_cost&lt;cmin)          /* Was this a new minimum? */
              {                               /* if so...*/
                 cmin=trial_cost;           /* reset cmin to new low...*/
                 imin=i;
                 assignd(D,best,tmp);           
              }                           
           }                            
           else
           {
              assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
           }
        }

          }   /* End mutation loop through pop. */

          assignd(D,bestit,best);  /* Save best population member of current iteration */

          /* swap population arrays. New generation becomes old one */

          pswap = pold;
          pold  = pnew;
          pnew  = pswap;

    /*----Compute the energy variance (just for monitoring purposes)-----------*/

          cmean = 0.;          /* compute the mean value first */
          for (j=0; j&lt;NP; j++)
          {
             cmean += cost[j];
          }
          cmean = cmean/NP;

          cvar = 0.;           /* now the variance              */
          for (j=0; j&lt;NP; j++)
          {
             cvar += (cost[j] - cmean)*(cost[j] - cmean);
          }
          cvar = cvar/(NP-1);


    /*----Output part----------------------------------------------------------*/

          if (gen%refresh==1)   /* display after every refresh generations */
          { /* ABORT works only if conio.h is accepted by your compiler */
        printf("\n\n                         PRESS ANY KEY TO ABORT"); 
        printf("\n\n\n Best-so-far cost funct. value=%-15.10g\n",cmin);

        for (j=0;j&lt;D;j++)
        {
          printf("\n best[%d]=%-15.10g",j,best[j]);
        }
        printf("\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
        printf("\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\n",
                   NP,F,CR,cvar);
          }

          fprintf(fpout_ptr,"%ld   %-15.10g\n",nfeval,cmin);
       }
    /*=======================================================================*/
    /*=========End of iteration loop=========================================*/
    /*=======================================================================*/

    /*-------Final output in file-------------------------------------------*/


       fprintf(fpout_ptr,"\n\n\n Best-so-far obj. funct. value = %-15.10g\n",cmin);

       for (j=0;j&lt;D;j++)
       {
         fprintf(fpout_ptr,"\n best[%d]=%-15.10g",j,best[j]);
       }
       fprintf(fpout_ptr,"\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
       fprintf(fpout_ptr,"\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\n",
               NP,F,CR,cvar); 

      fclose(fpout_ptr);

      /* Code you want timed here */
      printf("Time elapsed: %f\n", ((double)clock() - start) / CLOCKS_PER_SEC);
      return(0);
    }

    /*-----------End of main()------------------------------------------*/

    // 適應函式 fittness function (cost function)
    double evaluate(int D, double tmp[], long *nfeval)
    {
      // 先處理通過 5 個點的四連桿問題
      // x0, y0 為左方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[0], tmp[1]
      // x1, y1 為右方固定點座標, 必須在 0 ~ 100 間 - 設為 tmp[2], tmp[3]
      // L1 為第一桿件的長度, 必須 &gt; 0, 且小於 100 - 設為 tmp[4]
      // L2 為第二桿件的長度, 必須 &gt; 0, 且小於 100 - 設為 tmp[5]
      // L3 為第三桿件的長度, 必須 &gt; 0, 且小於 100 - 設為 tmp[6]
      // L5, L6 與 L2 共同圍出可動桿 L2 對應的三角形, 關注的三角形頂點即 L5 與 L6 的交點, 而 angle3 則為 L6 之對應角(為固定值)
      // L5, L6 必須 &gt; 0, 且小於 100 - 設為 tmp[7], tmp[8]
      // 以下的角度輸入值, 會隨著目標點數的增加而增加, 其索引值由 9 + 通過點數 - 1 決定, 5 點, 則索引至 13, 若通過 25 點, 則索引值為 9 + 24 = 33
      // input_angles[] 為五的輸入的雙浮點數角度值,代表個體的角度向量值 - 分別設為 tmp[9], tmp[10], tmp[11], tmp[12], tmp[13]
      // 這裡的輸入角度值, 將採用以第一角度&gt;0 作為起點, 隨後則為角度增量, 也都必須大於零
      // output_points[] 則為與 input_angles[] 對應的五個三角形的頂點值, 為座標結構值, 分別有 x 與 y 分量值
      // 當利用個體的向量值, 代入 mechanism 後所得到得 output_points[] 再與 target_points[] 進行 cost function 的誤差值最小化
      /* void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])*/
      struct Coord target_points[NUM_OF_POINTS], output_points[NUM_OF_POINTS];
      double input_angles[NUM_OF_POINTS], result, total_angle;
      int i;

      (*nfeval)++;

      target_points[0].x = 4.5;
      target_points[0].y = 6.75;

      target_points[1].x = 5.07;
      target_points[1].y = 6.85;

      target_points[2].x = 5.45;
      target_points[2].y = 6.84;

      target_points[3].x = 5.89;
      target_points[3].y = 6.83;

      target_points[4].x = 6.41;
      target_points[4].y = 6.8;

      target_points[5].x = 6.92;
      target_points[5].y = 6.58;

      target_points[6].x = 7.03;
      target_points[6].y = 5.99;

      target_points[7].x = 6.95;
      target_points[7].y = 5.45;

      target_points[8].x = 6.77;
      target_points[8].y = 5.03;

      target_points[9].x = 6.4;
      target_points[9].y = 4.6;

      target_points[10].x = 5.91;
      target_points[10].y = 4.03;

      target_points[11].x = 5.43;
      target_points[11].y = 3.56;

      target_points[12].x = 4.93;
      target_points[12].y = 2.94;

      target_points[13].x = 4.67;
      target_points[13].y = 2.6;

      target_points[14].x = 4.38;
      target_points[14].y = 2.2;

      target_points[15].x = 4.04;
      target_points[15].y = 1.67;

      target_points[16].x = 3.76;
      target_points[16].y = 1.22;

      target_points[17].x = 3.76;
      target_points[17].y = 1.97;

      target_points[18].x = 3.76;
      target_points[18].y = 2.78;

      target_points[19].x = 3.76;
      target_points[19].y = 3.56;

      target_points[20].x = 3.76;
      target_points[20].y = 4.34;

      target_points[21].x = 3.76;
      target_points[21].y = 4.91;

      target_points[22].x = 3.76;
      target_points[22].y = 5.47;

      target_points[23].x = 3.8;
      target_points[23].y = 5.98;

      target_points[24].x = 4.07;
      target_points[24].y = 6.4;


      // 輸入角度值與 tmp[] 的設定
      for(i = 0; i &lt; NUM_OF_POINTS; i++)
      {
        input_angles[i] = tmp[i + 9];
      }

      // 呼叫 mechanism() 以便計算 output_points[]
      mechanism(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], input_angles, output_points);

      // for debug
      /*
      if(*nfeval%5000 == 0)
      {
        for(i = 0; i &lt; NUM_OF_POINTS; i++)
        {
          printf("%-15.10g : %-15.10g\n", output_points[i].x, output_points[i].y);
        }
        printf("#####################################\n");
      }
    */
      // 利用 output_points[] 與 target_points 計算誤差值, 該誤差值就是 cost
      result = error_function(output_points, target_points);
      // 這裡要分別針對各變數的約束條件與範圍值來設定傳回 PENALITY 或 誤差值 result

     // x0 與 x1 點位於 -50 與 50 中間
        for(i = 0; i &lt; 4; i++)
      {
        if(tmp[i] &lt; -100 || tmp[i] &gt; 100){
          return PENALITY;
        }
      }

      // 三個連桿值, 一定要為正
        for(i = 4; i &lt; 7; i++)
      {
        if(tmp[i] &lt; 0 || tmp[i] &gt; 100){
          return PENALITY;
        }
      }

        // L5 L6 可以為 0 或負值
        for(i = 7; i &lt; 9; i++)
      {
        if(tmp[i] &lt; -100 || tmp[i] &gt; 100){
          return PENALITY;
        }
      }

      // 角度值不可以小於 0

      for(i = 1; i &lt;= NUM_OF_POINTS; i++)
      {
        if(tmp[D-i] &lt; 0){
          return PENALITY;
        }
      }


      /*
      for(i = 0; i &lt; D - NUM_OF_POINTS; i++)
      {
          if((tmp[i] &lt;= inibound_l)|| (tmp[i] &gt;inibound_h)){
          return PENALITY;
        }
      }

      for(i = 1; i &lt;= NUM_OF_POINTS; i++)
      {
        if(tmp[D-i] &lt; 0){
          return PENALITY;
        }
      }
      */
      return result;

      /*
       double result=0, surface = 80.0, z, volume, penality;
       (*nfeval)++;
       z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));
       volume = tmp[0]*tmp[1]*z;

      if(volume &lt;= 0){
        return PENALITY;
      }

      if((tmp[0] &lt;= inibound_l)|| (tmp[0] &gt;inibound_h)){
        return PENALITY;
      }

      if((tmp[1] &lt;= inibound_l) || (tmp[1] &gt;inibound_h)){
        return PENALITY;
      }
      // volume must &gt;0 and max volume
      // 目前為最小化問題
       return 1+1/(volume*volume);
       */
    }

    struct Coord triangletip_coord( double x0, double y0, double R0, double R1, double x1, double y1, double localt)
    {
        struct Coord tip_coord;

        if (localt&gt;=0 &amp;&amp; localt &lt;PI)
        {
            // 目前蓋掉的式子為利用手動代換出來的版本
            //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(-mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
            // 以下的式子,先利用文字編輯器,將原先 stringout() 出來的  sqrt 替換成  sqrtt, 以防止被  maxima 中的 subst("^"=pow,expr) 所替換, subst 之後,再使用文字編輯器換回來,就可以得到正確的 C 對應碼.
            tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
        pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2)+x0;
        }
        else
        {
            // 目前蓋掉的式子為利用手動代換出來的版本
            //x_value = ((x1-x0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2)))-(y1-y0)*(mech_loop)*sqrt(fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)/(4*(pow((y1-y0),2)+pow((x1-x0),2))))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))+x0;
            tip_coord.x = pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-mech_loop*(y1-y0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4))+(x1-x0)*pow(sqrt(pow(y1-y0,2)+
        pow(x1-x0,2)),-1)*(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+
        pow(x1-x0,2))/2)+x0;
        }

    // 請注意,與 Maxma 公式中的差異為,在 sqrt()中加入 fabs(),避免因為sqrt()中的負值而造成 NaN (Not a Number 問題.
        if (localt&gt;=0 &amp;&amp; localt &lt;PI)
        {
            tip_coord.y = /*((x1-x0)*(-mech_loop)*sqrt(
                    fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                    /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                    ))
                    +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                    +y0;*/
                    // 利用 sqrtt 居中進行代換所得到的式子
                    pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
        pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2-mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;

        }
        else
        {
            tip_coord.y = /*((x1-x0)*(mech_loop)*sqrt(
                    fabs(pow(R0,2)-pow((-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2)),2)
                    /(4*(pow((y1-y0),2)+pow((x1-x0),2)))
                    ))
                    +(y1-y0)*(-pow(R1,2)+pow(R0,2)+pow((y1-y0),2)+pow((x1-x0),2))/(2*sqrt(pow((y1-y0),2)+pow((x1-x0),2))))/sqrt(pow((y1-y0),2)+pow((x1-x0),2))
                    +y0;*/
                    pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*((y1-y0)*pow(sqrt(pow(y1-y0,2)+pow(x1-x0,2)),-1)*(-pow(R1,2)+
        pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2))/2+mech_loop*(x1-x0)*sqrt(fabs(pow(R0,2)-pow(pow(y1-y0,2)+
        pow(x1-x0,2),-1)*pow(-pow(R1,2)+pow(R0,2)+pow(y1-y0,2)+pow(x1-x0,2),2)/4)))+y0;
        }

      return tip_coord;
    }

    double distance(double x0, double y0, double x1, double y1)
    {
        double distance_value;
        distance_value = sqrt(pow((x1-x0),2) + pow((y1-y0),2));
        return distance_value;
    }

    double rr(double L1, double dd, double theta)
    {
        double rr_value;
        rr_value = sqrt(L1*L1+dd*dd - 2*L1*dd*cos(theta));
        return rr_value;
    }

    // 輸入每一個體的變數向量, 然後求各三角形頂點的座標陣列[NUM_OF_POINTS]
    void mechanism(double x0, double y0, double x1, double y1, double L1,
      double L2, double L3, double L5, double L6, double input_angles[NUM_OF_POINTS], struct Coord output_points[NUM_OF_POINTS])
    {
      // 這裡的輸入角度, 改採第一角度為起始角, 隨後的角度值則為增量值
      // 此函式要輸入控制變數, 然後計算機構尺寸合成的關注點座標位置
      // 以下為可能的處理變數宣告
      // 這裡希望能夠定義一個 struct 來處理座標點
      double rr_length, dd_length, angle;
      struct Coord link1_tip, link2_tip, triangle_tip;
        double angle2, angle3;
      int i;

      // 開始進行三角形頂點座標的計算
      // 以下變數由每一個體向量提供
      /*
        x0 = 0.0;
        y0 = 0.0;
        x1 = 10.0;
        y1 = 0.0;
        L1 = 5.0;
        L2 = 20;
        L3 = 10;
        L5 = 10;
        L6 = 10;
      */
      dd_length = distance(x0, y0, x1, y1);
      /* 設法表示 triangle 所對應的 local 角度,表示為已知變數與 t 的函式 */
      // 假如採用 finaltip_coord, 則不需要 angle3
      angle3 = acos((pow(L2,2)+pow(L5,2)-pow(L6,2))/(2*L2*L5));

      for(i = 0; i &lt; NUM_OF_POINTS; i++)
      {
        // 先建立第一點座標, 即 i=0 者
        // i=0;
        // angle = i*degree;

        /*
        // 利用角度增量進行運算, 相對於 input_angles[0] 作為基準
        if(i &gt; 0)
        {
          input_angles[i] = input_angles[i] + input_angles[i-1];
        }
        */
        angle = input_angles[i]*degree;
        rr_length = rr(L1, dd_length, angle);
        // 第一次三角形疊代
        link1_tip = triangletip_coord(x0, y0, L1, rr_length, x1, y1, angle);
        // 第二次三角形疊代
        /* 設法表示 link2 所對應的 local 角度,表示為已知變數與 t 的函式 */
        angle2 = acos((pow(L2,2)+pow(rr_length,2)-pow(L3,2))/(2*L2*rr_length));
        link2_tip = triangletip_coord(link1_tip.x, link1_tip.y, L2, L3, x1, y1, angle2);
        // 第三次三角形疊代
        //triangle_tip = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        // output_points[i] = triangletip_coord(link1_tip.x, link1_tip.y, L5, L6, link2_tip.x, link2_tip.y, angle3);
        // 這裡要嘗試利用 finaltip_coord() 求 tip3 座標, 而 L5 與 L6 可 0 可負
        output_points[i] = finaltip_coord(link1_tip, link2_tip, L5, L6);
      }
    }

    double error_function(struct Coord output_points[NUM_OF_POINTS], struct Coord target_points[NUM_OF_POINTS])
    {
      double error = 0.0;
      int i;
      for(i = 0; i &lt; NUM_OF_POINTS; i++)
      {
        error += fabs(distance(output_points[i].x, output_points[i].y, target_points[i].x, target_points[i].y));
      }
      return error;
    }

    struct Coord finaltip_coord(struct Coord tip1_coord, struct Coord tip2_coord, double r1, double r2)
    {
      struct Coord tip3_coord;
      double theta3, theta4, length3, length4;
      length3 = sqrt(pow(tip2_coord.x - tip1_coord.x,2) + pow(tip2_coord.y - tip1_coord.y,2));
      length4 = sqrt(pow(r1,2) + pow(r2,2));  
      theta3 = acos((tip2_coord.x - tip1_coord.x) / length3);
      theta4 = acos(r1 / length4);
      tip3_coord.x = tip1_coord.x + length4 * cos(theta3 + theta4);
      tip3_coord.y = tip1_coord.y + length4 * sin(theta3 + theta4);

      return tip3_coord;
    }
</pre>
            </div>
            <!-- /.entry-content -->
    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'projectmdetw'; // required: replace example with your forum shortname

                    var disqus_identifier = 'yen-rga-ji-yin-yan-suan-fa';
                var disqus_url = 'http://project.mde.tw/blog/yen-rga-ji-yin-yan-suan-fa.html';

            var disqus_config = function () {
                this.language = "en";
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
        </article>
    </section>

        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>

<section class="well well-sm">
    <ul class="list-group list-group-flush">

            <li class="list-group-item"><h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Recent Posts</span></h4>
                <ul class="list-group" id="recentposts">
                    <li class="list-group-item">
                        <a href="http://project.mde.tw/blog/kmolprint-0716.html">
                            KmolPrint 0716
                        </a>
                    </li>
                    <li class="list-group-item">
                        <a href="http://project.mde.tw/blog/40323230ji-lu-makefilede-jian-gou.html">
                            40323230紀錄 - Makefile的建構
                        </a>
                    </li>
                    <li class="list-group-item">
                        <a href="http://project.mde.tw/blog/40323218ri-zhi-1050715.html">
                            40323218日誌 - 105/07/15
                        </a>
                    </li>
                    <li class="list-group-item">
                        <a href="http://project.mde.tw/blog/40323131ri-zhi-1050715.html">
                            40323131日誌 105/07/15
                        </a>
                    </li>
                    <li class="list-group-item">
                        <a href="http://project.mde.tw/blog/40323143-ri-zhi-105nian-7yue-15ri.html">
                            40323143 -  日誌  105年7月15日
                        </a>
                    </li>
                </ul>
            </li>

            <li class="list-group-item"><a href="http://project.mde.tw/blog/categories.html"><h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Categories</span></h4></a>
                <ul class="list-group" id="categories">
                    <li class="list-group-item">
                        <a href="http://project.mde.tw/blog/category/2016bg2.html">
                            <i class="fa fa-folder-open fa-lg"></i> 2016bg2
                        </a>
                    </li>
                    <li class="list-group-item">
                        <a href="http://project.mde.tw/blog/category/2016g1.html">
                            <i class="fa fa-folder-open fa-lg"></i> 2016g1
                        </a>
                    </li>
                    <li class="list-group-item">
                        <a href="http://project.mde.tw/blog/category/misc.html">
                            <i class="fa fa-folder-open fa-lg"></i> Misc
                        </a>
                    </li>
                    <li class="list-group-item">
                        <a href="http://project.mde.tw/blog/category/tutorial.html">
                            <i class="fa fa-folder-open fa-lg"></i> Tutorial
                        </a>
                    </li>
                </ul>
            </li>

            <li class="list-group-item"><a href="http://project.mde.tw/blog/tags.html"><h4><i class="fa fa-tags fa-lg"></i><span class="icon-label">Tags</span></h4></a>
                <ul class="list-group list-inline tagcloud" id="tags">
                </ul>
            </li>
    <li class="list-group-item"><h4><i class="fa fa-external-link-square fa-lg"></i><span class="icon-label">Links</span></h4>
      <ul class="list-group" id="links">
        <li class="list-group-item">
            <a href="http://getpelican.com/" target="_blank">
                Pelican
            </a>
        </li>
        <li class="list-group-item">
            <a href="https://github.com/DandyDev/pelican-bootstrap3/" target="_blank">
                pelican-bootstrap3
            </a>
        </li>
        <li class="list-group-item">
            <a href="https://github.com/getpelican/pelican-plugins" target="_blank">
                pelican-plugins
            </a>
        </li>
        <li class="list-group-item">
            <a href="https://github.com/Tipue/Tipue-Search" target="_blank">
                Tipue search
            </a>
        </li>
      </ul>
    </li>
    </ul>
</section>
            </aside>
        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2016 KMOL
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://project.mde.tw/blog/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://project.mde.tw/blog/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://project.mde.tw/blog/theme/js/respond.min.js"></script>

    <!-- Disqus -->
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'projectmdetw'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script');
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <!-- End Disqus Code -->

</body>
</html>